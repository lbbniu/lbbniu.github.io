<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>lbbniu</title><link>/authors/lbbniu/</link><description>Recent content on lbbniu</description><generator>Hugo -- gohugo.io</generator><language>zh</language><managingEditor>lbbniu@gmail.com (lbbniu)</managingEditor><webMaster>lbbniu@gmail.com (lbbniu)</webMaster><copyright>&amp;copy; 2021 &lt;a href="https://blog.lbbniu.com/">lbbniu&lt;/a></copyright><lastBuildDate>Tue, 09 Jan 2024 15:20:00 +0800</lastBuildDate><atom:link href="/authors/lbbniu/index.xml" rel="self" type="application/rss+xml"/><item><title>写给Go开发者的Tars教程-context/status</title><link>/2024/01/09/tarsgo-context/</link><pubDate>Tue, 09 Jan 2024 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2024/01/09/tarsgo-context/</guid><description>本篇为【写给go开发者的Tars教程】系列第五篇
第一篇：Tars协议基础 第二篇：通信模式 第三篇：拦截器 第四篇：错误处理 第五篇：context/status
本系列将持续更新，欢迎关注👏获取实时通知
导语
和在普通HTTP请求中一样，TarsGo提供了在每一次RPC中携带上下文的结构：context和status。在Go语言中，它与context.Context紧密结合，帮助我们实现服务端与客户端之间互相传递信息。其中status主要用于框架底层传递一些框架特性相关的数据。
什么是 context？ TarsGo 的 context和status的简单理解，就是 HTTP Header 中的 key-value 对
context和status 都是以 key-value 的形式存储数据的，其中 key 和 value都是 string 类型。 context和status 使得 client 和 server 能够为对方提供关于本次调用的一些信息，就像一次HTTP请求的Request Header和Response Header一样 HTTP Header 的生命周期是一次 HTTP 请求，那么 context和status 的生命周期就是一次 RPC 调用 context和status 创建 🌲 直接使用make即可： context := make(map[string]string) status := make(map[string]string) 🌲 直接使用map初始化方式： context := map[string]string{&amp;quot;key1&amp;quot;:&amp;quot;value1&amp;quot;,&amp;quot;key2&amp;quot;:&amp;quot;value2&amp;quot;} status := map[string]string{&amp;quot;key1&amp;quot;:&amp;quot;value1&amp;quot;,&amp;quot;key2&amp;quot;:&amp;quot;value2&amp;quot;} context和status 发送和接受 让我们再次回顾下tars文件和生成出来的client与server端的接口
module order { struct Order { 1 require string id; 2 optional vector&amp;lt;string&amp;gt; items; 3 optional string description; 4 require float price; 5 optional string destination; }; interface OrderManagement { Order getOrder(string orderId); }; }; type OrderManagement struct { servant m.</description></item><item><title>写给go开发者的Tars教程-错误处理</title><link>/2024/01/08/tarsgo-errors/</link><pubDate>Mon, 08 Jan 2024 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2024/01/08/tarsgo-errors/</guid><description>本篇为【写给go开发者的Tars教程】系列第四篇
第一篇：Tars协议基础 第二篇：通信模式 第三篇：拦截器 第四篇：错误处理
本系列将持续更新，欢迎关注👏获取实时通知
基本错误处理 首先回顾下tars文件和生成出来的client与server端的接口
module order { struct Order { 1 require string id; 2 optional vector&amp;lt;string&amp;gt; items; 3 optional string description; 4 require float price; 5 optional string destination; }; interface OrderManagement { Order getOrder(string orderId); }; }; type OrderManagement struct { servant m.Servant } func (obj *OrderManagement) GetOrder(orderId string, opts ...map[string]string) (Order, error) { return obj.GetOrderWithContext(context.Background(), orderId, opts...) } func (obj *OrderManagement) GetOrderWithContext(tarsCtx context.Context, orderId string, opts ...map[string]string) (ret Order, err error) { // .</description></item><item><title>写给go开发者的Tars教程-拦截器</title><link>/2024/01/07/tarsgo-middleware/</link><pubDate>Sun, 07 Jan 2024 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2024/01/07/tarsgo-middleware/</guid><description>本篇为【写给go开发者的Tars教程】系列第三篇
第一篇：Tars协议基础 第二篇：通信模式 第三篇：拦截器
TarsGo的拦截器和其他框架的拦截器（也称middleware）作用是一样的。利用拦截器我们可以在不侵入业务逻辑的前提下修改或者记录服务端或客户端的请求与响应，利用拦截器我们可以实现诸如日志记录、权限认证、限流、链路追踪等诸多功能。拦截器可以分别应用在服务端和客户端，所以TarsGo总共为我们提供了多种拦截器，下面我们进行一一介绍。
服务端拦截器（过滤器） 处理前后拦截器（过滤器） 拦截器定义如下：
// Dispatch server side Dispatch type Dispatch func(context.Context, interface{}, *requestf.RequestPacket, *requestf.ResponsePacket, bool) error // ServerFilter is used for add Filter for server dispatcher ,for implementing plugins like opentracing. type ServerFilter func(ctx context.Context, d Dispatch, f interface{}, req *requestf.RequestPacket, resp *requestf.ResponsePacket, withContext bool) (err error) 注册服务端拦截器的方法如下：
func RegisterServerFilter(f ServerFilter) // 注册服务端拦截器，只能注册一个 func RegisterPreServerFilter(f ServerFilter) // 注册服务端处理前拦截器，可多个 func RegisterPostServerFilter(f ServerFilter) // 注册服务端处理后拦截器，可多个 不推荐上面三种注册方法来注册拦截件，将在1.5版本后彻底废弃移除，推荐使用下面介绍的中间件实现对应的逻辑。
示例：
// 注册服务端过滤器 tars.RegisterServerFilter(func(ctx context.Context, d tars.</description></item><item><title>一篇文章精通php多版本管理工具：phpbrew</title><link>/2024/01/04/phpbrew/</link><pubDate>Thu, 04 Jan 2024 22:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2024/01/04/phpbrew/</guid><description>大家好，我是lbbniu。
今天给大家介绍以下 Uber 开源的静态分析工具 NilAway，下面开鲁。
最近 Uber 开发和开源了一个挺不错的静态分析工具 NilAway：
NilAway是一个静态分析工具，旨在通过在编译时而不是运行时捕获nil panic来帮助开发人员避免在生产中出现这种情况。NilAway类似于标准的nilness分析器，但它采用更复杂和强大的静态分析技术来跟踪包内和跨包的nil流，并报告错误，为用户提供更轻松的调试nilness流程。
NilAway具有三个关键特性，使其脱颖而出：
完全自动化：NilAway配备有推理引擎，因此除了标准的Go代码之外，它不需要从开发人员那里获取任何其他信息（例如注释）。 速度快：我们设计NilAway为快速且可扩展，适用于大型代码库。在我们的测量中，启用NilAway时构建时间开销不到5%。我们还在不断应用优化来进一步减少其占用空间。 实用性：它不能阻止代码中所有可能的nil panic，但它可以捕获我们在生产中观察到的大多数潜在nil panic，使NilAway在实用性和构建时间开销之间保持良好平衡。 安装 NilAway是使用标准的go/analysis框架实现的，因此易于与现有的分析驱动程序集成（例如golangci-lint、nogo或作为独立检查器运行）。下面是将NilAway作为独立检查器运行的说明。更多集成支持将很快添加。
独立检查器 通过以下命令从源代码安装二进制文件：
go install go.uber.org/nilaway/cmd/nilaway@latest 然后，通过以下命令运行linter：
nilaway ./... 代码示例 案例一 让我们看一些示例，了解NilAway如何帮助防止nil panic。
// Example 1: var p *P if someCondition { p = &amp;amp;P{} } print(p.f) // nilness reports NO error here, but NilAway does. 在这个示例中，局部变量p仅在someCondition为true时初始化。在字段访问p.f时，如果someCondition为false，则可能发生panic。NilAway能够捕获这个潜在的nil导致的panic并报告以下错误：
go.uber.org/example.go:12:9: error: Potential nil panic detected. Observed nil flow from source to dereference point: -&amp;gt; go.uber.org/example.go:12:9: unassigned variable `p` accessed field `f` 如果我们使用nil检查（if p !</description></item><item><title>用Golang助力表妹轻松实现自动化办公！（完整代码附后）</title><link>/2023/12/10/goalng-execl/</link><pubDate>Sun, 10 Dec 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/12/10/goalng-execl/</guid><description>Hello，大家好，我是lbbniu~
今天有一个有趣的编程需求要分享，这次的灵感来源于我可爱的表妹。简单来说，我们将利用Golang对Excel文件进行批量处理，达到高效自动化办公的目的。
一、具体需求 手上有一系列N个表格，每个表格都有相同的结构，看起来就像这样：
任务是将所有表中的数据汇总，按照每个人的得分和积分进行合计，然后按总积分排名。在总积分相同的情况下，名次也相同但不是连续的排序。如果总积分和名次都相同，再按总得分降序展示，但不改变排名。
结果如下图所示：
二、Golang开发 首先，让我们引入需要的包：
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;log&amp;quot; &amp;quot;path/filepath&amp;quot; &amp;quot;sort&amp;quot; &amp;quot;github.com/tealeg/xlsx&amp;quot; ) 接下来，获取所有Excel文件的路径：
func getExcelFiles() []string { files, err := filepath.Glob(&amp;quot;./样例数据/*.xlsx&amp;quot;) if err != nil { log.Fatal(err) } return files } 然后，将各表数据合并到主结构体：
// Record 结构体表示每个人的记录 type Record struct { Name string Monthly int Points int Ranking int } func getCellValue(cell *xlsx.Cell) int { value, err := cell.Int() if err != nil { log.Fatal(err) } return value } func mergeData(files []string) []Record { var mergedData []Record for _, file := range files { // 读取Excel文件 xlFile, err := xlsx.</description></item><item><title>写给go开发者的Tars教程-Tars协议基础</title><link>/2023/06/18/tarsgo-protocol/</link><pubDate>Sun, 18 Jun 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/06/18/tarsgo-protocol/</guid><description>简介 Tars这个名字取自于电影&amp;quot;星际穿越&amp;quot;中的机器人，它是基于名字服务使用Tars协议的高性能RPC开发框架，配套一体化的运营管理平台，并通过伸缩调度，实现运维半托管服务。
Tars是腾讯从2008年到今天一直在使用的后台逻辑层的统一应用框架TAF（Total Application Framework），目前支持C++、Java、PHP、Nodejs、Go语言。该框架为用户提供了涉及到开发、运维、以及测试的一整套解决方案，帮助一个产品或者服务快速开发、部署、测试、上线。 它集可扩展协议编解码、高性能RPC通信框架、名字路由与发现、发布监控、日志统计、配置管理等于一体，通过它可以快速用微服务的方式构建自己的稳定可靠的分布式应用，并实现完整有效的服务治理。
目前该框架在腾讯内部，各大核心业务都在使用，颇受欢迎，基于该框架部署运行的服务节点规模达到上万个。
支持平台 目前运行的操作系统平台如下：
Linux
Mac(&amp;gt;=2.1.0 support)
支持语言 目前支持的开发语言如下：
C++
Java
Nodejs
PHP
Go
版本管理 Tars由多种模块组成, 分散在多个仓库中, 并且基础框架版本和语言版本可以独立发展, 鉴于此, 从2.1.0版本开始, 框架的版本TAG打在TarsFramework仓库上, 不再体现在Tars这个仓库上.
Tars IDL 所谓序列化通俗来说就是把内存的一段数据转化成二进制并存储或者通过网络传输，而读取磁盘或另一端收到后可以在内存中重建这段数据
1、tars协议是跨语言跨平台的序列化协议。
2、tars协议本身也可以被用于非RPC场景，如存储
json、 xml都是一种序列化的方式，只是他们不需要提前预定义idl，且具备可读性，当然他们传输的体积也因此较大，可以说是各有优劣。
关键字 void,struct,bool,byte,short,int,double,float,long,string,vector,map,key,routekey,module,interface,out,require,optional,false,true,enum,const 注释 采用 c++的注释规范：
//表示注释一行 /**/表示注释范围中的所有代码。 基本类型 基本类型会涉及到不同语言和编码方式，这里只整理tars和go类型对照表
.tars Type Go Type Notes void 函数无返回值 只能在函数的返回值表示 bool bool 布尔类型 byte int8 有符号字符 unsigned byte uint8 无符号字符 short int16 有符号短整型 unsigned short uint16 无符号短整形 int int32 有符号整型 unsigned int uint32 无符号整形 long int64 有符号长整型 float float32 32位浮点数 double float64 64位浮点数 string string 字符串 复杂类型 .</description></item><item><title>写给Go开发者的Tars教程-通信模式</title><link>/2023/06/18/tarsgo-rpc/</link><pubDate>Sun, 18 Jun 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/06/18/tarsgo-rpc/</guid><description>本篇为【写给Go开发者的Tars教程系列】第二篇
第一篇：Tars协议基础 第二篇：通信模式 上一篇介绍了如何编写 Tars 的 idl，并使用 idl 生成了 TarsGo RPC 的代码，现在来看看如何编写客户端和服务端的代码
Tars 示例 IDL module order { struct Order { 1 require string id; 2 optional vector&amp;lt;string&amp;gt; items; 3 optional string description; 4 require float price; 5 optional string destination; }; interface OrderManagement { Order getOrder(string orderId); }; }; 生成 go 协议编解码代码 tars2go -outdir=. \ -module=github.com/lbbniu/TarsGo-tutorial \ proto/order.tars order ├── order.go └── OrderManagement.tars.go proto └── order.tars server 实现 服务端开发 1、由 Tars 文件生成的 Go 代码中包含了 interface 的接口定义，它和我们定义的 idl 是吻合的</description></item><item><title>Redis Cluster vs Codis Slot Rebalance 算法</title><link>/2023/03/26/redis-cluster-vs-codis-slot-rebalance-%E7%AE%97%E6%B3%95/</link><pubDate>Sun, 26 Mar 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/03/26/redis-cluster-vs-codis-slot-rebalance-%E7%AE%97%E6%B3%95/</guid><description>Redis Cluster Slot Rebalance算法 迁移原则 尽可能的均匀分配Slots； 尽量减少迁移的Slots的数量； Slots分配方案 计算集群的总权重，节点数量； 计算每个集群节点需要移出或移入的槽数，balance 如果为正数代表需要移出的槽数，如果为负数代表需要出入槽数； 把weightedNodes 根据 balance 排序从小到大； 执行槽位移动，并更新集群节点 balance； 代码实现 static int clusterManagerCommandRebalance(int argc, char **argv) { int port = 0; char *ip = NULL; clusterManagerNode **weightedNodes = NULL; list *involved = NULL; if (!getClusterHostFromCmdArgs(argc, argv, &amp;amp;ip, &amp;amp;port)) goto invalid_args; clusterManagerNode *node = clusterManagerNewNode(ip, port, 0); if (!clusterManagerLoadInfoFromNode(node)) return 0; int result = 1, i; if (config.cluster_manager_command.weight != NULL) { for (i = 0; i &amp;lt; config.cluster_manager_command.weight_argc; i++) { char *name = config.</description></item><item><title>Golang语法的25个练习题：21至25题</title><link>/2023/02/24/uri-addr/</link><pubDate>Fri, 24 Feb 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/02/24/uri-addr/</guid><description>题目21：三个数取最大数 己知数字a，b，c分别为10，6，18
找出a，b，c中最大的数字(不借助函数以及列表等方式)
我们知道函数max可以直接获取到最大值，或者可以把数字添加到列表里，通过排序也能获取到最大数字，我们单纯使用if分支来实现
package main import &amp;quot;fmt&amp;quot; func main() { a, b, c := 10, 6, 8 max := a if max &amp;lt; b { max = b } if max &amp;lt; c { max = c } fmt.Println(max) } 题目22：因子之和“完数” 什么是因子？
因子就是所有可以整除这个数的数字，包括1但不包括这个数自身。比如8的因子有1，2，4
什么是完数？
一个数如果恰好等于它的因子之和，这个数就称为“完数”，打印输出1000以内的完数，例如6=1+2+3，6就是“完数
package main import &amp;quot;fmt&amp;quot; func main() { for i := 1; i &amp;lt; 1000; i++ { if i == factorSum(i) { fmt.Println(&amp;quot;//&amp;quot;, i) } } // output: // 6 // 28 // 496 } func factorSum(n int) int { sum := 0 for i := 1; i &amp;lt; n; i++ { if n%i == 0 { sum += i } } return sum } 题目23：递归阶乘求和 一个正整数的阶乘(factorial)是所有小于及等于该数的正整数之积，并且0的阶乘为1</description></item><item><title>Golang语法的25个练习题：16至20题</title><link>/2023/02/23/uri-addr/</link><pubDate>Thu, 23 Feb 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/02/23/uri-addr/</guid><description>题目16：大衍数列 中国古代文献中，曾记载过“大衍数列”，主要用于解释中国传统文化中的太极衍生原理
它的前几项是：0、2、4、8、12、18、24、32、40、50&amp;hellip;
其规律是：偶数项，是序号平方再除2，奇数项，是序号平方减1再除2。
打印大衍数列的前100项
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;math&amp;quot; ) func main() { for i := 1; i &amp;lt;= 100; i++ { var a int if i%2 == 0 { // 偶数 a = int(math.Pow(float64(i), 2)) / 2 } else { // 奇数 a = (int(math.Pow(float64(i), 2)) - 1) / 2 } fmt.Println(&amp;quot;//&amp;quot;, a) } // 0 // 2 // 4 // 8 // 12 // 18 // 24 // 32 // 40 // 50 } 题目17：单词分析 小蓝正在学习一门神奇的语言，这门语言中的单词都是由小写英文字母组成，有些单词很长，远远超过正常英文单词的长度。小蓝学了很长时间也记不住一些单词，他准备不再完全记忆这些单词，而是根据单词中哪个字母出现得最多来分辨单词 现在，请你帮助小蓝，给了一个单词后，帮助他找到出现最多的字母和这个字母出现的次数 其实就是让你输入一段字符串后，得到当前字符串出现最多的字母和它的次数 输入：HelloWorld 输出： l 3 我们可以对当前的字符串进行循环迭代，然后把字符串当前每个字符当作key值，把它存到字典里面，如果当前key在字典里面，我们就让它加一，如果不在那我们就让它的次数初始化为1，最终我们再从字典找到次数最多的key值和value值 package main import &amp;quot;fmt&amp;quot; func main() { analyseWords(&amp;quot;helloworld&amp;quot;) // l 3 } func analyseWords(word string) { wordDict := map[rune]int{} var ( count int ch rune ) for _, c := range word { wordDict[c]++ if wordDict[c] &amp;gt; count { count, ch = wordDict[c], c } } fmt.</description></item><item><title>Golang语法的25个练习题：11至15题</title><link>/2023/02/22/uri-addr/</link><pubDate>Wed, 22 Feb 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/02/22/uri-addr/</guid><description>题目11：剪刀石头布 游戏开始，初始状态下用户和电脑都有100分，赢一局+10分，输一局-10分。当用户为0分时，游戏结束，提示游戏结束，比赛输了，当用户为200分时，游戏结束，提示游戏结束，赢得比赛、每轮比赛都输出当前的分数
1代表剪刀 2代表石头 3代表布
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;math/rand&amp;quot; &amp;quot;os&amp;quot; &amp;quot;strconv&amp;quot; &amp;quot;strings&amp;quot; &amp;quot;time&amp;quot; ) var ( gameInfo = map[int]string{ 1: &amp;quot;剪刀&amp;quot;, 2: &amp;quot;石头&amp;quot;, 3: &amp;quot;布&amp;quot;, } score = 100 ) func main() { fmt.Println(strings.Repeat(&amp;quot;=&amp;quot;, 60)) fmt.Println(strings.Repeat(&amp;quot; &amp;quot;, 20), &amp;quot;剪刀石头布游戏&amp;quot;) fmt.Println(&amp;quot;1代表剪刀 2代表石头 3代表布&amp;quot;) for { rd := rand.New(rand.NewSource(time.Now().UnixNano())) robotsChoice := rd.Intn(3) if robotsChoice == 0 { robotsChoice++ } userChoice, err := input(&amp;quot;请出拳&amp;quot;) if err != nil { fmt.Println(err) continue } if _, ok := gameInfo[userChoice]; !</description></item><item><title>Golang语法的25个练习题：6至10题</title><link>/2023/02/15/uri-addr/</link><pubDate>Wed, 15 Feb 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/02/15/uri-addr/</guid><description>题目6：闰年问题升级版 输入年月日，输出该日期是否是闰年，并且输出该日期是此年份的第几天
闰年判断条件：
能被4整除，并且不能被100整除 能被400整除 两个条件满足任意一个就为闰年 算法思路
接收用户输入的年月日，创建保存12个月份天数的列表 根据年份判断是否是闰年，如果是把二月份设为29天，否则把二月份设为28天 根据月份和日期统计是当年的第几天 package main import ( &amp;quot;fmt&amp;quot; &amp;quot;log&amp;quot; &amp;quot;os&amp;quot; &amp;quot;strconv&amp;quot; ) func main() { year, err := input(&amp;quot;请输入年份&amp;quot;) if err != nil { log.Fatalln(err) } month, err := input(&amp;quot;请输入月份&amp;quot;) if err != nil { log.Fatalln(err) } day, err := input(&amp;quot;请输入日期&amp;quot;) if err != nil { log.Fatalln(err) } dateList := []int{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31} countDay := day if year%4 == 0 &amp;amp;&amp;amp; year%100 !</description></item><item><title>Golang语法的25个练习题：1至5题</title><link>/2023/02/13/uri-addr/</link><pubDate>Mon, 13 Feb 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/02/13/uri-addr/</guid><description>题目1：水仙花数 水仙花数（Narcissistic number）也被称为超完全数字不变数（pluperfect digital invariant, PPDI）、自恋数、自幂数、阿姆斯壮数或阿姆斯特朗数（Armstrong number），水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身。例如：1^3 + 5^3+ 3^3 = 153。
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;math&amp;quot; ) func main() { // 写法一 for i := 100; i &amp;lt; 1000; i++ { // 取百位数字 123//100=1 // 取十位数字 123//10=12 12%10=2 // 取个位数字 123%10=3 i1, i2, i3 := i/100, i/10%10, i%10 if int(math.Pow(float64(i1), 3)+math.Pow(float64(i2), 3)+math.Pow(float64(i3), 3)) == i { fmt.Printf(&amp;quot;%d是水仙花数\n&amp;quot;, i) // 153 是水仙花数 // 370 是水仙花数 // 371 是水仙花数 // 407 是水仙花数 } } // 写法二 for i := 1000; i &amp;lt; 10000; i++ { sum := 0 for k := i; k &amp;gt; 0; k = k / 10 { // 个十百 sum += int(math.</description></item><item><title>一篇文章精通php多版本管理工具：phpbrew</title><link>/2023/01/04/phpbrew/</link><pubDate>Wed, 04 Jan 2023 22:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/01/04/phpbrew/</guid><description>phpbrew是一个工具，可以在$HOME目录中构建和安装多个PHP版本。
phpbrew的功能包括：
将配置选项简化为变体，不再担心路径问题。 使用不同的变体构建PHP，如PDO、mysql、sqlite、debug等。 编译Apache PHP模块，并按不同版本分开。 在个人目录中构建和安装PHP，无需root权限。 轻松切换版本，与bash/zsh shell集成。 自动功能检测。 轻松在当前环境中安装和启用PHP扩展。 在系统范围内安装多个PHP。 针对HomeBrew和MacPorts的路径检测优化。 要求 请查看 Requirement 在开始之前。你需要安装一些用于构建 PHP 的开发包。
安装 只需下载它：
curl -L -O https://github.com/phpbrew/phpbrew/releases/latest/download/phpbrew.phar chmod +x phpbrew.phar 然后，你可以将其安装到 bin 文件夹中：
sudo mv phpbrew.phar /usr/local/bin/phpbrew 确保在你的 $PATH 环境变量中有 /usr/local/bin。
设置 初始化一个用于你的 shell 环境的 bash 脚本：
phpbrew init 将以下行添加到你的 .bashrc 或 .zshrc 文件：
[[ -e ~/.phpbrew/bashrc ]] &amp;amp;&amp;amp; source ~/.phpbrew/bashrc 设置查找前缀 你可以设置你首选的用于查找库的默认前缀，可用选项有 macports、homebrew、debian、ubuntu 或自定义路径：
对于 Homebrew 用户：
phpbrew lookup-prefix homebrew 对于 Macports 用户：
phpbrew lookup-prefix macports 基本用法 列出已知版本：</description></item><item><title>polaris-go 源码走读</title><link>/2022/10/28/polaris-go/</link><pubDate>Fri, 28 Oct 2022 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2022/10/28/polaris-go/</guid><description>provider 实例化ProviderAPI NewProviderAPI() -&amp;gt; 根据默认配置文件./polaris.yaml 实例化 api.newProviderAPI-&amp;gt;api.newProviderAPIByConfig-&amp;gt;api.InitContextByConfig-&amp;gt;[api.newProviderAPIByContext]-&amp;gt;&amp;amp;providerAPI{rawAPI: p} NewProviderAPIByFile(path string) -&amp;gt; 根据指定配置文件实例化 api.newProviderAPIByFile-&amp;gt;api.InitContextByFile-&amp;gt;api.InitContextByStream-&amp;gt;api.InitContextByConfig-&amp;gt;[api.newProviderAPIByContext]-&amp;gt;&amp;amp;providerAPI{rawAPI: p} NewProviderAPIByConfig(cfg config.Configuration) -&amp;gt; 根据指定配置实例化 api.newProviderAPIByConfig-&amp;gt;api.InitContextByConfig-&amp;gt;[api.newProviderAPIByContext] NewProviderAPIByContext(context api.SDKContext) -&amp;gt; 根据指定api.SDKContext实例化 api.newProviderAPIByContext-&amp;gt;&amp;amp;providerAPI{rawAPI: p} NewProviderAPIByAddress(address &amp;hellip;string) -&amp;gt; 根据指定 polaris-server 地址实例化 api.newProviderAPIByAddress-&amp;gt;[config.NewDefaultConfiguration]-&amp;gt;api.newProviderAPIByConfig-&amp;gt;api.InitContextByConfig-&amp;gt;[api.newProviderAPIByContext]-&amp;gt;&amp;amp;providerAPI{rawAPI: p} 以上所有方法最终都会走到api.newProviderAPIByContex方法, 然后返回&amp;amp;providerAPI{rawAPI: p}
![image-20221104120449226](/Users/lbbniu/Library/Application Support/typora-user-images/image-20221104120449226.png)
相关接口定义 // ProviderAPI CL5服务端API的主接口 type ProviderAPI interface { // RegisterInstance // minimum supported version of polaris-server is v1.10.0 RegisterInstance(instance *InstanceRegisterRequest) (*model.InstanceRegisterResponse, error) // Deregister synchronize the anti registration service Deregister(instance *InstanceDeRegisterRequest) error // Destroy the api is destroyed and cannot be called again Destroy() } RegisterInstance // providerAPI 调用者对外函数实现 type providerAPI struct { rawAPI api.</description></item><item><title>【腾讯云 Finops Crane 集训营】EHPA控制器核心源码分析</title><link>/2022/02/15/crane-ehpa-code/</link><pubDate>Tue, 15 Feb 2022 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2022/02/15/crane-ehpa-code/</guid><description>官方文档：https://gocrane.io/ Github： https://github.com/gocrane/crane 启动流程 main 函数 craned 启动入口在cmd/craned/main.go文件中，main方法代码如下
func main() { logs.InitLogs() defer logs.FlushLogs() ctx := signals.SetupSignalHandler() if err := app.NewManagerCommand(ctx).Execute(); err != nil { fmt.Fprintf(os.Stderr, &amp;quot;%v\n&amp;quot;, err) os.Exit(1) } } 下面进行逐行分析：
2~3 行初始化日志，历史defer在程序退出前刷新缓存区 5行通过controller-runtime包获取信号监听可取消的context 7行创建cobra.Command命令行实例并直接调用Execute方法启动应用，如果出错退出程序 app.NewManagerCommand方法在cmd/craned/app/manager.go文件中，函数中主要是创建Options和cobra.Command，并初始化命令行参数选项。cobra.Command在执行的时候回调用cmd/craned/app/manager.go文件中的Run函数。
Run 函数 下面来重点分析下Run函数。代码如下：
// Run runs the craned with options. This should never exit. func Run(ctx context.Context, opts *options.Options) error { config := ctrl.GetConfigOrDie() config.QPS = float32(opts.ApiQps) config.Burst = opts.ApiBurst ctrlOptions := ctrl.Options{ Scheme: scheme, MetricsBindAddress: opts.MetricsAddr, Port: 9443, HealthProbeBindAddress: opts.</description></item><item><title>如何实现 Service Weaver 部署器</title><link>/2022/02/15/deployers/</link><pubDate>Tue, 15 Feb 2022 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2022/02/15/deployers/</guid><description>声明 作者能力有限，如感觉有翻译不准确的请移步原文。
原文地址：https://serviceweaver.dev/blog/deployers.html 。
Service Weaver 允许您以多种不同的方式部署应用程序。例如，您可以在单个进程 、跨多个进程 或云 中部署应用程序。毫不奇怪，部署 Service Weaver 应用程序的代码称为deployer。这篇博文解释了部署器是什么以及如何实施部署器。我们假设您熟悉如何编写 Service Weaver 应用程序。如果不是，我们建议您阅读分步教程 。
概述 Service Weaver 应用程序由许多组件 组成。该应用程序被编译成单个应用程序二进制文件。部署者通过多次运行二进制文件来部署应用程序，通常是跨多台机器。二进制文件的每个实例都运行组件的一个子集。为了了解要运行哪些组件，二进制链接在一个称为 weavelet 的小型后台代理中，部署者使用envelope与之通信。如下图所示。
在这篇博文中，我们提供了对weavelets、deployers和envelopes的高级概述。然后，我们通过完全从头开始实施多进程部署程序，深入了解它们的工作原理。
Weavelets 要了解部署器，我们必须首先了解小波。Service Weaver 应用程序被编译成单个可执行二进制文件。链接到二进制文件中的 Service Weaver 库包括一个称为weavelet的小代理，它是在您调用 weaver.Init 时创建的。Weavelet 的主要职责是启动和管理一组组件。
部署 Service Weaver 应用程序时，不只有一个 weavelet。如果有只有一个，Service Weaver 应用程序就不会非常分散。相反，部署人员会多次运行您的二进制文件——在不同机器上的不同进程中以启动多个 weavelet，这些 weavelet 协同工作以执行您的分布式应用程序。
每个 weavelet 都承载一组可能不同的组件。因为组件是复制的，所以一个组件可能由多个weavelets托管。例如，考虑一个包含组件A、B和的应用程序C。下图显示了一个由三个weavelets组成的示例部署。weavelet 1 托管组件A和B；weavelet 2 承载组件B和 C，weavelet 3 承载组件C。
您还会注意到每个小波都有一个唯一的网络地址。Weavelets 使用这些地址来执行远程方法调用。例如，假设图中 weavelet 1上的A组件想要调用组件C 上的方法。weavelet 1 将联系地址 2.2.2.2 上的 weavelet 2 或地址 3.3.3.3 上的 weavelet 3 以执行该方法。
部署者 部署者通过启动和管理一组 weavelet 来分发 Service Weaver 应用程序。管理 weavelet 涉及与 (1) 组件、(2) 侦听器和 (3) 遥测相关的三个主要职责。</description></item><item><title>第一课Go程序怎么跑起来的</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/01%E7%AC%AC%E4%B8%80%E8%AF%BEgo%E7%A8%8B%E5%BA%8F%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/</link><pubDate>Tue, 23 Nov 2021 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/01%E7%AC%AC%E4%B8%80%E8%AF%BEgo%E7%A8%8B%E5%BA%8F%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/</guid><description>怎么学习？ https://xargin.com/how-to-learn 找程序入口 gdb info files readelf -h cutter[可视化工具] dlv 理解可执⾏⽂件 本节课涉及的⼯具都准备在Dockerfile⾥了，⼤家可以⾃⾏实验
2200000000 FROM centos RUN yum install golang -y \ &amp;amp;&amp;amp; yum install dlv -y \ &amp;amp;&amp;amp; yum install binutils -y \ &amp;amp;&amp;amp; yum install vim -y \ &amp;amp;&amp;amp; yum install gdb -y 编译方法 # 编译方法 docker build -t test . docker run -it --rm test bash Linux的可执⾏⽂件ELF(Executable and Linkable Format)为例，ELF由⼏部分构成：
ELF header Section header Sections 参考连接 https://github.com/corkaami/pics Go进程的启动与初始化 游戏：人力资源机器
环境变量：GOMAXPROCS
调度组件与调度循环 goroutine的⽣产端 https://www.figma.com/proto/gByIPDf4nRr6No4dNYjn3e/bootstrap?page-id=242%3A7&amp;amp;nodeid=242%3A215&amp;amp;viewport=516%2C209%2C0.07501539587974548&amp;amp;scaling=scale-down-width goroutine的消费端 https://www.</description></item><item><title>管理多版本 Go 安装</title><link>/2021/11/23/%E7%AE%A1%E7%90%86%E5%A4%9A%E7%89%88%E6%9C%AC-go-%E5%AE%89%E8%A3%85/</link><pubDate>Tue, 23 Nov 2021 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2021/11/23/%E7%AE%A1%E7%90%86%E5%A4%9A%E7%89%88%E6%9C%AC-go-%E5%AE%89%E8%A3%85/</guid><description>管理 Go 安装 目录 安装多个 Go 版本 卸载 Go Linux / macOS / FreeBSD 视窗 本主题介绍如何在同一台机器上安装多个版本的 Go，以及如何卸载 Go。
有关安装的其他内容，您可能对以下内容感兴趣：
下载和安装 ——最简单的安装和运行方式。 从源代码安装 Go—— 如何检查源代码、在您自己的机器上构建它们并运行它们。 安装多个 Go 版本 您可以在同一台机器上安装多个 Go 版本。例如，您可能希望在多个 Go 版本上测试您的代码。有关可以通过这种方式安装的版本列表，请参阅下载页面 。
**注意：**要使用此处描述的方法进行安装，您需要安装git 。
要安装其他 Go 版本，请运行go install命令 ，指定要安装的版本的下载位置。以下示例说明了版本 1.10.7：
# go version &amp;lt; 1.17 $ go get -u golang.org/dl/go1.10.7 # go version &amp;gt;= 1.17 $ go install golang.org/dl/go1.10.7@latest $ go1.10.7 download	要使用新下载的版本运行go命令，请将版本号附加到go命令中，如下所示：
$ go1.10.7 version go version go1.10.7 linux/amd64 当您安装了多个版本时，您可以发现每个版本的安装位置，查看版本的GOROOT值。例如，运行如下命令：
$ go1.10.7 env GOROOT 要卸载下载的版本，只需删除其GOROOT环境变量和 goX.</description></item><item><title>第二课 Go语法背后的秘密</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/02%E7%AC%AC%E4%BA%8C%E8%AF%BEgo%E8%AF%AD%E6%B3%95%E8%83%8C%E5%90%8E%E7%9A%84%E7%A7%98%E5%AF%86/</link><pubDate>Wed, 15 Dec 2021 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/02%E7%AC%AC%E4%BA%8C%E8%AF%BEgo%E8%AF%AD%E6%B3%95%E8%83%8C%E5%90%8E%E7%9A%84%E7%A7%98%E5%AF%86/</guid><description> go build -x hello.go 语法分析 https://astexplorer.net GOSSAFUNC=funcname go builld x.go
编译过程 https://godbolt.org go tool compile -S ./hello.go | grep &amp;ldquo;hello.go:5&amp;rdquo;
go tool objdump ./x
goyacc
课上推荐资源 https://xargin.com/addr-of-empty-struct-may-not-eq/ https://xargin.com/go1-17-new-calling-convention/ https://elasticsearch.cn/article/114 Github https://github.com/cch123/elasticsql https://github.com/cch123/parser_example https://github.com/go-internals-cn/go-internals https://github.com/grantseltzer/weaver https://github.com/YYCoder/protobuf-thrift https://github.com/vitessio/vitess https://github.com/xwb1989/sqlparser Dash 文档工具
电子书渠道 libgen、z-lib
关注公众号获得更多精彩文章</description></item><item><title>第三课 神奇的内置数据结构</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/03%E7%AC%AC%E4%B8%89%E8%AF%BE%E7%A5%9E%E5%A5%87%E7%9A%84%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Wed, 15 Dec 2021 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/03%E7%AC%AC%E4%B8%89%E8%AF%BE%E7%A5%9E%E5%A5%87%E7%9A%84%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>参考资料 Github https://github.com/go-internals-cn/go-internals https://github.com/grantseltzer/weaver gopsutil、top、runtime.MemStats
关注公众号获得更多精彩文章</description></item><item><title>第四课 编程语言与操作系统的桥梁</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/04%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A1%A5%E6%A2%81/</link><pubDate>Wed, 22 Dec 2021 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/04%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A1%A5%E6%A2%81/</guid><description>关注公众号获得更多精彩文章</description></item><item><title>第五课 Go 语言的内存管理和拉垃圾回收</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/05%E7%AC%AC%E4%BA%94%E8%AF%BEgo-%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E6%8B%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link><pubDate>Wed, 22 Dec 2021 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/05%E7%AC%AC%E4%BA%94%E8%AF%BEgo-%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E6%8B%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid><description>内存逃逸分析： cmd/compile/internal/escape.go
test：/master/test
go build -gcflags=&amp;quot;-m&amp;quot; escapge.go 书 垃圾回收的算法与实现 垃圾回收算法手册（章节1、2、7、11.8、12.1、15、19.6） 关注公众号获得更多精彩文章</description></item><item><title>第三课 神奇的内置数据结构</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/04%E7%AC%AC%E4%B8%89%E5%9B%9B%E8%AF%BE%E7%AD%94%E7%96%91/</link><pubDate>Wed, 15 Dec 2021 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/04%E7%AC%AC%E4%B8%89%E5%9B%9B%E8%AF%BE%E7%AD%94%E7%96%91/</guid><description>课上推荐资源：
Benchstat go
https://github.com/gopl-zh/gopl-zh.github.com https://github.com/cznic/goyacc https://github.com/chai2010/go-ast-book java https://github.com/alibaba/arthas 关注公众号获得更多精彩文章</description></item><item><title>第六课 并发编程最佳实践实</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/06%E7%AC%AC%E5%85%AD%E8%AF%BE%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%AE%9E/</link><pubDate>Fri, 14 Jan 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/06%E7%AC%AC%E5%85%AD%E8%AF%BE%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%AE%9E/</guid><description>关注公众号获得更多精彩文章</description></item><item><title>第七课 社区优秀开源框架对比</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/07%E7%AC%AC%E4%B8%83%E8%AF%BE%E7%A4%BE%E5%8C%BA%E4%BC%98%E7%A7%80%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/</link><pubDate>Fri, 14 Jan 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/07%E7%AC%AC%E4%B8%83%E8%AF%BE%E7%A4%BE%E5%8C%BA%E4%BC%98%E7%A7%80%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/</guid><description> https://jaycechant.info/2020/go-bindata-golang-static-resources-embedding/ 关注公众号获得更多精彩文章</description></item><item><title>第八课 深入Web框架原理与实现</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/08%E7%AC%AC%E5%85%AB%E8%AF%BE%E6%B7%B1%E5%85%A5web%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</link><pubDate>Fri, 14 Jan 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/08%E7%AC%AC%E5%85%AB%E8%AF%BE%E6%B7%B1%E5%85%A5web%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</guid><description>关注公众号获得更多精彩文章</description></item><item><title>第8周 位运算、布隆过滤器和LRU缓存、排序算法</title><link>/study/algorithm/go/week08/</link><pubDate>Mon, 20 Dec 2021 22:42:54 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/go/week08/</guid><description>题目数量：12
第16课 | 位运算 1. 位运算基础及实战要点 参考链接 如何从十进制转换为二进制 2. 位运算实战题目解析 参考链接 N 皇后位运算代码示例 实战题目 / 课后作业 191. 位1的个数 // 最优写法 func hammingWeight(num uint32) (cnt int) { for num &amp;gt; 0 { cnt++ num &amp;amp;= num - 1 } return cnt } // O(n) n = 32 func hammingWeight(num uint32) (cnt int) { for num &amp;gt; 0 { cnt += int(num &amp;amp; 1) num &amp;gt;&amp;gt;= 1 } return cnt } 231. 2的幂 func isPowerOfTwo(n int) bool { return n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;amp; (n - 1) == 0 } // 没有上面运行快 func isPowerOfTwo(n int) bool { return n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;amp; -n == n } //方案二： 判断是否为最大 22 的幂的约数 func isPowerOfTwo(n int) bool { const big = 1 &amp;lt;&amp;lt; 30 return n &amp;gt; 0 &amp;amp;&amp;amp; big%n == 0 } 190.</description></item><item><title>第九课 框架之上的业务分层</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/09%E7%AC%AC%E4%B9%9D%E8%AF%BE%E6%A1%86%E6%9E%B6%E4%B9%8B%E4%B8%8A%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%88%86%E5%B1%82/</link><pubDate>Fri, 14 Jan 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/09%E7%AC%AC%E4%B9%9D%E8%AF%BE%E6%A1%86%E6%9E%B6%E4%B9%8B%E4%B8%8A%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%88%86%E5%B1%82/</guid><description>关注公众号获得更多精彩文章</description></item><item><title>第十课如何写出优雅的Go代码</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/10%E7%AC%AC%E5%8D%81%E8%AF%BE%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%BC%98%E9%9B%85%E7%9A%84go%E4%BB%A3%E7%A0%81/</link><pubDate>Fri, 14 Jan 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/10%E7%AC%AC%E5%8D%81%E8%AF%BE%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%BC%98%E9%9B%85%E7%9A%84go%E4%BB%A3%E7%A0%81/</guid><description> effective-go
50 shades
100 Go Mistakes (How to Avoid Them)
awesome-go
golint golangci-lint go fmt go vet gocyclo 圈复杂度检查 ineffassign misspell reviewdog
《重构》第二版第三章 bad smell
《代码大全》表驱动章节
参考学习资料 goreportcard.com https://golang.com/cmd/vet https://github.com/kisielk/errcheck https://github.com/timakin/bodyclose https://github.com/gostaticanalysis/sqlrows https://github.com/analysis-tools-dev/static-analysis https://xargin.com/about-livinig-doc/ https://www.jetbrains.com/help/go/using-the-testify-toolkit.html#compare-expected-and-actual-values https://github.com/golang/go/wiki/TableDrivenTests https://segment.com/blog/5-advanced-testing-techniques-in-go/ https://stackoverflow.com/questions/42102496/testing-a-grpc-service https://github.com/smartystreets/goconvey https://github.com/onsi/ginkgo https://blog.csdn.net/zwqjoy/article/details/79474196 https://juejin.cn/post/6844903837875208205 Go programming language第11章
https://github.com/gopl-zh/gopl-zh.github.com PingCAP的failpoint
https://github.com/pingcap/failpoint failpoint的设计与实现
https://juejin.cn/post/6844903837875208205 GoConvey测试
https://blog.csdn.net/zwqjoy/article/details/79474196 ginkgo测试
https://semaphoreci.com/community/tutorials/getting-started-with-bdd-in-go-using-ginkgo Didi的Go流量录制、流量回放⽅案
https://github.com/didi/sharingan 关注公众号获得更多精彩文章</description></item><item><title>第十一课 设计互联网高并发数据中台</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/11%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AF%BE%E8%AE%BE%E8%AE%A1%E4%BA%92%E8%81%94%E7%BD%91%E9%AB%98%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0/</link><pubDate>Fri, 14 Jan 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/11%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AF%BE%E8%AE%BE%E8%AE%A1%E4%BA%92%E8%81%94%E7%BD%91%E9%AB%98%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0/</guid><description>关注公众号获得更多精彩文章</description></item><item><title>第十二课 成为Go语言性能调优专家</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/12%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AF%BE%E6%88%90%E4%B8%BAgo%E8%AF%AD%E8%A8%80%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%93%E5%AE%B6/</link><pubDate>Fri, 14 Jan 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/12%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AF%BE%E6%88%90%E4%B8%BAgo%E8%AF%AD%E8%A8%80%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%93%E5%AE%B6/</guid><description>关注公众号获得更多精彩文章</description></item><item><title>第十三课 分布式服务的拆分难题</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/13%E7%AC%AC%E5%8D%81%E4%B8%89%E8%AF%BE%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%8B%86%E5%88%86%E9%9A%BE%E9%A2%98/</link><pubDate>Fri, 14 Jan 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/13%E7%AC%AC%E5%8D%81%E4%B8%89%E8%AF%BE%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%8B%86%E5%88%86%E9%9A%BE%E9%A2%98/</guid><description>关注公众号获得更多精彩文章</description></item><item><title>第十四课 一线互联网公司的CI/CD实践</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/14%E7%AC%AC%E5%8D%81%E5%9B%9B%E8%AF%BE%E4%B8%80%E7%BA%BF%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E7%9A%84cicd%E5%AE%9E%E8%B7%B5/</link><pubDate>Fri, 14 Jan 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/14%E7%AC%AC%E5%8D%81%E5%9B%9B%E8%AF%BE%E4%B8%80%E7%BA%BF%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E7%9A%84cicd%E5%AE%9E%E8%B7%B5/</guid><description>关注公众号获得更多精彩文章</description></item><item><title>第十五课 微服务的监控和可观测序</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/15%E7%AC%AC%E5%8D%81%E4%BA%94%E8%AF%BE%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%9B%91%E6%8E%A7%E5%92%8C%E5%8F%AF%E8%A7%82%E6%B5%8B%E5%BA%8F/</link><pubDate>Mon, 10 Jan 2022 13:40:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/15%E7%AC%AC%E5%8D%81%E4%BA%94%E8%AF%BE%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%9B%91%E6%8E%A7%E5%92%8C%E5%8F%AF%E8%A7%82%E6%B5%8B%E5%BA%8F/</guid><description>Metrics Prometheus 默认端口9090 Counter【计数类】、Gauge【状态数据】、Summary【分位数据】、Histogram【直方图】 Pushgateway 默认端口9091 Alertmanager 告警模块 Google 的Monarch Traces Logs 关注公众号获得更多精彩文章</description></item><item><title>第十六课微服务基础设施-服务发现、检索、定时任务、MQ</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/16%E7%AC%AC%E5%8D%81%E5%85%AD%E8%AF%BE%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%A3%80%E7%B4%A2%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1mq/</link><pubDate>Mon, 10 Jan 2022 13:40:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/16%E7%AC%AC%E5%8D%81%E5%85%AD%E8%AF%BE%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%A3%80%E7%B4%A2%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1mq/</guid><description>MQ Kafka
Pulsar
关注公众号获得更多精彩文章</description></item><item><title>第十七课 大型互联网公司的稳定性密码</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/17%E7%AC%AC%E5%8D%81%E4%B8%83%E8%AF%BE%E5%A4%A7%E5%9E%8B%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%AF%86%E7%A0%81/</link><pubDate>Fri, 14 Jan 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/17%E7%AC%AC%E5%8D%81%E4%B8%83%E8%AF%BE%E5%A4%A7%E5%9E%8B%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%AF%86%E7%A0%81/</guid><description>混沌工程 ChaosBlade
Chaos Mesh
关注公众号获得更多精彩文章</description></item><item><title>第十八课 Cloud Native Go</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/18%E7%AC%AC%E5%8D%81%E5%85%AB%E8%AF%BEcloud-native-go/</link><pubDate>Fri, 14 Jan 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/18%E7%AC%AC%E5%8D%81%E5%85%AB%E8%AF%BEcloud-native-go/</guid><description>参考 https://github.com/lorin/resilience-engineering https://sre.google 安全容器：gVisor、katacontainer
sealos、minikube
etcd运维平台：kstone
《深入剖析kubernetes》
《DevSecOps 实战》
Caddy
https://dengxiaolong.com/caddy/zh/ https://caddyserver.com/docs/ 云原生 ingress：envoy Contour maglev 论文
https://blog.csdn.net/chenyulancn/article/details/79019457 SDN 关注公众号获得更多精彩文章</description></item><item><title>第十九课 Go语言前沿实时剖析</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/19%E7%AC%AC%E5%8D%81%E4%B9%9D%E8%AF%BEgo%E8%AF%AD%E8%A8%80%E5%89%8D%E6%B2%BF%E5%AE%9E%E6%97%B6%E5%89%96%E6%9E%90/</link><pubDate>Fri, 14 Jan 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/19%E7%AC%AC%E5%8D%81%E4%B9%9D%E8%AF%BEgo%E8%AF%AD%E8%A8%80%E5%89%8D%E6%B2%BF%E5%AE%9E%E6%97%B6%E5%89%96%E6%9E%90/</guid><description>关注公众号获得更多精彩文章</description></item><item><title>第二十课 Go 语言与未来架构</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/20%E7%AC%AC%E4%BA%8C%E5%8D%81%E8%AF%BEgo%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%9C%AA%E6%9D%A5%E6%9E%B6%E6%9E%84/</link><pubDate>Fri, 14 Jan 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/20%E7%AC%AC%E4%BA%8C%E5%8D%81%E8%AF%BEgo%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%9C%AA%E6%9D%A5%E6%9E%B6%E6%9E%84/</guid><description>Service Mesh cds (Cluster discovery service) eds (Endpotin discovery service) lds (Listener discovery service) rds (Route discovery service) 组件 xDS protoc
Envoy
MOSN
Istio
Dapr（Distributed Application Runtime）
Mecha架构 http2&amp;amp;3学习手册: https://github.com/bagder/http2-explained https://http2-explained.haxx.se/zh https://github.com/bagder/http3-explained https://http3-explained.haxx.se/zh https://cloud.google.com/traffic-director/docs/proxyless-overview https://isovalent.com/blog/post/2021-12-08-ebpf-servicemesh 练习 Dapr 搭建hello world
dapr 文档: https://docs.dapr.io/zh-hans/ 关注公众号获得更多精彩文章</description></item><item><title>第十八课 以go-micro为例讲讲抽象【二期内容】</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/21%E7%AC%AC%E5%8D%81%E5%85%AB%E8%AF%BE-%E4%BB%A5go-micro%E4%B8%BA%E4%BE%8B%E8%AE%B2%E8%AE%B2%E6%8A%BD%E8%B1%A1%E4%BA%8C%E6%9C%9F/</link><pubDate>Sat, 12 Mar 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/21%E7%AC%AC%E5%8D%81%E5%85%AB%E8%AF%BE-%E4%BB%A5go-micro%E4%B8%BA%E4%BE%8B%E8%AE%B2%E8%AE%B2%E6%8A%BD%E8%B1%A1%E4%BA%8C%E6%9C%9F/</guid><description>参考链接 依赖反转相关 righting software 读书笔记 关注公众号获得更多精彩文章</description></item></channel></rss>