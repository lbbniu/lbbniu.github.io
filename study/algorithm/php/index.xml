<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PHP算法练习 on lbbniu</title><link>/study/algorithm/php/</link><description>Recent content in PHP算法练习 on lbbniu</description><generator>Hugo -- gohugo.io</generator><language>zh</language><managingEditor>lbbniu@gmail.com (lbbniu)</managingEditor><webMaster>lbbniu@gmail.com (lbbniu)</webMaster><copyright>&amp;copy; 2021 &lt;a href="https://blog.lbbniu.com/">lbbniu&lt;/a></copyright><lastBuildDate>Sat, 20 Nov 2021 17:18:16 +0800</lastBuildDate><atom:link href="/study/algorithm/php/index.xml" rel="self" type="application/rss+xml"/><item><title>预习</title><link>/study/algorithm/php/00%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E9%A2%84%E4%B9%A0/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/php/00%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E9%A2%84%E4%B9%A0/</guid><description>预习 第一课 预习 第二课 预习知识点 数组：为什么很多编程语言中数组都从 0 开始编号？ 链表：如何实现 LRU 缓存淘汰算法? 链表：如何轻松写出正确的链表代码？ 跳表：为什么 Redis 一定要用跳表来实现有序集合？ 预习题目 移动零 盛最多水的容器 爬楼梯 三数之和 环形链表</description></item><item><title>第1周</title><link>/study/algorithm/php/01%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%80%E5%91%A8/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/php/01%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%80%E5%91%A8/</guid><description>第一周 第三课|数组、链表、跳表 参考链接 Java 源码分析（ArrayList） Linked List 的标准实现代码 [Linked List 示例代码](http://www.cs.cmu.edu/~adamchik/15-121/lectures/Linked Lists/code/LinkedList.java) Java 源码分析（LinkedList） LRU Cache - Linked list： LRU 缓存机制 Redis - Skip List：跳跃表 、为啥 Redis 使用跳表（Skip List）而不是使用 Red-Black？ Array 实战题目 11. 盛最多水的容器 //方法一： 暴力求解 双循环 class Solution { /** * @param Integer[] $height * @return Integer */ function maxArea($height) { $max = 0; $len = count($height); for ($i = 0; $i &amp;lt; $len - 1; $i++) { for ($j = $i + 1; $j &amp;lt; $len; $j++) { $area = ($j - $i) * min($height[$i], $height[$j]); $max = $area &amp;lt; $max ?</description></item><item><title>第2周</title><link>/study/algorithm/php/02%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%BA%8C%E5%91%A8/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/php/02%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%BA%8C%E5%91%A8/</guid><description>第2周 第4课 | 栈、队列、优先队列、双端队列 参考链接 Java 的 PriorityQueue 文档 Java 的 Stack 源码 Java 的 Queue 源码 Python 的 heapq 高性能的 container 库 预习题目 20. 有效的括号 class Solution { /** * 方法一：栈(spl标准库) * @param String $s * @return Boolean */ function isValid($s) { //构造哈希表 $map = [')'=&amp;gt;'(', ']'=&amp;gt;'[', '}'=&amp;gt;'{']; $stack = new SplStack(); for ($i = 0, $len = strlen($s); $i &amp;lt; $len; $i++) { if (!isset($map[$s[$i]])) { $stack-&amp;gt;push($s[$i]); } else if (!$stack-&amp;gt;count() || $stack-&amp;gt;pop() !</description></item><item><title>第3周</title><link>/study/algorithm/php/03%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%89%E5%91%A8/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/php/03%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%89%E5%91%A8/</guid><description>第3周 第6课 | 树、二叉树、二叉搜索树 1. 树、二叉树、二叉搜索树的实现和特性 参考链接 二叉搜索树 Demo 思考题 树的面试题解法一般都是递归，为什么？ 说明：同学们可以将自己的思考写在课程下方的留言区一起讨论，也可以写在第 2 周的学习总结中。
2. 实战题目解析：二叉树的中序遍历 参考链接 树的遍历 Demo 实战题目 / 课后作业 94. 二叉树的中序遍历 /** * Definition for a binary tree node. * class TreeNode { * public $val = null; * public $left = null; * public $right = null; * function __construct($value) { $this-&amp;gt;val = $value; } * } */ class Solution { private $values = []; /** * 方法一：递归 * @param TreeNode $root * @return Integer[] */ function inorderTraversal1($root) { $this-&amp;gt;inorder($root); return $this-&amp;gt;values; } function inorder($root) { if ($root) { $this-&amp;gt;inorder($root-&amp;gt;left); $this-&amp;gt;values[] = $root-&amp;gt;val; $this-&amp;gt;inorder($root-&amp;gt;right); } } /** * 方法二：迭代 * @param TreeNode $root * @return Integer[] */ function inorderTraversal2($root) { $stack = $res = []; while ($root || $stack) { while ($root) { $stack[] = $root; $root = $root-&amp;gt;left; } $root = array_pop($stack); $res[] = $root-&amp;gt;val; $root = $root-&amp;gt;right; } return $res; } /** * 方法三：颜色标记法 * @param TreeNode $root * @return Integer[] */ function inorderTraversal3($root) { $white = 0; $gray = 1; $stack = [[$white, $root]]; $res = []; while ($stack) { [$color, $node ] = array_pop($stack); if (!</description></item><item><title>第4周</title><link>/study/algorithm/php/04%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%9B%9B%E5%91%A8/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/php/04%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%9B%9B%E5%91%A8/</guid><description>第4周 第9课 | 深度优先搜索和广度优先搜索 1. 深度优先搜索、广度优先搜索的实现和特性 参考链接 DFS 代码模板（递归写法、非递归写法） 递归写法
visited = set() def dfs(node, visited): if node in visited: # terminator # already visited return visited.add(node) # process current node here. ... for next_node in node.children(): if next_node not in visited: dfs(next_node, visited) 非递归写法
def DFS(self, tree): if tree.root is None: return [] visited, stack = [], [tree.root] while stack: node = stack.pop() visited.add(node) process (node) nodes = generate_related_nodes(node) stack.push(nodes) # other processing work .</description></item><item><title>第4周总结</title><link>/study/algorithm/php/04%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%9B%9B%E5%91%A8%E6%80%BB%E7%BB%93/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/php/04%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%9B%9B%E5%91%A8%E6%80%BB%E7%BB%93/</guid><description>DFS 代码模板（递归写法、非递归写法） 递归写法
visited = set() def dfs(node, visited): if node in visited: # terminator # already visited return visited.add(node) # process current node here. ... for next_node in node.children(): if next_node not in visited: dfs(next_node, visited) 非递归写法
def DFS(self, tree): if tree.root is None: return [] visited, stack = [], [tree.root] while stack: node = stack.pop() visited.add(node) process (node) nodes = generate_related_nodes(node) stack.push(nodes) # other processing work ... BFS 代码模板 def BFS(graph, start, end): visited = set() queue = [] queue.</description></item><item><title>第6周</title><link>/study/algorithm/php/06%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%85%AD%E5%91%A8/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/php/06%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%85%AD%E5%91%A8/</guid><description>第12课 | 动态规划 1. 动态规划的实现及关键点 参考链接 递归代码模板 # Python 代码模板 def recursion(level, param1, param2, ...): # recursion terminator if level &amp;gt; MAX_LEVEL: process_result return # process logic in current level process(level, data...) # drill down self.recursion(level + 1, p1, ...) # reverse the current level status if needed //Java 代码模板 public void recur(int level, int param) { // terminator if (level &amp;gt; MAX_LEVEL) { // process result return; // process current logic process(level, param); // drill down recur( level: level + 1, newParam); // restore current status } 分治代码模板 def divide_conquer(problem, param1, param2, .</description></item><item><title>第7周</title><link>/study/algorithm/php/07%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%83%E5%91%A8/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/php/07%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%83%E5%91%A8/</guid><description>第7周 第13课 | 字典树和并查集 1. Trie树的基本实现和特性 参考链接 102. 二叉树的层序遍历 /** * Definition for a binary tree node. * class TreeNode { * public $val = null; * public $left = null; * public $right = null; * function __construct($value) { $this-&amp;gt;val = $value; } * } */ class Solution { /** * bfs * @param TreeNode $root * @return Integer[][] */ function levelOrder($root) { if (!$root) return []; $queue = [$root]; $res = []; while ($queue) { $count = count($queue); $row = []; while ($count--) { $node = array_shift($queue); $row[] = $node-&amp;gt;val; $node-&amp;gt;left &amp;amp;&amp;amp; $queue[] = $node-&amp;gt;left; $node-&amp;gt;right &amp;amp;&amp;amp; $queue[] = $node-&amp;gt;right; } $res[] = $row; } return $res; } // function levelOrder($root) { if (!</description></item><item><title>第8周</title><link>/study/algorithm/php/08%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%85%AB%E5%91%A8/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/php/08%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%85%AB%E5%91%A8/</guid><description>第8周 第16课 | 位运算 1. 位运算基础及实战要点 参考链接 如何从十进制转换为二进制 2. 位运算实战题目解析 参考链接 N 皇后位运算代码示例 def totalNQueens(self, n): if n &amp;lt; 1: return [] self.count = 0 self.DFS(n, 0, 0, 0, 0) return self.count def DFS(self, n, row, cols, pie, na): # recursion terminator if row &amp;gt;= n: self.count += 1 return bits = (~(cols | pie | na)) &amp;amp; ((1 &amp;lt;&amp;lt; n) — 1) # 得到当前所有的空位 while bits: p = bits &amp;amp; —bits # 取到最低位的1 bits = bits &amp;amp; (bits — 1) # 表示在p位置上放入皇后 self.</description></item><item><title>第9周</title><link>/study/algorithm/php/09%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B9%9D%E5%91%A8/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/php/09%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B9%9D%E5%91%A8/</guid><description>第9周 第19课 | 高级动态规划 1. 动态规划、状态转移方程串讲 参考链接 70.爬楼梯 class Solution { /** * 动态规划解法 * Binets 方法 和 斐波那契公式 时间复杂度为O(log(N)) * @param Integer $n * @return Integer */ function climbStairs($n) { if ($n &amp;lt;= 2) return $n; $first = 1; $second = 2; for ($i = 3; $i &amp;lt;= $n; $i++) { $tmp = $first + $second; $first = $second; $second = $tmp; } return $second; } } //斐波那契公式 public class Solution { public int climbStairs(int n) { double sqrt5=Math.</description></item></channel></rss>