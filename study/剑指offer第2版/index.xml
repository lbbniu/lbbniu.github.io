<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>剑指Offer第二版 on lbbniu</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/</link><description>Recent content in 剑指Offer第二版 on lbbniu</description><generator>Hugo -- gohugo.io</generator><language>zh</language><managingEditor>lbbniu@gmail.com (lbbniu)</managingEditor><webMaster>lbbniu@gmail.com (lbbniu)</webMaster><copyright>&amp;copy; 2021 &lt;a href="https://blog.lbbniu.com/">lbbniu&lt;/a></copyright><lastBuildDate>Thu, 28 Jul 2022 21:30:00 +0800</lastBuildDate><atom:link href="/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/index.xml" rel="self" type="application/rss+xml"/><item><title>剑指 Offer 03 数组中重复的数字</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/</guid><description>剑指 Offer 03 数组中重复的数字 找出数组中重复的数字。
在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
示例 1：
输入： [2, 3, 1, 0, 2, 5, 3] 输出：2 或 3 &amp;nbsp;
限制：
2 &amp;lt;= n &amp;lt;= 100000
func findRepeatNumber(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof</description></item><item><title>剑指 Offer 04 二维数组中的查找</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-wei-shu-zu-zhong-de-cha-zhao-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-wei-shu-zu-zhong-de-cha-zhao-lcof/</guid><description>剑指 Offer 04 二维数组中的查找 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
示例:
现有矩阵 matrix 如下：
[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。
给定 target = 20，返回 false。
限制：
0 &lt;= n &lt;= 1000
0 &lt;= m &lt;= 1000
注意：本题与主站 240 题相同：https://leetcode-cn.com/problems/search-a-2d-matrix-ii/
func findNumberIn2DArray(matrix [][]int, target int) bool { } LeetCode题库地址 https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof</description></item><item><title>剑指 Offer 05 替换空格</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ti-huan-kong-ge-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ti-huan-kong-ge-lcof/</guid><description>剑指 Offer 05 替换空格 请实现一个函数，把字符串 s 中的每个空格替换成&amp;quot;%20&amp;quot;。
&amp;nbsp;
示例 1：
输入：s = &amp;quot;We are happy.&amp;quot; 输出：&amp;quot;We%20are%20happy.&amp;quot; &amp;nbsp;
限制：
0 &amp;lt;= s 的长度 &amp;lt;= 10000
func replaceSpace(s string) string { } LeetCode题库地址 https://leetcode.cn/problems/ti-huan-kong-ge-lcof</description></item><item><title>剑指 Offer 06 从尾到头打印链表</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/cong-wei-dao-tou-da-yin-lian-biao-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/cong-wei-dao-tou-da-yin-lian-biao-lcof/</guid><description>剑指 Offer 06 从尾到头打印链表 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
&amp;nbsp;
示例 1：
输入：head = [1,3,2] 输出：[2,3,1] &amp;nbsp;
限制：
0 &amp;lt;= 链表长度 &amp;lt;= 10000
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reversePrint(head *ListNode) []int { } LeetCode题库地址 https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof</description></item><item><title>剑指 Offer 07 重建二叉树</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zhong-jian-er-cha-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zhong-jian-er-cha-shu-lcof/</guid><description>剑指 Offer 07 重建二叉树 输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。
假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
示例 1:
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] Output: [3,9,20,null,null,15,7] 示例 2:
Input: preorder = [-1], inorder = [-1] Output: [-1] 限制：
0 &lt;= 节点个数 &lt;= 5000
注意：本题与主站 105 题重复：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func buildTree(preorder []int, inorder []int) *TreeNode { } LeetCode题库地址 https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof</description></item><item><title>剑指 Offer 09 用两个栈实现队列</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/</guid><description>剑指 Offer 09 用两个栈实现队列 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead&amp;nbsp;操作返回 -1 )
&amp;nbsp;
示例 1：
输入： [&amp;quot;CQueue&amp;quot;,&amp;quot;appendTail&amp;quot;,&amp;quot;deleteHead&amp;quot;,&amp;quot;deleteHead&amp;quot;] [[],[3],[],[]] 输出：[null,null,3,-1] 示例 2：
输入： [&amp;quot;CQueue&amp;quot;,&amp;quot;deleteHead&amp;quot;,&amp;quot;appendTail&amp;quot;,&amp;quot;appendTail&amp;quot;,&amp;quot;deleteHead&amp;quot;,&amp;quot;deleteHead&amp;quot;] [[],[],[5],[2],[],[]] 输出：[null,-1,null,null,5,2] 提示：
1 &amp;lt;= values &amp;lt;= 10000 最多会对&amp;nbsp;appendTail、deleteHead 进行&amp;nbsp;10000&amp;nbsp;次调用 type CQueue struct { } func Constructor() CQueue { } func (this *CQueue) AppendTail(value int) { } func (this *CQueue) DeleteHead() int { } /** * Your CQueue object will be instantiated and called as such: * obj := Constructor(); * obj.AppendTail(value); * param_2 := obj.</description></item><item><title>剑指 Offer 10- I 斐波那契数列</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/fei-bo-na-qi-shu-lie-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/fei-bo-na-qi-shu-lie-lcof/</guid><description>剑指 Offer 10- I 斐波那契数列 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：
F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N > 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
示例 1：
输入：n = 2 输出：1 示例 2：
输入：n = 5 输出：5 提示：
0 &lt;= n &lt;= 100 func fib(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof</description></item><item><title>剑指 Offer 10- II 青蛙跳台阶问题</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/qing-wa-tiao-tai-jie-wen-ti-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/qing-wa-tiao-tai-jie-wen-ti-lcof/</guid><description>剑指 Offer 10- II 青蛙跳台阶问题 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n&amp;nbsp;级的台阶总共有多少种跳法。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
示例 1：
输入：n = 2 输出：2 示例 2：
输入：n = 7 输出：21 示例 3：
输入：n = 0 输出：1 提示：
0 &amp;lt;= n &amp;lt;= 100 注意：本题与主站 70 题相同：https://leetcode-cn.com/problems/climbing-stairs/
&amp;nbsp;
func numWays(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof</description></item><item><title>剑指 Offer 11 旋转数组的最小数字</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/</guid><description>剑指 Offer 11 旋转数组的最小数字 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
给你一个可能存在&amp;nbsp;重复&amp;nbsp;元素值的数组&amp;nbsp;numbers&amp;nbsp;，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组&amp;nbsp;[3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。&amp;nbsp;&amp;nbsp;
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。
&amp;nbsp;
示例 1：
输入：numbers = [3,4,5,1,2] 输出：1 示例 2：
输入：numbers = [2,2,2,0,1] 输出：0 &amp;nbsp;
提示：
n == numbers.length 1 &amp;lt;= n &amp;lt;= 5000 -5000 &amp;lt;= numbers[i] &amp;lt;= 5000 numbers 原来是一个升序排序的数组，并进行了 1 至 n 次旋转 注意：本题与主站 154 题相同：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/
func minArray(numbers []int) int { } LeetCode题库地址 https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof</description></item><item><title>剑指 Offer 12 矩阵中的路径</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ju-zhen-zhong-de-lu-jing-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ju-zhen-zhong-de-lu-jing-lcof/</guid><description>剑指 Offer 12 矩阵中的路径 给定一个&amp;nbsp;m x n 二维字符网格&amp;nbsp;board 和一个字符串单词&amp;nbsp;word 。如果&amp;nbsp;word 存在于网格中，返回 true ；否则，返回 false 。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
&amp;nbsp;
例如，在下面的 3×4 的矩阵中包含单词 "ABCCED"（单词中的字母已标出）。
&amp;nbsp;
示例 1：
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED" 输出：true 示例 2：
输入：board = [["a","b"],["c","d"]], word = "abcd" 输出：false &amp;nbsp;
提示：
m == board.length n = board[i].length 1 &amp;lt;= m, n &amp;lt;= 6 1 &amp;lt;= word.length &amp;lt;= 15 board 和 word 仅由大小写英文字母组成 注意：本题与主站 79 题相同：https://leetcode-cn.com/problems/word-search/
func exist(board [][]byte, word string) bool { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer 13 机器人的运动范围</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ji-qi-ren-de-yun-dong-fan-wei-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ji-qi-ren-de-yun-dong-fan-wei-lcof/</guid><description>剑指 Offer 13 机器人的运动范围 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？
&amp;nbsp;
示例 1：
输入：m = 2, n = 3, k = 1 输出：3 示例 2：
输入：m = 3, n = 1, k = 0 输出：1 提示：
1 &amp;lt;= n,m &amp;lt;= 100 0 &amp;lt;= k&amp;nbsp;&amp;lt;= 20 func movingCount(m int, n int, k int) int { } LeetCode题库地址 https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof</description></item><item><title>面试题13 机器人的运动范围</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ji-qi-ren-de-yun-dong-fan-wei-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ji-qi-ren-de-yun-dong-fan-wei-lcof/</guid><description>面试题13 机器人的运动范围 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？
&amp;nbsp;
示例 1：
输入：m = 2, n = 3, k = 1 输出：3 示例 2：
输入：m = 3, n = 1, k = 0 输出：1 提示：
1 &amp;lt;= n,m &amp;lt;= 100 0 &amp;lt;= k&amp;nbsp;&amp;lt;= 20 func movingCount(m int, n int, k int) int { } LeetCode题库地址 https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof</description></item><item><title>剑指 Offer 14- I 剪绳子</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/jian-sheng-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/jian-sheng-zi-lcof/</guid><description>剑指 Offer 14- I 剪绳子 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&amp;gt;1并且m&amp;gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
示例 1：
输入: 2 输出: 1 解释: 2 = 1 + 1, 1 &amp;times; 1 = 1 示例&amp;nbsp;2:
输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 &amp;times;&amp;nbsp;3 &amp;times;&amp;nbsp;4 = 36 提示：
2 &amp;lt;= n &amp;lt;= 58 注意：本题与主站 343 题相同：https://leetcode-cn.com/problems/integer-break/
func cuttingRope(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/jian-sheng-zi-lcof</description></item><item><title>剑指 Offer 14- II 剪绳子 II</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/jian-sheng-zi-ii-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/jian-sheng-zi-ii-lcof/</guid><description>剑指 Offer 14- II 剪绳子 II 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m&amp;nbsp;段（m、n都是整数，n&amp;gt;1并且m&amp;gt;1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
&amp;nbsp;
示例 1：
输入: 2 输出: 1 解释: 2 = 1 + 1, 1 &amp;times; 1 = 1 示例&amp;nbsp;2:
输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 &amp;times;&amp;nbsp;3 &amp;times;&amp;nbsp;4 = 36 &amp;nbsp;
提示：
2 &amp;lt;= n &amp;lt;= 1000 注意：本题与主站 343 题相同：https://leetcode-cn.com/problems/integer-break/
func cuttingRope(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/jian-sheng-zi-ii-lcof</description></item><item><title>剑指 Offer 15 二进制中1的个数</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-jin-zhi-zhong-1de-ge-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-jin-zhi-zhong-1de-ge-shu-lcof/</guid><description>剑指 Offer 15 二进制中1的个数 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为 汉明重量).）。
提示：
请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。 示例 1：
输入：n = 11 (控制台输入 00000000000000000000000000001011) 输出：3 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。 示例 2：
输入：n = 128 (控制台输入 00000000000000000000000010000000) 输出：1 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。 示例 3：
输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3） 输出：31 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。 提示：
输入必须是长度为 32 的 二进制串 。 注意：本题与主站 191 题相同：https://leetcode-cn.com/problems/number-of-1-bits/
func hammingWeight(num uint32) int { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer 16 数值的整数次方</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zhi-de-zheng-shu-ci-fang-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zhi-de-zheng-shu-ci-fang-lcof/</guid><description>剑指 Offer 16 数值的整数次方 实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。
示例 1：
输入：x = 2.00000, n = 10 输出：1024.00000 示例 2：
输入：x = 2.10000, n = 3 输出：9.26100 示例 3：
输入：x = 2.00000, n = -2 输出：0.25000 解释：2-2 = 1/22 = 1/4 = 0.25 提示：
-100.0 &lt; x &lt; 100.0 -231 &lt;= n &lt;= 231-1 -104 &lt;= xn &lt;= 104 注意：本题与主站 50 题相同：https://leetcode-cn.com/problems/powx-n/
func myPow(x float64, n int) float64 { } LeetCode题库地址 https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof</description></item><item><title>剑指 Offer 17 打印从1到最大的n位数</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/</guid><description>剑指 Offer 17 打印从1到最大的n位数 输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。
示例 1:
输入: n = 1 输出: [1,2,3,4,5,6,7,8,9] &amp;nbsp;
说明：
用返回一个整数列表来代替打印 n 为正整数 func printNumbers(n int) []int { } LeetCode题库地址 https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof</description></item><item><title>剑指 Offer 18 删除链表的节点</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shan-chu-lian-biao-de-jie-dian-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shan-chu-lian-biao-de-jie-dian-lcof/</guid><description>剑指 Offer 18 删除链表的节点 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。
返回删除后的链表的头节点。
注意：此题对比原题有改动
示例 1:
输入: head = [4,5,1,9], val = 5 输出: [4,1,9] 解释: 给定你链表中值为&amp;nbsp;5&amp;nbsp;的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 1 -&amp;gt; 9. 示例 2:
输入: head = [4,5,1,9], val = 1 输出: [4,5,9] 解释: 给定你链表中值为&amp;nbsp;1&amp;nbsp;的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 5 -&amp;gt; 9. &amp;nbsp;
说明：
题目保证链表中节点的值互不相同 若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func deleteNode(head *ListNode, val int) *ListNode { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer 19 正则表达式匹配</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zheng-ze-biao-da-shi-pi-pei-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zheng-ze-biao-da-shi-pi-pei-lcof/</guid><description>剑指 Offer 19 正则表达式匹配 请实现一个函数用来匹配包含&amp;#39;. &amp;#39;和&amp;#39;*&amp;#39;的正则表达式。模式中的字符&amp;#39;.&amp;#39;表示任意一个字符，而&amp;#39;*&amp;#39;表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&amp;quot;aaa&amp;quot;与模式&amp;quot;a.a&amp;quot;和&amp;quot;ab*ac*a&amp;quot;匹配，但与&amp;quot;aa.a&amp;quot;和&amp;quot;ab*a&amp;quot;均不匹配。
示例 1:
输入: s = &amp;quot;aa&amp;quot; p = &amp;quot;a&amp;quot; 输出: false 解释: &amp;quot;a&amp;quot; 无法匹配 &amp;quot;aa&amp;quot; 整个字符串。 示例 2:
输入: s = &amp;quot;aa&amp;quot; p = &amp;quot;a*&amp;quot; 输出: true 解释:&amp;nbsp;因为 &amp;#39;*&amp;#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &amp;#39;a&amp;#39;。因此，字符串 &amp;quot;aa&amp;quot; 可被视为 &amp;#39;a&amp;#39; 重复了一次。 示例&amp;nbsp;3:
输入: s = &amp;quot;ab&amp;quot; p = &amp;quot;.*&amp;quot; 输出: true 解释:&amp;nbsp;&amp;quot;.*&amp;quot; 表示可匹配零个或多个（&amp;#39;*&amp;#39;）任意字符（&amp;#39;.&amp;#39;）。 示例 4:
输入: s = &amp;quot;aab&amp;quot; p = &amp;quot;c*a*b&amp;quot; 输出: true 解释:&amp;nbsp;因为 &amp;#39;*&amp;#39; 表示零个或多个，这里 &amp;#39;c&amp;#39; 为 0 个, &amp;#39;a&amp;#39; 被重复一次。因此可以匹配字符串 &amp;quot;aab&amp;quot;。 示例 5:</description></item><item><title>剑指 Offer 20 表示数值的字符串</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/</guid><description>剑指 Offer 20 表示数值的字符串 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。
数值（按顺序）可以分成以下几个部分：
若干空格 一个 小数 或者 整数 （可选）一个 'e' 或 'E' ，后面跟着一个 整数 若干空格 小数（按顺序）可以分成以下几个部分：
（可选）一个符号字符（'+' 或 '-'） 下述格式之一： 至少一位数字，后面跟着一个点 '.' 至少一位数字，后面跟着一个点 '.' ，后面再跟着至少一位数字 一个点 '.' ，后面跟着至少一位数字 整数（按顺序）可以分成以下几个部分：
（可选）一个符号字符（'+' 或 '-'） 至少一位数字 部分数值列举如下：
["+100", "5e2", "-123", "3.1416", "-1E-16", "0123"] 部分非数值列举如下：
["12e", "1a3.14", "1.2.3", "+-5", "12e+5.4"] 示例 1：
输入：s = "0" 输出：true 示例 2：
输入：s = "e" 输出：false 示例 3：
输入：s = "." 输出：false 示例 4：
输入：s = " .1 " 输出：true 提示：</description></item><item><title>剑指 Offer 21 调整数组顺序使奇数位于偶数前面</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/</guid><description>剑指 Offer 21 调整数组顺序使奇数位于偶数前面 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。
&amp;nbsp;
示例：
输入：nums =&amp;nbsp;[1,2,3,4] 输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一。 &amp;nbsp;
提示：
0 &amp;lt;= nums.length &amp;lt;= 50000 0 &amp;lt;= nums[i] &amp;lt;= 10000 func exchange(nums []int) []int { } LeetCode题库地址 https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof</description></item><item><title>剑指 Offer 22 链表中倒数第k个节点</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/</guid><description>剑指 Offer 22 链表中倒数第k个节点 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。
例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。
示例：
给定一个链表: 1->2->3->4->5, 和 k = 2. 返回链表 4->5. /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func getKthFromEnd(head *ListNode, k int) *ListNode { } LeetCode题库地址 https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof</description></item><item><title>剑指 Offer 24 反转链表</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/fan-zhuan-lian-biao-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/fan-zhuan-lian-biao-lcof/</guid><description>剑指 Offer 24 反转链表 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。
&amp;nbsp;
示例:
输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL 输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL &amp;nbsp;
限制：
0 &amp;lt;= 节点个数 &amp;lt;= 5000
&amp;nbsp;
注意：本题与主站 206 题相同：https://leetcode-cn.com/problems/reverse-linked-list/
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { } LeetCode题库地址 https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof</description></item><item><title>剑指 Offer 25 合并两个排序的链表</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/</guid><description>剑指 Offer 25 合并两个排序的链表 输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。
示例1：
输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4 输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4 限制：
0 &amp;lt;= 链表长度 &amp;lt;= 1000
注意：本题与主站 21 题相同：https://leetcode-cn.com/problems/merge-two-sorted-lists/
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { } LeetCode题库地址 https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof</description></item><item><title>剑指 Offer 26 树的子结构</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-de-zi-jie-gou-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-de-zi-jie-gou-lcof/</guid><description>剑指 Offer 26 树的子结构 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)
B是A的子结构， 即 A中有出现和B相同的结构和节点值。
例如:
给定的树 A:
&amp;nbsp; &amp;nbsp; &amp;nbsp;3
&amp;nbsp; &amp;nbsp; / \
&amp;nbsp; &amp;nbsp;4 &amp;nbsp; 5
&amp;nbsp; / \
&amp;nbsp;1 &amp;nbsp; 2
给定的树 B：
&amp;nbsp; &amp;nbsp;4&amp;nbsp;
&amp;nbsp; /
&amp;nbsp;1
返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。
示例 1：
输入：A = [1,2,3], B = [3,1] 输出：false 示例 2：
输入：A = [3,4,5,1,2], B = [4,1] 输出：true 限制：
0 &amp;lt;= 节点个数 &amp;lt;= 10000
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isSubStructure(A *TreeNode, B *TreeNode) bool { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer 27 二叉树的镜像</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-shu-de-jing-xiang-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-shu-de-jing-xiang-lcof/</guid><description>剑指 Offer 27 二叉树的镜像 请完成一个函数，输入一个二叉树，该函数输出它的镜像。
例如输入：
&amp;nbsp; &amp;nbsp; &amp;nbsp;4
&amp;nbsp; &amp;nbsp;/ &amp;nbsp; \
&amp;nbsp; 2 &amp;nbsp; &amp;nbsp; 7
&amp;nbsp;/ \ &amp;nbsp; / \
1 &amp;nbsp; 3 6 &amp;nbsp; 9
镜像输出：
&amp;nbsp; &amp;nbsp; &amp;nbsp;4
&amp;nbsp; &amp;nbsp;/ &amp;nbsp; \
&amp;nbsp; 7 &amp;nbsp; &amp;nbsp; 2
&amp;nbsp;/ \ &amp;nbsp; / \
9 &amp;nbsp; 6 3&amp;nbsp; &amp;nbsp;1
&amp;nbsp;
示例 1：
输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1] &amp;nbsp;
限制：
0 &amp;lt;= 节点个数 &amp;lt;= 1000
注意：本题与主站 226 题相同：https://leetcode-cn.com/problems/invert-binary-tree/
/** * Definition for a binary tree node.</description></item><item><title>剑指 Offer 28 对称的二叉树</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/dui-cheng-de-er-cha-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/dui-cheng-de-er-cha-shu-lcof/</guid><description>剑指 Offer 28 对称的二叉树 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。
例如，二叉树&amp;nbsp;[1,2,2,3,4,4,3] 是对称的。
&amp;nbsp; &amp;nbsp; 1
&amp;nbsp; &amp;nbsp;/ \
&amp;nbsp; 2 &amp;nbsp; 2
&amp;nbsp;/ \ / \
3 &amp;nbsp;4 4 &amp;nbsp;3
但是下面这个&amp;nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:
&amp;nbsp; &amp;nbsp; 1
&amp;nbsp; &amp;nbsp;/ \
&amp;nbsp; 2 &amp;nbsp; 2
&amp;nbsp; &amp;nbsp;\ &amp;nbsp; \
&amp;nbsp; &amp;nbsp;3 &amp;nbsp; &amp;nbsp;3
&amp;nbsp;
示例 1：
输入：root = [1,2,2,3,4,4,3] 输出：true 示例 2：
输入：root = [1,2,2,null,3,null,3] 输出：false &amp;nbsp;
限制：
0 &amp;lt;= 节点个数 &amp;lt;= 1000
注意：本题与主站 101 题相同：https://leetcode-cn.com/problems/symmetric-tree/
/** * Definition for a binary tree node.</description></item><item><title>剑指 Offer 29 顺时针打印矩阵</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shun-shi-zhen-da-yin-ju-zhen-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shun-shi-zhen-da-yin-ju-zhen-lcof/</guid><description>剑指 Offer 29 顺时针打印矩阵 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。
&amp;nbsp;
示例 1：
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,3,6,9,8,7,4,5] 示例 2：
输入：matrix =&amp;nbsp;[[1,2,3,4],[5,6,7,8],[9,10,11,12]] 输出：[1,2,3,4,8,12,11,10,9,5,6,7] &amp;nbsp;
限制：
0 &amp;lt;= matrix.length &amp;lt;= 100 0 &amp;lt;= matrix[i].length&amp;nbsp;&amp;lt;= 100 注意：本题与主站 54 题相同：https://leetcode-cn.com/problems/spiral-matrix/
func spiralOrder(matrix [][]int) []int { } LeetCode题库地址 https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof</description></item><item><title>剑指 Offer 30 包含min函数的栈</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/bao-han-minhan-shu-de-zhan-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/bao-han-minhan-shu-de-zhan-lcof/</guid><description>剑指 Offer 30 包含min函数的栈 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。
&amp;nbsp;
示例:
MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.min(); --&amp;gt; 返回 -3. minStack.pop(); minStack.top(); --&amp;gt; 返回 0. minStack.min(); --&amp;gt; 返回 -2. &amp;nbsp;
提示：
各函数的调用总次数不超过 20000 次 &amp;nbsp;
注意：本题与主站 155 题相同：https://leetcode-cn.com/problems/min-stack/
type MinStack struct { } /** initialize your data structure here. */ func Constructor() MinStack { } func (this *MinStack) Push(x int) { } func (this *MinStack) Pop() { } func (this *MinStack) Top() int { } func (this *MinStack) Min() int { } /** * Your MinStack object will be instantiated and called as such: * obj := Constructor(); * obj.</description></item><item><title>剑指 Offer 31 栈的压入、弹出序列</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zhan-de-ya-ru-dan-chu-xu-lie-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zhan-de-ya-ru-dan-chu-xu-lie-lcof/</guid><description>剑指 Offer 31 栈的压入、弹出序列 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。
&amp;nbsp;
示例 1：
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1] 输出：true 解释：我们可以按以下顺序执行： push(1), push(2), push(3), push(4), pop() -&amp;gt; 4, push(5), pop() -&amp;gt; 5, pop() -&amp;gt; 3, pop() -&amp;gt; 2, pop() -&amp;gt; 1 示例 2：
输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2] 输出：false 解释：1 不能在 2 之前弹出。 &amp;nbsp;
提示：
0 &amp;lt;= pushed.length == popped.length &amp;lt;= 1000 0 &amp;lt;= pushed[i], popped[i] &amp;lt; 1000 pushed&amp;nbsp;是&amp;nbsp;popped&amp;nbsp;的排列。 注意：本题与主站 946 题相同：https://leetcode-cn.com/problems/validate-stack-sequences/
func validateStackSequences(pushed []int, popped []int) bool { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer 32 - I 从上到下打印二叉树</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/</guid><description>剑指 Offer 32 - I 从上到下打印二叉树 从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。
&amp;nbsp;
例如:
给定二叉树:&amp;nbsp;[3,9,20,null,null,15,7],
3 / \ 9 20 / \ 15 7 返回：
[3,9,20,15,7] &amp;nbsp;
提示：
节点总数 &amp;lt;= 1000 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func levelOrder(root *TreeNode) []int { } LeetCode题库地址 https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof</description></item><item><title>剑指 Offer 32 - II 从上到下打印二叉树 II</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/</guid><description>剑指 Offer 32 - II 从上到下打印二叉树 II 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。
&amp;nbsp;
例如:
给定二叉树:&amp;nbsp;[3,9,20,null,null,15,7],
3 / \ 9 20 / \ 15 7 返回其层次遍历结果：
[ [3], [9,20], [15,7] ] &amp;nbsp;
提示：
节点总数 &amp;lt;= 1000 注意：本题与主站 102 题相同：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func levelOrder(root *TreeNode) [][]int { } LeetCode题库地址 https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof</description></item><item><title>剑指 Offer 32 - III 从上到下打印二叉树 III</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/</guid><description>剑指 Offer 32 - III 从上到下打印二叉树 III 请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。
&amp;nbsp;
例如:
给定二叉树:&amp;nbsp;[3,9,20,null,null,15,7],
3 / \ 9 20 / \ 15 7 返回其层次遍历结果：
[ [3], [20,9], [15,7] ] &amp;nbsp;
提示：
节点总数 &amp;lt;= 1000 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func levelOrder(root *TreeNode) [][]int { } LeetCode题库地址 https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof</description></item><item><title>剑指 Offer 33 二叉搜索树的后序遍历序列</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/</guid><description>剑指 Offer 33 二叉搜索树的后序遍历序列 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回&amp;nbsp;true，否则返回&amp;nbsp;false。假设输入的数组的任意两个数字都互不相同。
&amp;nbsp;
参考以下这颗二叉搜索树：
5 / \ 2 6 / \ 1 3 示例 1：
输入: [1,6,3,2,5] 输出: false 示例 2：
输入: [1,3,2,6,5] 输出: true &amp;nbsp;
提示：
数组长度 &amp;lt;= 1000 func verifyPostorder(postorder []int) bool { } LeetCode题库地址 https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof</description></item><item><title>剑指 Offer 34 二叉树中和为某一值的路径</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/</guid><description>剑指 Offer 34 二叉树中和为某一值的路径 给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。
叶子节点 是指没有子节点的节点。
&amp;nbsp;
示例 1：
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 输出：[[5,4,11,2],[5,8,4,5]] 示例 2：
输入：root = [1,2,3], targetSum = 5 输出：[] 示例 3：
输入：root = [1,2], targetSum = 0 输出：[] &amp;nbsp;
提示：
树中节点总数在范围 [0, 5000] 内 -1000 &amp;lt;= Node.val &amp;lt;= 1000 -1000 &amp;lt;= targetSum &amp;lt;= 1000 注意：本题与主站 113&amp;nbsp;题相同：https://leetcode-cn.com/problems/path-sum-ii/
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func pathSum(root *TreeNode, target int) [][]int { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer 35 复杂链表的复制</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/fu-za-lian-biao-de-fu-zhi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/fu-za-lian-biao-de-fu-zhi-lcof/</guid><description>剑指 Offer 35 复杂链表的复制 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。
&amp;nbsp;
示例 1：
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]] 输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 示例 2：
输入：head = [[1,1],[2,1]] 输出：[[1,1],[2,1]] 示例 3：
输入：head = [[3,null],[3,0],[3,null]] 输出：[[3,null],[3,0],[3,null]] 示例 4：
输入：head = [] 输出：[] 解释：给定的链表为空（空指针），因此返回 null。 &amp;nbsp;
提示：
-10000 &amp;lt;= Node.val &amp;lt;= 10000 Node.random&amp;nbsp;为空（null）或指向链表中的节点。 节点数目不超过 1000 。 &amp;nbsp;
注意：本题与主站 138 题相同：https://leetcode-cn.com/problems/copy-list-with-random-pointer/
&amp;nbsp;
/** * Definition for a Node. * type Node struct { * Val int * Next *Node * Random *Node * } */ func copyRandomList(head *Node) *Node { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer 36 二叉搜索树与双向链表</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/</guid><description>剑指 Offer 36 二叉搜索树与双向链表 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。
&amp;nbsp;
为了让您更好地理解问题，以下面的二叉搜索树为例：
&amp;nbsp;
&amp;nbsp;
我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。
下图展示了上面的二叉搜索树转化成的链表。&amp;ldquo;head&amp;rdquo; 表示指向链表中有最小元素的节点。
&amp;nbsp;
&amp;nbsp;
特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。
&amp;nbsp;
注意：本题与主站 426 题相同：https://leetcode-cn.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/
注意：此题对比原题有改动。
LeetCode题库地址 https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof</description></item><item><title>剑指 Offer 37 序列化二叉树</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/xu-lie-hua-er-cha-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/xu-lie-hua-er-cha-shu-lcof/</guid><description>剑指 Offer 37 序列化二叉树 请实现两个函数，分别用来序列化和反序列化二叉树。
你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。
提示：输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅&amp;nbsp;LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。
&amp;nbsp;
示例：
输入：root = [1,2,3,null,null,4,5] 输出：[1,2,3,null,null,4,5] &amp;nbsp;
注意：本题与主站 297 题相同：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/
LeetCode题库地址 https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof</description></item><item><title>剑指 Offer 38 字符串的排列</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zi-fu-chuan-de-pai-lie-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zi-fu-chuan-de-pai-lie-lcof/</guid><description>剑指 Offer 38 字符串的排列 输入一个字符串，打印出该字符串中字符的所有排列。
&amp;nbsp;
你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。
&amp;nbsp;
示例:
输入：s = &amp;quot;abc&amp;quot; 输出：[&amp;quot;abc&amp;quot;,&amp;quot;acb&amp;quot;,&amp;quot;bac&amp;quot;,&amp;quot;bca&amp;quot;,&amp;quot;cab&amp;quot;,&amp;quot;cba&amp;quot;] &amp;nbsp;
限制：
1 &amp;lt;= s 的长度 &amp;lt;= 8
func permutation(s string) []string { } LeetCode题库地址 https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof</description></item><item><title>剑指 Offer 39 数组中出现次数超过一半的数字</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/</guid><description>剑指 Offer 39 数组中出现次数超过一半的数字 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。
&amp;nbsp;
你可以假设数组是非空的，并且给定的数组总是存在多数元素。
&amp;nbsp;
示例&amp;nbsp;1:
输入: [1, 2, 3, 2, 2, 2, 5, 4, 2] 输出: 2 &amp;nbsp;
限制：
1 &amp;lt;= 数组长度 &amp;lt;= 50000
&amp;nbsp;
注意：本题与主站 169 题相同：https://leetcode-cn.com/problems/majority-element/
&amp;nbsp;
func majorityElement(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof</description></item><item><title>剑指 Offer 40 最小的k个数</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zui-xiao-de-kge-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zui-xiao-de-kge-shu-lcof/</guid><description>剑指 Offer 40 最小的k个数 输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。
&amp;nbsp;
示例 1：
输入：arr = [3,2,1], k = 2 输出：[1,2] 或者 [2,1] 示例 2：
输入：arr = [0,1,2,1], k = 1 输出：[0] &amp;nbsp;
限制：
0 &amp;lt;= k &amp;lt;= arr.length &amp;lt;= 10000 0 &amp;lt;= arr[i]&amp;nbsp;&amp;lt;= 10000 func getLeastNumbers(arr []int, k int) []int { } LeetCode题库地址 https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof</description></item><item><title>剑指 Offer 41 数据流中的中位数</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/</guid><description>剑指 Offer 41 数据流中的中位数 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。
例如，
[2,3,4]&amp;nbsp;的中位数是 3
[2,3] 的中位数是 (2 + 3) / 2 = 2.5
设计一个支持以下两种操作的数据结构：
void addNum(int num) - 从数据流中添加一个整数到数据结构中。 double findMedian() - 返回目前所有元素的中位数。 示例 1：
输入： [&amp;quot;MedianFinder&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;] [[],[1],[2],[],[3],[]] 输出：[null,null,null,1.50000,null,2.00000] 示例 2：
输入： [&amp;quot;MedianFinder&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;] [[],[2],[],[3],[]] 输出：[null,null,2.00000,null,2.50000] &amp;nbsp;
限制：
最多会对&amp;nbsp;addNum、findMedian 进行&amp;nbsp;50000&amp;nbsp;次调用。 注意：本题与主站 295 题相同：https://leetcode-cn.com/problems/find-median-from-data-stream/
type MedianFinder struct { } /** initialize your data structure here. */ func Constructor() MedianFinder { } func (this *MedianFinder) AddNum(num int) { } func (this *MedianFinder) FindMedian() float64 { } /** * Your MedianFinder object will be instantiated and called as such: * obj := Constructor(); * obj.</description></item><item><title>剑指 Offer 42 连续子数组的最大和</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/lian-xu-zi-shu-zu-de-zui-da-he-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/lian-xu-zi-shu-zu-de-zui-da-he-lcof/</guid><description>剑指 Offer 42 连续子数组的最大和 输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。
要求时间复杂度为O(n)。
&amp;nbsp;
示例1:
输入: nums = [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释:&amp;nbsp;连续子数组&amp;nbsp;[4,-1,2,1] 的和最大，为&amp;nbsp;6。 &amp;nbsp;
提示：
1 &amp;lt;=&amp;nbsp;arr.length &amp;lt;= 10^5 -100 &amp;lt;= arr[i] &amp;lt;= 100 注意：本题与主站 53 题相同：https://leetcode-cn.com/problems/maximum-subarray/
&amp;nbsp;
func maxSubArray(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof</description></item><item><title>剑指 Offer 43 1～n 整数中 1 出现的次数</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/</guid><description>剑指 Offer 43 1～n 整数中 1 出现的次数 输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。
例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。
示例 1：
输入：n = 12 输出：5 示例 2：
输入：n = 13 输出：6 限制：
1 &lt;= n &lt; 2^31 注意：本题与主站 233 题相同：https://leetcode-cn.com/problems/number-of-digit-one/
func countDigitOne(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof</description></item><item><title>剑指 Offer 44 数字序列中某一位的数字</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/</guid><description>剑指 Offer 44 数字序列中某一位的数字 数字以0123456789101112131415&amp;hellip;的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。
请写一个函数，求任意第n位对应的数字。
&amp;nbsp;
示例 1：
输入：n = 3 输出：3 示例 2：
输入：n = 11 输出：0 &amp;nbsp;
限制：
0 &amp;lt;= n &amp;lt;&amp;nbsp;2^31 注意：本题与主站 400 题相同：https://leetcode-cn.com/problems/nth-digit/
func findNthDigit(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof</description></item><item><title>剑指 Offer 45 把数组排成最小的数</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/</guid><description>剑指 Offer 45 把数组排成最小的数 输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。
&amp;nbsp;
示例 1:
输入: [10,2] 输出: &amp;quot;102&amp;quot; 示例&amp;nbsp;2:
输入: [3,30,34,5,9] 输出: &amp;quot;3033459&amp;quot; &amp;nbsp;
提示:
0 &amp;lt; nums.length &amp;lt;= 100 说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数 拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0 func minNumber(nums []int) string { } LeetCode题库地址 https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof</description></item><item><title>剑指 Offer 46 把数字翻译成字符串</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/</guid><description>剑指 Offer 46 把数字翻译成字符串 给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 &amp;ldquo;a&amp;rdquo; ，1 翻译成 &amp;ldquo;b&amp;rdquo;，&amp;hellip;&amp;hellip;，11 翻译成 &amp;ldquo;l&amp;rdquo;，&amp;hellip;&amp;hellip;，25 翻译成 &amp;ldquo;z&amp;rdquo;。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。
&amp;nbsp;
示例 1:
输入: 12258 输出: 5 解释: 12258有5种不同的翻译，分别是&amp;quot;bccfi&amp;quot;, &amp;quot;bwfi&amp;quot;, &amp;quot;bczi&amp;quot;, &amp;quot;mcfi&amp;quot;和&amp;quot;mzi&amp;quot; &amp;nbsp;
提示：
0 &amp;lt;= num &amp;lt; 231 func translateNum(num int) int { } LeetCode题库地址 https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof</description></item><item><title>剑指 Offer 47 礼物的最大价值</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/li-wu-de-zui-da-jie-zhi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/li-wu-de-zui-da-jie-zhi-lcof/</guid><description>剑指 Offer 47 礼物的最大价值 在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？
&amp;nbsp;
示例 1:
输入: [ &amp;nbsp; [1,3,1], &amp;nbsp; [1,5,1], &amp;nbsp; [4,2,1] ] 输出: 12 解释: 路径 1&amp;rarr;3&amp;rarr;5&amp;rarr;2&amp;rarr;1 可以拿到最多价值的礼物 &amp;nbsp;
提示：
0 &amp;lt; grid.length &amp;lt;= 200 0 &amp;lt; grid[0].length &amp;lt;= 200 func maxValue(grid [][]int) int { } LeetCode题库地址 https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof</description></item><item><title>剑指 Offer 48 最长不含重复字符的子字符串</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/</guid><description>剑指 Offer 48 最长不含重复字符的子字符串 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。
&amp;nbsp;
示例&amp;nbsp;1:
输入: &amp;quot;abcabcbb&amp;quot; 输出: 3 解释: 因为无重复字符的最长子串是 &amp;quot;abc&amp;quot;，所以其长度为 3。 示例 2:
输入: &amp;quot;bbbbb&amp;quot; 输出: 1 解释: 因为无重复字符的最长子串是 &amp;quot;b&amp;quot;，所以其长度为 1。 示例 3:
输入: &amp;quot;pwwkew&amp;quot; 输出: 3 解释: 因为无重复字符的最长子串是&amp;nbsp;&amp;quot;wke&amp;quot;，所以其长度为 3。 &amp;nbsp; 请注意，你的答案必须是 子串 的长度，&amp;quot;pwke&amp;quot;&amp;nbsp;是一个子序列，不是子串。 &amp;nbsp;
提示：
s.length &amp;lt;= 40000 注意：本题与主站 3 题相同：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/
func lengthOfLongestSubstring(s string) int { } LeetCode题库地址 https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof</description></item><item><title>剑指 Offer 49 丑数</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/chou-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/chou-shu-lcof/</guid><description>剑指 Offer 49 丑数 我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。
&amp;nbsp;
示例:
输入: n = 10 输出: 12 解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 说明:&amp;nbsp;&amp;nbsp;
1&amp;nbsp;是丑数。 n&amp;nbsp;不超过1690。 注意：本题与主站 264 题相同：https://leetcode-cn.com/problems/ugly-number-ii/
func nthUglyNumber(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/chou-shu-lcof</description></item><item><title>剑指 Offer 50 第一个只出现一次的字符</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/</guid><description>剑指 Offer 50 第一个只出现一次的字符 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。
示例 1:
输入：s = "abaccdeff" 输出：'b' 示例 2:
输入：s = "" 输出：' ' &amp;nbsp;
限制：
0 &amp;lt;= s 的长度 &amp;lt;= 50000
func firstUniqChar(s string) byte { } LeetCode题库地址 https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof</description></item><item><title>剑指 Offer 51 数组中的逆序对</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zu-zhong-de-ni-xu-dui-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zu-zhong-de-ni-xu-dui-lcof/</guid><description>剑指 Offer 51 数组中的逆序对 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。
&amp;nbsp;
示例 1:
输入: [7,5,6,4] 输出: 5 &amp;nbsp;
限制：
0 &amp;lt;= 数组长度 &amp;lt;= 50000
func reversePairs(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof</description></item><item><title>剑指 Offer 52 两个链表的第一个公共节点</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/</guid><description>剑指 Offer 52 两个链表的第一个公共节点 输入两个链表，找出它们的第一个公共节点。
如下面的两个链表：
在节点 c1 开始相交。
&amp;nbsp;
示例 1：
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 &amp;nbsp;
示例&amp;nbsp;2：
输入：intersectVal&amp;nbsp;= 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Reference of the node with value = 2 输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 &amp;nbsp;</description></item><item><title>剑指 Offer 53 - I 在排序数组中查找数字 I</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/</guid><description>剑指 Offer 53 - I 在排序数组中查找数字 I 统计一个数字在排序数组中出现的次数。
示例 1:
输入: nums = [5,7,7,8,8,10], target = 8 输出: 2 示例 2:
输入: nums = [5,7,7,8,8,10], target = 6 输出: 0 提示：
0 &lt;= nums.length &lt;= 105 -109 &lt;= nums[i] &lt;= 109 nums 是一个非递减数组 -109 &lt;= target &lt;= 109 注意：本题与主站 34 题相同（仅返回值不同）：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/
func search(nums []int, target int) int { } LeetCode题库地址 https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof</description></item><item><title>剑指 Offer 53 - II 0～n-1中缺失的数字</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/que-shi-de-shu-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/que-shi-de-shu-zi-lcof/</guid><description>剑指 Offer 53 - II 0～n-1中缺失的数字 一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。
&amp;nbsp;
示例 1:
输入: [0,1,3] 输出: 2 示例&amp;nbsp;2:
输入: [0,1,2,3,4,5,6,7,9] 输出: 8 &amp;nbsp;
限制：
1 &amp;lt;= 数组长度 &amp;lt;= 10000
func missingNumber(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/que-shi-de-shu-zi-lcof</description></item><item><title>剑指 Offer 54 二叉搜索树的第k大节点</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/</guid><description>剑指 Offer 54 二叉搜索树的第k大节点 给定一棵二叉搜索树，请找出其中第 k 大的节点的值。
&amp;nbsp;
示例 1:
输入: root = [3,1,4,null,2], k = 1 3 / \ 1 4 \ &amp;nbsp; 2 输出: 4 示例 2:
输入: root = [5,3,6,2,4,null,null,1], k = 3 5 / \ 3 6 / \ 2 4 / 1 输出: 4 &amp;nbsp;
限制：
1 ≤ k ≤ 二叉搜索树元素个数 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func kthLargest(root *TreeNode, k int) int { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer 55 - I 二叉树的深度</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-shu-de-shen-du-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-shu-de-shen-du-lcof/</guid><description>剑指 Offer 55 - I 二叉树的深度 输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。
例如：
给定二叉树 [3,9,20,null,null,15,7]，
3 / \ 9 20 / \ 15 7 返回它的最大深度&amp;nbsp;3 。
&amp;nbsp;
提示：
节点总数 &amp;lt;= 10000 注意：本题与主站 104&amp;nbsp;题相同：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func maxDepth(root *TreeNode) int { } LeetCode题库地址 https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof</description></item><item><title>剑指 Offer 55 - II 平衡二叉树</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ping-heng-er-cha-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ping-heng-er-cha-shu-lcof/</guid><description>剑指 Offer 55 - II 平衡二叉树 输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。
示例 1:
给定二叉树 [3,9,20,null,null,15,7]
3 / \ 9 20 / \ 15 7 返回 true 。
示例 2:
给定二叉树 [1,2,2,3,3,null,null,4,4]
1 / \ 2 2 / \ 3 3 / \ 4 4 返回 false 。
限制：
0 &lt;= 树的结点个数 &lt;= 10000 注意：本题与主站 110 题相同：https://leetcode-cn.com/problems/balanced-binary-tree/
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isBalanced(root *TreeNode) bool { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer 56 - I 数组中数字出现的次数</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/</guid><description>剑指 Offer 56 - I 数组中数字出现的次数 一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。
&amp;nbsp;
示例 1：
输入：nums = [4,1,4,6] 输出：[1,6] 或 [6,1] 示例 2：
输入：nums = [1,2,10,4,1,4,3,3] 输出：[2,10] 或 [10,2] &amp;nbsp;
限制：
2 &amp;lt;= nums.length &amp;lt;= 10000 &amp;nbsp;
func singleNumbers(nums []int) []int { } LeetCode题库地址 https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof</description></item><item><title>剑指 Offer 56 - II 数组中数字出现的次数 II</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/</guid><description>剑指 Offer 56 - II 数组中数字出现的次数 II 在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。
&amp;nbsp;
示例 1：
输入：nums = [3,4,3,3] 输出：4 示例 2：
输入：nums = [9,1,7,9,7,9,7] 输出：1 &amp;nbsp;
限制：
1 &amp;lt;= nums.length &amp;lt;= 10000 1 &amp;lt;= nums[i] &amp;lt; 2^31 &amp;nbsp;
func singleNumber(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof</description></item><item><title>剑指 Offer 57 和为s的两个数字</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/he-wei-sde-liang-ge-shu-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/he-wei-sde-liang-ge-shu-zi-lcof/</guid><description>剑指 Offer 57 和为s的两个数字 输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。
&amp;nbsp;
示例 1：
输入：nums = [2,7,11,15], target = 9 输出：[2,7] 或者 [7,2] 示例 2：
输入：nums = [10,26,30,31,47,60], target = 40 输出：[10,30] 或者 [30,10] &amp;nbsp;
限制：
1 &amp;lt;= nums.length &amp;lt;= 10^5 1 &amp;lt;= nums[i]&amp;nbsp;&amp;lt;= 10^6 func twoSum(nums []int, target int) []int { } LeetCode题库地址 https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof</description></item><item><title>剑指 Offer 57 - II 和为s的连续正数序列</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/</guid><description>剑指 Offer 57 - II 和为s的连续正数序列 输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。
序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。
&amp;nbsp;
示例 1：
输入：target = 9 输出：[[2,3,4],[4,5]] 示例 2：
输入：target = 15 输出：[[1,2,3,4,5],[4,5,6],[7,8]] &amp;nbsp;
限制：
1 &amp;lt;= target &amp;lt;= 10^5 &amp;nbsp;
func findContinuousSequence(target int) [][]int { } LeetCode题库地址 https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof</description></item><item><title>剑指 Offer 58 - I 翻转单词顺序</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/fan-zhuan-dan-ci-shun-xu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/fan-zhuan-dan-ci-shun-xu-lcof/</guid><description>剑指 Offer 58 - I 翻转单词顺序 输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串&amp;quot;I am a student. &amp;quot;，则输出&amp;quot;student. a am I&amp;quot;。
&amp;nbsp;
示例 1：
输入: &amp;quot;the sky is blue&amp;quot; 输出:&amp;nbsp;&amp;quot;blue is sky the&amp;quot; 示例 2：
输入: &amp;quot; &amp;nbsp;hello world! &amp;nbsp;&amp;quot; 输出:&amp;nbsp;&amp;quot;world! hello&amp;quot; 解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 示例 3：
输入: &amp;quot;a good &amp;nbsp; example&amp;quot; 输出:&amp;nbsp;&amp;quot;example good a&amp;quot; 解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 &amp;nbsp;
说明：
无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 注意：本题与主站 151 题相同：https://leetcode-cn.com/problems/reverse-words-in-a-string/
注意：此题对比原题有改动
func reverseWords(s string) string { } LeetCode题库地址 https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof</description></item><item><title>剑指 Offer 58 - II 左旋转字符串</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zuo-xuan-zhuan-zi-fu-chuan-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zuo-xuan-zhuan-zi-fu-chuan-lcof/</guid><description>剑指 Offer 58 - II 左旋转字符串 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&amp;quot;abcdefg&amp;quot;和数字2，该函数将返回左旋转两位得到的结果&amp;quot;cdefgab&amp;quot;。
&amp;nbsp;
示例 1：
输入: s = &amp;quot;abcdefg&amp;quot;, k = 2 输出:&amp;nbsp;&amp;quot;cdefgab&amp;quot; 示例 2：
输入: s = &amp;quot;lrloseumgh&amp;quot;, k = 6 输出:&amp;nbsp;&amp;quot;umghlrlose&amp;quot; &amp;nbsp;
限制：
1 &amp;lt;= k &amp;lt; s.length &amp;lt;= 10000 func reverseLeftWords(s string, n int) string { } LeetCode题库地址 https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof</description></item><item><title>剑指 Offer 59 - I 滑动窗口的最大值</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/hua-dong-chuang-kou-de-zui-da-zhi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/hua-dong-chuang-kou-de-zui-da-zhi-lcof/</guid><description>剑指 Offer 59 - I 滑动窗口的最大值 给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。
示例:
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 输出: [3,3,5,5,6,7] 解释: 滑动窗口的位置 最大值 --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 &amp;nbsp;</description></item><item><title>剑指 Offer 59 - II 队列的最大值</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/dui-lie-de-zui-da-zhi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/dui-lie-de-zui-da-zhi-lcof/</guid><description>剑指 Offer 59 - II 队列的最大值 请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。
若队列为空，pop_front 和 max_value&amp;nbsp;需要返回 -1
示例 1：
输入: [&amp;quot;MaxQueue&amp;quot;,&amp;quot;push_back&amp;quot;,&amp;quot;push_back&amp;quot;,&amp;quot;max_value&amp;quot;,&amp;quot;pop_front&amp;quot;,&amp;quot;max_value&amp;quot;] [[],[1],[2],[],[],[]] 输出:&amp;nbsp;[null,null,null,2,1,2] 示例 2：
输入: [&amp;quot;MaxQueue&amp;quot;,&amp;quot;pop_front&amp;quot;,&amp;quot;max_value&amp;quot;] [[],[],[]] 输出:&amp;nbsp;[null,-1,-1] &amp;nbsp;
限制：
1 &amp;lt;= push_back,pop_front,max_value的总操作数&amp;nbsp;&amp;lt;= 10000 1 &amp;lt;= value &amp;lt;= 10^5 type MaxQueue struct { } func Constructor() MaxQueue { } func (this *MaxQueue) Max_value() int { } func (this *MaxQueue) Push_back(value int) { } func (this *MaxQueue) Pop_front() int { } /** * Your MaxQueue object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.</description></item><item><title>面试题59 - II 队列的最大值</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/dui-lie-de-zui-da-zhi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/dui-lie-de-zui-da-zhi-lcof/</guid><description>面试题59 - II 队列的最大值 请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。
若队列为空，pop_front 和 max_value&amp;nbsp;需要返回 -1
示例 1：
输入: [&amp;quot;MaxQueue&amp;quot;,&amp;quot;push_back&amp;quot;,&amp;quot;push_back&amp;quot;,&amp;quot;max_value&amp;quot;,&amp;quot;pop_front&amp;quot;,&amp;quot;max_value&amp;quot;] [[],[1],[2],[],[],[]] 输出:&amp;nbsp;[null,null,null,2,1,2] 示例 2：
输入: [&amp;quot;MaxQueue&amp;quot;,&amp;quot;pop_front&amp;quot;,&amp;quot;max_value&amp;quot;] [[],[],[]] 输出:&amp;nbsp;[null,-1,-1] &amp;nbsp;
限制：
1 &amp;lt;= push_back,pop_front,max_value的总操作数&amp;nbsp;&amp;lt;= 10000 1 &amp;lt;= value &amp;lt;= 10^5 type MaxQueue struct { } func Constructor() MaxQueue { } func (this *MaxQueue) Max_value() int { } func (this *MaxQueue) Push_back(value int) { } func (this *MaxQueue) Pop_front() int { } /** * Your MaxQueue object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.</description></item><item><title>剑指 Offer 60 n个骰子的点数</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/nge-tou-zi-de-dian-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/nge-tou-zi-de-dian-shu-lcof/</guid><description>剑指 Offer 60 n个骰子的点数 把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。
&amp;nbsp;
你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。
&amp;nbsp;
示例 1:
输入: 1 输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667] 示例&amp;nbsp;2:
输入: 2 输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778] &amp;nbsp;
限制：
1 &amp;lt;= n &amp;lt;= 11
func dicesProbability(n int) []float64 { } LeetCode题库地址 https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof</description></item><item><title>剑指 Offer 61 扑克牌中的顺子</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/bu-ke-pai-zhong-de-shun-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/bu-ke-pai-zhong-de-shun-zi-lcof/</guid><description>剑指 Offer 61 扑克牌中的顺子 从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。
&amp;nbsp;
示例&amp;nbsp;1:
输入: [1,2,3,4,5] 输出: True &amp;nbsp;
示例&amp;nbsp;2:
输入: [0,0,1,2,5] 输出: True &amp;nbsp;
限制：
数组长度为 5&amp;nbsp;
数组的数取值为 [0, 13] .
func isStraight(nums []int) bool { } LeetCode题库地址 https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof</description></item><item><title>剑指 Offer 62 圆圈中最后剩下的数字</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</guid><description>剑指 Offer 62 圆圈中最后剩下的数字 0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。
例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。
示例 1：
输入: n = 5, m = 3 输出: 3 示例 2：
输入: n = 10, m = 17 输出: 2 限制：
1 &lt;= n &lt;= 10^5 1 &lt;= m &lt;= 10^6 func lastRemaining(n int, m int) int { } LeetCode题库地址 https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof</description></item><item><title>剑指 Offer 63 股票的最大利润</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/gu-piao-de-zui-da-li-run-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/gu-piao-de-zui-da-li-run-lcof/</guid><description>剑指 Offer 63 股票的最大利润 假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？
&amp;nbsp;
示例 1:
输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2:
输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 &amp;nbsp;
限制：
0 &amp;lt;= 数组长度 &amp;lt;= 10^5
&amp;nbsp;
注意：本题与主站 121 题相同：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/
func maxProfit(prices []int) int { } LeetCode题库地址 https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof</description></item><item><title>剑指 Offer 64 求1+2+…+n</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/qiu-12n-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/qiu-12n-lcof/</guid><description>剑指 Offer 64 求1+2+…+n 求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
&amp;nbsp;
示例 1：
输入: n = 3 输出:&amp;nbsp;6 示例 2：
输入: n = 9 输出:&amp;nbsp;45 &amp;nbsp;
限制：
1 &amp;lt;= n&amp;nbsp;&amp;lt;= 10000 func sumNums(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/qiu-12n-lcof</description></item><item><title>剑指 Offer 65 不用加减乘除做加法</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/</guid><description>剑指 Offer 65 不用加减乘除做加法 写一个函数，求两个整数之和，要求在函数体内不得使用 &amp;ldquo;+&amp;rdquo;、&amp;ldquo;-&amp;rdquo;、&amp;ldquo;*&amp;rdquo;、&amp;ldquo;/&amp;rdquo; 四则运算符号。
&amp;nbsp;
示例:
输入: a = 1, b = 1 输出: 2 &amp;nbsp;
提示：
a,&amp;nbsp;b&amp;nbsp;均可能是负数或 0 结果不会溢出 32 位整数 func add(a int, b int) int { } LeetCode题库地址 https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof</description></item><item><title>剑指 Offer 66 构建乘积数组</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/gou-jian-cheng-ji-shu-zu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/gou-jian-cheng-ji-shu-zu-lcof/</guid><description>剑指 Offer 66 构建乘积数组 给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。
示例:
输入: [1,2,3,4,5] 输出: [120,60,40,30,24] 提示：
所有元素乘积之和不会溢出 32 位整数 a.length &lt;= 100000 func constructArr(a []int) []int { } LeetCode题库地址 https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof</description></item><item><title>剑指 Offer 67 把字符串转换成整数</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/</guid><description>剑指 Offer 67 把字符串转换成整数 写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。
&amp;nbsp;
首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。
当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。
该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。
注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。
在任何情况下，若函数不能进行有效的转换时，请返回 0。
说明：
假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为&amp;nbsp;[&amp;minus;231,&amp;nbsp; 231&amp;nbsp;&amp;minus; 1]。如果数值超过这个范围，请返回 &amp;nbsp;INT_MAX (231&amp;nbsp;&amp;minus; 1) 或&amp;nbsp;INT_MIN (&amp;minus;231) 。
示例&amp;nbsp;1:
输入: &amp;quot;42&amp;quot; 输出: 42 示例&amp;nbsp;2:
输入: &amp;quot; -42&amp;quot; 输出: -42 解释: 第一个非空白字符为 &amp;#39;-&amp;#39;, 它是一个负号。 &amp;nbsp; 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例&amp;nbsp;3:
输入: &amp;quot;4193 with words&amp;quot; 输出: 4193 解释: 转换截止于数字 &amp;#39;3&amp;#39; ，因为它的下一个字符不为数字。 示例&amp;nbsp;4:
输入: &amp;quot;words and 987&amp;quot; 输出: 0 解释: 第一个非空字符是 &amp;#39;w&amp;#39;, 但它不是数字或正、负号。 因此无法执行有效的转换。 示例&amp;nbsp;5:
输入: &amp;quot;-91283472332&amp;quot; 输出: -2147483648 解释: 数字 &amp;quot;-91283472332&amp;quot; 超过 32 位有符号整数范围。 &amp;nbsp; 因此返回 INT_MIN (&amp;minus;231) 。 &amp;nbsp;</description></item><item><title>剑指 Offer 68 - I 二叉搜索树的最近公共祖先</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/</guid><description>剑指 Offer 68 - I 二叉搜索树的最近公共祖先 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：&amp;ldquo;对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。&amp;rdquo;
例如，给定如下二叉搜索树:&amp;nbsp; root =&amp;nbsp;[6,2,8,0,4,7,9,null,null,3,5]
&amp;nbsp;
示例 1:
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2:
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 输出: 2 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 &amp;nbsp;
说明:
所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。 注意：本题与主站 235 题相同：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/
LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer 68 - II 二叉树的最近公共祖先</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/</guid><description>剑指 Offer 68 - II 二叉树的最近公共祖先 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：&amp;ldquo;对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。&amp;rdquo;
例如，给定如下二叉树:&amp;nbsp; root =&amp;nbsp;[3,5,1,6,2,0,8,null,null,7,4]
&amp;nbsp;
示例 1:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例&amp;nbsp;2:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 &amp;nbsp;
说明:
所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。 注意：本题与主站 236 题相同：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/
/** * Definition for a binary tree node.</description></item></channel></rss>