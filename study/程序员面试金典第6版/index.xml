<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>程序员面试金典第6版 on lbbniu</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/</link><description>Recent content in 程序员面试金典第6版 on lbbniu</description><generator>Hugo -- gohugo.io</generator><language>zh</language><managingEditor>lbbniu@gmail.com (lbbniu)</managingEditor><webMaster>lbbniu@gmail.com (lbbniu)</webMaster><copyright>&amp;copy; 2021 &lt;a href="https://blog.lbbniu.com/">lbbniu&lt;/a></copyright><lastBuildDate>Thu, 28 Jul 2022 22:00:00 +0800</lastBuildDate><atom:link href="/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/index.xml" rel="self" type="application/rss+xml"/><item><title>面试题 01.01 判定字符是否唯一</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/is-unique-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/is-unique-lcci/</guid><description>面试题 01.01 判定字符是否唯一 实现一个算法，确定一个字符串 s 的所有字符是否全都不同。
示例 1：
输入: s = "leetcode" 输出: false 示例 2：
输入: s = "abc" 输出: true 限制：
0 &amp;lt;= len(s) &amp;lt;= 100 s[i]仅包含小写字母 如果你不使用额外的数据结构，会很加分。 func isUnique(astr string) bool { } LeetCode题库地址 https://leetcode.cn/problems/is-unique-lcci</description></item><item><title>面试题 01.02 判定是否互为字符重排</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/check-permutation-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/check-permutation-lcci/</guid><description>面试题 01.02 判定是否互为字符重排 给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。
示例 1：
输入: s1 = &amp;quot;abc&amp;quot;, s2 = &amp;quot;bca&amp;quot; 输出: true 示例 2：
输入: s1 = &amp;quot;abc&amp;quot;, s2 = &amp;quot;bad&amp;quot; 输出: false 说明：
0 &amp;lt;= len(s1) &amp;lt;= 100 0 &amp;lt;= len(s2) &amp;lt;= 100 func CheckPermutation(s1 string, s2 string) bool { } LeetCode题库地址 https://leetcode.cn/problems/check-permutation-lcci</description></item><item><title>面试题 01.03 URL化</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/string-to-url-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/string-to-url-lcci/</guid><description>面试题 01.03 URL化 URL化。编写一种方法，将字符串中的空格全部替换为%20。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用Java实现的话，请使用字符数组实现，以便直接在数组上操作。）
示例 1：
输入："Mr John Smith ", 13 输出："Mr%20John%20Smith" 示例 2：
输入：" ", 5 输出："%20%20%20%20%20" 提示：
字符串长度在 [0, 500000] 范围内。 func replaceSpaces(S string, length int) string { } LeetCode题库地址 https://leetcode.cn/problems/string-to-url-lcci</description></item><item><title>面试题 01.04 回文排列</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/palindrome-permutation-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/palindrome-permutation-lcci/</guid><description>面试题 01.04 回文排列 给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。
回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。
回文串不一定是字典当中的单词。
&amp;nbsp;
示例1：
输入：&amp;quot;tactcoa&amp;quot; 输出：true（排列有&amp;quot;tacocat&amp;quot;、&amp;quot;atcocta&amp;quot;，等等） &amp;nbsp;
func canPermutePalindrome(s string) bool { } LeetCode题库地址 https://leetcode.cn/problems/palindrome-permutation-lcci</description></item><item><title>面试题 01.05 一次编辑</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/one-away-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/one-away-lcci/</guid><description>面试题 01.05 一次编辑 字符串有三种编辑操作:插入一个英文字符、删除一个英文字符或者替换一个英文字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。
&amp;nbsp;
示例&amp;nbsp;1:
输入: first = "pale" second = "ple" 输出: True &amp;nbsp;
示例&amp;nbsp;2:
输入: first = "pales" second = "pal" 输出: False func oneEditAway(first string, second string) bool { } LeetCode题库地址 https://leetcode.cn/problems/one-away-lcci</description></item><item><title>面试题 01.06 字符串压缩</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/compress-string-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/compress-string-lcci/</guid><description>面试题 01.06 字符串压缩 字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。
示例1:
输入："aabcccccaaa" 输出："a2b1c5a3" 示例2:
输入："abbccd" 输出："abbccd" 解释："abbccd"压缩后为"a1b2c2d1"，比原字符串长度更长。 提示：
字符串长度在[0, 50000]范围内。 func compressString(S string) string { } LeetCode题库地址 https://leetcode.cn/problems/compress-string-lcci</description></item><item><title>面试题 01.07 旋转矩阵</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/rotate-matrix-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/rotate-matrix-lcci/</guid><description>面试题 01.07 旋转矩阵 给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。
不占用额外内存空间能否做到？
示例 1:
给定 matrix = [ [1,2,3], [4,5,6], [7,8,9] ], 原地旋转输入矩阵，使其变为: [ [7,4,1], [8,5,2], [9,6,3] ] 示例 2:
给定 matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], 原地旋转输入矩阵，使其变为: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ] 注意：本题与主站 48 题相同：https://leetcode-cn.com/problems/rotate-image/
func rotate(matrix [][]int) { } LeetCode题库地址 https://leetcode.cn/problems/rotate-matrix-lcci</description></item><item><title>面试题 01.08 零矩阵</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/zero-matrix-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/zero-matrix-lcci/</guid><description>面试题 01.08 零矩阵 编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。
&amp;nbsp;
示例 1：
输入： [ [1,1,1], [1,0,1], [1,1,1] ] 输出： [ [1,0,1], [0,0,0], [1,0,1] ] 示例 2：
输入： [ [0,1,2,0], [3,4,5,2], [1,3,1,5] ] 输出： [ [0,0,0,0], [0,4,5,0], [0,3,1,0] ] func setZeroes(matrix [][]int) { } LeetCode题库地址 https://leetcode.cn/problems/zero-matrix-lcci</description></item><item><title>面试题 01.09 字符串轮转</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/string-rotation-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/string-rotation-lcci/</guid><description>面试题 01.09 字符串轮转 字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。
示例1:
输入：s1 = &amp;quot;waterbottle&amp;quot;, s2 = &amp;quot;erbottlewat&amp;quot; 输出：True 示例2:
输入：s1 = &amp;quot;aa&amp;quot;, s2 = &amp;quot;aba&amp;quot; 输出：False 提示：
字符串长度在[0, 100000]范围内。 说明:
你能只调用一次检查子串的方法吗？ func isFlipedString(s1 string, s2 string) bool { } LeetCode题库地址 https://leetcode.cn/problems/string-rotation-lcci</description></item><item><title>面试题 02.01 移除重复节点</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/remove-duplicate-node-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/remove-duplicate-node-lcci/</guid><description>面试题 02.01 移除重复节点 编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。
示例1:
输入：[1, 2, 3, 3, 2, 1] 输出：[1, 2, 3] 示例2:
输入：[1, 1, 1, 1, 2] 输出：[1, 2] 提示：
链表长度在[0, 20000]范围内。 链表元素在[0, 20000]范围内。 进阶：
如果不得使用临时缓冲区，该怎么解决？
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeDuplicateNodes(head *ListNode) *ListNode { } LeetCode题库地址 https://leetcode.cn/problems/remove-duplicate-node-lcci</description></item><item><title>面试题 02.02 返回倒数第 k 个节点</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/kth-node-from-end-of-list-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/kth-node-from-end-of-list-lcci/</guid><description>面试题 02.02 返回倒数第 k 个节点 实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。
注意：本题相对原题稍作改动
示例：
输入： 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5 和 k = 2 输出： 4 说明：
给定的 k&amp;nbsp;保证是有效的。
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func kthToLast(head *ListNode, k int) int { } LeetCode题库地址 https://leetcode.cn/problems/kth-node-from-end-of-list-lcci</description></item><item><title>面试题 02.03 删除中间节点</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/delete-middle-node-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/delete-middle-node-lcci/</guid><description>面试题 02.03 删除中间节点 若链表中的某个节点，既不是链表头节点，也不是链表尾节点，则称其为该链表的「中间节点」。
假定已知链表的某一个中间节点，请实现一种算法，将该节点从链表中删除。
例如，传入节点 c（位于单向链表 a->b->c->d->e->f 中），将其删除后，剩余链表为 a->b->d->e->f
示例：
输入：节点 5 （位于单向链表 4->5->1->9 中） 输出：不返回任何数据，从链表中删除传入的节点 5，使链表变为 4->1->9 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func deleteNode(node *ListNode) { } LeetCode题库地址 https://leetcode.cn/problems/delete-middle-node-lcci</description></item><item><title>面试题 02.04 分割链表</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/partition-list-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/partition-list-lcci/</guid><description>面试题 02.04 分割链表 给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。
你不需要&amp;nbsp;保留&amp;nbsp;每个分区中各节点的初始相对位置。
&amp;nbsp;
示例 1：
输入：head = [1,4,3,2,5,2], x = 3 输出：[1,2,2,4,3,5] 示例 2：
输入：head = [2,1], x = 2 输出：[1,2] &amp;nbsp;
提示：
链表中节点的数目在范围 [0, 200] 内 -100 &amp;lt;= Node.val &amp;lt;= 100 -200 &amp;lt;= x &amp;lt;= 200 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func partition(head *ListNode, x int) *ListNode { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 02.05 链表求和</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sum-lists-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sum-lists-lcci/</guid><description>面试题 02.05 链表求和 给定两个用链表表示的整数，每个节点包含一个数位。
这些数位是反向存放的，也就是个位排在链表首部。
编写函数对这两个整数求和，并用链表形式返回结果。
&amp;nbsp;
示例：
输入：(7 -&amp;gt; 1 -&amp;gt; 6) + (5 -&amp;gt; 9 -&amp;gt; 2)，即617 + 295 输出：2 -&amp;gt; 1 -&amp;gt; 9，即912 进阶：思考一下，假设这些数位是正向存放的，又该如何解决呢?
示例：
输入：(6 -&amp;gt; 1 -&amp;gt; 7) + (2 -&amp;gt; 9 -&amp;gt; 5)，即617 + 295 输出：9 -&amp;gt; 1 -&amp;gt; 2，即912 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 02.06 回文链表</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/palindrome-linked-list-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/palindrome-linked-list-lcci/</guid><description>面试题 02.06 回文链表 编写一个函数，检查输入的链表是否是回文的。
&amp;nbsp;
示例 1：
输入： 1-&amp;gt;2 输出： false 示例 2：
输入： 1-&amp;gt;2-&amp;gt;2-&amp;gt;1 输出： true &amp;nbsp;
进阶：
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func isPalindrome(head *ListNode) bool { } LeetCode题库地址 https://leetcode.cn/problems/palindrome-linked-list-lcci</description></item><item><title>面试题 02.07 链表相交</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/intersection-of-two-linked-lists-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/intersection-of-two-linked-lists-lcci/</guid><description>面试题 02.07 链表相交 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。
图示两个链表在节点 c1 开始相交：
题目数据 保证 整个链式结构中不存在环。
注意，函数返回结果后，链表必须 保持其原始结构 。
示例 1：
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Intersected at '8' 解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2：
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Intersected at '2' 解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。 在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3：</description></item><item><title>面试题 02.08 环路检测</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/linked-list-cycle-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/linked-list-cycle-lcci/</guid><description>面试题 02.08 环路检测 给定一个链表，如果它是有环链表，实现一个算法返回环路的开头节点。若环不存在，请返回 null。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。
&amp;nbsp;
示例 1：
输入：head = [3,2,0,-4], pos = 1 输出：tail connects to node index 1 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2：
输入：head = [1,2], pos = 0 输出：tail connects to node index 0 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3：
输入：head = [1], pos = -1 输出：no cycle 解释：链表中没有环。 &amp;nbsp;
进阶：
你是否可以不用额外空间解决此题？ &amp;nbsp;
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func detectCycle(head *ListNode) *ListNode { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 03.01 三合一</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/three-in-one-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/three-in-one-lcci/</guid><description>面试题 03.01 三合一 三合一。描述如何只用一个数组来实现三个栈。
你应该实现push(stackNum, value)、pop(stackNum)、isEmpty(stackNum)、peek(stackNum)方法。stackNum表示栈下标，value表示压入的值。
构造函数会传入一个stackSize参数，代表每个栈的大小。
示例1:
输入： ["TripleInOne", "push", "push", "pop", "pop", "pop", "isEmpty"] [[1], [0, 1], [0, 2], [0], [0], [0], [0]] 输出： [null, null, null, 1, -1, -1, true] 说明：当栈为空时`pop, peek`返回-1，当栈满时`push`不压入元素。 示例2:
输入： ["TripleInOne", "push", "push", "push", "pop", "pop", "pop", "peek"] [[2], [0, 1], [0, 2], [0, 3], [0], [0], [0], [0]] 输出： [null, null, null, null, 2, 1, -1, -1] &amp;nbsp;
提示：
0 &amp;lt;= stackNum &amp;lt;= 2 type TripleInOne struct { } func Constructor(stackSize int) TripleInOne { } func (this *TripleInOne) Push(stackNum int, value int) { } func (this *TripleInOne) Pop(stackNum int) int { } func (this *TripleInOne) Peek(stackNum int) int { } func (this *TripleInOne) IsEmpty(stackNum int) bool { } /** * Your TripleInOne object will be instantiated and called as such: * obj := Constructor(stackSize); * obj.</description></item><item><title>面试题 03.02 栈的最小值</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/min-stack-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/min-stack-lcci/</guid><description>面试题 03.02 栈的最小值 请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。
示例：MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); --> 返回 -3.
minStack.pop();
minStack.top(); --> 返回 0.
minStack.getMin(); --> 返回 -2.
type MinStack struct { } /** initialize your data structure here. */ func Constructor() MinStack { } func (this *MinStack) Push(x int) { } func (this *MinStack) Pop() { } func (this *MinStack) Top() int { } func (this *MinStack) GetMin() int { } /** * Your MinStack object will be instantiated and called as such: * obj := Constructor(); * obj.</description></item><item><title>面试题 03.03 堆盘子</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/stack-of-plates-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/stack-of-plates-lcci/</guid><description>面试题 03.03 堆盘子 堆盘子。设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构SetOfStacks，模拟这种行为。SetOfStacks应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，SetOfStacks.push()和SetOfStacks.pop()应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）。 进阶：实现一个popAt(int index)方法，根据指定的子栈，执行pop操作。
当某个栈为空时，应当删除该栈。当栈中没有元素或不存在该栈时，pop，popAt&amp;nbsp;应返回 -1.
示例1:
输入： [&amp;quot;StackOfPlates&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;popAt&amp;quot;, &amp;quot;pop&amp;quot;, &amp;quot;pop&amp;quot;] [[1], [1], [2], [1], [], []] 输出： [null, null, null, 2, 1, -1] 示例2:
输入： [&amp;quot;StackOfPlates&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;popAt&amp;quot;, &amp;quot;popAt&amp;quot;, &amp;quot;popAt&amp;quot;] [[2], [1], [2], [3], [0], [0], [0]] 输出： [null, null, null, null, 2, 1, 3] type StackOfPlates struct { } func Constructor(cap int) StackOfPlates { } func (this *StackOfPlates) Push(val int) { } func (this *StackOfPlates) Pop() int { } func (this *StackOfPlates) PopAt(index int) int { } /** * Your StackOfPlates object will be instantiated and called as such: * obj := Constructor(cap); * obj.</description></item><item><title>面试题 03.04 化栈为队</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/implement-queue-using-stacks-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/implement-queue-using-stacks-lcci/</guid><description>面试题 03.04 化栈为队 实现一个MyQueue类，该类用两个栈来实现一个队列。
示例：MyQueue queue = new MyQueue();
queue.push(1);
queue.push(2);
queue.peek(); // 返回 1
queue.pop(); // 返回 1
queue.empty(); // 返回 false
说明：
你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size 和 is empty 操作是合法的。你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。
type MyQueue struct { } /** Initialize your data structure here. */ func Constructor() MyQueue { } /** Push element x to the back of queue. */ func (this *MyQueue) Push(x int) { } /** Removes the element from in front of queue and returns that element.</description></item><item><title>面试题 03.05 栈排序</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sort-of-stacks-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sort-of-stacks-lcci/</guid><description>面试题 03.05 栈排序 栈排序。 编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：push、pop、peek 和 isEmpty。当栈为空时，peek&amp;nbsp;返回 -1。
示例1:
输入： [&amp;quot;SortedStack&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;peek&amp;quot;, &amp;quot;pop&amp;quot;, &amp;quot;peek&amp;quot;] [[], [1], [2], [], [], []] 输出： [null,null,null,1,null,2] 示例2:
输入： [&amp;quot;SortedStack&amp;quot;, &amp;quot;pop&amp;quot;, &amp;quot;pop&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;pop&amp;quot;, &amp;quot;isEmpty&amp;quot;] [[], [], [], [1], [], []] 输出： [null,null,null,null,null,true] 说明:
栈中的元素数目在[0, 5000]范围内。 type SortedStack struct { } func Constructor() SortedStack { } func (this *SortedStack) Push(val int) { } func (this *SortedStack) Pop() { } func (this *SortedStack) Peek() int { } func (this *SortedStack) IsEmpty() bool { } /** * Your SortedStack object will be instantiated and called as such: * obj := Constructor(); * obj.</description></item><item><title>面试题 03.06 动物收容所</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/animal-shelter-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/animal-shelter-lcci/</guid><description>面试题 03.06 动物收容所 动物收容所。有家动物收容所只收容狗与猫，且严格遵守&amp;ldquo;先进先出&amp;rdquo;的原则。在收养该收容所的动物时，收养人只能收养所有动物中&amp;ldquo;最老&amp;rdquo;（由其进入收容所的时间长短而定）的动物，或者可以挑选猫或狗（同时必须收养此类动物中&amp;ldquo;最老&amp;rdquo;的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如enqueue、dequeueAny、dequeueDog和dequeueCat。允许使用Java内置的LinkedList数据结构。
enqueue方法有一个animal参数，animal[0]代表动物编号，animal[1]代表动物种类，其中 0 代表猫，1 代表狗。
dequeue*方法返回一个列表[动物编号, 动物种类]，若没有可以收养的动物，则返回[-1,-1]。
示例1:
输入： [&amp;quot;AnimalShelf&amp;quot;, &amp;quot;enqueue&amp;quot;, &amp;quot;enqueue&amp;quot;, &amp;quot;dequeueCat&amp;quot;, &amp;quot;dequeueDog&amp;quot;, &amp;quot;dequeueAny&amp;quot;] [[], [[0, 0]], [[1, 0]], [], [], []] 输出： [null,null,null,[0,0],[-1,-1],[1,0]] 示例2:
输入： [&amp;quot;AnimalShelf&amp;quot;, &amp;quot;enqueue&amp;quot;, &amp;quot;enqueue&amp;quot;, &amp;quot;enqueue&amp;quot;, &amp;quot;dequeueDog&amp;quot;, &amp;quot;dequeueCat&amp;quot;, &amp;quot;dequeueAny&amp;quot;] [[], [[0, 0]], [[1, 0]], [[2, 1]], [], [], []] 输出： [null,null,null,null,[2,1],[0,0],[1,0]] 说明:
收纳所的最大容量为20000 type AnimalShelf struct { } func Constructor() AnimalShelf { } func (this *AnimalShelf) Enqueue(animal []int) { } func (this *AnimalShelf) DequeueAny() []int { } func (this *AnimalShelf) DequeueDog() []int { } func (this *AnimalShelf) DequeueCat() []int { } /** * Your AnimalShelf object will be instantiated and called as such: * obj := Constructor(); * obj.</description></item><item><title>面试题 04.01 节点间通路</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/route-between-nodes-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/route-between-nodes-lcci/</guid><description>面试题 04.01 节点间通路 节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。
示例1:
输入：n = 3, graph = [[0, 1], [0, 2], [1, 2], [1, 2]], start = 0, target = 2 输出：true 示例2:
输入：n = 5, graph = [[0, 1], [0, 2], [0, 4], [0, 4], [0, 1], [1, 3], [1, 4], [1, 3], [2, 3], [3, 4]], start = 0, target = 4 输出 true 提示：
节点数量n在[0, 1e5]范围内。 节点编号大于等于 0 小于 n。 图中可能存在自环和平行边。 func findWhetherExistsPath(n int, graph [][]int, start int, target int) bool { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 04.02 最小高度树</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/minimum-height-tree-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/minimum-height-tree-lcci/</guid><description>面试题 04.02 最小高度树 给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。
示例:给定有序数组: [-10,-3,0,5,9],
一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：
0 / &amp;#92 -3 9 / / -10 5 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func sortedArrayToBST(nums []int) *TreeNode { } LeetCode题库地址 https://leetcode.cn/problems/minimum-height-tree-lcci</description></item><item><title>面试题 04.03 特定深度节点链表</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/list-of-depth-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/list-of-depth-lcci/</guid><description>面试题 04.03 特定深度节点链表 给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 D，则会创建出 D 个链表）。返回一个包含所有深度的链表的数组。
&amp;nbsp;
示例：
输入：[1,2,3,4,5,null,7,8] 1 / \ 2 3 / \ \ 4 5 7 / 8 输出：[[1],[2,3],[4,5,7],[8]] /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func listOfDepth(tree *TreeNode) []*ListNode { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 04.04 检查平衡性</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/check-balance-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/check-balance-lcci/</guid><description>面试题 04.04 检查平衡性 实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过 1。
示例 1:给定二叉树 [3,9,20,null,null,15,7]
3
/ &amp;#92
9 20
/ &amp;#92
15 7
返回 true 。示例 2:
给定二叉树 [1,2,2,3,3,null,null,4,4]
1
/ &amp;#92
2 2
/ &amp;#92
3 3
/ &amp;#92
4 4
返回 false 。 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isBalanced(root *TreeNode) bool { } LeetCode题库地址 https://leetcode.cn/problems/check-balance-lcci</description></item><item><title>面试题 04.05 合法二叉搜索树</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/legal-binary-search-tree-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/legal-binary-search-tree-lcci/</guid><description>面试题 04.05 合法二叉搜索树 实现一个函数，检查一棵二叉树是否为二叉搜索树。
示例 1:输入:
2
/ &amp;#92
1 3
输出: true
示例 2:输入:
5
/ &amp;#92
1 4
/ &amp;#92
3 6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
根节点的值为 5 ，但是其右子节点值为 4 。 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isValidBST(root *TreeNode) bool { } LeetCode题库地址 https://leetcode.cn/problems/legal-binary-search-tree-lcci</description></item><item><title>面试题 04.06 后继者</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/successor-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/successor-lcci/</guid><description>面试题 04.06 后继者 设计一个算法，找出二叉搜索树中指定节点的&amp;ldquo;下一个&amp;rdquo;节点（也即中序后继）。
如果指定节点没有对应的&amp;ldquo;下一个&amp;rdquo;节点，则返回null。
示例 1:
输入: root = [2,1,3], p = 1 2 / \ 1 3 输出: 2 示例 2:
输入: root = [5,3,6,2,4,null,null,1], p = 6 5 / \ 3 6 / \ 2 4 / 1 输出: null /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func inorderSuccessor(root *TreeNode, p *TreeNode) *TreeNode { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 04.08 首个共同祖先</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/first-common-ancestor-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/first-common-ancestor-lcci/</guid><description>面试题 04.08 首个共同祖先 设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。
例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]
3 / \ 5 1 / \ / \ 6 2 0 8 / \ 7 4 示例 1:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明:
所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。 /** * Definition for a binary tree node.</description></item><item><title>面试题 04.09 二叉搜索树序列</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/bst-sequences-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/bst-sequences-lcci/</guid><description>面试题 04.09 二叉搜索树序列 从左向右遍历一个数组，通过不断将其中的元素插入树中可以逐步地生成一棵二叉搜索树。
给定一个由不同节点组成的二叉搜索树 root，输出所有可能生成此树的数组。
&amp;nbsp;
示例 1:
输入: root = [2,1,3] 输出: [[2,1,3],[2,3,1]] 解释: 数组 [2,1,3]、[2,3,1] 均可以通过从左向右遍历元素插入树中形成以下二叉搜索树 &amp;nbsp; 2 &amp;nbsp; / \ &amp;nbsp; 1 3 示例&amp;nbsp;2:
输入: root = [4,1,null,null,3,2] 输出: [[4,1,3,2]] &amp;nbsp;
提示：
二叉搜索树中的节点数在&amp;nbsp;[0, 1000]&amp;nbsp;的范围内 1 &amp;lt;= 节点值&amp;nbsp;&amp;lt;= 10^6 用例保证符合要求的数组数量不超过 5000
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func BSTSequences(root *TreeNode) [][]int { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 04.10 检查子树</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/check-subtree-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/check-subtree-lcci/</guid><description>面试题 04.10 检查子树 检查子树。你有两棵非常大的二叉树：T1，有几万个节点；T2，有几万个节点。设计一个算法，判断 T2 是否为 T1 的子树。
如果 T1 有这么一个节点 n，其子树与 T2 一模一样，则 T2 为 T1 的子树，也就是说，从节点 n 处把树砍断，得到的树与 T2 完全相同。
注意：此题相对书上原题略有改动。
示例1:
输入：t1 = [1, 2, 3], t2 = [2] 输出：true 示例2:
输入：t1 = [1, null, 2, 4], t2 = [3, 2] 输出：false 提示：
树的节点数目范围为[0, 20000]。 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func checkSubTree(t1 *TreeNode, t2 *TreeNode) bool { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 04.12 求和路径</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/paths-with-sum-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/paths-with-sum-lcci/</guid><description>面试题 04.12 求和路径 给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。
示例:
给定如下二叉树，以及目标和&amp;nbsp;sum = 22，
5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1 返回:
3 解释：和为 22&amp;nbsp;的路径有：[5,4,11,2], [5,8,4,5], [4,11,7] 提示：
节点总数 &amp;lt;= 10000 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func pathSum(root *TreeNode, sum int) int { } LeetCode题库地址 https://leetcode.cn/problems/paths-with-sum-lcci</description></item><item><title>面试题 05.01 插入</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/insert-into-bits-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/insert-into-bits-lcci/</guid><description>面试题 05.01 插入 给定两个整型数字 N 与 M，以及表示比特位置的 i 与 j（i &lt;= j，且从 0 位开始计算）。
编写一种方法，使 M 对应的二进制数字插入 N 对应的二进制数字的第 i ~ j 位区域，不足之处用 0 补齐。具体插入过程如图所示。
题目保证从 i 位到 j 位足以容纳 M， 例如： M = 10011，则 i～j 区域至少可容纳 5 位。
示例1:
输入：N = 1024(10000000000), M = 19(10011), i = 2, j = 6 输出：N = 1100(10001001100) 示例2:
输入： N = 0, M = 31(11111), i = 0, j = 4 输出：N = 31(11111) func insertBits(N int, M int, i int, j int) int { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 05.02 二进制数转字符串</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/bianry-number-to-string-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/bianry-number-to-string-lcci/</guid><description>面试题 05.02 二进制数转字符串 二进制数转字符串。给定一个介于0和1之间的实数（如0.72），类型为double，打印它的二进制表达式。如果该数字无法精确地用32位以内的二进制表示，则打印“ERROR”。
示例1:
输入：0.625 输出："0.101" 示例2:
输入：0.1 输出："ERROR" 提示：0.1无法被二进制准确表示 &amp;nbsp;
提示：
32位包括输出中的 "0." 这两位。 题目保证输入用例的小数位数最多只有 6 位 func printBin(num float64) string { } LeetCode题库地址 https://leetcode.cn/problems/bianry-number-to-string-lcci</description></item><item><title>面试题 05.03 翻转数位</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/reverse-bits-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/reverse-bits-lcci/</guid><description>面试题 05.03 翻转数位 给定一个32位整数 num，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。
示例 1：
输入: num = 1775(110111011112) 输出: 8 示例 2：
输入: num = 7(01112) 输出: 4 func reverseBits(num int) int { } LeetCode题库地址 https://leetcode.cn/problems/reverse-bits-lcci</description></item><item><title>面试题 05.04 下一个数</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/closed-number-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/closed-number-lcci/</guid><description>面试题 05.04 下一个数 下一个数。给定一个正整数，找出与其二进制表达式中1的个数相同且大小最接近的那两个数（一个略大，一个略小）。
示例1:
输入：num = 2（或者0b10） 输出：[4, 1] 或者（[0b100, 0b1]） 示例2:
输入：num = 1 输出：[2, -1] 提示:
num的范围在[1, 2147483647]之间； 如果找不到前一个或者后一个满足条件的正数，那么输出 -1。 func findClosedNumbers(num int) []int { } LeetCode题库地址 https://leetcode.cn/problems/closed-number-lcci</description></item><item><title>面试题 05.06 整数转换</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/convert-integer-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/convert-integer-lcci/</guid><description>面试题 05.06 整数转换 整数转换。编写一个函数，确定需要改变几个位才能将整数A转成整数B。
示例1:
输入：A = 29 （或者0b11101）, B = 15（或者0b01111） 输出：2 示例2:
输入：A = 1，B = 2 输出：2 提示:
A，B范围在[-2147483648, 2147483647]之间 func convertInteger(A int, B int) int { } LeetCode题库地址 https://leetcode.cn/problems/convert-integer-lcci</description></item><item><title>面试题 05.07 配对交换</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/exchange-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/exchange-lcci/</guid><description>面试题 05.07 配对交换 配对交换。编写程序，交换某个整数的奇数位和偶数位，尽量使用较少的指令（也就是说，位0与位1交换，位2与位3交换，以此类推）。
示例1:
输入：num = 2（或者0b10） 输出 1 (或者 0b01) 示例2:
输入：num = 3 输出：3 提示:
num的范围在[0, 2^30 - 1]之间，不会发生整数溢出。 func exchangeBits(num int) int { } LeetCode题库地址 https://leetcode.cn/problems/exchange-lcci</description></item><item><title>面试题 05.08 绘制直线</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/draw-line-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/draw-line-lcci/</guid><description>面试题 05.08 绘制直线 已知一个由像素点组成的单色屏幕，每行均有 w 个像素点，所有像素点初始为 0，左上角位置为 (0,0)。
现将每行的像素点按照「每 32 个像素点」为一组存放在一个 int 中，再依次存入长度为 length 的一维数组中。
我们将在屏幕上绘制一条从点 (x1,y) 到点 (x2,y) 的直线（即像素点修改为 1），请返回绘制过后的数组。
&amp;nbsp;
注意：
用例保证屏幕宽度 w 可被 32 整除（即一个 int 不会分布在两行上） &amp;nbsp;
示例1:
输入：length = 1, w = 32, x1 = 30, x2 = 31, y = 0 输出：[3] 解释：在第 0 行的第 30 位到第 31 位画一条直线，屏幕二进制形式表示为 [00000000000000000000000000000011]，因此返回 [3] 示例2:
输入：length = 3, w = 96, x1 = 0, x2 = 95, y = 0 输出：[-1, -1, -1] 解释：由于二进制 11111111111111111111111111111111 的 int 类型代表 -1，因此返回 [-1,-1,-1] &amp;nbsp;</description></item><item><title>面试题 08.01 三步问题</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/three-steps-problem-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/three-steps-problem-lcci/</guid><description>面试题 08.01 三步问题 三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。
示例1:
输入：n = 3 输出：4 说明: 有四种走法 示例2:
输入：n = 5 输出：13 提示:
n范围在[1, 1000000]之间 func waysToStep(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/three-steps-problem-lcci</description></item><item><title>面试题 08.02 迷路的机器人</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/robot-in-a-grid-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/robot-in-a-grid-lcci/</guid><description>面试题 08.02 迷路的机器人 设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。设计一种算法，寻找机器人从左上角移动到右下角的路径。
网格中的障碍物和空位置分别用 1 和 0 来表示。
返回一条可行的路径，路径由经过的网格的行号和列号组成。左上角为 0 行 0 列。如果没有可行的路径，返回空数组。
示例&amp;nbsp;1:
输入: [ &amp;nbsp; [0,0,0], &amp;nbsp; [0,1,0], &amp;nbsp; [0,0,0] ] 输出: [[0,0],[0,1],[0,2],[1,2],[2,2]] 解释: 输入中标粗的位置即为输出表示的路径，即 0行0列（左上角） -&amp;gt; 0行1列 -&amp;gt; 0行2列 -&amp;gt; 1行2列 -&amp;gt; 2行2列（右下角） 说明：r&amp;nbsp;和 c 的值均不超过 100。
func pathWithObstacles(obstacleGrid [][]int) [][]int { } LeetCode题库地址 https://leetcode.cn/problems/robot-in-a-grid-lcci</description></item><item><title>面试题 08.03 魔术索引</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/magic-index-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/magic-index-lcci/</guid><description>面试题 08.03 魔术索引 魔术索引。 在数组A[0...n-1]中，有所谓的魔术索引，满足条件A[i] = i。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。
示例1:
输入：nums = [0, 2, 3, 4, 5] 输出：0 说明: 0下标的元素为0 示例2:
输入：nums = [1, 1, 1] 输出：1 说明:
nums长度在[1, 1000000]之间 此题为原书中的 Follow-up，即数组中可能包含重复元素的版本 func findMagicIndex(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/magic-index-lcci</description></item><item><title>面试题 08.04 幂集</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/power-set-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/power-set-lcci/</guid><description>面试题 08.04 幂集 幂集。编写一种方法，返回某集合的所有子集。集合中不包含重复的元素。
说明：解集不能包含重复的子集。
示例:
输入： nums = [1,2,3] 输出： [ [3], &amp;nbsp; [1], &amp;nbsp; [2], &amp;nbsp; [1,2,3], &amp;nbsp; [1,3], &amp;nbsp; [2,3], &amp;nbsp; [1,2], &amp;nbsp; [] ] func subsets(nums []int) [][]int { } LeetCode题库地址 https://leetcode.cn/problems/power-set-lcci</description></item><item><title>面试题 08.05 递归乘法</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/recursive-mulitply-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/recursive-mulitply-lcci/</guid><description>面试题 08.05 递归乘法 递归乘法。 写一个递归函数，不使用 * 运算符， 实现两个正整数的相乘。可以使用加号、减号、位移，但要吝啬一些。
示例1:
输入：A = 1, B = 10 输出：10 示例2:
输入：A = 3, B = 4 输出：12 提示:
保证乘法范围不会溢出 func multiply(A int, B int) int { } LeetCode题库地址 https://leetcode.cn/problems/recursive-mulitply-lcci</description></item><item><title>面试题 08.06 汉诺塔问题</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/hanota-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/hanota-lcci/</guid><description>面试题 08.06 汉诺塔问题 在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:
(1) 每次只能移动一个盘子;
(2) 盘子只能从柱子顶端滑出移到下一根柱子;
(3) 盘子只能叠在比它大的盘子上。
请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。
你需要原地修改栈。
示例1:
输入：A = [2, 1, 0], B = [], C = [] 输出：C = [2, 1, 0] 示例2:
输入：A = [1, 0], B = [], C = [] 输出：C = [1, 0] 提示:
A中盘子的数目不大于14个。 func hanota(A []int, B []int, C []int) []int { } LeetCode题库地址 https://leetcode.cn/problems/hanota-lcci</description></item><item><title>面试题 08.07 无重复字符串的排列组合</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/permutation-i-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/permutation-i-lcci/</guid><description>面试题 08.07 无重复字符串的排列组合 无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。
示例1:
输入：S = "qwe" 输出：["qwe", "qew", "wqe", "weq", "ewq", "eqw"] 示例2:
输入：S = "ab" 输出：["ab", "ba"] 提示:
字符都是英文字母。 字符串长度在[1, 9]之间。 func permutation(S string) []string { } LeetCode题库地址 https://leetcode.cn/problems/permutation-i-lcci</description></item><item><title>面试题 08.08 有重复字符串的排列组合</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/permutation-ii-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/permutation-ii-lcci/</guid><description>面试题 08.08 有重复字符串的排列组合 有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。
示例1:
输入：S = &amp;quot;qqe&amp;quot; 输出：[&amp;quot;eqq&amp;quot;,&amp;quot;qeq&amp;quot;,&amp;quot;qqe&amp;quot;] 示例2:
输入：S = &amp;quot;ab&amp;quot; 输出：[&amp;quot;ab&amp;quot;, &amp;quot;ba&amp;quot;] 提示:
字符都是英文字母。 字符串长度在[1, 9]之间。 func permutation(S string) []string { } LeetCode题库地址 https://leetcode.cn/problems/permutation-ii-lcci</description></item><item><title>面试题 08.09 括号</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/bracket-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/bracket-lcci/</guid><description>面试题 08.09 括号 括号。设计一种算法，打印n对括号的所有合法的（例如，开闭一一对应）组合。
说明：解集不能包含重复的子集。
例如，给出 n = 3，生成结果为：
[ "((()))", "(()())", "(())()", "()(())", "()()()" ] func generateParenthesis(n int) []string { } LeetCode题库地址 https://leetcode.cn/problems/bracket-lcci</description></item><item><title>面试题 08.10 颜色填充</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/color-fill-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/color-fill-lcci/</guid><description>面试题 08.10 颜色填充 编写函数，实现许多图片编辑软件都支持的「颜色填充」功能。
待填充的图像用二维数组 image 表示，元素为初始颜色值。初始坐标点的行坐标为 sr 列坐标为 sc。需要填充的新颜色为 newColor 。
「周围区域」是指颜色相同且在上、下、左、右四个方向上存在相连情况的若干元素。
请用新颜色填充初始坐标点的周围区域，并返回填充后的图像。
示例：
输入： image = [[1,1,1],[1,1,0],[1,0,1]] sr = 1, sc = 1, newColor = 2 输出：[[2,2,2],[2,2,0],[2,0,1]] 解释: 初始坐标点位于图像的正中间，坐标 (sr,sc)=(1,1) 。 初始坐标点周围区域上所有符合条件的像素点的颜色都被更改成 2 。 注意，右下角的像素没有更改为 2 ，因为它不属于初始坐标点的周围区域。 提示：
image 和 image[0] 的长度均在范围 [1, 50] 内。 初始坐标点 (sr,sc) 满足 0 &lt;= sr &lt; image.length 和 0 &lt;= sc &lt; image[0].length 。 image[i][j] 和 newColor 表示的颜色值在范围 [0, 65535] 内。 func floodFill(image [][]int, sr int, sc int, newColor int) [][]int { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 08.11 硬币</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/coin-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/coin-lcci/</guid><description>面试题 08.11 硬币 硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)
示例1:
输入: n = 5 输出：2 解释: 有两种方式可以凑成总金额: 5=5 5=1+1+1+1+1 示例2:
输入: n = 10 输出：4 解释: 有四种方式可以凑成总金额: 10=10 10=5+5 10=5+1+1+1+1+1 10=1+1+1+1+1+1+1+1+1+1 说明：
注意:
你可以假设：
0 &amp;lt;= n (总金额) &amp;lt;= 1000000 func waysToChange(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/coin-lcci</description></item><item><title>面试题 08.12 八皇后</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/eight-queens-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/eight-queens-lcci/</guid><description>面试题 08.12 八皇后 设计一种算法，打印 N 皇后在 N &amp;times; N 棋盘上的各种摆法，其中每个皇后都不同行、不同列，也不在对角线上。这里的&amp;ldquo;对角线&amp;rdquo;指的是所有的对角线，不只是平分整个棋盘的那两条对角线。
注意：本题相对原题做了扩展
示例:
输入：4 输出：[[&amp;quot;.Q..&amp;quot;,&amp;quot;...Q&amp;quot;,&amp;quot;Q...&amp;quot;,&amp;quot;..Q.&amp;quot;],[&amp;quot;..Q.&amp;quot;,&amp;quot;Q...&amp;quot;,&amp;quot;...Q&amp;quot;,&amp;quot;.Q..&amp;quot;]] 解释: 4 皇后问题存在如下两个不同的解法。 [ &amp;nbsp;[&amp;quot;.Q..&amp;quot;, &amp;nbsp;// 解法 1 &amp;nbsp; &amp;quot;...Q&amp;quot;, &amp;nbsp; &amp;quot;Q...&amp;quot;, &amp;nbsp; &amp;quot;..Q.&amp;quot;], &amp;nbsp;[&amp;quot;..Q.&amp;quot;, &amp;nbsp;// 解法 2 &amp;nbsp; &amp;quot;Q...&amp;quot;, &amp;nbsp; &amp;quot;...Q&amp;quot;, &amp;nbsp; &amp;quot;.Q..&amp;quot;] ] func solveNQueens(n int) [][]string { } LeetCode题库地址 https://leetcode.cn/problems/eight-queens-lcci</description></item><item><title>面试题 08.13 堆箱子</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/pile-box-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/pile-box-lcci/</guid><description>面试题 08.13 堆箱子 堆箱子。给你一堆n个箱子，箱子宽 wi、深 di、高 hi。箱子不能翻转，将箱子堆起来时，下面箱子的宽度、高度和深度必须大于上面的箱子。实现一种方法，搭出最高的一堆箱子。箱堆的高度为每个箱子高度的总和。
输入使用数组[wi, di, hi]表示每个箱子。
示例1:
输入：box = [[1, 1, 1], [2, 2, 2], [3, 3, 3]] 输出：6 示例2:
输入：box = [[1, 1, 1], [2, 3, 4], [2, 6, 7], [3, 4, 5]] 输出：10 提示:
箱子的数目不大于3000个。 func pileBox(box [][]int) int { } LeetCode题库地址 https://leetcode.cn/problems/pile-box-lcci</description></item><item><title>面试题 08.14 布尔运算</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/boolean-evaluation-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/boolean-evaluation-lcci/</guid><description>面试题 08.14 布尔运算 给定一个布尔表达式和一个期望的布尔结果 result，布尔表达式由 0 (false)、1 (true)、&amp;amp; (AND)、 | (OR) 和 ^ (XOR) 符号组成。实现一个函数，算出有几种可使该表达式得出 result 值的括号方法。
示例 1:
输入: s = &amp;quot;1^0|0|1&amp;quot;, result = 0 输出: 2 解释:&amp;nbsp;两种可能的括号方法是 1^(0|(0|1)) 1^((0|0)|1) 示例 2:
输入: s = &amp;quot;0&amp;amp;0&amp;amp;0&amp;amp;1^1|0&amp;quot;, result = 1 输出: 10 提示：
运算符的数量不超过 19 个 func countEval(s string, result int) int { } LeetCode题库地址 https://leetcode.cn/problems/boolean-evaluation-lcci</description></item><item><title>面试题 10.01 合并排序的数组</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sorted-merge-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sorted-merge-lcci/</guid><description>面试题 10.01 合并排序的数组 给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。
初始化&amp;nbsp;A 和 B 的元素数量分别为&amp;nbsp;m 和 n。
示例:
输入: A = [1,2,3,0,0,0], m = 3 B = [2,5,6], n = 3 输出:&amp;nbsp;[1,2,2,3,5,6] 说明:
A.length == n + m func merge(A []int, m int, B []int, n int) { } LeetCode题库地址 https://leetcode.cn/problems/sorted-merge-lcci</description></item><item><title>面试题 10.02 变位词组</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/group-anagrams-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/group-anagrams-lcci/</guid><description>面试题 10.02 变位词组 编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。
注意：本题相对原题稍作修改
示例:
输入: [&amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;tan&amp;quot;, &amp;quot;ate&amp;quot;, &amp;quot;nat&amp;quot;, &amp;quot;bat&amp;quot;], 输出: [ [&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;], [&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;], [&amp;quot;bat&amp;quot;] ] 说明：
所有输入均为小写字母。 不考虑答案输出的顺序。 func groupAnagrams(strs []string) [][]string { } LeetCode题库地址 https://leetcode.cn/problems/group-anagrams-lcci</description></item><item><title>面试题 10.03 搜索旋转数组</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/search-rotate-array-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/search-rotate-array-lcci/</guid><description>面试题 10.03 搜索旋转数组 搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。
示例1:
输入: arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 5 输出: 8（元素5在该数组中的索引） 示例2:
输入：arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 11 输出：-1 （没有找到） 提示:
arr 长度范围在[1, 1000000]之间 func search(arr []int, target int) int { } LeetCode题库地址 https://leetcode.cn/problems/search-rotate-array-lcci</description></item><item><title>面试题 10.05 稀疏数组搜索</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sparse-array-search-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sparse-array-search-lcci/</guid><description>面试题 10.05 稀疏数组搜索 稀疏数组搜索。有个排好序的字符串数组，其中散布着一些空字符串，编写一种方法，找出给定字符串的位置。
示例1:
输入: words = [&amp;quot;at&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;ball&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;car&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;,&amp;quot;dad&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;], s = &amp;quot;ta&amp;quot; 输出：-1 说明: 不存在返回-1。 示例2:
输入：words = [&amp;quot;at&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;ball&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;car&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;,&amp;quot;dad&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;], s = &amp;quot;ball&amp;quot; 输出：4 提示:
words的长度在[1, 1000000]之间 func findString(words []string, s string) int { } LeetCode题库地址 https://leetcode.cn/problems/sparse-array-search-lcci</description></item><item><title>面试题 10.09 排序矩阵查找</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sorted-matrix-search-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sorted-matrix-search-lcci/</guid><description>面试题 10.09 排序矩阵查找 给定M&amp;times;N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。
示例:
现有矩阵 matrix 如下：
[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target&amp;nbsp;=&amp;nbsp;5，返回&amp;nbsp;true。
给定&amp;nbsp;target&amp;nbsp;=&amp;nbsp;20，返回&amp;nbsp;false。
func searchMatrix(matrix [][]int, target int) bool { } LeetCode题库地址 https://leetcode.cn/problems/sorted-matrix-search-lcci</description></item><item><title>面试题 10.10 数字流的秩</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/rank-from-stream-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/rank-from-stream-lcci/</guid><description>面试题 10.10 数字流的秩 假设你正在读取一串整数。每隔一段时间，你希望能找出数字 x 的秩(小于或等于 x 的值的个数)。请实现数据结构和算法来支持这些操作，也就是说：
实现 track(int x)&amp;nbsp;方法，每读入一个数字都会调用该方法；
实现 getRankOfNumber(int x) 方法，返回小于或等于 x 的值的个数。
注意：本题相对原题稍作改动
示例:
输入: [&amp;quot;StreamRank&amp;quot;, &amp;quot;getRankOfNumber&amp;quot;, &amp;quot;track&amp;quot;, &amp;quot;getRankOfNumber&amp;quot;] [[], [1], [0], [0]] 输出: [null,0,null,1] 提示：
x &amp;lt;= 50000 track&amp;nbsp;和&amp;nbsp;getRankOfNumber 方法的调用次数均不超过 2000 次 type StreamRank struct { } func Constructor() StreamRank { } func (this *StreamRank) Track(x int) { } func (this *StreamRank) GetRankOfNumber(x int) int { } /** * Your StreamRank object will be instantiated and called as such: * obj := Constructor(); * obj.</description></item><item><title>面试题 10.11 峰与谷</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/peaks-and-valleys-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/peaks-and-valleys-lcci/</guid><description>面试题 10.11 峰与谷 在一个整数数组中，&amp;ldquo;峰&amp;rdquo;是大于或等于相邻整数的元素，相应地，&amp;ldquo;谷&amp;rdquo;是小于或等于相邻整数的元素。例如，在数组{5, 8, 4, 2, 3, 4, 6}中，{8, 6}是峰， {5, 2}是谷。现在给定一个整数数组，将该数组按峰与谷的交替顺序排序。
示例:
输入: [5, 3, 1, 2, 3] 输出:&amp;nbsp;[5, 1, 3, 2, 3] 提示：
nums.length &amp;lt;= 10000 func wiggleSort(nums []int) { } LeetCode题库地址 https://leetcode.cn/problems/peaks-and-valleys-lcci</description></item><item><title>面试题 16.01 交换数字</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/swap-numbers-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/swap-numbers-lcci/</guid><description>面试题 16.01 交换数字 编写一个函数，不用临时变量，直接交换numbers = [a, b]中a与b的值。
示例：
输入: numbers = [1,2] 输出: [2,1] 提示：
numbers.length == 2 -2147483647 &lt;= numbers[i] &lt;= 2147483647 func swapNumbers(numbers []int) []int { } LeetCode题库地址 https://leetcode.cn/problems/swap-numbers-lcci</description></item><item><title>面试题 16.02 单词频率</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/words-frequency-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/words-frequency-lcci/</guid><description>面试题 16.02 单词频率 设计一个方法，找出任意指定单词在一本书中的出现频率。
你的实现应该支持如下操作：
WordsFrequency(book)构造函数，参数为字符串数组构成的一本书 get(word)查询指定单词在书中出现的频率 示例：
WordsFrequency wordsFrequency = new WordsFrequency({&amp;quot;i&amp;quot;, &amp;quot;have&amp;quot;, &amp;quot;an&amp;quot;, &amp;quot;apple&amp;quot;, &amp;quot;he&amp;quot;, &amp;quot;have&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;pen&amp;quot;}); wordsFrequency.get(&amp;quot;you&amp;quot;); //返回0，&amp;quot;you&amp;quot;没有出现过 wordsFrequency.get(&amp;quot;have&amp;quot;); //返回2，&amp;quot;have&amp;quot;出现2次 wordsFrequency.get(&amp;quot;an&amp;quot;); //返回1 wordsFrequency.get(&amp;quot;apple&amp;quot;); //返回1 wordsFrequency.get(&amp;quot;pen&amp;quot;); //返回1 提示：
book[i]中只包含小写字母 1 &amp;lt;= book.length &amp;lt;= 100000 1 &amp;lt;= book[i].length &amp;lt;= 10 get函数的调用次数不会超过100000 type WordsFrequency struct { } func Constructor(book []string) WordsFrequency { } func (this *WordsFrequency) Get(word string) int { } /** * Your WordsFrequency object will be instantiated and called as such: * obj := Constructor(book); * param_1 := obj.</description></item><item><title>面试题 16.03 交点</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/intersection-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/intersection-lcci/</guid><description>面试题 16.03 交点 给定两条线段（表示为起点start = {X1, Y1}和终点end = {X2, Y2}），如果它们有交点，请计算其交点，没有交点则返回空值。
要求浮点型误差不超过10^-6。若有多个交点（线段重叠）则返回 X 值最小的点，X 坐标相同则返回 Y 值最小的点。
&amp;nbsp;
示例 1：
输入： line1 = {0, 0}, {1, 0} line2 = {1, 1}, {0, -1} 输出： {0.5, 0} 示例 2：
输入： line1 = {0, 0}, {3, 3} line2 = {1, 1}, {2, 2} 输出： {1, 1} 示例 3：
输入： line1 = {0, 0}, {1, 1} line2 = {1, 0}, {2, 1} 输出： {}，两条线段没有交点 &amp;nbsp;
提示：
坐标绝对值不会超过 2^7 输入的坐标均是有效的二维坐标 func intersection(start1 []int, end1 []int, start2 []int, end2 []int) []float64 { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 16.04 井字游戏</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/tic-tac-toe-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/tic-tac-toe-lcci/</guid><description>面试题 16.04 井字游戏 设计一个算法，判断玩家是否赢了井字游戏。输入是一个 N x N 的数组棋盘，由字符&amp;quot; &amp;quot;，&amp;quot;X&amp;quot;和&amp;quot;O&amp;quot;组成，其中字符&amp;quot; &amp;quot;代表一个空位。
以下是井字游戏的规则：
玩家轮流将字符放入空位（&amp;quot; &amp;quot;）中。 第一个玩家总是放字符&amp;quot;O&amp;quot;，且第二个玩家总是放字符&amp;quot;X&amp;quot;。 &amp;quot;X&amp;quot;和&amp;quot;O&amp;quot;只允许放置在空位中，不允许对已放有字符的位置进行填充。 当有N个相同（且非空）的字符填充任何行、列或对角线时，游戏结束，对应该字符的玩家获胜。 当所有位置非空时，也算为游戏结束。 如果游戏结束，玩家不允许再放置字符。 如果游戏存在获胜者，就返回该游戏的获胜者使用的字符（&amp;quot;X&amp;quot;或&amp;quot;O&amp;quot;）；如果游戏以平局结束，则返回 &amp;quot;Draw&amp;quot;；如果仍会有行动（游戏未结束），则返回 &amp;quot;Pending&amp;quot;。
示例 1：
输入： board = [&amp;quot;O X&amp;quot;,&amp;quot; XO&amp;quot;,&amp;quot;X O&amp;quot;] 输出： &amp;quot;X&amp;quot; 示例 2：
输入： board = [&amp;quot;OOX&amp;quot;,&amp;quot;XXO&amp;quot;,&amp;quot;OXO&amp;quot;] 输出： &amp;quot;Draw&amp;quot; 解释： 没有玩家获胜且不存在空位 示例 3：
输入： board = [&amp;quot;OOX&amp;quot;,&amp;quot;XXO&amp;quot;,&amp;quot;OX &amp;quot;] 输出： &amp;quot;Pending&amp;quot; 解释： 没有玩家获胜且仍存在空位 提示：
1 &amp;lt;= board.length == board[i].length &amp;lt;= 100 输入一定遵循井字棋规则 func tictactoe(board []string) string { } LeetCode题库地址 https://leetcode.cn/problems/tic-tac-toe-lcci</description></item><item><title>面试题 16.05 阶乘尾数</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/factorial-zeros-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/factorial-zeros-lcci/</guid><description>面试题 16.05 阶乘尾数 设计一个算法，算出 n 阶乘有多少个尾随零。
示例 1:
输入: 3 输出: 0 解释:&amp;nbsp;3! = 6, 尾数中没有零。 示例&amp;nbsp;2:
输入: 5 输出: 1 解释:&amp;nbsp;5! = 120, 尾数中有 1 个零. 说明: 你算法的时间复杂度应为&amp;nbsp;O(log&amp;nbsp;n)&amp;nbsp;。
func trailingZeroes(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/factorial-zeros-lcci</description></item><item><title>面试题 16.06 最小差</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/smallest-difference-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/smallest-difference-lcci/</guid><description>面试题 16.06 最小差 给定两个整数数组a和b，计算具有最小差绝对值的一对数值（每个数组中取一个值），并返回该对数值的差
示例：
输入：{1, 3, 15, 11, 2}, {23, 127, 235, 19, 8} 输出：3，即数值对(11, 8) 提示：
1 &lt;= a.length, b.length &lt;= 100000 -2147483648 &lt;= a[i], b[i] &lt;= 2147483647 正确结果在区间 [0, 2147483647] 内 func smallestDifference(a []int, b []int) int { } LeetCode题库地址 https://leetcode.cn/problems/smallest-difference-lcci</description></item><item><title>面试题 16.07 最大数值</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/maximum-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/maximum-lcci/</guid><description>面试题 16.07 最大数值 编写一个方法，找出两个数字a和b中最大的那一个。不得使用if-else或其他比较运算符。
示例：
输入： a = 1, b = 2 输出： 2 func maximum(a int, b int) int { } LeetCode题库地址 https://leetcode.cn/problems/maximum-lcci</description></item><item><title>面试题 16.08 整数的英语表示</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/english-int-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/english-int-lcci/</guid><description>面试题 16.08 整数的英语表示 给定一个整数，打印该整数的英文描述。
示例 1:
输入: 123 输出: "One Hundred Twenty Three" 示例 2:
输入: 12345 输出: "Twelve Thousand Three Hundred Forty Five" 示例 3:
输入: 1234567 输出: "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven" 示例 4:
输入: 1234567891 输出: "One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One" 注意：本题与 273 题相同：https://leetcode-cn.com/problems/integer-to-english-words/
func numberToWords(num int) string { } LeetCode题库地址 https://leetcode.cn/problems/english-int-lcci</description></item><item><title>面试题 16.09 运算</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/operations-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/operations-lcci/</guid><description>面试题 16.09 运算 请实现整数数字的乘法、减法和除法运算，运算结果均为整数数字，程序中只允许使用加法运算符和逻辑运算符，允许程序中出现正负常数，不允许使用位运算。
你的实现应该支持如下操作：
Operations() 构造函数 minus(a, b) 减法，返回a - b multiply(a, b) 乘法，返回a * b divide(a, b) 除法，返回a / b 示例：
Operations operations = new Operations(); operations.minus(1, 2); //返回-1 operations.multiply(3, 4); //返回12 operations.divide(5, -2); //返回-2 提示：
你可以假设函数输入一定是有效的，例如不会出现除法分母为0的情况 单个用例的函数调用次数不会超过1000次 type Operations struct { } func Constructor() Operations { } func (this *Operations) Minus(a int, b int) int { } func (this *Operations) Multiply(a int, b int) int { } func (this *Operations) Divide(a int, b int) int { } /** * Your Operations object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.</description></item><item><title>面试题 16.10 生存人数</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/living-people-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/living-people-lcci/</guid><description>面试题 16.10 生存人数 给定 N 个人的出生年份和死亡年份，第 i 个人的出生年份为 birth[i]，死亡年份为 death[i]，实现一个方法以计算生存人数最多的年份。
你可以假设所有人都出生于 1900 年至 2000 年（含 1900 和 2000 ）之间。如果一个人在某一年的任意时期处于生存状态，那么他应该被纳入那一年的统计中。例如，生于 1908 年、死于 1909 年的人应当被列入 1908 年和 1909 年的计数。
如果有多个年份生存人数相同且均为最大值，输出其中最小的年份。
示例：
输入： birth = {1900, 1901, 1950} death = {1948, 1951, 2000} 输出： 1901 提示：
0 &lt; birth.length == death.length &lt;= 10000 birth[i] &lt;= death[i] func maxAliveYear(birth []int, death []int) int { } LeetCode题库地址 https://leetcode.cn/problems/living-people-lcci</description></item><item><title>面试题 16.11 跳水板</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/diving-board-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/diving-board-lcci/</guid><description>面试题 16.11 跳水板 你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。
返回的长度需要从小到大排列。
示例 1
输入： shorter = 1 longer = 2 k = 3 输出： [3,4,5,6] 解释： 可以使用 3 次 shorter，得到结果 3；使用 2 次 shorter 和 1 次 longer，得到结果 4 。以此类推，得到最终结果。 提示：
0 &amp;lt; shorter &amp;lt;= longer 0 &amp;lt;= k &amp;lt;= 100000 func divingBoard(shorter int, longer int, k int) []int { } LeetCode题库地址 https://leetcode.cn/problems/diving-board-lcci</description></item><item><title>面试题 16.13 平分正方形</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/bisect-squares-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/bisect-squares-lcci/</guid><description>面试题 16.13 平分正方形 给定两个正方形及一个二维平面。请找出将这两个正方形分割成两半的一条直线。假设正方形顶边和底边与 x 轴平行。
每个正方形的数据square包含3个数值，正方形的左下顶点坐标[X,Y] = [square[0],square[1]]，以及正方形的边长square[2]。所求直线穿过两个正方形会形成4个交点，请返回4个交点形成线段的两端点坐标（两个端点即为4个交点中距离最远的2个点，这2个点所连成的线段一定会穿过另外2个交点）。2个端点坐标[X1,Y1]和[X2,Y2]的返回格式为{X1,Y1,X2,Y2}，要求若X1 != X2，需保证X1 &amp;lt; X2，否则需保证Y1 &amp;lt;= Y2。
若同时有多条直线满足要求，则选择斜率最大的一条计算并返回（与Y轴平行的直线视为斜率无穷大）。
示例：
输入： square1 = {-1, -1, 2} square2 = {0, -1, 2} 输出： {-1,0,2,0} 解释： 直线 y = 0 能将两个正方形同时分为等面积的两部分，返回的两线段端点为[-1,0]和[2,0] 提示：
square.length == 3 square[2] &amp;gt; 0 func cutSquares(square1 []int, square2 []int) []float64 { } LeetCode题库地址 https://leetcode.cn/problems/bisect-squares-lcci</description></item><item><title>面试题 16.14 最佳直线</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/best-line-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/best-line-lcci/</guid><description>面试题 16.14 最佳直线 给定一个二维平面及平面上的 N 个点列表Points，其中第i个点的坐标为Points[i]=[Xi,Yi]。请找出一条直线，其通过的点的数目最多。
设穿过最多点的直线所穿过的全部点编号从小到大排序的列表为S，你仅需返回[S[0],S[1]]作为答案，若有多条直线穿过了相同数量的点，则选择S[0]值较小的直线返回，S[0]相同则选择S[1]值较小的直线返回。
示例：
输入： [[0,0],[1,1],[1,0],[2,0]] 输出： [0,2] 解释： 所求直线穿过的3个点的编号为[0,2,3] 提示：
2 &lt;= len(Points) &lt;= 300 len(Points[i]) = 2 func bestLine(points [][]int) []int { } LeetCode题库地址 https://leetcode.cn/problems/best-line-lcci</description></item><item><title>面试题 16.15 珠玑妙算</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/master-mind-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/master-mind-lcci/</guid><description>面试题 16.15 珠玑妙算 珠玑妙算游戏（the game of master mind）的玩法如下。
计算机有4个槽，每个槽放一个球，颜色可能是红色（R）、黄色（Y）、绿色（G）或蓝色（B）。例如，计算机可能有RGGB 4种（槽1为红色，槽2、3为绿色，槽4为蓝色）。作为用户，你试图猜出颜色组合。打个比方，你可能会猜YRGB。要是猜对某个槽的颜色，则算一次“猜中”；要是只猜对颜色但槽位猜错了，则算一次“伪猜中”。注意，“猜中”不能算入“伪猜中”。
给定一种颜色组合solution和一个猜测guess，编写一个方法，返回猜中和伪猜中的次数answer，其中answer[0]为猜中的次数，answer[1]为伪猜中的次数。
示例：
输入： solution="RGBY",guess="GGRR" 输出： [1,1] 解释： 猜中1次，伪猜中1次。 提示：
len(solution) = len(guess) = 4 solution和guess仅包含"R","G","B","Y"这4种字符 func masterMind(solution string, guess string) []int { } LeetCode题库地址 https://leetcode.cn/problems/master-mind-lcci</description></item><item><title>面试题 16.16 部分排序</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sub-sort-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sub-sort-lcci/</guid><description>面试题 16.16 部分排序 给定一个整数数组，编写一个函数，找出索引m和n，只要将索引区间[m,n]的元素排好序，整个数组就是有序的。注意：n-m尽量最小，也就是说，找出符合条件的最短序列。函数返回值为[m,n]，若不存在这样的m和n（例如整个数组是有序的），请返回[-1,-1]。
示例：
输入： [1,2,4,7,10,11,7,12,6,7,16,18,19] 输出： [3,9] 提示：
0 &lt;= len(array) &lt;= 1000000 func subSort(array []int) []int { } LeetCode题库地址 https://leetcode.cn/problems/sub-sort-lcci</description></item><item><title>面试题 16.17 连续数列</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/contiguous-sequence-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/contiguous-sequence-lcci/</guid><description>面试题 16.17 连续数列 给定一个整数数组，找出总和最大的连续数列，并返回总和。
示例：
输入： [-2,1,-3,4,-1,2,1,-5,4] 输出： 6 解释： 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶：
如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。
func maxSubArray(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/contiguous-sequence-lcci</description></item><item><title>面试题 16.18 模式匹配</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/pattern-matching-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/pattern-matching-lcci/</guid><description>面试题 16.18 模式匹配 你有两个字符串，即pattern和value。 pattern字符串由字母&amp;quot;a&amp;quot;和&amp;quot;b&amp;quot;组成，用于描述字符串中的模式。例如，字符串&amp;quot;catcatgocatgo&amp;quot;匹配模式&amp;quot;aabab&amp;quot;（其中&amp;quot;cat&amp;quot;是&amp;quot;a&amp;quot;，&amp;quot;go&amp;quot;是&amp;quot;b&amp;quot;），该字符串也匹配像&amp;quot;a&amp;quot;、&amp;quot;ab&amp;quot;和&amp;quot;b&amp;quot;这样的模式。但需注意&amp;quot;a&amp;quot;和&amp;quot;b&amp;quot;不能同时表示相同的字符串。编写一个方法判断value字符串是否匹配pattern字符串。
示例 1：
输入： pattern = &amp;quot;abba&amp;quot;, value = &amp;quot;dogcatcatdog&amp;quot; 输出： true 示例 2：
输入： pattern = &amp;quot;abba&amp;quot;, value = &amp;quot;dogcatcatfish&amp;quot; 输出： false 示例 3：
输入： pattern = &amp;quot;aaaa&amp;quot;, value = &amp;quot;dogcatcatdog&amp;quot; 输出： false 示例 4：
输入： pattern = &amp;quot;abba&amp;quot;, value = &amp;quot;dogdogdogdog&amp;quot; 输出： true 解释： &amp;quot;a&amp;quot;=&amp;quot;dogdog&amp;quot;,b=&amp;quot;&amp;quot;，反之也符合规则 提示：
1 &amp;lt;= len(pattern) &amp;lt;= 1000 0 &amp;lt;= len(value) &amp;lt;= 1000 你可以假设pattern只包含字母&amp;quot;a&amp;quot;和&amp;quot;b&amp;quot;，value仅包含小写字母。 func patternMatching(pattern string, value string) bool { } LeetCode题库地址 https://leetcode.cn/problems/pattern-matching-lcci</description></item><item><title>面试题 16.19 水域大小</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/pond-sizes-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/pond-sizes-lcci/</guid><description>面试题 16.19 水域大小 你有一个用于表示一片土地的整数矩阵land，该矩阵中每个点的值代表对应地点的海拔高度。若值为0则表示水域。由垂直、水平或对角连接的水域为池塘。池塘的大小是指相连接的水域的个数。编写一个方法来计算矩阵中所有池塘的大小，返回值需要从小到大排序。
示例：
输入： [ [0,2,1,0], [0,1,0,1], [1,1,0,1], [0,1,0,1] ] 输出： [1,2,4] 提示：
0 &lt; len(land) &lt;= 1000 0 &lt; len(land[i]) &lt;= 1000 func pondSizes(land [][]int) []int { } LeetCode题库地址 https://leetcode.cn/problems/pond-sizes-lcci</description></item><item><title>面试题 16.20 T9键盘</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/t9-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/t9-lcci/</guid><description>面试题 16.20 T9键盘 在老式手机上，用户通过数字键盘输入，手机将提供与这些数字相匹配的单词列表。每个数字映射到0至4个字母。给定一个数字序列，实现一个算法来返回匹配单词的列表。你会得到一张含有有效单词的列表。映射如下图所示：
示例 1:
输入: num = &amp;quot;8733&amp;quot;, words = [&amp;quot;tree&amp;quot;, &amp;quot;used&amp;quot;] 输出: [&amp;quot;tree&amp;quot;, &amp;quot;used&amp;quot;] 示例 2:
输入: num = &amp;quot;2&amp;quot;, words = [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;] 输出: [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;] 提示：
num.length &amp;lt;= 1000 words.length &amp;lt;= 500 words[i].length == num.length num中不会出现 0, 1 这两个数字 func getValidT9Words(num string, words []string) []string { } LeetCode题库地址 https://leetcode.cn/problems/t9-lcci</description></item><item><title>面试题 16.21 交换和</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sum-swap-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sum-swap-lcci/</guid><description>面试题 16.21 交换和 给定两个整数数组，请交换一对数值（每个数组中取一个数值），使得两个数组所有元素的和相等。
返回一个数组，第一个元素是第一个数组中要交换的元素，第二个元素是第二个数组中要交换的元素。若有多个答案，返回任意一个均可。若无满足条件的数值，返回空数组。
示例:
输入: array1 = [4, 1, 2, 1, 1, 2], array2 = [3, 6, 3, 3] 输出: [1, 3] 示例:
输入: array1 = [1, 2, 3], array2 = [4, 5, 6] 输出: [] 提示：
1 &amp;lt;= array1.length, array2.length &amp;lt;= 100000 func findSwapValues(array1 []int, array2 []int) []int { } LeetCode题库地址 https://leetcode.cn/problems/sum-swap-lcci</description></item><item><title>面试题 16.22 兰顿蚂蚁</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/langtons-ant-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/langtons-ant-lcci/</guid><description>面试题 16.22 兰顿蚂蚁 一只蚂蚁坐在由白色和黑色方格构成的无限网格上。开始时，网格全白，蚂蚁面向右侧。每行走一步，蚂蚁执行以下操作。
(1) 如果在白色方格上，则翻转方格的颜色，向右(顺时针)转 90 度，并向前移动一个单位。
(2) 如果在黑色方格上，则翻转方格的颜色，向左(逆时针方向)转 90 度，并向前移动一个单位。
编写程序来模拟蚂蚁执行的前 K 个动作，并返回最终的网格。
网格由数组表示，每个元素是一个字符串，代表网格中的一行，黑色方格由&amp;nbsp;&amp;#39;X&amp;#39;&amp;nbsp;表示，白色方格由&amp;nbsp;&amp;#39;_&amp;#39;&amp;nbsp;表示，蚂蚁所在的位置由&amp;nbsp;&amp;#39;L&amp;#39;, &amp;#39;U&amp;#39;, &amp;#39;R&amp;#39;, &amp;#39;D&amp;#39;&amp;nbsp;表示，分别表示蚂蚁&amp;nbsp;左、上、右、下 的朝向。只需要返回能够包含蚂蚁走过的所有方格的最小矩形。
示例 1:
输入: 0 输出: [&amp;quot;R&amp;quot;] 示例 2:
输入: 2 输出: [ &amp;nbsp; &amp;quot;_X&amp;quot;, &amp;nbsp; &amp;quot;LX&amp;quot; ] 示例 3:
输入: 5 输出: [ &amp;nbsp; &amp;quot;_U&amp;quot;, &amp;nbsp; &amp;quot;X_&amp;quot;, &amp;nbsp; &amp;quot;XX&amp;quot; ] 说明：
K &amp;lt;= 100000 func printKMoves(K int) []string { } LeetCode题库地址 https://leetcode.cn/problems/langtons-ant-lcci</description></item><item><title>面试题 16.24 数对和</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/pairs-with-sum-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/pairs-with-sum-lcci/</guid><description>面试题 16.24 数对和 设计一个算法，找出数组中两数之和为指定值的所有整数对。一个数只能属于一个数对。
示例 1:
输入: nums = [5,6,5], target = 11 输出: [[5,6]] 示例 2:
输入: nums = [5,6,5,6], target = 11 输出: [[5,6],[5,6]] 提示：
nums.length &amp;lt;= 100000 func pairSums(nums []int, target int) [][]int { } LeetCode题库地址 https://leetcode.cn/problems/pairs-with-sum-lcci</description></item><item><title>面试题 16.25 LRU 缓存</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/lru-cache-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/lru-cache-lcci/</guid><description>面试题 16.25 LRU 缓存 设计和构建一个&amp;ldquo;最近最少使用&amp;rdquo;缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。
它应该支持以下操作： 获取数据 get 和 写入数据 put 。
获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。
写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。
示例:
LRUCache cache = new LRUCache( 2 /* 缓存容量 */ ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // 返回 1 cache.put(3, 3); // 该操作会使得密钥 2 作废 cache.get(2); // 返回 -1 (未找到) cache.put(4, 4); // 该操作会使得密钥 1 作废 cache.get(1); // 返回 -1 (未找到) cache.get(3); // 返回 3 cache.get(4); // 返回 4 type LRUCache struct { } func Constructor(capacity int) LRUCache { } func (this *LRUCache) Get(key int) int { } func (this *LRUCache) Put(key int, value int) { } /** * Your LRUCache object will be instantiated and called as such: * obj := Constructor(capacity); * param_1 := obj.</description></item><item><title>面试题 16.26 计算器</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/calculator-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/calculator-lcci/</guid><description>面试题 16.26 计算器 给定一个包含正整数、加(+)、减(-)、乘(*)、除(/)的算数表达式(括号除外)，计算其结果。
表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格&amp;nbsp;&amp;nbsp;。 整数除法仅保留整数部分。
示例&amp;nbsp;1:
输入: &amp;quot;3+2*2&amp;quot; 输出: 7 示例 2:
输入: &amp;quot; 3/2 &amp;quot; 输出: 1 示例 3:
输入: &amp;quot; 3+5 / 2 &amp;quot; 输出: 5 说明：
你可以假设所给定的表达式都是有效的。 请不要使用内置的库函数 eval。 func calculate(s string) int { } LeetCode题库地址 https://leetcode.cn/problems/calculator-lcci</description></item><item><title>面试题 17.01 不用加号的加法</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/add-without-plus-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/add-without-plus-lcci/</guid><description>面试题 17.01 不用加号的加法 设计一个函数把两个数字相加。不得使用 + 或者其他算术运算符。
示例:
输入: a = 1, b = 1 输出: 2 &amp;nbsp;
提示：
a,&amp;nbsp;b&amp;nbsp;均可能是负数或 0 结果不会溢出 32 位整数 func add(a int, b int) int { } LeetCode题库地址 https://leetcode.cn/problems/add-without-plus-lcci</description></item><item><title>面试题 17.04 消失的数字</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/missing-number-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/missing-number-lcci/</guid><description>面试题 17.04 消失的数字 数组nums包含从0到n的所有整数，但其中缺了一个。请编写代码找出那个缺失的整数。你有办法在O(n)时间内完成吗？
注意：本题相对书上原题稍作改动
示例 1：
输入：[3,0,1] 输出：2 &amp;nbsp;
示例 2：
输入：[9,6,4,2,3,5,7,0,1] 输出：8 func missingNumber(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/missing-number-lcci</description></item><item><title>面试题 17.05 字母与数字</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/find-longest-subarray-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/find-longest-subarray-lcci/</guid><description>面试题 17.05 字母与数字 给定一个放有字母和数字的数组，找到最长的子数组，且包含的字母和数字的个数相同。
返回该子数组，若存在多个最长子数组，返回左端点下标值最小的子数组。若不存在这样的数组，返回一个空数组。
示例 1:
输入: ["A","1","B","C","D","2","3","4","E","5","F","G","6","7","H","I","J","K","L","M"] 输出: ["A","1","B","C","D","2","3","4","E","5","F","G","6","7"] 示例 2:
输入: ["A","A"] 输出: [] 提示：
array.length &lt;= 100000 func findLongestSubarray(array []string) []string { } LeetCode题库地址 https://leetcode.cn/problems/find-longest-subarray-lcci</description></item><item><title>面试题 17.06 2出现的次数</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/number-of-2s-in-range-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/number-of-2s-in-range-lcci/</guid><description>面试题 17.06 2出现的次数 编写一个方法，计算从 0 到 n (含 n) 中数字 2 出现的次数。
示例:
输入: 25 输出: 9 解释: (2, 12, 20, 21, 22, 23, 24, 25)(注意 22 应该算作两次) 提示：
n &amp;lt;= 10^9 func numberOf2sInRange(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/number-of-2s-in-range-lcci</description></item><item><title>面试题 17.07 婴儿名字</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/baby-names-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/baby-names-lcci/</guid><description>面试题 17.07 婴儿名字 每年，政府都会公布一万个最常见的婴儿名字和它们出现的频率，也就是同名婴儿的数量。有些名字有多种拼法，例如，John 和 Jon 本质上是相同的名字，但被当成了两个名字公布出来。给定两个列表，一个是名字及对应的频率，另一个是本质相同的名字对。设计一个算法打印出每个真实名字的实际频率。注意，如果 John 和 Jon 是相同的，并且 Jon 和 Johnny 相同，则 John 与 Johnny 也相同，即它们有传递和对称性。
在结果列表中，选择 字典序最小 的名字作为真实名字。
示例：
输入：names = ["John(15)","Jon(12)","Chris(13)","Kris(4)","Christopher(19)"], synonyms = ["(Jon,John)","(John,Johnny)","(Chris,Kris)","(Chris,Christopher)"] 输出：["John(27)","Chris(36)"] 提示：
names.length &lt;= 100000 func trulyMostPopular(names []string, synonyms []string) []string { } LeetCode题库地址 https://leetcode.cn/problems/baby-names-lcci</description></item><item><title>面试题 17.08 马戏团人塔</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/circus-tower-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/circus-tower-lcci/</guid><description>面试题 17.08 马戏团人塔 有个马戏团正在设计叠罗汉的表演节目，一个人要站在另一人的肩膀上。出于实际和美观的考虑，在上面的人要比下面的人矮一点且轻一点。已知马戏团每个人的身高和体重，请编写代码计算叠罗汉最多能叠几个人。
示例：
输入：height = [65,70,56,75,60,68] weight = [100,150,90,190,95,110] 输出：6 解释：从上往下数，叠罗汉最多能叠 6 层：(56,90), (60,95), (65,100), (68,110), (70,150), (75,190) 提示：
height.length == weight.length &lt;= 10000 func bestSeqAtIndex(height []int, weight []int) int { } LeetCode题库地址 https://leetcode.cn/problems/circus-tower-lcci</description></item><item><title>面试题 17.09 第 k 个数</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/get-kth-magic-number-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/get-kth-magic-number-lcci/</guid><description>面试题 17.09 第 k 个数 有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。
示例 1:
输入: k = 5 输出: 9 func getKthMagicNumber(k int) int { } LeetCode题库地址 https://leetcode.cn/problems/get-kth-magic-number-lcci</description></item><item><title>面试题 17.10 主要元素</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/find-majority-element-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/find-majority-element-lcci/</guid><description>面试题 17.10 主要元素 数组中占比超过一半的元素称之为主要元素。给你一个 整数 数组，找出其中的主要元素。若没有，返回 -1 。请设计时间复杂度为 O(N) 、空间复杂度为 O(1) 的解决方案。
示例 1：
输入：[1,2,5,9,5,9,5,5,5] 输出：5 示例 2：
输入：[3,2] 输出：-1 示例 3：
输入：[2,2,1,1,1,2,2] 输出：2 func majorityElement(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/find-majority-element-lcci</description></item><item><title>面试题 17.11 单词距离</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/find-closest-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/find-closest-lcci/</guid><description>面试题 17.11 单词距离 有个内含单词的超大文本文件，给定任意两个不同的单词，找出在这个文件中这两个单词的最短距离(相隔单词数)。如果寻找过程在这个文件中会重复多次，而每次寻找的单词不同，你能对此优化吗?
示例：
输入：words = ["I","am","a","student","from","a","university","in","a","city"], word1 = "a", word2 = "student" 输出：1 提示：
words.length &amp;lt;= 100000 func findClosest(words []string, word1 string, word2 string) int { } LeetCode题库地址 https://leetcode.cn/problems/find-closest-lcci</description></item><item><title>面试题 17.12 BiNode</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/binode-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/binode-lcci/</guid><description>面试题 17.12 BiNode 二叉树数据结构TreeNode可用来表示单向链表（其中left置空，right为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求依然符合二叉搜索树的性质，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。
返回转换后的单向链表的头节点。
注意：本题相对原题稍作改动
&amp;nbsp;
示例：
输入： [4,2,5,1,3,null,6,0] 输出： [0,null,1,null,2,null,3,null,4,null,5,null,6] 提示：
节点数量不会超过 100000。 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func convertBiNode(root *TreeNode) *TreeNode { } LeetCode题库地址 https://leetcode.cn/problems/binode-lcci</description></item><item><title>面试题 17.13 恢复空格</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/re-space-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/re-space-lcci/</guid><description>面试题 17.13 恢复空格 哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子&amp;quot;I reset the computer. It still didn&amp;rsquo;t boot!&amp;quot;已经变成了&amp;quot;iresetthecomputeritstilldidntboot&amp;quot;。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。
注意：本题相对原题稍作改动，只需返回未识别的字符数
&amp;nbsp;
示例：
输入： dictionary = [&amp;quot;looked&amp;quot;,&amp;quot;just&amp;quot;,&amp;quot;like&amp;quot;,&amp;quot;her&amp;quot;,&amp;quot;brother&amp;quot;] sentence = &amp;quot;jesslookedjustliketimherbrother&amp;quot; 输出： 7 解释： 断句后为&amp;quot;jess looked just like tim her brother&amp;quot;，共7个未识别字符。 提示：
0 &amp;lt;= len(sentence) &amp;lt;= 1000 dictionary中总字符数不超过 150000。 你可以认为dictionary和sentence中只包含小写字母。 func respace(dictionary []string, sentence string) int { } LeetCode题库地址 https://leetcode.cn/problems/re-space-lcci</description></item><item><title>面试题 17.14 最小K个数</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/smallest-k-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/smallest-k-lcci/</guid><description>面试题 17.14 最小K个数 设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。
示例：
输入： arr = [1,3,5,7,2,4,6,8], k = 4 输出： [1,2,3,4] 提示：
0 &amp;lt;= len(arr) &amp;lt;= 100000 0 &amp;lt;= k &amp;lt;= min(100000, len(arr)) func smallestK(arr []int, k int) []int { } LeetCode题库地址 https://leetcode.cn/problems/smallest-k-lcci</description></item><item><title>面试题 17.15 最长单词</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/longest-word-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/longest-word-lcci/</guid><description>面试题 17.15 最长单词 给定一组单词words，编写一个程序，找出其中的最长单词，且该单词由这组单词中的其他单词组合而成。若有多个长度相同的结果，返回其中字典序最小的一项，若没有符合要求的单词则返回空字符串。
示例：
输入： [&amp;quot;cat&amp;quot;,&amp;quot;banana&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;nana&amp;quot;,&amp;quot;walk&amp;quot;,&amp;quot;walker&amp;quot;,&amp;quot;dogwalker&amp;quot;] 输出： &amp;quot;dogwalker&amp;quot; 解释： &amp;quot;dogwalker&amp;quot;可由&amp;quot;dog&amp;quot;和&amp;quot;walker&amp;quot;组成。 提示：
0 &amp;lt;= len(words) &amp;lt;= 200 1 &amp;lt;= len(words[i]) &amp;lt;= 100 func longestWord(words []string) string { } LeetCode题库地址 https://leetcode.cn/problems/longest-word-lcci</description></item><item><title>面试题 17.16 按摩师</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/the-masseuse-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/the-masseuse-lcci/</guid><description>面试题 17.16 按摩师 一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。
注意：本题相对原题稍作改动
&amp;nbsp;
示例 1：
输入： [1,2,3,1] 输出： 4 解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。 示例 2：
输入： [2,7,9,3,1] 输出： 12 解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。 示例 3：
输入： [2,1,4,5,3,1,1,3] 输出： 12 解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。 func massage(nums []int) int { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 17.17 多次搜索</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/multi-search-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/multi-search-lcci/</guid><description>面试题 17.17 多次搜索 给定一个较长字符串big和一个包含较短字符串的数组smalls，设计一个方法，根据smalls中的每一个较短字符串，对big进行搜索。输出smalls中的字符串在big里出现的所有位置positions，其中positions[i]为smalls[i]出现的所有位置。
示例：
输入： big = &amp;quot;mississippi&amp;quot; smalls = [&amp;quot;is&amp;quot;,&amp;quot;ppi&amp;quot;,&amp;quot;hi&amp;quot;,&amp;quot;sis&amp;quot;,&amp;quot;i&amp;quot;,&amp;quot;ssippi&amp;quot;] 输出： [[1,4],[8],[],[3],[1,4,7,10],[5]] 提示：
0 &amp;lt;= len(big) &amp;lt;= 1000 0 &amp;lt;= len(smalls[i]) &amp;lt;= 1000 smalls的总字符数不会超过 100000。 你可以认为smalls中没有重复字符串。 所有出现的字符均为英文小写字母。 func multiSearch(big string, smalls []string) [][]int { } LeetCode题库地址 https://leetcode.cn/problems/multi-search-lcci</description></item><item><title>面试题 17.18 最短超串</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/shortest-supersequence-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/shortest-supersequence-lcci/</guid><description>面试题 17.18 最短超串 假设你有两个数组，一个长一个短，短的元素均不相同。找到长数组中包含短数组所有的元素的最短子数组，其出现顺序无关紧要。
返回最短子数组的左端点和右端点，如有多个满足条件的子数组，返回左端点最小的一个。若不存在，返回空数组。
示例 1:
输入: big = [7,5,9,0,2,1,3,5,7,9,1,1,5,8,8,9,7] small = [1,5,9] 输出: [7,10] 示例 2:
输入: big = [1,2,3] small = [4] 输出: [] 提示：
big.length&amp;nbsp;&amp;lt;= 100000 1 &amp;lt;= small.length&amp;nbsp;&amp;lt;= 100000 func shortestSeq(big []int, small []int) []int { } LeetCode题库地址 https://leetcode.cn/problems/shortest-supersequence-lcci</description></item><item><title>面试题 17.19 消失的两个数字</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/missing-two-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/missing-two-lcci/</guid><description>面试题 17.19 消失的两个数字 给定一个数组，包含从 1 到 N 所有的整数，但其中缺了两个数字。你能在 O(N) 时间内只用 O(1) 的空间找到它们吗？
以任意顺序返回这两个数字均可。
示例 1:
输入: [1] 输出: [2,3] 示例 2:
输入: [2,3] 输出: [1,4] 提示：
nums.length &amp;lt;=&amp;nbsp;30000 func missingTwo(nums []int) []int { } LeetCode题库地址 https://leetcode.cn/problems/missing-two-lcci</description></item><item><title>面试题 17.20 连续中值</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/continuous-median-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/continuous-median-lcci/</guid><description>面试题 17.20 连续中值 随机产生数字并传递给一个方法。你能否完成这个方法，在每次产生新值时，寻找当前所有值的中间值（中位数）并保存。
中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。
例如，
[2,3,4]&amp;nbsp;的中位数是 3
[2,3] 的中位数是 (2 + 3) / 2 = 2.5
设计一个支持以下两种操作的数据结构：
void addNum(int num) - 从数据流中添加一个整数到数据结构中。 double findMedian() - 返回目前所有元素的中位数。 示例：
addNum(1) addNum(2) findMedian() -&amp;gt; 1.5 addNum(3) findMedian() -&amp;gt; 2 type MedianFinder struct { } /** initialize your data structure here. */ func Constructor() MedianFinder { } func (this *MedianFinder) AddNum(num int) { } func (this *MedianFinder) FindMedian() float64 { } /** * Your MedianFinder object will be instantiated and called as such: * obj := Constructor(); * obj.</description></item><item><title>面试题 17.21 直方图的水量</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/volume-of-histogram-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/volume-of-histogram-lcci/</guid><description>面试题 17.21 直方图的水量 给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。
上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的直方图，在这种情况下，可以接 6 个单位的水（蓝色部分表示水）。&amp;nbsp;感谢 Marcos 贡献此图。
示例:
输入: [0,1,0,2,1,0,1,3,2,1,2,1] 输出: 6 func trap(height []int) int { } LeetCode题库地址 https://leetcode.cn/problems/volume-of-histogram-lcci</description></item><item><title>面试题 17.22 单词转换</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/word-transformer-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/word-transformer-lcci/</guid><description>面试题 17.22 单词转换 给定字典中的两个词，长度相等。写一个方法，把一个词转换成另一个词， 但是一次只能改变一个字符。每一步得到的新词都必须能在字典中找到。
编写一个程序，返回一个可能的转换序列。如有多个可能的转换序列，你可以返回任何一个。
示例 1:
输入: beginWord = &amp;quot;hit&amp;quot;, endWord = &amp;quot;cog&amp;quot;, wordList = [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;,&amp;quot;cog&amp;quot;] 输出: [&amp;quot;hit&amp;quot;,&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;,&amp;quot;cog&amp;quot;] 示例 2:
输入: beginWord = &amp;quot;hit&amp;quot; endWord = &amp;quot;cog&amp;quot; wordList = [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;] 输出: [] 解释:&amp;nbsp;endWord &amp;quot;cog&amp;quot; 不在字典中，所以不存在符合要求的转换序列。 func findLadders(beginWord string, endWord string, wordList []string) []string { } LeetCode题库地址 https://leetcode.cn/problems/word-transformer-lcci</description></item><item><title>面试题 17.23 最大黑方阵</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/max-black-square-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/max-black-square-lcci/</guid><description>面试题 17.23 最大黑方阵 给定一个方阵，其中每个单元(像素)非黑即白。设计一个算法，找出 4 条边皆为黑色像素的最大子方阵。
返回一个数组 [r, c, size] ，其中&amp;nbsp;r,&amp;nbsp;c&amp;nbsp;分别代表子方阵左上角的行号和列号，size 是子方阵的边长。若有多个满足条件的子方阵，返回 r 最小的，若 r 相同，返回 c 最小的子方阵。若无满足条件的子方阵，返回空数组。
示例 1:
输入: [ &amp;nbsp; [1,0,1], &amp;nbsp; [0,0,1], &amp;nbsp; [0,0,1] ] 输出: [1,0,2] 解释: 输入中 0 代表黑色，1 代表白色，标粗的元素即为满足条件的最大子方阵 示例 2:
输入: [ &amp;nbsp; [0,1,1], &amp;nbsp; [1,0,1], &amp;nbsp; [1,1,0] ] 输出: [0,0,1] 提示：
matrix.length == matrix[0].length &amp;lt;= 200 func findSquare(matrix [][]int) []int { } LeetCode题库地址 https://leetcode.cn/problems/max-black-square-lcci</description></item><item><title>面试题 17.24 最大子矩阵</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/max-submatrix-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/max-submatrix-lcci/</guid><description>面试题 17.24 最大子矩阵 给定一个正整数、负整数和 0 组成的 N &amp;times; M&amp;nbsp;矩阵，编写代码找出元素总和最大的子矩阵。
返回一个数组 [r1, c1, r2, c2]，其中 r1, c1 分别代表子矩阵左上角的行号和列号，r2, c2 分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。
注意：本题相对书上原题稍作改动
示例：
输入： [ &amp;nbsp; [-1,0], &amp;nbsp; [0,-1] ] 输出：[0,1,0,1] 解释：输入中标粗的元素即为输出所表示的矩阵 &amp;nbsp;
说明：
1 &amp;lt;= matrix.length, matrix[0].length &amp;lt;= 200 func getMaxMatrix(matrix [][]int) []int { } LeetCode题库地址 https://leetcode.cn/problems/max-submatrix-lcci</description></item><item><title>面试题 17.25 单词矩阵</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/word-rectangle-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/word-rectangle-lcci/</guid><description>面试题 17.25 单词矩阵 给定一份单词的清单，设计一个算法，创建由字母组成的面积最大的矩形，其中每一行组成一个单词(自左向右)，每一列也组成一个单词(自上而下)。不要求这些单词在清单里连续出现，但要求所有行等长，所有列等高。
如果有多个面积最大的矩形，输出任意一个均可。一个单词可以重复使用。
示例 1:
输入: [&amp;quot;this&amp;quot;, &amp;quot;real&amp;quot;, &amp;quot;hard&amp;quot;, &amp;quot;trh&amp;quot;, &amp;quot;hea&amp;quot;, &amp;quot;iar&amp;quot;, &amp;quot;sld&amp;quot;] 输出: [ &amp;nbsp; &amp;quot;this&amp;quot;, &amp;nbsp; &amp;quot;real&amp;quot;, &amp;nbsp; &amp;quot;hard&amp;quot; ] 示例 2:
输入: [&amp;quot;aa&amp;quot;] 输出: [&amp;quot;aa&amp;quot;,&amp;quot;aa&amp;quot;] 说明：
words.length &amp;lt;= 1000 words[i].length &amp;lt;= 100 数据保证单词足够随机 func maxRectangle(words []string) []string { } LeetCode题库地址 https://leetcode.cn/problems/word-rectangle-lcci</description></item><item><title>面试题 17.26 稀疏相似度</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sparse-similarity-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sparse-similarity-lcci/</guid><description>面试题 17.26 稀疏相似度 两个(具有不同单词的)文档的交集(intersection)中元素的个数除以并集(union)中元素的个数，就是这两个文档的相似度。例如，{1, 5, 3} 和 {1, 7, 2, 3} 的相似度是 0.4，其中，交集的元素有 2 个，并集的元素有 5 个。给定一系列的长篇文档，每个文档元素各不相同，并与一个 ID 相关联。它们的相似度非常&amp;ldquo;稀疏&amp;rdquo;，也就是说任选 2 个文档，相似度都很接近 0。请设计一个算法返回每对文档的 ID 及其相似度。只需输出相似度大于 0 的组合。请忽略空文档。为简单起见，可以假定每个文档由一个含有不同整数的数组表示。
输入为一个二维数组 docs，docs[i]&amp;nbsp;表示&amp;nbsp;id 为 i 的文档。返回一个数组，其中每个元素是一个字符串，代表每对相似度大于 0 的文档，其格式为 {id1},{id2}: {similarity}，其中 id1 为两个文档中较小的 id，similarity 为相似度，精确到小数点后 4 位。以任意顺序返回数组均可。
示例:
输入: [ &amp;nbsp; [14, 15, 100, 9, 3], &amp;nbsp; [32, 1, 9, 3, 5], &amp;nbsp; [15, 29, 2, 6, 8, 7], &amp;nbsp; [7, 10] ] 输出: [ &amp;nbsp; &amp;quot;0,1: 0.2500&amp;quot;, &amp;nbsp; &amp;quot;0,2: 0.1000&amp;quot;, &amp;nbsp; &amp;quot;2,3: 0.</description></item></channel></rss>