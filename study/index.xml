<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Studies on lbbniu</title>
    <link>https://blog.lbbniu.com/study/</link>
    <description>Recent content in Studies on lbbniu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>lbbniu@gmail.com (lbbniu)</managingEditor>
    <webMaster>lbbniu@gmail.com (lbbniu)</webMaster>
    <copyright>(c) 2021 lbbniu.</copyright>
    <lastBuildDate>Sat, 20 Nov 2021 17:18:16 +0800</lastBuildDate><atom:link href="https://blog.lbbniu.com/study/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LeetCode</title>
      <link>https://blog.lbbniu.com/study/leetcode/leetcode/</link>
      <pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate>
      <author>lbbniu@gmail.com (lbbniu)</author>
      <guid>https://blog.lbbniu.com/study/leetcode/leetcode/</guid>
      <description>数组和链表 206. 反转链表 24. 两两交换链表中的节点 141. 环形链表 142. 环形链表 II 24. 两两交换链表中的节点  21. 合并两个有序链表 25.K 个一组翻转链表 86.分隔链表 92.反转链表 II /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* reverseBetween(ListNode* head, int m, int n) { int change_len = n - m + 1; ListNode *pre_head = NULL; ListNode *result = head; while (head &amp;amp;&amp;amp; --m) { pre_head = head; head = head-&amp;gt;next; } ListNode *modify_list_tail = head; ListNode *new_head = NULL; while (head &amp;amp;&amp;amp; change_len--) { ListNode *next = head-&amp;gt;next; head-&amp;gt;next = new_head; new_head = head; head = next; } //连接为翻转部分  modify_list_tail-&amp;gt;next = head; if (pre_head) { pre_head-&amp;gt;next = new_head; } else { result = new_head; } return result; } }; /** * Definition for a singly-linked list.</description>
    </item>
    
    <item>
      <title>LeetCode每日一题</title>
      <link>https://blog.lbbniu.com/study/leetcode/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</link>
      <pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate>
      <author>lbbniu@gmail.com (lbbniu)</author>
      <guid>https://blog.lbbniu.com/study/leetcode/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</guid>
      <description>03-26 999. 车的可用捕获量 class Solution { /** * @param String[][] $board * @return Integer */ function numRookCaptures($board) { $cnt = $st = $ed = 0; //查找车  for ($i =0 ; $i &amp;lt; 8; $i++) { for ($j = 0; $j &amp;lt; 8; $j++) { if ($board[$i][$j] == &amp;#39;R&amp;#39;) { $st = $i; $ed = $j; break; } } } //遍历扩散  $dx = [-1, 1, 0, 0]; $dy = [0, 0, -1, 1]; for ($i = 0; $i &amp;lt; 4; $i++) { for ($step = 0;; $step++){ $x = $st + $dx[$i] * $step; $y = $ed + $dy[$i] * $step; //遇到边界或者白色的象  if ($x &amp;lt; 0 || $x &amp;gt;= 8 || $y &amp;lt; 0 || $y &amp;gt;= 8 || $board[$x][$y] ==&amp;#39;B&amp;#39;) break; if ($board[$x][$y] == &amp;#39;p&amp;#39;) { $borad[$x][$y] = &amp;#39;.</description>
    </item>
    
    <item>
      <title>第八课动态规划</title>
      <link>https://blog.lbbniu.com/study/batj%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/8.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate>
      <author>lbbniu@gmail.com (lbbniu)</author>
      <guid>https://blog.lbbniu.com/study/batj%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/8.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <description>70. 爬楼梯 class Solution { public: int climbStairs(int n) { std::vector&amp;lt;int&amp;gt; dp(n + 3, 0); dp[1] = 1; dp[2] = 1; for (int i = 3; i &amp;lt;= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; } }; 198. 打家劫舍 class Solution { public: int rob(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.size() == 0) { return 0; } if (nums.size() == 1) { return nums[0]; } //设第一个房间的最优解dp[i]  std::vector&amp;lt;int&amp;gt; dp(nums.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/go/%E7%AC%AC10%E5%91%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>lbbniu@gmail.com (lbbniu)</author>
      <guid>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/go/%E7%AC%AC10%E5%91%A8/</guid>
      <description>期末串讲 参考连接 Big O Cheat Sheet 算法训练营第 4 期学员谭帅的脑图作业（提取码：ykyn） Steve Jobs 演讲 期末考试 👉考试形式：考试平台为 LeetCode。 共 10 道单选题（每题 3 分）、2 道多选题（每题 5 分）、2 道编程题（每题 20 分）和 4 道附加选择题（每题 5 分），考试时长 3 小时。3 小时内可多次修改和提交，最终全部完成后点击“结束考试”即可。
注意：为保证评测体验，需要使用 Chrome 浏览器 注意：考试前不要尝试进入系统，进入系统即开始计时，3 小时为不间断计时，关闭网页不会暂停，仍在继续计时 注意：每道选择题务必点击提交再进行下一题
👉考试系统须知： https://shimo.im/docs/786914580242497f
👉登陆账号密码：均为你极客时间登陆时的手机帐号，如无法登陆，请联系班主任确认。
👉考试日期：截止至 2020 年 5 月 24 日 23:59
👉考试链接： https://e.leetcode-cn.com/assessment/geekbang-0019
本周是大家学习的最后一周，训练营学习服务团队希望能得到大家的建议和反馈，动动你的小手，填一下问卷吧！👉 https://jinshuju.net/f/ER0LhF
另外，如果你想换工作，不知道怎么写简历，可以看下这篇文章。
毕业刷题路线 首先，恭喜各位同学从极客大学算法训练营毕业，相信 70 天的刻意练习给你带来了不少改变。但是毕业后的练习还不能停止，除了课上老师讲授的题目和布置的作业，这里还有一份“左耳朵耗子”陈皓老师和超哥分享的毕业刷题路线，助你在训练营结束后持续练习。
基础 两数之和（简单） 有效的括号（简单） 字符串解码（中等） LRU 缓存机制（困难） 实现 Trie（前缀树）（中等） 添加与搜索单词 - 数据结构设计（中等） 单词搜索 II （困难） 找不同（简单） 单词规律（简单） 字符串中的第一个唯一字符（简单） 无重复字符的最长子串（中等） 最小覆盖子串（困难） 合并两个有序链表（简单） 环形链表（简单） 环形链表 II （中等） 反转链表（简单） 反转链表 II （中等） 旋转链表（中等） 排序链表 链表中倒数第 k 个节点 两两交换链表中的节点（中等） 按奇偶排序数组（简单） 按奇偶排序数组 II （简单） 有序数组的平方（简单） 山脉数组的峰顶索引（简单） 搜索旋转排序数组（困难） 搜索旋转排序数组 II （中等） 寻找旋转排序数组中的最小值（中等） 寻找旋转排序数组中的最小值 II （困难） 搜索二维矩阵（中等） 等式方程的可满足性（中等） 朋友圈（中等） 账户合并（中等） 深度优先搜索 二叉树的最大深度（简单） 路径总和（简单） 路径总和 II （中等） 被围绕的区域（中等） 岛屿数量（中等） 岛屿的最大面积（中等） 在二叉树中分配硬币（中等） 回溯 括号生成（中等） N 皇后（困难） N 皇后 II （困难） 解数独 （中等） 不同路径 III （困难） 单词搜索（中等） 分治 搜索二维矩阵 II （中等） 合并 K 个排序链表（中等） 为运算表达式设计优先级（中等） 给表达式添加运算符（困难） 数组中的第 K 个最大元素（中等） 最接近原点的 K 个点（中等） 鸡蛋掉落（困难） 动态规划 使用最小花费爬楼梯（简单） 爬楼梯（简单） 不同路径（简单） 最小路径和 （中等） 最大子序和 （简单） 乘积最大子数组（中等） 买卖股票的最佳时机（简单） 买卖股票的最佳时机 II （简单） 买卖股票的最佳时机 III （困难） 买卖股票的最佳时机 IV （困难） 最佳买卖股票时机含冷冻期（中等） 买卖股票的最佳时机含手续费（中等） 零钱兑换 （中等） 零钱兑换 II （中等） 编辑距离（困难） 不同的子序列（困难） 柱状图中最大的矩形（困难） 最大矩形（困难） 最大正方形（中等） 最低票价（中等） 区域和检索 - 数组不可变（简单） 二维区域和检索 - 矩阵不可变（中等） 最长上升子序列 （中等） 鸡蛋掉落（困难） </description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/go/%E7%AC%AC1%E5%91%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>lbbniu@gmail.com (lbbniu)</author>
      <guid>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/go/%E7%AC%AC1%E5%91%A8/</guid>
      <description>第三课|数组、链表、跳表 1. 数组、链表、跳表的基本实现和特性 参考链接 Java 源码分析（ArrayList） Linked List 的标准实现代码 [Linked List 示例代码](http://www.cs.cmu.edu/~adamchik/15-121/lectures/Linked Lists/code/LinkedList.java) Java 源码分析（LinkedList） LRU Cache - Linked list：LRU 缓存机制 Redis - Skip List：跳跃表、为啥 Redis 使用跳表（Skip List）而不是使用 Red-Black？ 2. 实战题目解析：移动零 3. 实战题目解析：盛水最多的容器、爬楼梯 Array 实战题目 11. 盛最多水的容器 283. 移动零 70. 爬楼梯 15. 三数之和(高频老题） 4. 实战题目解析：3数之和、环形链表 两数之和题目：https://leetcode-cn.com/problems/two-sum/
Linked List 实战题目 206. 反转链表  使用递归函数，一直递归到链表的最后一个结点，该结点就是反转后的头结点，记作 ret . 此后，每次函数在返回的过程中，让当前结点的下一个结点的 next 指针指向当前节点。 同时让当前结点的 next 指针指向 NULL ，从而实现从链表尾部开始的局部反转 当递归函数全部出栈后，链表反转完成。  24. 两两交换链表中的节点 141. 环形链表 142. 环形链表 II 25.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/go/%E7%AC%AC6%E5%91%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>lbbniu@gmail.com (lbbniu)</author>
      <guid>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/go/%E7%AC%AC6%E5%91%A8/</guid>
      <description>第12课 动态规划 1.动态规划的实现与关键点 参考连接 递归代码模板 # go 代码模板 func recursion(level int, param1, param2, ...) { # recursion terminator if level &amp;gt; MAX_LEVEL { process_result return } # process logic in current level process(level, data...) # drill down recursion(level + 1, p1, ...) # reverse the current level status if needed } 分治代码模板 func divide_conquer(problem, param1, param2, ...) { # recursion terminator if problem == nil { print_result return } # prepare data data = prepare_data(problem) subproblems = split_problem(problem, data) # conquer subproblems subresult1 = divide_conquer(subproblems[0], p1, .</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/go/%E7%AC%AC9%E5%91%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>lbbniu@gmail.com (lbbniu)</author>
      <guid>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/go/%E7%AC%AC9%E5%91%A8/</guid>
      <description>第19课 | 高级动态规划 1. 动态规划、状态转移方程串讲 参考链接 70.爬楼梯 62.不同路径 63. 不同路径 II 一维dp写法
198.打家劫舍 64.最小路径和 121.股票买卖 课后作业 在第 9 周学习总结中，写出63. 不同路径 II这道题目的状态转移方程。
2. 高级动态规划题目详解 参考链接 70.爬楼梯 746.使用最小花费爬楼梯 72.编辑距离 课后作业 300. 最长上升子序列 91. 解码方法 32. 最长有效括号 85. 最大矩形 115. 不同的子序列 818. 赛车 第20课 | 字符串算法 1. 字符串基础知识和引申题目 参考链接 不可变字符串 Atoi 代码示例 字符串基础问题 709. 转换成小写字母 58. 最后一个单词的长度 771. 宝石与石头 387. 字符串中的第一个唯一字符 8. 字符串转换整数 (atoi) 字符串操作问题 14. 最长公共前缀 344. 反转字符串 541. 反转字符串 II 151. 翻转字符串里的单词 557.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/go/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>lbbniu@gmail.com (lbbniu)</author>
      <guid>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/go/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/</guid>
      <description>云账户 https://docs.qq.com/doc/DTWlXakVOR3lnTU1N
/** 给定一个包括 &amp;#39;(&amp;#39;，&amp;#39;)&amp;#39;，&amp;#39;{&amp;#39;，&amp;#39;}&amp;#39;，&amp;#39;[&amp;#39;，&amp;#39;]&amp;#39; 和&amp;#39;*&amp;#39;干扰字符的字符串，判断字符串是否有效。 例： {**[*()*(**)**]**} 输出true {**[**)**(**]**} 输出false */ 快手 260. 只出现一次的数字 III 腾讯 168. Excel表列名称 72. 编辑距离  字节 package main import &amp;#34;fmt&amp;#34; func calc(x, y int) int { fmt.Println(x, y, x+y) return x + y } func main() { a := 1 b := 2 defer calc(a, calc(a, b)) a = 0 defer calc(a, calc(a, b)) } 200. 岛屿数量 128. 最长连续序列 蓝湖 n 个数有序数组合并 探探 139.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/php/00%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E9%A2%84%E4%B9%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>lbbniu@gmail.com (lbbniu)</author>
      <guid>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/php/00%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E9%A2%84%E4%B9%A0/</guid>
      <description>预习 第一课 预习 第二课 预习知识点  数组：为什么很多编程语言中数组都从 0 开始编号？ 链表：如何实现 LRU 缓存淘汰算法? 链表：如何轻松写出正确的链表代码？ 跳表：为什么 Redis 一定要用跳表来实现有序集合？  预习题目  移动零 盛最多水的容器 爬楼梯 三数之和 环形链表  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/php/01%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%80%E5%91%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>lbbniu@gmail.com (lbbniu)</author>
      <guid>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/php/01%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%80%E5%91%A8/</guid>
      <description>第一周 第三课|数组、链表、跳表 参考链接  Java 源码分析（ArrayList） Linked List 的标准实现代码 [Linked List 示例代码](http://www.cs.cmu.edu/~adamchik/15-121/lectures/Linked Lists/code/LinkedList.java) Java 源码分析（LinkedList） LRU Cache - Linked list：LRU 缓存机制 Redis - Skip List：跳跃表、为啥 Redis 使用跳表（Skip List）而不是使用 Red-Black？  Array 实战题目 11. 盛最多水的容器 //方法一： 暴力求解 双循环 class Solution { /** * @param Integer[] $height * @return Integer */ function maxArea($height) { $max = 0; $len = count($height); for ($i = 0; $i &amp;lt; $len - 1; $i++) { for ($j = $i + 1; $j &amp;lt; $len; $j++) { $area = ($j - $i) * min($height[$i], $height[$j]); $max = $area &amp;lt; $max ?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/php/02%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%BA%8C%E5%91%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>lbbniu@gmail.com (lbbniu)</author>
      <guid>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/php/02%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%BA%8C%E5%91%A8/</guid>
      <description>第2周 第4课 | 栈、队列、优先队列、双端队列 参考链接  Java 的 PriorityQueue 文档 Java 的 Stack 源码 Java 的 Queue 源码 Python 的 heapq 高性能的 container 库  预习题目 20. 有效的括号 class Solution { /** * 方法一：栈(spl标准库) * @param String $s * @return Boolean */ function isValid($s) { //构造哈希表 	$map = [&amp;#39;)&amp;#39;=&amp;gt;&amp;#39;(&amp;#39;, &amp;#39;]&amp;#39;=&amp;gt;&amp;#39;[&amp;#39;, &amp;#39;}&amp;#39;=&amp;gt;&amp;#39;{&amp;#39;]; $stack = new SplStack(); for ($i = 0, $len = strlen($s); $i &amp;lt; $len; $i++) { if (!isset($map[$s[$i]])) { $stack-&amp;gt;push($s[$i]); } else if (!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/php/03%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%89%E5%91%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>lbbniu@gmail.com (lbbniu)</author>
      <guid>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/php/03%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%89%E5%91%A8/</guid>
      <description>第3周 第6课 | 树、二叉树、二叉搜索树 1. 树、二叉树、二叉搜索树的实现和特性 参考链接  二叉搜索树 Demo  思考题 树的面试题解法一般都是递归，为什么？ 说明：同学们可以将自己的思考写在课程下方的留言区一起讨论，也可以写在第 2 周的学习总结中。
2. 实战题目解析：二叉树的中序遍历 参考链接  树的遍历 Demo  实战题目 / 课后作业 94. 二叉树的中序遍历 /** * Definition for a binary tree node. * class TreeNode { * public $val = null; * public $left = null; * public $right = null; * function __construct($value) { $this-&amp;gt;val = $value; } * } */ class Solution { private $values = []; /** * 方法一：递归 * @param TreeNode $root * @return Integer[] */ function inorderTraversal1($root) { $this-&amp;gt;inorder($root); return $this-&amp;gt;values; } function inorder($root) { if ($root) { $this-&amp;gt;inorder($root-&amp;gt;left); $this-&amp;gt;values[] = $root-&amp;gt;val; $this-&amp;gt;inorder($root-&amp;gt;right); } } /** * 方法二：迭代 * @param TreeNode $root * @return Integer[] */ function inorderTraversal2($root) { $stack = $res = []; while ($root || $stack) { while ($root) { $stack[] = $root; $root = $root-&amp;gt;left; } $root = array_pop($stack); $res[] = $root-&amp;gt;val; $root = $root-&amp;gt;right; } return $res; } /** * 方法三：颜色标记法 * @param TreeNode $root * @return Integer[] */ function inorderTraversal3($root) { $white = 0; $gray = 1; $stack = [[$white, $root]]; $res = []; while ($stack) { [$color, $node ] = array_pop($stack); if (!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/php/04%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%9B%9B%E5%91%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>lbbniu@gmail.com (lbbniu)</author>
      <guid>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/php/04%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%9B%9B%E5%91%A8/</guid>
      <description>第4周 第9课 | 深度优先搜索和广度优先搜索 1. 深度优先搜索、广度优先搜索的实现和特性 参考链接 DFS 代码模板（递归写法、非递归写法） 递归写法
visited = set() def dfs(node, visited): if node in visited: # terminator # already visited  return visited.add(node) # process current node here.  ... for next_node in node.children(): if next_node not in visited: dfs(next_node, visited) 非递归写法
def DFS(self, tree): if tree.root is None: return [] visited, stack = [], [tree.root] while stack: node = stack.pop() visited.add(node) process (node) nodes = generate_related_nodes(node) stack.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/php/04%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%9B%9B%E5%91%A8%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>lbbniu@gmail.com (lbbniu)</author>
      <guid>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/php/04%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%9B%9B%E5%91%A8%E6%80%BB%E7%BB%93/</guid>
      <description>DFS 代码模板（递归写法、非递归写法） 递归写法
visited = set() def dfs(node, visited): if node in visited: # terminator # already visited  return visited.add(node) # process current node here.  ... for next_node in node.children(): if next_node not in visited: dfs(next_node, visited) 非递归写法
def DFS(self, tree): if tree.root is None: return [] visited, stack = [], [tree.root] while stack: node = stack.pop() visited.add(node) process (node) nodes = generate_related_nodes(node) stack.push(nodes) # other processing work  .</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/php/06%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%85%AD%E5%91%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>lbbniu@gmail.com (lbbniu)</author>
      <guid>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/php/06%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%85%AD%E5%91%A8/</guid>
      <description>第12课 | 动态规划 1. 动态规划的实现及关键点 参考链接   递归代码模板
# Python 代码模板 def recursion(level, param1, param2, ...): # recursion terminator  if level &amp;gt; MAX_LEVEL: process_result return # process logic in current level  process(level, data...) # drill down  self.recursion(level + 1, p1, ...) # reverse the current level status if needed //Java 代码模板 public void recur(int level, int param) { // terminator  if (level &amp;gt; MAX_LEVEL) { // process result  return; // process current logic  process(level, param); // drill down  recur( level: level + 1, newParam); // restore current status }   分治代码模板</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/php/07%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%83%E5%91%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>lbbniu@gmail.com (lbbniu)</author>
      <guid>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/php/07%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%83%E5%91%A8/</guid>
      <description>第7周 第13课 | 字典树和并查集 1. Trie树的基本实现和特性 参考链接 102. 二叉树的层序遍历 /** * Definition for a binary tree node. * class TreeNode { * public $val = null; * public $left = null; * public $right = null; * function __construct($value) { $this-&amp;gt;val = $value; } * } */ class Solution { /** * bfs * @param TreeNode $root * @return Integer[][] */ function levelOrder($root) { if (!$root) return []; $queue = [$root]; $res = []; while ($queue) { $count = count($queue); $row = []; while ($count--) { $node = array_shift($queue); $row[] = $node-&amp;gt;val; $node-&amp;gt;left &amp;amp;&amp;amp; $queue[] = $node-&amp;gt;left; $node-&amp;gt;right &amp;amp;&amp;amp; $queue[] = $node-&amp;gt;right; } $res[] = $row; } return $res; } //  function levelOrder($root) { if (!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/php/08%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%85%AB%E5%91%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>lbbniu@gmail.com (lbbniu)</author>
      <guid>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/php/08%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%85%AB%E5%91%A8/</guid>
      <description>第8周 第16课 | 位运算 1. 位运算基础及实战要点 参考链接 如何从十进制转换为二进制 2. 位运算实战题目解析 参考链接 N 皇后位运算代码示例 def totalNQueens(self, n): if n &amp;lt; 1: return [] self.count = 0 self.DFS(n, 0, 0, 0, 0) return self.count def DFS(self, n, row, cols, pie, na): # recursion terminator  if row &amp;gt;= n: self.count += 1 return bits = (~(cols | pie | na)) &amp;amp; ((1 &amp;lt;&amp;lt; n) — 1) # 得到当前所有的空位 while bits: p = bits &amp;amp; —bits # 取到最低位的1 bits = bits &amp;amp; (bits — 1) # 表示在p位置上放入皇后 self.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/php/09%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B9%9D%E5%91%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>lbbniu@gmail.com (lbbniu)</author>
      <guid>https://blog.lbbniu.com/study/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/php/09%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B9%9D%E5%91%A8/</guid>
      <description>第9周 第19课 | 高级动态规划 1. 动态规划、状态转移方程串讲 参考链接 70.爬楼梯 class Solution { /** * 动态规划解法 * Binets 方法 和 斐波那契公式 时间复杂度为O(log(N)) * @param Integer $n * @return Integer */ function climbStairs($n) { if ($n &amp;lt;= 2) return $n; $first = 1; $second = 2; for ($i = 3; $i &amp;lt;= $n; $i++) { $tmp = $first + $second; $first = $second; $second = $tmp; } return $second; } } //斐波那契公式 public class Solution { public int climbStairs(int n) { double sqrt5=Math.</description>
    </item>
    
  </channel>
</rss>
