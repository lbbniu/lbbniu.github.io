<!doctype html><html lang=zh dir=ltr><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>第二周 哈希表、集合、映射、前缀和、差分、双指针扫描 | 极客时间算法训练营2021版 | lbbniu</title>
<meta name=generator content="Hugo Eureka 0.9.3"><link rel=stylesheet href=/css/eureka.min.9cec6350e37e534b0338fa9a085bf06855de3b0f2dcf857e792e5e97b07ea905d4d5513db554cbc26a9c3da622bae92d.css><script defer src=/js/eureka.min.fa9a6bf6d7a50bb635b4cca7d2ba5cf3dfb095ae3798773f1328f7950028b48c17d06276594e1b5f244a25a6c969a705.js></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&amp;family=Noto+Serif+SC:wght@400;600;700&amp;display=swap" as=style onload='this.onload=null,this.rel="stylesheet"'><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/styles/github.min.css media=print onload='this.media="all",this.onload=null' crossorigin><script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/highlight.min.js crossorigin></script><script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/dart.min.js crossorigin></script><script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/php.min.js crossorigin></script><script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/java.min.js crossorigin></script><script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/go.min.js crossorigin></script><script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/python.min.js crossorigin></script><link rel=stylesheet href=/css/highlightjs.min.2958991528e43eb6fc9b8c4f2b8e052f79c4010718e1d1e888a777620e9ee63021c2c57ec7417a3108019bb8c41943e6.css media=print onload='this.media="all",this.onload=null'><script defer type=text/javascript src=/js/fontawesome.min.35973bea57658ef0dd22ad59ea4642b6c8c67af62bed8659ac326d284ef285a6657cdbcf57d3b2910e7e992f2b20426e.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ media=print onload='this.media="all",this.onload=null' crossorigin><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script><script defer src=https://cdn.jsdelivr.net/npm/mermaid@8.14.0/dist/mermaid.min.js integrity=sha384-atOyb0FxAgN9LyAc6PEf9BjgwLISyansgdH8/VXQH8p2o5vfrRgmGIJ2Sg22L0A0 crossorigin></script><link rel=icon type=image/png sizes=32x32 href=/images/icon_hu46eef4dc61dcf438cf488ad55e1d2c12_638750_32x32_fill_box_center_3.png><link rel=apple-touch-icon sizes=180x180 href=/images/icon_hu46eef4dc61dcf438cf488ad55e1d2c12_638750_180x180_fill_box_center_3.png><meta name=description content="第 3 课 哈希表、集合、映射，第 4 课 前缀和、差分、双指针扫描"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"算法学习","item":"/study/"},{"@type":"ListItem","position":2,"name":"极客时间算法训练营2021版","item":"/study/2021algorithm/"},{"@type":"ListItem","position":3,"name":"第二周 哈希表、集合、映射、前缀和、差分、双指针扫描","item":"/study/2021algorithm/week02/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"/study/2021algorithm/week02/"},"headline":"第二周 哈希表、集合、映射、前缀和、差分、双指针扫描 | 极客时间算法训练营2021版 | lbbniu","datePublished":"2021-11-25T10:30:00+08:00","dateModified":"2024-01-08T23:58:46+08:00","wordCount":2901,"publisher":{"@type":"Person","name":"lbbniu","logo":{"@type":"ImageObject","url":"/images/icon.gif"}},"description":"第 3 课 哈希表、集合、映射，第 4 课 前缀和、差分、双指针扫描"}</script><meta property="og:title" content="第二周 哈希表、集合、映射、前缀和、差分、双指针扫描 | 极客时间算法训练营2021版 | lbbniu"><meta property="og:type" content="article"><meta property="og:image" content="/images/icon.png"><meta property="og:url" content="/study/2021algorithm/week02/"><meta property="og:description" content="第 3 课 哈希表、集合、映射，第 4 课 前缀和、差分、双指针扫描"><meta property="og:locale" content="zh"><meta property="og:site_name" content="lbbniu"><meta property="article:published_time" content="2021-11-25T10:30:00+08:00"><meta property="article:modified_time" content="2024-01-08T23:58:46+08:00"><meta property="article:section" content="study"><body class="flex min-h-screen flex-col"><header class="min-h-16 pl-scrollbar bg-secondary-bg fixed z-50 flex w-full items-center shadow-sm"><div class="mx-auto w-full max-w-screen-xl"><script>let storageColorScheme=localStorage.getItem("lightDarkMode");((storageColorScheme=="Auto"||storageColorScheme==null)&&window.matchMedia("(prefers-color-scheme: dark)").matches||storageColorScheme=="Dark")&&document.getElementsByTagName("html")[0].classList.add("dark")</script><nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0"><a href=/ class="me-6 text-primary-text text-xl font-bold">lbbniu</a>
<button id=navbar-btn class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
<i class="fas fa-bars"></i></button><div id=target class="hidden block md:flex md:grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20"><div class="md:flex md:h-16 text-sm md:grow pb-4 md:pb-0 border-b md:border-b-0"><a href=/post/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">文章</a>
<a href=/cloud-native/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">云原生</a>
<a href=/study/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 selected-menu-item me-4">算法学习</a>
<a href=/docs/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">Go学习训练营</a>
<a href=/tags/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">标签</a></div><div class=flex><div class="relative pt-4 md:pt-0"><div class="cursor-pointer hover:text-eureka" id=lightDarkMode><i class="fas fa-adjust"></i></div><div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id=is-open></div><div class="absolute flex flex-col start-0 md:start-auto end-auto md:end-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40" id=lightDarkOptions><span class="px-4 py-1 hover:text-eureka" name=Light>浅色</span>
<span class="px-4 py-1 hover:text-eureka" name=Dark>深色</span>
<span class="px-4 py-1 hover:text-eureka" name=Auto>自动</span></div></div></div></div><div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id=is-open-mobile></div></nav><script>let element=document.getElementById("lightDarkMode");storageColorScheme==null||storageColorScheme=="Auto"?document.addEventListener("DOMContentLoaded",()=>{window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",switchDarkMode)}):storageColorScheme=="Light"?(element.firstElementChild.classList.remove("fa-adjust"),element.firstElementChild.setAttribute("data-icon","sun"),element.firstElementChild.classList.add("fa-sun")):storageColorScheme=="Dark"&&(element.firstElementChild.classList.remove("fa-adjust"),element.firstElementChild.setAttribute("data-icon","moon"),element.firstElementChild.classList.add("fa-moon")),document.addEventListener("DOMContentLoaded",()=>{getcolorscheme(),switchBurger()})</script></div></header><main class="grow pt-16"><div class=pl-scrollbar><div class="mx-auto w-full max-w-screen-xl lg:px-4 xl:px-8"><div class=lg:pt-12><div class="flex flex-col md:flex-row bg-secondary-bg rounded"><div class="md:w-1/4 lg:w-1/5 border-e"><div class="sticky top-16 pt-6"><div id=sidebar-title class="md:hidden mx-4 px-2 pt-4 pb-2 md:border-b text-tertiary-text md:text-primary-text"><span class=font-semibold>目录</span>
<i class='fas fa-caret-right ms-1'></i></div><div id=sidebar-toc class="hidden md:block overflow-y-auto mx-6 md:mx-0 pe-6 pt-2 md:max-h-doc-sidebar bg-primary-bg md:bg-transparent"><div class="flex flex-wrap ms-4 -me-2 p-2 bg-secondary-bg md:bg-primary-bg rounded"><a class=hover:text-eureka href=/study/2021algorithm/>极客时间算法训练营2021版</a></div><ul class=ps-6><li class=py-2><div><a class=hover:text-eureka href=/study/2021algorithm/week01/>第一周 数组、链表、栈、队列</a></div></li><li class=py-2><div><a class="text-eureka hover:text-eureka" href=/study/2021algorithm/week02/>第二周 哈希表、集合、映射、前缀和、差分、双指针扫描</a></div></li><li class=py-2><div><a class=hover:text-eureka href=/study/2021algorithm/week03/>第三周 递归、分治、树与图</a></div></li><li class=py-2><div><a class=hover:text-eureka href=/study/2021algorithm/week04/>第四周 深度优先搜索、广度优先搜索、二叉堆、二叉搜索树</a></div></li><li class=py-2><div><a class=hover:text-eureka href=/study/2021algorithm/week05/>第五周 二分、排序</a></div></li><li class=py-2><div><a class=hover:text-eureka href=/study/2021algorithm/week06/>第六周 贪心、动态规划</a></div></li><li class=py-2><div><a class=hover:text-eureka href=/study/2021algorithm/week07/>第七周 动态规划</a></div></li><li class=py-2><div><a class=hover:text-eureka href=/study/2021algorithm/week08/>第八周 字典树、并查集，图论算法</a></div></li><li class=py-2><div><a class=hover:text-eureka href=/study/2021algorithm/week09/>第九周 字符串处理、高级搜索</a></div></li><li class=py-2><div><a class=hover:text-eureka href=/study/2021algorithm/week10/>第十周 平衡二叉树、跳跃表、树状数组与线段树、实战技巧、总结回顾</a></div></li><li class=py-2><div><a class=hover:text-eureka href=/study/2021algorithm/final/>毕业刷新路径</a></div></li></ul></div></div></div><div class="w-full md:w-3/4 lg:w-4/5 pb-8 pt-2 md:pt-8"><div class=flex><div class="w-full lg:w-3/4 px-6"><article class=prose><h1 class=mb-4>第二周 哈希表、集合、映射、前缀和、差分、双指针扫描</h1><div class="text-tertiary-text not-prose mt-2 flex flex-row flex-wrap items-center"><div class="me-6 my-2"><i class="fas fa-calendar me-1"></i>
<span>2021-11-25</span></div><div class="me-6 my-2"><i class="fas fa-clock me-1"></i>
<span>14分钟阅读时长</span></div></div><p>题目数：16</p><h2 id=本周作业>本周作业</h2><ul><li><a href=https://leetcode-cn.com/problems/subdomain-visit-count/ target=_blank rel=noopener>811.子域名访问计数</a></li></ul><p>（Easy）半年内出题频次：</p><table><thead><tr><th style=text-align:center>Wayfair</th><th style=text-align:center>Roblox</th></tr></thead><tbody><tr><td style=text-align:center>9</td><td style=text-align:center>2</td></tr></tbody></table><pre><code class=language-go>func subdomainVisits(cpdomains []string) (ans []string) {
    h := map[string]int{}
    for _, cpdomain := range cpdomains {
        cp := strings.Split(cpdomain, &quot; &quot;)
        count, _ := strconv.Atoi(cp[0])
        domains := strings.Split(cp[1], &quot;.&quot;)
        cur := &quot;&quot;
        for i := len(domains) - 1; i &gt;= 0; i-- {
            if cpdomain == &quot;&quot; {
                cur = domains[i]
            } else {
                cur = domains[i] + &quot;.&quot; + cur
            }
            h[cur] += count
        }
    }
    for domain, cnt := range h {
        ans = append(ans, fmt.Sprintf(&quot;%d %s&quot;, cnt, domain))
    }
    return ans
}
</code></pre><ul><li><a href=https://leetcode-cn.com/problems/degree-of-an-array/ target=_blank rel=noopener>697.数组的度</a></li></ul><p>（Easy）半年内出题频次：</p><table><thead><tr><th style=text-align:center>字节跳动</th><th style=text-align:center>Bloomberg</th><th style=text-align:center>英伟达</th></tr></thead><tbody><tr><td style=text-align:center>3</td><td style=text-align:center>2</td><td style=text-align:center>2</td></tr></tbody></table><pre><code class=language-go>func findShortestSubArray(nums []int) (ans int) {
    type stat struct {cnt, l, r int}
    ht := map[int]stat{}
    for i, num := range nums {
        if st, ok := ht[num]; ok {
            st.cnt++
            st.r = i
            ht[num] = st
        } else {
            ht[num] = stat{1, i, i}
        }
    }
    maxCnt := 0
    for _, st := range ht {
        if st.cnt &gt; maxCnt {
            maxCnt, ans = st.cnt, st.r - st.l + 1
        } else if st.cnt == maxCnt {
            if st.r - st.l + 1 &lt; ans {
                ans = st.r - st.l + 1 
            }
        }
    }
    return ans
}
</code></pre><ul><li><a href=https://leetcode-cn.com/problems/subarray-sum-equals-k/ target=_blank rel=noopener>560.和为 K 的子数组</a></li></ul><p>（Medium）半年内出题频次：</p><table><thead><tr><th style=text-align:center>Facebook</th><th style=text-align:center>字节跳动</th><th style=text-align:center>微软</th><th style=text-align:center>Amazon</th><th style=text-align:center>Bloomberg</th><th style=text-align:center>Google</th><th style=text-align:center>Apple</th><th style=text-align:center>Tesla</th><th style=text-align:center>LinkedIn</th></tr></thead><tbody><tr><td style=text-align:center>76</td><td style=text-align:center>10</td><td style=text-align:center>15</td><td style=text-align:center>11</td><td style=text-align:center>2</td><td style=text-align:center>6</td><td style=text-align:center>3</td><td style=text-align:center>2</td><td style=text-align:center>2</td></tr></tbody></table><pre><code class=language-go>// 方法一：模拟
func subarraySum(nums []int, k int) int {
    cnt := 0
    for start := 0; start &lt; len(nums); start++ {
        sum := 0
        for end := start; end &gt;= 0; end-- {
            sum += nums[end]
            if sum == k {
                cnt++
            }
        }
    }
    return cnt
}

// 方法二：前缀和
func subarraySum(nums []int, k int) int {
    n, cnt := len(nums), 0
    preSum := make([]int, n + 1)
    for i := 1; i &lt;= n; i++ {
        preSum[i] = preSum[i-1] + nums[i-1]
    }
    for left := 1; left &lt;= n; left++ {
        for right := left; right &lt;= n; right++ {
            if preSum[right] - preSum[left-1] == k {
                cnt++
            }   
        }
    }
    return cnt
}

// 方法三：前缀和 + 哈希表
func subarraySum(nums []int, k int) (cnt int) {
    pre := 0
    m := map[int]int{}
    m[0] = 1
    for _, num := range nums {
        pre += num
        if c, ok := m[pre-k]; ok {
            cnt += c
        }
        m[pre]++
    }
	return cnt
}
</code></pre><ul><li><a href=https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/ target=_blank rel=noopener>1074.元素和为目标值的子矩阵数量</a></li></ul><p>（Hard）半年内出题频次：</p><table><thead><tr><th style=text-align:center>Facebook</th><th style=text-align:center>Google</th></tr></thead><tbody><tr><td style=text-align:center>3</td><td style=text-align:center>2</td></tr></tbody></table><pre><code class=language-go>// 写法一：
func numSubmatrixSumTarget(matrix [][]int, target int) (ans int) {
    for i := range matrix { // 枚举上边界
        sum := make([]int, len(matrix[i]))
        for _, row := range matrix[i:] { // 枚举下边界
            for c, v := range row {
                sum[c] += v // 更新每列的元素和
            }
            ans += subarraySum(sum, target)
        }
    }
    return ans
}

func subarraySum(nums []int, k int) (ans int) {
    h := map[int]int{0: 1}
    for pre, i, n := 0, 0, len(nums); i &lt; n; i++ {
        pre += nums[i]
        if cnt, ok := h[pre - k]; ok {
            ans += cnt
        }
        h[pre]++
    }
    return ans
}


// 写法二：
func numSubmatrixSumTarget(matrix [][]int, target int) int {
    m, n, ans := len(matrix), len(matrix[0]), 0
    for i := 0; i &lt; m; i++ {
        sum := make([]int, n)
        for j := i; j &lt; m; j++ {
            for c := 0; c &lt; n; c++ {
                sum[c] += matrix[j][c]
            }
            ans += subarraySum(sum, target)
        }
    }
    return ans
}

func subarraySum(sum []int, k int) (ans int) {
    h := map[int]int{0: 1}
    pre := 0
    for _, num := range sum {
        pre += num
        if cnt, ok := h[pre - k]; ok {
            ans += cnt
        }
        h[pre]++
    }
    return ans
}
</code></pre><h2 id=实战例题>实战例题</h2><blockquote><p>以下为课上实战例题</p></blockquote><h3 id=第-3-课-哈希表集合映射>第 3 课 哈希表、集合、映射</h3><h4 id=无序集合映射>无序集合、映射</h4><ul><li><a href=https://leetcode-cn.com/problems/two-sum/description/ target=_blank rel=noopener>1.两数之和</a></li></ul><p>（Easy）半年内出题频次：</p><table><thead><tr><th style=text-align:center>Facebook</th><th style=text-align:center>字节跳动</th><th style=text-align:center>微软</th><th style=text-align:center>Amazon</th><th style=text-align:center>Google</th><th style=text-align:center>Apple</th><th style=text-align:center>阿里巴巴</th><th style=text-align:center>Bloomberg</th><th style=text-align:center>腾讯</th><th style=text-align:center>Cisco</th></tr></thead><tbody><tr><td style=text-align:center>33</td><td style=text-align:center>91</td><td style=text-align:center>40</td><td style=text-align:center>124</td><td style=text-align:center>51</td><td style=text-align:center>33</td><td style=text-align:center>6</td><td style=text-align:center>17</td><td style=text-align:center>14</td><td style=text-align:center>5</td></tr></tbody></table><pre><code class=language-go>func twoSum(nums []int, target int) []int {
    h := map[int]int{}
    for i, num := range nums {
        if j, ok := h[target-num]; ok {
            return []int{j, i}
        }
        h[num] = i
    }
    return nil
}
</code></pre><ul><li><a href=https://leetcode-cn.com/problems/walking-robot-simulation/ target=_blank rel=noopener>874.模拟行走机器人</a></li></ul><p>（Medium）半年内出题频次：</p><table><thead><tr><th style=text-align:center>Amazon</th></tr></thead><tbody><tr><td style=text-align:center>2</td></tr></tbody></table><pre><code class=language-go>func robotSim(commands []int, obstacles [][]int) (ans int) {
    // 注意方向数组定义
    dx := []int{0, 1, 0, -1}
    dy := []int{1, 0, -1, 0}
    h := map[int64]bool{}
    for _, obstacle := range obstacles {
        h[calcHash(obstacle[0], obstacle[1])] = true
    }
    x, y, di := 0, 0, 0
    for _, command := range commands {
        if command == -2 {
            di = (di + 3) % 4
        } else if command == -1 {
            di = (di + 1) % 4
        } else {
            // 模拟新增
            for i := 1; i &lt;= command; i++ {
                nx, ny := x + dx[di], y + dy[di]
                if !h[calcHash(nx, ny)] {
                    x, y = nx, ny
                    ans = max(ans, x * x + y * y)
                }
            }
        }
    }
    return ans
}

func calcHash(x, y int) int64 {
    // fmt.Sprintf(&quot;%d,%d&quot;, x, y)
    // [2]int{x, y}
	return int64(x + 30000) * 60001 + int64(y) + 30000
}

func max(a, b int) int {
    if a &gt; b {
        return a
    }
    return b
}
</code></pre><ul><li><a href=https://leetcode-cn.com/problems/group-anagrams/ target=_blank rel=noopener>49.字母异位词分组</a></li></ul><p>（Medium）半年内出题频次：</p><table><thead><tr><th style=text-align:center>Facebook</th><th style=text-align:center>字节跳动</th><th style=text-align:center>微软</th><th style=text-align:center>Amazon</th><th style=text-align:center>Google</th><th style=text-align:center>Apple</th><th style=text-align:center>高盛集团</th><th style=text-align:center>eBay</th><th style=text-align:center>PayPal</th></tr></thead><tbody><tr><td style=text-align:center>6</td><td style=text-align:center>5</td><td style=text-align:center>23</td><td style=text-align:center>24</td><td style=text-align:center>3</td><td style=text-align:center>6</td><td style=text-align:center>14</td><td style=text-align:center>10</td><td style=text-align:center>4</td></tr></tbody></table><pre><code class=language-go>// 方法一：排序后做hash key
func groupAnagrams(strs []string) (ans [][]string) {
    mp := map[string][]string{}
    for _, str := range strs {
        strb := []byte(str)
        sort.Slice(strb, func (i, j int) bool {return strb[i] &lt; strb[j]})
        nstr := string(strb)
        mp[nstr] = append(mp[nstr], str)
    }
    for _, words := range mp {
        ans = append(ans, words)
    }
    return ans
}

// 方法二：key [26]int
func groupAnagrams(strs []string) [][]string {
    mp := map[[26]int][]string{}
    for _, str := range strs {
        cnt := [26]int{}
        for _, c := range str {
            cnt[c - 'a']++
        }
        mp[cnt] = append(mp[cnt], str)
    }
    ans := [][]string{}
    for _, v := range mp {
        ans = append(ans, v)
    }
    return ans
}
</code></pre><ul><li><a href=https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/ target=_blank rel=noopener>30.串联所有单词的子串</a></li></ul><p>（Hard）半年内出题频次：</p><table><thead><tr><th style=text-align:center>字节跳动</th><th style=text-align:center>Amazon</th></tr></thead><tbody><tr><td style=text-align:center>2</td><td style=text-align:center>2</td></tr></tbody></table><pre><code class=language-go>// 高效算法
func findSubstring(s string, words []string) (res []int) {
	if len(words) &lt; 1 {
		return 
	}

	slen := len(s)
	wlen := len(words)
	k := len(words[0])
	if slen &lt; k*wlen {
		return 
	}

    mp := map[string]int{}
	for _, w := range words {
		mp[w]++
	}

	// 移动窗口减少重复检查单词，按单词长度取不同批次
	for i := 0; i &lt; k; i++ {
        countermp, count := map[string]int{}, 0
		for l, r := i, i; r &lt;= slen-k; r = r + k {
			word := s[r : r+k]
			if num, found := mp[word]; found {
				// 如果计数器中单词数目超标，左移指针直至符合数目要求
				for countermp[word] &gt;= num {
					countermp[s[l:l+k]]--
					count--
					l += k
				}
				countermp[word]++
				count++
				// fmt.Println(countermp, count)
			} else {
				// 如果当前单词不在词典里，左移指针至下一个单词，左移过程中清理计数
				for l &lt; r {
					countermp[s[l:l+k]]--
					count--
					l += k
				}
                // 此时l = r
				l += k
			}
			if count == wlen {
				res = append(res, l)
			}
		}
	}
	return res
}

// c++方法一写法翻译
func findSubstring(s string, words []string) (ans []int) {
    search := map[string]int{}
    for _, word := range words {
        search[word]++
    }
    n, m, size := len(s), len(words), len(words[0])
    for i, j := 0, 0; i &lt; n - m * size + 1; i++ {
        sub := map[string]int{}
        for j = 0; j &lt; m; j++ {
            idx := i + j * size
            word := s[idx:idx+size]
            if _, ok := search[word]; !ok {
                break
            }
            sub[word]++
            if sub[word] &gt; search[word] {
                break
            }
        }
        if j == m {
            ans = append(ans, i)
        }
    }
    return ans
}
// 方法三：	2022/02/23 23:35 时间提交

</code></pre><pre><code class=language-c++>// 方法一：
class Solution {
public:
    vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) {
        vector&lt;int&gt; res; // 结果
        unordered_map&lt;string, int&gt; search;
        for (auto &amp;word : words) ++search[word]; // 参照物初始化
        int n = s.size(), m = words.size(), len = words[0].size(); // 获取隐藏变量
        for (int i = 0, j = 0; i &lt; n - m * len + 1; ++i) { // 主逻辑
            unordered_map&lt;string, int&gt; sub; // 子字符 查找的中间结果
            for (j = 0; j &lt; m; ++j) { // 子字符串查找逻辑
                auto word = s.substr(i + j * len, len); // 获取子串
                if (!search.count(word)) break; // 子串 不在 words 里面
                if (++sub[word] &gt; search[word]) break; // 子串个数 比 words 多
            }
            if (j == m) res.push_back(i); // 完全匹配
        }
        return res;
    }
};

// 训练营老师写法
class Solution {
public:
    vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) {
        int tot = 0;
        for (string&amp; word : words) {
            tot += word.length();
            wordsMap[word]++;
        }
        vector&lt;int&gt; ans;
        for (int i = 0; i + tot &lt;= s.length(); i++) {
            if (valid(s.substr(i, tot), words)) {
                ans.push_back(i);
            }
        }
        return ans;
    }
private:
    bool valid(string str, vector&lt;string&gt;&amp;words) {
        int k = words[0].length();
        unordered_map&lt;string, int&gt; splitWordsMap;
        for (int i = 0; i &lt; str.length(); i += k) {
            splitWordsMap[str.substr(i, k)]++;
        }
        return equalsMap(splitWordsMap, wordsMap);
    }
    bool equalsMap(unordered_map&lt;string, int&gt;&amp; a, unordered_map&lt;string, int&gt;&amp; b) {
        for (auto &amp; key_and_value : a) {
            const string&amp; key = key_and_value.first;
            int value = key_and_value.second;
            if (b.find(key) == b.end() || b[key] != value) return false;
        }

        for (auto &amp; key_and_value : b) {
            const string&amp; key = key_and_value.first;
            int value = key_and_value.second;
            if (a.find(key) == a.end() || a[key] != value)  return false;
        }
        return true;
    }
    unordered_map&lt;string, int&gt; wordsMap;
};
</code></pre><h4 id=lru>LRU</h4><ul><li><a href=https://leetcode-cn.com/problems/lru-cache/ target=_blank rel=noopener>146.LRU 缓存机制</a></li></ul><p>（Medium）半年内出题频次：</p><table><thead><tr><th style=text-align:center>Facebook</th><th style=text-align:center>字节跳动</th><th style=text-align:center>微软</th><th style=text-align:center>Amazon</th><th style=text-align:center>Google</th><th style=text-align:center>Apple</th><th style=text-align:center>阿里巴巴</th><th style=text-align:center>Bloomberg</th><th style=text-align:center>腾讯</th><th style=text-align:center>eBay</th></tr></thead><tbody><tr><td style=text-align:center>28</td><td style=text-align:center>33</td><td style=text-align:center>56</td><td style=text-align:center>92</td><td style=text-align:center>10</td><td style=text-align:center>17</td><td style=text-align:center>7</td><td style=text-align:center>11</td><td style=text-align:center>6</td><td style=text-align:center>10</td></tr></tbody></table><pre><code class=language-go>type listNode struct {
	Key, Value int
	Pre, Next *listNode
}

type LRUCache struct {
	capacity, cnt int
	h map[int]*listNode
	head, tail *listNode
}

func Constructor(capacity int) LRUCache {
	h := make(map[int]*listNode, capacity)
	head, tail := &amp;listNode{}, &amp;listNode{}
	head.Next = tail
	tail.Pre = head
	return LRUCache{
        capacity:capacity,
        h:h,
        head:head,
        tail:tail,
    }
}

func (this *LRUCache) Get(key int) int {
	if node, ok := this.h[key]; ok {
		this.removeNode(node)
		this.insertHeadNode(node)
		return node.Value
	}
	return -1
}

func (this *LRUCache) Put(key int, value int)  {
	if node, ok := this.h[key]; ok {
		node.Value = value
		this.removeNode(node)
		this.insertHeadNode(node)
	} else {
		if this.cnt == this.capacity {
			node = this.tail.Pre
			this.removeNode(this.tail.Pre)
			delete(this.h, node.Key)
			this.cnt--
		}
		node = &amp;listNode{Key: key, Value: value}
		this.insertHeadNode(node)
		this.h[key] = node
		this.cnt++
	}
}

func (this *LRUCache) removeNode(node *listNode) {
	node.Next.Pre = node.Pre
	node.Pre.Next = node.Next
}

func (this *LRUCache) insertHeadNode(node *listNode) {
	this.head.Next.Pre, node.Next = node, this.head.Next
	this.head.Next, node.Pre = node, this.head
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * obj := Constructor(capacity);
 * param_1 := obj.Get(key);
 * obj.Put(key,value);
 */
</code></pre><h3 id=第-4-课-前缀和差分双指针扫描>第 4 课 前缀和、差分、双指针扫描</h3><h4 id=前缀和差分>前缀和、差分</h4><ul><li><a href=https://leetcode-cn.com/problems/count-number-of-nice-subarrays/ target=_blank rel=noopener>1248.统计「优美子数组」</a></li></ul><p>（Medium）半年内出题频次：</p><table><thead><tr><th style=text-align:center>Amazon</th><th style=text-align:center>Citadel</th></tr></thead><tbody><tr><td style=text-align:center>2</td><td style=text-align:center>2</td></tr></tbody></table><pre><code class=language-go>// 训练营
func numberOfSubarrays(nums []int, k int) (ans int) {
    n := len(nums)
    s := make([]int, n + 1)
    for i := 1; i &lt;= n; i++ {
        s[i] = s[i-1] + nums[i-1] &amp; 1
    }
    cnt := make([]int, n + 1)
    cnt[s[0]]++
    for i := 1; i &lt;= n; i++ {
        if s[i] - k &gt;= 0 {
            ans += cnt[s[i] - k]
        }
        cnt[s[i]]++
    }
    return ans
}

// 官方
func numberOfSubarrays(nums []int, k int) int {
    n := len(nums)
    cnt := make([]int, n + 1)
    odd, ans := 0, 0
    cnt[0] = 1
    for i := 0; i &lt; n; i++ {
        odd += nums[i] &amp; 1
        if odd &gt;= k {
            ans += cnt[odd-k]
        }
        cnt[odd]++
    }
    return ans
}
</code></pre><ul><li><a href=https://leetcode-cn.com/problems/maximum-subarray/ target=_blank rel=noopener>53.最大子序和</a></li></ul><p>（Easy）半年内出题频次：</p><table><thead><tr><th style=text-align:center>Facebook</th><th style=text-align:center>字节跳动</th><th style=text-align:center>微软</th><th style=text-align:center>Amazon</th><th style=text-align:center>Google</th><th style=text-align:center>Bloomberg</th><th style=text-align:center>华为</th><th style=text-align:center>eBay</th><th style=text-align:center>Apple</th><th style=text-align:center>LinkedIn</th></tr></thead><tbody><tr><td style=text-align:center>7</td><td style=text-align:center>21</td><td style=text-align:center>16</td><td style=text-align:center>19</td><td style=text-align:center>6</td><td style=text-align:center>5</td><td style=text-align:center>3</td><td style=text-align:center>4</td><td style=text-align:center>12</td><td style=text-align:center>11</td></tr></tbody></table><pre><code class=language-go>// 前缀和 + 前缀最小值
func maxSubArray(nums []int) int {
    n := len(nums)
    s := make([]int, n + 1)
    preMin := make([]int, n + 1)
    for i := 1; i &lt;= n; i++ {
        s[i] = s[i-1] + nums[i-1]
    }
    preMin[0] = s[0]
    for i := 1; i &lt;= n; i++ {
        preMin[i] = min(preMin[i-1], s[i])
    }
    ans := math.MinInt32
    for i := 1; i &lt;= n; i++ {
        if ans &lt; s[i] - preMin[i-1] {
            ans = s[i] - preMin[i-1]
        }
    }
    return ans
}
func min(a, b int) int{
    if a &lt; b {
        return a
    }
    return b
}

// 贪心
func maxSubArray(nums []int) int {
    sum, ans, n := 0, math.MinInt32, len(nums)
    for i := 0; i &lt; n; i++ {
        sum += nums[i]
        if ans &lt; sum {
            ans = sum
        }
        if sum &lt; 0 {
            sum = 0
        }
    }
    return ans
}

// 动态规划: 
// 标准dp
func maxSubArray(nums []int) int {
    ans, n := nums[0], len(nums)
    dp := make([]int, n)
    dp[0] = nums[0]
    for i := 1; i &lt; n; i++ {
        dp[i] = max(0, dp[i-1]) + nums[i]
        ans = max(ans, dp[i])
    }
    return ans
}
// 简化dp
func maxSubArray(nums []int) int {
    ans, pre, n := nums[0], nums[0], len(nums)
    for i := 1; i &lt; n; i++ {
        pre = max(0, pre) + nums[i]
        if pre &gt; ans {
            ans = pre
        }
    }
    return ans
}
func max(a, b int) int {
    if a &gt; b {
        return a
    }
    return b
}
</code></pre><ul><li><a href=https://leetcode-cn.com/problems/range-sum-query-2d-immutable/ target=_blank rel=noopener>304.二维区域和检索 - 矩阵不可变</a></li></ul><p>（Medium）半年内出题频次：</p><table><thead><tr><th style=text-align:center>Facebook</th><th style=text-align:center>字节跳动</th><th style=text-align:center>微软</th><th style=text-align:center>Bloomberg</th><th style=text-align:center>Google</th></tr></thead><tbody><tr><td style=text-align:center>8</td><td style=text-align:center>4</td><td style=text-align:center>3</td><td style=text-align:center>2</td><td style=text-align:center>6</td></tr></tbody></table><pre><code class=language-go>type NumMatrix struct {
    sum [][]int
}

func Constructor(matrix [][]int) NumMatrix {
    m, n := len(matrix), len(matrix[0])
    sum := make([][]int, m + 1)
    sum[0] = make([]int, n + 1)
    for i := 1; i &lt;= m; i++ {
        sum[i] = make([]int, n + 1)
        for j := 1; j &lt;= n; j++ {
            sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + matrix[i-1][j-1]
        }
    }
    return NumMatrix{sum}
}

func (this *NumMatrix) SumRegion(row1 int, col1 int, row2 int, col2 int) int {
    sum := this.sum
    return sum[row2+1][col2+1] - sum[row2+1][col1] - sum[row1][col2+1] + sum[row1][col1]
}

/**
 * Your NumMatrix object will be instantiated and called as such:
 * obj := Constructor(matrix);
 * param_1 := obj.SumRegion(row1,col1,row2,col2);
 */
</code></pre><pre><code class=language-go>// 写法二
type NumMatrix struct {
    sums [][]int
}

func Constructor(matrix [][]int) NumMatrix {
    m := len(matrix)
    if m == 0 {
        return NumMatrix{}
    }
    n := len(matrix[0])
    sums := make([][]int, m+1)
    sums[0] = make([]int, n+1)
    for i, row := range matrix {
        sums[i+1] = make([]int, n+1)
        for j, v := range row {
            sums[i+1][j+1] = sums[i+1][j] + sums[i][j+1] - sums[i][j] + v
        }
    }
    return NumMatrix{sums}
}

func (nm *NumMatrix) SumRegion(row1, col1, row2, col2 int) int {
    return nm.sums[row2+1][col2+1] - nm.sums[row1][col2+1] - nm.sums[row2+1][col1] + nm.sums[row1][col1]
}
</code></pre><ul><li><a href=https://leetcode-cn.com/problems/corporate-flight-bookings/ target=_blank rel=noopener>1109.航班预订统计</a></li></ul><p>（Medium）半年内出题频次：</p><table><thead><tr><th style=text-align:center>华为</th></tr></thead><tbody><tr><td style=text-align:center>2</td></tr></tbody></table><pre><code class=language-go>// 差分思想
func corpFlightBookings(bookings [][]int, n int) []int {
    delta := make([]int, n + 2)
    for _, booking := range bookings {
        first, last, seats := booking[0], booking[1], booking[2]
        delta[first] += seats
        delta[last+1] -= seats
    }
    ans := make([]int, n + 1)
    for i := 1; i &lt;= n; i++ {
        ans[i] = ans[i-1] + delta[i] 
    }
    return ans[1:]
}

// 官方题解，更简洁，单理解稍难
func corpFlightBookings(bookings [][]int, n int) []int {
    nums := make([]int, n)
    for _, booking := range bookings {
        first, last, seats := booking[0], booking[1], booking[2]
        nums[first-1] += seats
        if last &lt; n {
            delta[last] -= seats
        }
    }
    for i := 1; i &lt; n; i++ {
        nums[i] += nums[i-1]
    }
    return nums
}
</code></pre><h4 id=双指针扫描滑动窗口>双指针扫描、滑动窗口</h4><ul><li><a href=https://leetcode-cn.com/problems/two-sum/ target=_blank rel=noopener>1.两数之和</a></li></ul><p>（Easy）半年内出题频次：</p><table><thead><tr><th style=text-align:center>Facebook</th><th style=text-align:center>字节跳动</th><th style=text-align:center>微软</th><th style=text-align:center>Amazon</th><th style=text-align:center>Apple</th><th style=text-align:center>Bloomberg</th><th style=text-align:center>Google</th><th style=text-align:center>腾讯</th><th style=text-align:center>阿里巴巴</th><th style=text-align:center>Cisco</th></tr></thead><tbody><tr><td style=text-align:center>33</td><td style=text-align:center>91</td><td style=text-align:center>40</td><td style=text-align:center>123</td><td style=text-align:center>33</td><td style=text-align:center>17</td><td style=text-align:center>51</td><td style=text-align:center>14</td><td style=text-align:center>6</td><td style=text-align:center>5</td></tr></tbody></table><pre><code class=language-go>// 训练营写法go版本
type pair struct{x, y int}
func twoSum(numbers []int, target int) []int {
    pairs := []pair{}
    // 构造 type pair struct{x, y int} slice
    for i, num := range numbers {
        pairs = append(pairs, pair{i, num})
    }
    // 对 slice 排序
    sort.Slice(pairs, func (i, j int) bool {
        return pairs[i].y &lt; pairs[j].y
    })
    // 双指针
    j := len(numbers) - 1
    for i := 0; i &lt; j; i++ {
        for i &lt; j &amp;&amp; pairs[i].y + pairs[j].y &gt; target { j-- }
        if i &lt; j &amp;&amp; pairs[i].y + pairs[j].y == target {
            return []int{pairs[i].x, pairs[j].x}
        }
    }
    return nil
}
</code></pre><ul><li><a href=https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/ target=_blank rel=noopener>167.两数之和 II - 输入有序数组</a></li></ul><p>（Easy）半年内出题频次：</p><table><thead><tr><th style=text-align:center>字节跳动</th><th style=text-align:center>微软</th><th style=text-align:center>Amazon</th><th style=text-align:center>Bloomberg</th><th style=text-align:center>Apple</th></tr></thead><tbody><tr><td style=text-align:center>5</td><td style=text-align:center>2</td><td style=text-align:center>5</td><td style=text-align:center>2</td><td style=text-align:center>2</td></tr></tbody></table><pre><code class=language-go>// 双指针
func twoSum(numbers []int, target int) []int {
    left, right := 0, len(numbers)-1
    for left &lt; right {
        sum := numbers[left] + numbers[right]
        if sum == target {
            return []int{left+1, right+1}
        } else if sum &lt; target {
            left++
        } else {
            right--
        }
    }
    return nil
}

// 训练营写法go版本
func twoSum(numbers []int, target int) []int {
    j := len(numbers) - 1
    for i := 0; i &lt; j; i++ {
        for i &lt; j &amp;&amp; numbers[i] + numbers[j] &gt; target { j-- }
        if i &lt; j &amp;&amp; numbers[i] + numbers[j] == target {
            return []int{i+1, j+1}
        }
    }
    return nil
}
</code></pre><ul><li><a href=https://leetcode-cn.com/problems/3sum/ target=_blank rel=noopener>15.三数之和</a></li></ul><p>（Medium）半年内出题频次：</p><table><thead><tr><th style=text-align:center>Facebook</th><th style=text-align:center>字节跳动</th><th style=text-align:center>微软</th><th style=text-align:center>Amazon</th><th style=text-align:center>Apple</th><th style=text-align:center>美团</th><th style=text-align:center>Google</th><th style=text-align:center>腾讯</th><th style=text-align:center>Bloomberg</th><th style=text-align:center>Cisco</th></tr></thead><tbody><tr><td style=text-align:center>19</td><td style=text-align:center>34</td><td style=text-align:center>13</td><td style=text-align:center>34</td><td style=text-align:center>10</td><td style=text-align:center>5</td><td style=text-align:center>5</td><td style=text-align:center>9</td><td style=text-align:center>5</td><td style=text-align:center>4</td></tr></tbody></table><pre><code class=language-go>func threeSum(nums []int) (ans [][]int) {
    sort.Ints(nums)
    n := len(nums)
    for i := 0; i &lt; n - 2; i++ {
        if i &gt; 0 &amp;&amp; nums[i-1] == nums[i] {
            continue
        }
        for j, k := i + 1, n - 1; j &lt; k; {
            sum := nums[i] + nums[j] + nums[k]
            if sum &lt; 0 {
                for j++; j &lt; k &amp;&amp; nums[j-1] == nums[j]; j++ {}
            } else if sum &gt; 0 {
                for k--; j &lt; k &amp;&amp; nums[k+1] == nums[k]; k-- {}
            } else {
                ans = append(ans, []int{nums[i], nums[j], nums[k]})
                for j++; j &lt; k &amp;&amp; nums[j-1] == nums[j]; j++ {}
                for k--; j &lt; k &amp;&amp; nums[k+1] == nums[k]; k-- {}
            }
        }
    }
    return ans
}
</code></pre><ul><li><a href=https://leetcode-cn.com/problems/container-with-most-water/ target=_blank rel=noopener>11.盛最多水的容器</a></li></ul><p>（Medium）半年内出题频次：</p><table><thead><tr><th style=text-align:center>Facebook</th><th style=text-align:center>字节跳动</th><th style=text-align:center>微软</th><th style=text-align:center>Amazon</th><th style=text-align:center>Apple</th><th style=text-align:center>Google</th><th style=text-align:center>高盛集团</th><th style=text-align:center>华为</th><th style=text-align:center>百度</th></tr></thead><tbody><tr><td style=text-align:center>15</td><td style=text-align:center>15</td><td style=text-align:center>8</td><td style=text-align:center>12</td><td style=text-align:center>3</td><td style=text-align:center>8</td><td style=text-align:center>4</td><td style=text-align:center>2</td><td style=text-align:center>2</td></tr></tbody></table><pre><code class=language-go>func maxArea(height []int) (ans int) {
    i, j := 0, len(height) - 1
    for i &lt; j {
        if height[i] &lt; height[j] {
            ans = max(ans, (j-i) * height[i])
            i++
        } else {
            ans = max(ans, (j-i) * height[j])
            j--
        }
    }
    return ans
}

func max(a, b int) int {
    if a &gt; b {
        return a
    }
    return b
}
</code></pre></article><div class="-mx-2 mt-4 flex flex-col border-t px-2 pt-4 md:flex-row md:justify-between"><div><span class="text-primary-text block font-bold">上一页</span>
<a href=/study/2021algorithm/week01/ class=block>第一周 数组、链表、栈、队列</a></div><div class="mt-4 md:mt-0 md:text-right"><span class="text-primary-text block font-bold">下一页</span>
<a href=/study/2021algorithm/week03/ class=block>第三周 递归、分治、树与图</a></div></div></div><div class="hidden lg:block lg:w-1/4"><div class="bg-secondary-bg
prose sticky top-16 z-10 hidden px-6 py-4 lg:block"><h3>本页内容</h3></div><div class="sticky-toc
border-s
hidden px-6 pb-6 lg:block"><nav id=TableOfContents><ul><li><a href=#本周作业>本周作业</a></li><li><a href=#实战例题>实战例题</a><ul><li><a href=#第-3-课-哈希表集合映射>第 3 课 哈希表、集合、映射</a><ul><li><a href=#无序集合映射>无序集合、映射</a></li><li><a href=#lru>LRU</a></li></ul></li><li><a href=#第-4-课-前缀和差分双指针扫描>第 4 课 前缀和、差分、双指针扫描</a><ul><li><a href=#前缀和差分>前缀和、差分</a></li><li><a href=#双指针扫描滑动窗口>双指针扫描、滑动窗口</a></li></ul></li></ul></li></ul></nav></div><script>window.addEventListener("DOMContentLoaded",()=>{enableStickyToc()})</script></div></div></div></div></div><script>document.addEventListener("DOMContentLoaded",()=>{hljs.highlightAll(),changeSidebarHeight(),switchDocToc()})</script></div></div></main><footer class=pl-scrollbar><div class="mx-auto w-full max-w-screen-xl"><div class="text-center p-6 pin-b"><p class="text-sm text-tertiary-text">&copy; 2021 <a href=https://blog.lbbniu.com/>lbbniu</a>
&#183; Powered by the <a href=https://github.com/wangchucheng/hugo-eureka class=hover:text-eureka>Eureka</a> theme for <a href=https://gohugo.io class=hover:text-eureka>Hugo</a></p></div></div></footer></body></html>