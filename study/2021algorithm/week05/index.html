<!doctype html><html lang=zh dir=ltr><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>第五周 二分、排序 | 极客时间算法训练营2021版 | lbbniu</title>
<meta name=generator content="Hugo Eureka 0.9.3"><link rel=stylesheet href=/css/eureka.min.9cec6350e37e534b0338fa9a085bf06855de3b0f2dcf857e792e5e97b07ea905d4d5513db554cbc26a9c3da622bae92d.css><script defer src=/js/eureka.min.fa9a6bf6d7a50bb635b4cca7d2ba5cf3dfb095ae3798773f1328f7950028b48c17d06276594e1b5f244a25a6c969a705.js></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&amp;family=Noto+Serif+SC:wght@400;600;700&amp;display=swap" as=style onload='this.onload=null,this.rel="stylesheet"'><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/styles/github.min.css media=print onload='this.media="all",this.onload=null' crossorigin><script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/highlight.min.js crossorigin></script><script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/dart.min.js crossorigin></script><script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/php.min.js crossorigin></script><script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/java.min.js crossorigin></script><script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/go.min.js crossorigin></script><script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/python.min.js crossorigin></script><link rel=stylesheet href=/css/highlightjs.min.2958991528e43eb6fc9b8c4f2b8e052f79c4010718e1d1e888a777620e9ee63021c2c57ec7417a3108019bb8c41943e6.css media=print onload='this.media="all",this.onload=null'><script defer type=text/javascript src=/js/fontawesome.min.35973bea57658ef0dd22ad59ea4642b6c8c67af62bed8659ac326d284ef285a6657cdbcf57d3b2910e7e992f2b20426e.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ media=print onload='this.media="all",this.onload=null' crossorigin><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script><script defer src=https://cdn.jsdelivr.net/npm/mermaid@8.14.0/dist/mermaid.min.js integrity=sha384-atOyb0FxAgN9LyAc6PEf9BjgwLISyansgdH8/VXQH8p2o5vfrRgmGIJ2Sg22L0A0 crossorigin></script><link rel=icon type=image/png sizes=32x32 href=/images/icon_hu46eef4dc61dcf438cf488ad55e1d2c12_638750_32x32_fill_box_center_3.png><link rel=apple-touch-icon sizes=180x180 href=/images/icon_hu46eef4dc61dcf438cf488ad55e1d2c12_638750_180x180_fill_box_center_3.png><meta name=description content="第 9 课 二分，第10课 排序"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"算法学习","item":"/study/"},{"@type":"ListItem","position":2,"name":"极客时间算法训练营2021版","item":"/study/2021algorithm/"},{"@type":"ListItem","position":3,"name":"第五周 二分、排序","item":"/study/2021algorithm/week05/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"/study/2021algorithm/week05/"},"headline":"第五周 二分、排序 | 极客时间算法训练营2021版 | lbbniu","datePublished":"2021-12-12T08:00:00+08:00","dateModified":"2024-01-13T20:58:24+08:00","wordCount":4240,"publisher":{"@type":"Person","name":"lbbniu","logo":{"@type":"ImageObject","url":"/images/icon.gif"}},"description":"第 9 课 二分，第10课 排序"}</script><meta property="og:title" content="第五周 二分、排序 | 极客时间算法训练营2021版 | lbbniu"><meta property="og:type" content="article"><meta property="og:image" content="/images/icon.png"><meta property="og:url" content="/study/2021algorithm/week05/"><meta property="og:description" content="第 9 课 二分，第10课 排序"><meta property="og:locale" content="zh"><meta property="og:site_name" content="lbbniu"><meta property="article:published_time" content="2021-12-12T08:00:00+08:00"><meta property="article:modified_time" content="2024-01-13T20:58:24+08:00"><meta property="article:section" content="study"><body class="flex min-h-screen flex-col"><header class="min-h-16 pl-scrollbar bg-secondary-bg fixed z-50 flex w-full items-center shadow-sm"><div class="mx-auto w-full max-w-screen-xl"><script>let storageColorScheme=localStorage.getItem("lightDarkMode");((storageColorScheme=="Auto"||storageColorScheme==null)&&window.matchMedia("(prefers-color-scheme: dark)").matches||storageColorScheme=="Dark")&&document.getElementsByTagName("html")[0].classList.add("dark")</script><nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0"><a href=/ class="me-6 text-primary-text text-xl font-bold">lbbniu</a>
<button id=navbar-btn class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
<i class="fas fa-bars"></i></button><div id=target class="hidden block md:flex md:grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20"><div class="md:flex md:h-16 text-sm md:grow pb-4 md:pb-0 border-b md:border-b-0"><a href=/post/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">文章</a>
<a href=/cloud-native/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">云原生</a>
<a href=/study/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 selected-menu-item me-4">算法学习</a>
<a href=/docs/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">Go学习训练营</a>
<a href=/tags/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">标签</a></div><div class=flex><div class="relative pt-4 md:pt-0"><div class="cursor-pointer hover:text-eureka" id=lightDarkMode><i class="fas fa-adjust"></i></div><div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id=is-open></div><div class="absolute flex flex-col start-0 md:start-auto end-auto md:end-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40" id=lightDarkOptions><span class="px-4 py-1 hover:text-eureka" name=Light>浅色</span>
<span class="px-4 py-1 hover:text-eureka" name=Dark>深色</span>
<span class="px-4 py-1 hover:text-eureka" name=Auto>自动</span></div></div></div></div><div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id=is-open-mobile></div></nav><script>let element=document.getElementById("lightDarkMode");storageColorScheme==null||storageColorScheme=="Auto"?document.addEventListener("DOMContentLoaded",()=>{window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",switchDarkMode)}):storageColorScheme=="Light"?(element.firstElementChild.classList.remove("fa-adjust"),element.firstElementChild.setAttribute("data-icon","sun"),element.firstElementChild.classList.add("fa-sun")):storageColorScheme=="Dark"&&(element.firstElementChild.classList.remove("fa-adjust"),element.firstElementChild.setAttribute("data-icon","moon"),element.firstElementChild.classList.add("fa-moon")),document.addEventListener("DOMContentLoaded",()=>{getcolorscheme(),switchBurger()})</script></div></header><main class="grow pt-16"><div class=pl-scrollbar><div class="mx-auto w-full max-w-screen-xl lg:px-4 xl:px-8"><div class=lg:pt-12><div class="flex flex-col md:flex-row bg-secondary-bg rounded"><div class="md:w-1/4 lg:w-1/5 border-e"><div class="sticky top-16 pt-6"><div id=sidebar-title class="md:hidden mx-4 px-2 pt-4 pb-2 md:border-b text-tertiary-text md:text-primary-text"><span class=font-semibold>目录</span>
<i class='fas fa-caret-right ms-1'></i></div><div id=sidebar-toc class="hidden md:block overflow-y-auto mx-6 md:mx-0 pe-6 pt-2 md:max-h-doc-sidebar bg-primary-bg md:bg-transparent"><div class="flex flex-wrap ms-4 -me-2 p-2 bg-secondary-bg md:bg-primary-bg rounded"><a class=hover:text-eureka href=/study/2021algorithm/>极客时间算法训练营2021版</a></div><ul class=ps-6><li class=py-2><div><a class=hover:text-eureka href=/study/2021algorithm/week01/>第一周 数组、链表、栈、队列</a></div></li><li class=py-2><div><a class=hover:text-eureka href=/study/2021algorithm/week02/>第二周 哈希表、集合、映射、前缀和、差分、双指针扫描</a></div></li><li class=py-2><div><a class=hover:text-eureka href=/study/2021algorithm/week03/>第三周 递归、分治、树与图</a></div></li><li class=py-2><div><a class=hover:text-eureka href=/study/2021algorithm/week04/>第四周 深度优先搜索、广度优先搜索、二叉堆、二叉搜索树</a></div></li><li class=py-2><div><a class="text-eureka hover:text-eureka" href=/study/2021algorithm/week05/>第五周 二分、排序</a></div></li><li class=py-2><div><a class=hover:text-eureka href=/study/2021algorithm/week06/>第六周 贪心、动态规划</a></div></li><li class=py-2><div><a class=hover:text-eureka href=/study/2021algorithm/week07/>第七周 动态规划</a></div></li><li class=py-2><div><a class=hover:text-eureka href=/study/2021algorithm/week08/>第八周 字典树、并查集，图论算法</a></div></li><li class=py-2><div><a class=hover:text-eureka href=/study/2021algorithm/week09/>第九周 字符串处理、高级搜索</a></div></li><li class=py-2><div><a class=hover:text-eureka href=/study/2021algorithm/week10/>第十周 平衡二叉树、跳跃表、树状数组与线段树、实战技巧、总结回顾</a></div></li><li class=py-2><div><a class=hover:text-eureka href=/study/2021algorithm/final/>毕业刷新路径</a></div></li></ul></div></div></div><div class="w-full md:w-3/4 lg:w-4/5 pb-8 pt-2 md:pt-8"><div class=flex><div class="w-full lg:w-3/4 px-6"><article class=prose><h1 class=mb-4>第五周 二分、排序</h1><div class="text-tertiary-text not-prose mt-2 flex flex-row flex-wrap items-center"><div class="me-6 my-2"><i class="fas fa-calendar me-1"></i>
<span>2021-12-12</span></div><div class="me-6 my-2"><i class="fas fa-clock me-1"></i>
<span>20分钟阅读时长</span></div><div class="me-6 my-2"><i class="fas fa-folder me-1"></i>
<a href=/categories/%E8%AE%AD%E7%BB%83%E8%90%A5/ class=hover:text-eureka>训练营</a></div></div><p>题目数：20</p><h2 id=本周作业>本周作业</h2><ul><li><a href=https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/ target=_blank rel=noopener>1011.在 D 天内送达包裹的能力</a>
<strong>重点</strong></li></ul><p>（Medium）半年内出题频次：</p><table><thead><tr><th style=text-align:center>Facebook</th><th style=text-align:center>字节跳动</th><th style=text-align:center>Google</th><th style=text-align:center>Amazon</th></tr></thead><tbody><tr><td style=text-align:center>14</td><td style=text-align:center>9</td><td style=text-align:center>3</td><td style=text-align:center>7</td></tr></tbody></table><pre><code class=language-go>// 官方题解：
func shipWithinDays(weights []int, D int) int {
    // 确定二分查找左右边界
    left, right := 0, 0
    for _, w := range weights {
        if w &gt; left {
            left = w
        }
        right += w
    }
    return left + sort.Search(right-left, func(x int) bool {
        x += left
        day := 1 // 需要运送的天数
        sum := 0 // 当前这一天已经运送的包裹重量之和
        for _, w := range weights {
            if sum+w &gt; x {
                day++
                sum = 0
            }
            sum += w
        }
        return day &lt;= D
    })
}
// 官方c++版本go化
func shipWithinDays(weights []int, days int) int {
    left, right := weights[0], weights[0]
    for _, weight := range weights[1:] {
        if weight &gt; left {
            left = weight 
        }
        right += weight
    }
    for left &lt; right {
        mid := (left + right) &gt;&gt; 1
        need, cur := 1, 0
        for _, weight := range weights {
            if cur + weight &gt; mid {
                cur = 0
                need++
            }
            cur += weight
        }
        if need &lt;= days {
            right = mid
        } else {
            left = mid + 1
        }
    }
    return left
}
</code></pre><pre><code class=language-go>// 训练营
func shipWithinDays(weights []int, days int) int {
    low, high := weights[0], weights[0]
    for _, weight := range weights[1:] {
        if weight &gt; low {
            low = weight 
        }
        high += weight
    }
    for low &lt; high {
        mid := (low + high) &gt;&gt; 1
        if validate(weights, mid, days) {
            high = mid
        } else {
            low = mid + 1
        }
    }
    return low
}

func validate(weights []int, weight, day int) bool {
    cur, curDay := 0, 1 // 注意curDay初始化为1
    for _, w := range weights {
        if cur + w &lt;= weight {
            cur += w
        } else {
            curDay++
            cur = w
        }
    }
    return curDay &lt;= day
}
</code></pre><ul><li><a href=https://leetcode-cn.com/problems/online-election/ target=_blank rel=noopener>911.在线选举</a>
<strong>重点</strong></li></ul><p>（Medium） 1 年内出题频次：</p><table><thead><tr><th style=text-align:center>Google</th></tr></thead><tbody><tr><td style=text-align:center>3</td></tr></tbody></table><pre><code class=language-go>type TopVotedCandidate struct {
    tops, times []int
}

func Constructor(persons, times []int) TopVotedCandidate {
    tops := []int{}
    top := -1
    voteCounts := map[int]int{-1: -1}
    for _, p := range persons {
        voteCounts[p]++
        if voteCounts[p] &gt;= voteCounts[top] {
            top = p
        }
        tops = append(tops, top)
    }
    return TopVotedCandidate{tops, times}
}

func (c *TopVotedCandidate) Q(t int) int {
    return c.tops[sort.SearchInts(c.times, t+1)-1]
}


/**
 * Your TopVotedCandidate object will be instantiated and called as such:
 * obj := Constructor(persons, times);
 * param_1 := obj.Q(t);
 */
</code></pre><pre><code class=language-java>class TopVotedCandidate {
    List&lt;Integer&gt; tops;
    Map&lt;Integer, Integer&gt; voteCounts;
    int[] times;

    public TopVotedCandidate(int[] persons, int[] times) {
        tops = new ArrayList&lt;Integer&gt;();
        voteCounts = new HashMap&lt;Integer, Integer&gt;();
        voteCounts.put(-1, -1);
        int top = -1;
        for (int i = 0; i &lt; persons.length; ++i) {
            int p = persons[i];
            voteCounts.put(p, voteCounts.getOrDefault(p, 0) + 1);
            if (voteCounts.get(p) &gt;= voteCounts.get(top)) {
                top = p;
            }
            tops.add(top);
        }
        this.times = times;
    }
    
    public int q(int t) {
        int l = 0, r = times.length - 1;
        // 找到满足 times[l] &lt;= t 的最大的 l
        while (l &lt; r) {
            int m = l + (r - l + 1) / 2;
            if (times[m] &lt;= t) {
                l = m;
            } else {
                r = m - 1;
            }
        }
        return tops.get(l);
    }
}
</code></pre><ul><li><a href=https://leetcode-cn.com/problems/koko-eating-bananas/ target=_blank rel=noopener>875.爱吃香蕉的珂珂</a>
<strong>重点</strong></li></ul><p>（Medium）半年内出题频次：</p><table><thead><tr><th style=text-align:center>Facebook</th><th style=text-align:center>Airbnb</th><th style=text-align:center>Google</th></tr></thead><tbody><tr><td style=text-align:center>3</td><td style=text-align:center>2</td><td style=text-align:center>10</td></tr></tbody></table><pre><code class=language-go>func minEatingSpeed(piles []int, h int) int {
    low, high := 1, int(1e9)
    for low &lt; high {
        mid := low + (high - low) &gt;&gt; 1
        if validate(piles, h, mid) {
            high = mid
        } else {
            low = mid + 1
        }
    }
    return low
}

func validate(piles []int, h int, k int) bool {
    time := 0
    for _, pile := range piles {
        // 向上取整
        time += (pile - 1) / k + 1 // (pile + k - 1) / k
    }
    return time &lt;= h
}
</code></pre><ul><li><a href=https://leetcode-cn.com/problems/count-of-range-sum/ target=_blank rel=noopener>372.区间和的个数（选做）</a>
<strong>重点</strong> <strong>重点</strong></li></ul><p>（Hard）半年内出题频次：</p><table><thead><tr><th style=text-align:center>字节跳动</th><th style=text-align:center>Amazon</th></tr></thead><tbody><tr><td style=text-align:center>2</td><td style=text-align:center>2</td></tr></tbody></table><pre><code class=language-go>// 方法一：归并排序
func countRangeSum(nums []int, lower int, upper int) (ans int) {
    var mergeSort func([]int, int, int)
    mergeSort = func(preSum []int, left, right int) {
        if left &gt;= right {
            return
        }
        mid := (left + right) &gt;&gt; 1
        mergeSort(preSum, left, mid)
        mergeSort(preSum, mid + 1, right)
        // 计算统计
        l, r := mid + 1, mid + 1
        for i := left; i &lt;= mid; i++ {
            for l &lt;= right &amp;&amp; preSum[l] - preSum[i] &lt; lower {
                l++
            }
            for r &lt;= right &amp;&amp; preSum[r] - preSum[i] &lt;= upper {
                r++
            }
            ans += r - l
        }

        // 合并
        tmp := make([]int, right - left + 1)
        i, j := left, mid + 1
        for k := 0; k &lt; len(tmp); k++ {
            if j &gt; right || (i &lt;= mid &amp;&amp; preSum[i] &lt;= preSum[j]) {
                tmp[k], i = preSum[i], i + 1
            } else {
                tmp[k], j = preSum[j], j + 1
            }
        }
        for i, v := range tmp {
            preSum[left+i] = v
        }
    }
    preSum := make([]int, len(nums) + 1)
    for i, num := range nums {
        preSum[i+1] = preSum[i] + num
    }
    mergeSort(preSum, 0, len(preSum)-1)
    return ans
}
// 归并官方写法
func countRangeSum(nums []int, lower, upper int) int {
    var mergeCount func([]int) int
    mergeCount = func(arr []int) int {
        n := len(arr)
        if n &lt;= 1 {
            return 0
        }

        n1 := append([]int(nil), arr[:n/2]...)
        n2 := append([]int(nil), arr[n/2:]...)
        cnt := mergeCount(n1) + mergeCount(n2) // 递归完毕后，n1 和 n2 均为有序

        // 统计下标对的数量
        l, r := 0, 0
        for _, v := range n1 {
            for l &lt; len(n2) &amp;&amp; n2[l]-v &lt; lower {
                l++
            }
            for r &lt; len(n2) &amp;&amp; n2[r]-v &lt;= upper {
                r++
            }
            cnt += r - l
        }

        // n1 和 n2 归并填入 arr
        p1, p2 := 0, 0
        for i := range arr {
            if p1 &lt; len(n1) &amp;&amp; (p2 == len(n2) || n1[p1] &lt;= n2[p2]) {
                arr[i] = n1[p1]
                p1++
            } else {
                arr[i] = n2[p2]
                p2++
            }
        }
        return cnt
    }

    prefixSum := make([]int, len(nums)+1)
    for i, v := range nums {
        prefixSum[i+1] = prefixSum[i] + v
    }
    return mergeCount(prefixSum)
}
// 方法二：线段树

// 方法三：动态增加节点的线段树

// 方法四：树状数组

// 方法五：平衡二叉搜索树
</code></pre><pre><code class=language-java>class Solution {
    public int countRangeSum(int[] nums, int lower, int upper) {
        long s = 0;
        long[] sum = new long[nums.length + 1];
        for (int i = 0; i &lt; nums.length; ++i) {
            s += nums[i];
            sum[i + 1] = s;
        }
        return countRangeSumRecursive(sum, lower, upper, 0, sum.length - 1);
    }

    public int countRangeSumRecursive(long[] sum, int lower, int upper, int left, int right) {
        if (left == right) {
            return 0;
        } else {
            int mid = (left + right) / 2;
            int n1 = countRangeSumRecursive(sum, lower, upper, left, mid);
            int n2 = countRangeSumRecursive(sum, lower, upper, mid + 1, right);
            int ret = n1 + n2;

            // 首先统计下标对的数量
            int i = left;
            int l = mid + 1;
            int r = mid + 1;
            while (i &lt;= mid) {
                while (l &lt;= right &amp;&amp; sum[l] - sum[i] &lt; lower) {
                    l++;
                }
                while (r &lt;= right &amp;&amp; sum[r] - sum[i] &lt;= upper) {
                    r++;
                }
                ret += r - l;
                i++;
            }

            // 随后合并两个排序数组
            long[] sorted = new long[right - left + 1];
            int p1 = left, p2 = mid + 1;
            int p = 0;
            while (p1 &lt;= mid || p2 &lt;= right) {
                if (p1 &gt; mid) {
                    sorted[p++] = sum[p2++];
                } else if (p2 &gt; right) {
                    sorted[p++] = sum[p1++];
                } else {
                    if (sum[p1] &lt; sum[p2]) {
                        sorted[p++] = sum[p1++];
                    } else {
                        sorted[p++] = sum[p2++];
                    }
                }
            }
            for (int j = 0; j &lt; sorted.length; j++) {
                sum[left + j] = sorted[j];
            }
            return ret;
        }
    }
}
</code></pre><ul><li><a href=https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/ target=_blank rel=noopener>154.寻找旋转排序数组中的最小值 II </a><strong>重点</strong></li></ul><p><strong>重点</strong>（Hard）半年内出题频次：</p><table><thead><tr><th style=text-align:center>Facebook</th></tr></thead><tbody><tr><td style=text-align:center>2</td></tr></tbody></table><pre><code class=language-go>// 数组中存在重复值
func findMin(nums []int) int {
    low, high := 0, len(nums)-1
    for low &lt; high {
        mid := low + (high - low) &gt;&gt; 1
        if nums[mid] &lt; nums[high] {
            high = mid
        } else if nums[mid] &gt; nums[high] {
            low = mid + 1
        } else {
            high-- // nums[mid] == nums[high] 相等，逐渐缩小high
        }
    }
    return nums[low] // 返回 nums[high] 也可
}
</code></pre><ul><li><a href=https://leetcode-cn.com/problems/search-a-2d-matrix/ target=_blank rel=noopener>74.搜索二维矩阵</a>
（Medium）半年内出题频次：</li></ul><table><thead><tr><th style=text-align:center>Facebook</th><th style=text-align:center>字节跳动</th><th style=text-align:center>微软</th><th style=text-align:center>Amazon</th><th style=text-align:center>Google</th><th style=text-align:center>Apple</th></tr></thead><tbody><tr><td style=text-align:center>3</td><td style=text-align:center>3</td><td style=text-align:center>2</td><td style=text-align:center>9</td><td style=text-align:center>2</td><td style=text-align:center>3</td></tr></tbody></table><pre><code class=language-go>func searchMatrix(matrix [][]int, target int) bool {
    n := len(matrix[0])
    left, right := 0, len(matrix) * len(matrix[0]) - 1
    for left &lt;= right {
        mid := (left + right) &gt;&gt; 1
        row, col := mid/n, mid%n
        if matrix[row][col] == target {
            return true
        } else if matrix[row][col] &lt; target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return false
}
</code></pre><h2 id=实战例题>实战例题</h2><blockquote><p>以下为课上实战例题</p></blockquote><h3 id=第-9-课-二分>第 9 课 二分</h3><h4 id=二分查找>二分查找</h4><ul><li><a href=https://leetcode-cn.com/problems/binary-search/ target=_blank rel=noopener>704.二分查找</a>
（Easy）半年内出题频次：</li></ul><table><thead><tr><th style=text-align:center>Facebook</th><th style=text-align:center>字节跳动</th><th style=text-align:center>微软</th><th style=text-align:center>Amazon</th><th style=text-align:center>Google</th><th style=text-align:center>Apple</th><th style=text-align:center>腾讯</th><th style=text-align:center>高盛集团</th></tr></thead><tbody><tr><td style=text-align:center>4</td><td style=text-align:center>16</td><td style=text-align:center>3</td><td style=text-align:center>5</td><td style=text-align:center>4</td><td style=text-align:center>2</td><td style=text-align:center>2</td><td style=text-align:center>2</td></tr></tbody></table><pre><code class=language-go>func search(nums []int, target int) int {
    left, right := 0, len(nums) - 1
    for left &lt;= right {
        mid := left + (right - left) &gt;&gt; 1
        if nums[mid] == target {
            return mid
        } else if nums[mid] &lt; target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}
</code></pre><ul><li><a href=https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/ target=_blank rel=noopener>153.寻找旋转排序数组中的最小值</a>
（Medium）半年内出题频次：</li></ul><table><thead><tr><th style=text-align:center>微软</th><th style=text-align:center>Apple</th><th style=text-align:center>Amazon</th><th style=text-align:center>Facebook</th><th style=text-align:center>高盛集团</th></tr></thead><tbody><tr><td style=text-align:center>10</td><td style=text-align:center>3</td><td style=text-align:center>9</td><td style=text-align:center>8</td><td style=text-align:center>3</td></tr></tbody></table><pre><code class=language-go>/*
3 4 5 1 2 让每个数尝试给结尾数比较 nums[i] &lt;= nums[n-1]
0 0 0 1 1
*/
func findMin(nums []int) int {
    left, right := 0, len(nums) - 1
    for left &lt; right {
        mid := left + (right - left) &gt;&gt; 1
        // 条件满足true， 即为1
        if nums[mid] &lt;= nums[right] {
            right = mid
        } else {
            left = mid + 1
        }
    }
    return nums[right]
}

// 以前的垃圾写法
func findMin(nums []int) int {
    l, r := 0, len(nums) - 1
    if nums[l] &lt; nums[r] || r == l {
        return nums[l]
    }
    for l &lt; r {
        m := l + (r - l) &gt;&gt; 1
        if nums[m] &gt; nums[m + 1] {
            return nums[m + 1]
        }
        if nums[m - 1] &gt; nums[m] {
            return nums[m]
        }
        if nums[0] &lt; nums[m] {
            l = m + 1
        } else {
            r = m - 1
        }
    }
    return nums[0]
}
</code></pre><ul><li><a href=https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/ target=_blank rel=noopener>34.在排序数组中查找元素的第一个和最后一个位置</a>
（Medium）半年内出题频次：</li></ul><table><thead><tr><th style=text-align:center>Facebook</th><th style=text-align:center>字节跳动</th><th style=text-align:center>微软</th><th style=text-align:center>LinkedIn</th><th style=text-align:center>Google</th><th style=text-align:center>Apple</th></tr></thead><tbody><tr><td style=text-align:center>27</td><td style=text-align:center>11</td><td style=text-align:center>5</td><td style=text-align:center>9</td><td style=text-align:center>6</td><td style=text-align:center>6</td></tr></tbody></table><pre><code class=language-go>// 训练营
func searchRange(nums []int, target int) []int {
    ans := make([]int, 2)
    // 查找 第一个 &gt;=target 的位置
    left, right := 0, len(nums)
    for left &lt; right {
        mid := (left + right) &gt;&gt; 1
        if nums[mid] &gt;= target {
            right = mid
        } else {
            left = mid + 1
        }
    }
    ans[0] = right
    // 查找 最后一个 &lt;=target 的位置
    left, right = -1, len(nums) - 1
    for left &lt; right {
        mid := (left + right + 1) &gt;&gt; 1
        if nums[mid] &lt;= target {
            left = mid
        } else {
            right = mid - 1
        }
    }
    ans[1] = right
    if ans[0] &gt; ans[1] {
        return []int{-1, -1}
    }
    return ans
}
// 以前写法
func searchRange(nums []int, target int) []int {
    leftmost := sort.SearchInts(nums, target)
    if leftmost == len(nums) || nums[leftmost] != target {
        return []int{-1, -1}
    }
    rightmost := sort.SearchInts(nums, target + 1) - 1
    return []int{leftmost, rightmost}
}
</code></pre><ul><li><a href=https://leetcode-cn.com/problems/sqrtx/ target=_blank rel=noopener>69.Sqrt(x) </a>（Easy）半年内出题频次：</li></ul><table><thead><tr><th style=text-align:center>NVIDIA</th><th style=text-align:center>字节跳动</th><th style=text-align:center>微软</th><th style=text-align:center>Amazon</th><th style=text-align:center>Google</th><th style=text-align:center>Apple</th><th style=text-align:center>LinkedIn</th><th style=text-align:center>美团</th></tr></thead><tbody><tr><td style=text-align:center>2</td><td style=text-align:center>11</td><td style=text-align:center>4</td><td style=text-align:center>5</td><td style=text-align:center>3</td><td style=text-align:center>2</td><td style=text-align:center>5</td><td style=text-align:center>2</td></tr></tbody></table><pre><code class=language-go>// 训练营写法一
func mySqrt(x int) int {
    left, right := 1, x
    for left &lt; right {
        mid := (left + right + 1) &gt;&gt; 1
        if mid * mid &lt;= x {
            left = mid
        } else {
            right = mid - 1
        }
    }
    return right
}
// 训练营写法二
func mySqrt(x int) int {
    left, right := 1, x
    for left &lt; right {
        mid := (left + right + 1) &gt;&gt; 1
        if mid &lt;= x / mid {
            left = mid
        } else {
            right = mid - 1
        }
    }
    return right
}
// 训练营写法三
func mySqrt(x int) int {
    return int(myRealSqrt(float64(x)))
}
func myRealSqrt(x float64) float64 {
    left, right := float64(0), x
    for right - left &gt; 1e-7 {
        mid := (right + left) / 2
        if mid * mid &lt;= x {
            left = mid
        } else {
            right = mid
        }
    }
    return right
}
</code></pre><pre><code class=language-java>// 训练营写法三
class Solution {
    public int mySqrt(int x) {
        return (int)myRealSqrt(x);
    }

    public double myRealSqrt(double x) {
        double left = 0, right = x;
        while (right - left &gt; 1e-7) {
            double mid = (left + right) / 2;
            if (mid * mid &lt;= x) {
                left = mid;
            } else {
                right = mid;
            }
        }
        return right;
    }
}
</code></pre><h4 id=三分查找>三分查找</h4><ul><li><a href=https://leetcode-cn.com/problems/find-peak-element/ target=_blank rel=noopener>162.寻找峰值</a>
<strong>重点</strong></li></ul><p>（Medium）半年内出题频次：</p><table><thead><tr><th style=text-align:center>Facebook</th><th style=text-align:center>字节跳动</th><th style=text-align:center>微软</th><th style=text-align:center>Amazon</th><th style=text-align:center>Google</th><th style=text-align:center>Apple</th><th style=text-align:center>Roblox</th><th style=text-align:center>拼多多</th></tr></thead><tbody><tr><td style=text-align:center>31</td><td style=text-align:center>6</td><td style=text-align:center>7</td><td style=text-align:center>10</td><td style=text-align:center>2</td><td style=text-align:center>2</td><td style=text-align:center>7</td><td style=text-align:center>2</td></tr></tbody></table><pre><code class=language-go>func findPeakElement(nums []int) int {
    left, right := 0, len(nums) - 1
    for left &lt; right {
        mid := (left + right) &gt;&gt; 1
        if nums[mid] &lt;= nums[mid+1] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return right
}
// 训练营写法
func findPeakElement(nums []int) int {
    left, right := 0, len(nums) - 1
    for left &lt; right {
        lmid := (left + right) &gt;&gt; 1
        rmid := lmid + 1
        if nums[lmid] &lt;= nums[rmid] {
            left = lmid + 1
        } else {
            right = rmid - 1
        }
    }
    return right
}
</code></pre><h4 id=二分答案>二分答案</h4><ul><li><a href=https://leetcode-cn.com/problems/guess-number-higher-or-lower/ target=_blank rel=noopener>374.猜数字大小</a>
（Easy）半年内出题频次：</li></ul><table><thead><tr><th style=text-align:center>Google</th><th style=text-align:center>Amazon</th></tr></thead><tbody><tr><td style=text-align:center>3</td><td style=text-align:center>2</td></tr></tbody></table><pre><code class=language-go>/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return 	     -1 if num is lower than the guess number
 *			      1 if num is higher than the guess number
 *               otherwise return 0
 * func guess(num int) int;
 */
// 训练营写法
func guessNumber(n int) int {
    left, right := 0, n
    for left &lt; right {
        mid := (left + right) &gt;&gt; 1
        if guess(mid) &lt;= 0 {
            right = mid
        } else {
            left = mid + 1
        }
    }
    return right
}
// 自己
func guessNumber(n int) int {
    left, right := 1, n
    for left &lt;= right {
        mid := (left+right) &gt;&gt; 1
        pick := guess(mid)
        if pick == 0 {
            return mid
        } else if pick == -1 {
            right = mid - 1
        } else {
            left = mid + 1
        }
    }
    return right
}
// 官方题解
func guessNumber(n int) int {
    return sort.Search(n, func(x int) bool { return guess(x) &lt;= 0 })
}
</code></pre><ul><li><a href=https://leetcode-cn.com/problems/split-array-largest-sum/ target=_blank rel=noopener>410.分割数组的最大值</a>
<strong>重点</strong></li></ul><p>（Hard）半年内出题频次：</p><table><thead><tr><th style=text-align:center>Google</th><th style=text-align:center>字节跳动</th><th style=text-align:center>Shopee</th><th style=text-align:center>Amazon</th><th style=text-align:center>腾讯</th><th style=text-align:center>Apple</th></tr></thead><tbody><tr><td style=text-align:center>12</td><td style=text-align:center>2</td><td style=text-align:center>3</td><td style=text-align:center>8</td><td style=text-align:center>2</td><td style=text-align:center>2</td></tr></tbody></table><pre><code class=language-go>// 训练营
func splitArray(nums []int, m int) int {
    left, right := 0, 0
    for _, num := range nums {
        right += num
        if left &lt; num {
            left = num
        }
    }
    for left &lt; right {
        mid := (left + right) &gt;&gt; 1
        if validate(nums, m, mid) {
            right = mid
        } else {
            left = mid+1
        }
    }
    return right
}

func validate(nums[]int, m, size int) bool {
    count, box := 1, 0
    for _, num := range nums {
        if box + num &lt;= size {
            box += num
        } else {
            box = num
            count++
        }
    }
    return count &lt;= m
}
</code></pre><ul><li><a href=https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/ target=_blank rel=noopener>1482.制作 m 束花所需的最少天数</a>
<strong>重点</strong></li></ul><p>（Medium） 2 年内出过此题：</p><table><thead><tr><th style=text-align:center>Facebook</th><th style=text-align:center>VMware</th><th style=text-align:center>Bloomberg</th><th style=text-align:center>Salesforce</th></tr></thead><tbody><tr><td style=text-align:center>Google</td><td style=text-align:center>字节跳动</td><td style=text-align:center>Adobe</td><td style=text-align:center>Apple</td></tr></tbody></table><pre><code class=language-go>// 训练营
func minDays(bloomDay []int, m int, k int) int {
    left, latestBloom := 0, 0
    for _, bloom := range bloomDay {
        if latestBloom &lt; bloom {
            latestBloom = bloom
        }
    }
    right := latestBloom + 1
    for left &lt; right {
        mid := (left + right) &gt;&gt; 1
        if validate(bloomDay, m, k, mid) {
            right = mid
        } else {
            left = mid + 1
        }
    }
    if right == latestBloom + 1 {
        return -1
    }
    return right
}

func validate(bloomDay []int, m, k int, now int) bool {
    bouquet, consecutine := 0, 0
    for _, bloom := range bloomDay {
        if bloom &lt;= now {
            consecutine++
            if bouquet == k {
                bouquet = 0
                bouquet++
            }
        } else {
            consecutine = 0
        }
    }
    return bouquet &gt;= m
}
</code></pre><h3 id=第-10-课-排序>第 10 课 排序</h3><h4 id=排序>排序</h4><ul><li><a href=https://leetcode-cn.com/problems/sort-an-array/ target=_blank rel=noopener>912.排序数组</a>
<strong>重点</strong></li></ul><p>（Medium）半年内出题频次：</p><table><thead><tr><th style=text-align:center>百度</th><th style=text-align:center>字节跳动</th><th style=text-align:center>Amazon</th><th style=text-align:center>微软</th><th style=text-align:center>同花顺</th></tr></thead><tbody><tr><td style=text-align:center>3</td><td style=text-align:center>13</td><td style=text-align:center>5</td><td style=text-align:center>2</td><td style=text-align:center>2</td></tr></tbody></table><pre><code class=language-go>// todo: 练习10中排序

</code></pre><ul><li><a href=https://leetcode-cn.com/problems/relative-sort-array/ target=_blank rel=noopener>数组的相对排序</a>
<strong>重点</strong></li></ul><p>（Easy）半年内出题频次：</p><table><thead><tr><th style=text-align:center>Amazon</th></tr></thead><tbody><tr><td style=text-align:center>3</td></tr></tbody></table><pre><code class=language-go>// 方法一：排序
func relativeSortArray(arr1 []int, arr2 []int) []int {
    mp := make(map[int]int, len(arr2))
    for i, num := range arr2 {
        mp[num] = i
    }
    sort.Slice(arr1, func(i, j int) bool {
        x, xo := mp[arr1[i]]
        if !xo {
            x = len(arr1)
        }
        y, yo := mp[arr1[j]]
        if !yo  {
            y = len(arr1)
        }
        return x &lt; y || (x == y &amp;&amp; arr1[i] &lt; arr1[j])
    })
    return arr1
}
// 方法二：计数
// https://leetcode-cn.com/submissions/detail/261393931/
// https://leetcode-cn.com/submissions/detail/123303531/
func relativeSortArray(arr1 []int, arr2 []int) (ans []int) {
   cnt := make([]int, 10001)
   for _, v := range arr1 {
       cnt[v]++
   }
   for _, v := range arr2 {
       for cnt[v] &gt; 0 {
           ans = append(ans, v)
           cnt[v]--
       }
   }
   for v := range cnt {
       for cnt[v] &gt; 0 {
           ans = append(ans, v)
           cnt[v]--
       }
   }
   return ans
}
</code></pre><ul><li><a href=https://leetcode-cn.com/problems/merge-intervals/ target=_blank rel=noopener>合并区间</a>
<strong>重点</strong></li></ul><p>（Medium）半年内出题频次：</p><table><thead><tr><th style=text-align:center>Facebook</th><th style=text-align:center>字节跳动</th><th style=text-align:center>微软</th><th style=text-align:center>Amazon</th><th style=text-align:center>Apple</th><th style=text-align:center>IBM</th><th style=text-align:center>Google</th><th style=text-align:center>eBay</th><th style=text-align:center>VMware</th><th style=text-align:center>LinkedIn</th></tr></thead><tbody><tr><td style=text-align:center>57</td><td style=text-align:center>29</td><td style=text-align:center>35</td><td style=text-align:center>70</td><td style=text-align:center>7</td><td style=text-align:center>8</td><td style=text-align:center>17</td><td style=text-align:center>5</td><td style=text-align:center>7</td><td style=text-align:center>4</td></tr></tbody></table><pre><code class=language-go>// 写法一：
func merge(intervals [][]int) (ans [][]int) {
    if len(intervals) &lt;= 1 {
		return intervals
	}
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] &lt; intervals[j][0] || (intervals[i][0] == intervals[j][0] &amp;&amp; intervals[i][1] &lt; intervals[j][1])
    })
    // 其他提交记录，均为下面写法不同
    cur := intervals[0]
    for i := 1; i &lt; len(intervals); i++ {
        if cur[1] &gt;= intervals[i][0] {
            cur[1] = max(cur[1], intervals[i][1])
        } else {
            ans = append(ans, cur)
            cur = intervals[i]
        }
    }
    ans = append(ans, cur)
    return ans
}
func max(a, b int) int {
    if a &gt; b {
        return a
    }
    return b
}
// 写法二：
func merge(intervals [][]int) (res [][]int) {
	if len(intervals) &lt;= 1 {
		return intervals
	}

	// 第一个数字升序
	sort.Slice(intervals, func(i, j int) bool {
		return intervals[i][0] &lt; intervals[j][0]
	})

	left, right := intervals[0][0], intervals[0][1]
	for i := 1; i &lt; len(intervals); i++ {
		if right &gt;= intervals[i][0] {
			// 有交叉
			right = max(right, intervals[i][1])
		} else {
			res = append(res, []int{left, right})
			left, right = intervals[i][0], intervals[i][1]
		}
	}
	res = append(res, []int{left, right})

	return res
}

// 训练营：go翻译版本
func merge(intervals [][]int) (ans [][]int) {
    if len(intervals) &lt;= 1 {
		return intervals
	}
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] &lt; intervals[j][0] || (intervals[i][0] == intervals[j][0] &amp;&amp; intervals[i][1] &lt; intervals[j][1])
    })
    start, end := -1, -1
    for _, interval := range intervals {
        left, right := interval[0], interval[1]
        if left &lt;= end {
            end = max(end, right)
        } else {
            if end != -1 {
                ans = append(ans, []int{start, end})
            }
            start = left
            end = right
        }
    }
    ans = append(ans, []int{start, end})
    return ans
}
</code></pre><pre><code class=language-c++>// 训练营解法一

// 训练营解法二
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {
        vector&lt;pair&lt;int, int&gt;&gt; events;
        for (const vector&lt;int&gt; &amp;interval : intervals) {
            events.push_back({interval[0], 1});
            events.push_back({interval[1] + 1, -1});
        }
        sort(events.begin(), events.end());
        int covering = 0;
        int start;
        vector&lt;vector&lt;int&gt;&gt; ans;
        for (const pair&lt;int, int&gt;&amp; event : events) {
            if (covering == 0) start = event.first;
            covering += event.second;
            if (covering == 0) {
                ans.push_back({start, event.first - 1});
            }
        }
        return ans;
    }
};
</code></pre><ul><li><a href=https://leetcode-cn.com/problems/kth-largest-element-in-an-array/ target=_blank rel=noopener>数组中的第 K 个最大元素</a>
<strong>重点</strong></li></ul><p>（Medium）半年内出题频次：</p><table><thead><tr><th style=text-align:center>Facebook</th><th style=text-align:center>字节跳动</th><th style=text-align:center>微软</th><th style=text-align:center>Amazon</th><th style=text-align:center>高盛集团</th><th style=text-align:center>LinkedIn</th><th style=text-align:center>Google</th><th style=text-align:center>腾讯</th><th style=text-align:center>Shopee</th><th style=text-align:center>百度</th></tr></thead><tbody><tr><td style=text-align:center>76</td><td style=text-align:center>23</td><td style=text-align:center>9</td><td style=text-align:center>22</td><td style=text-align:center>6</td><td style=text-align:center>15</td><td style=text-align:center>5</td><td style=text-align:center>5</td><td style=text-align:center>5</td><td style=text-align:center>3</td></tr></tbody></table><pre><code class=language-go>// 最佳解法：利用快排
func findKthLargest(nums []int, k int) int {
    return quickSort(nums, 0, len(nums) - 1, len(nums) - k)
}

func quickSort(nums []int, left, right, idx int) int {
    if left &gt;= right {
        return nums[left]
    }
    pivot := partition(nums, left, right)
    if idx &lt;= pivot {
        return quickSort(nums, left, pivot, idx)
    } else {
        return quickSort(nums, pivot + 1, right, idx)
    }
}

func partition(nums []int, l, r int) int {
    pivot := l + (r - l) &gt;&gt; 1
    pivotVal := nums[pivot]
    for l &lt;= r {
        for nums[l] &lt; pivotVal {l++}
        for pivotVal &lt; nums[r] {r--}
        if l == r {
            break
        }
        if l &lt; r {
            nums[l], nums[r] = nums[r], nums[l]
            l++
            r--
        }
    }
    return r
}
</code></pre><pre><code class=language-c++>// 训练营
class Solution {
public:
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
        return quickSort(nums, 0, nums.size()-1, nums.size()-k);
    }
private:
    int quickSort(vector&lt;int&gt;&amp; nums, int l, int r, int index) {
        if (l &gt;= r) {
            return nums[l];
        }
        int pivot = partition(nums, l, r);
        if (index &lt;= pivot) {
            return quickSort(nums, l, pivot, index);
        } else {
            return quickSort(nums, pivot + 1, r, index);
        }
    }
    int partition(vector&lt;int&gt;&amp; nums, int l, int r) {
        int pivot = l + rand() % (r - l + 1);
        int pivotVal = nums[pivot];
        while (l &lt;= r) {
            while (nums[l] &lt; pivotVal) l++;
            while (nums[r] &gt; pivotVal) r--;
            if (l == r) break;
            if (l &lt; r) {
                int tmp = nums[l];
                nums[l] = nums[r];
                nums[r] = tmp;
                l++; r--;
            }
        }
        return r;
    }
};
// 方法二：最小堆
class Solution {
public:
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
      //最小堆
      std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; Q;
      //遍历nums数组
      for (int i = 0; i &lt; nums.size(); i++){
        if (Q.size() &lt; k) {
          Q.push(nums[i]);
        } else if (nums[i] &gt; Q.top()) {
          Q.pop();
          Q.push(nums[i]);
        }
      }
      return Q.top();//返回堆顶
    }
};
</code></pre><ul><li><a href=https://www.acwing.com/problem/content/description/106/ target=_blank rel=noopener>104.货仓选址</a>
（Easy）（ACWing）</li></ul><pre><code class=language-c++>// 训练营写法，排序取中位数，在迭代计算
#include&lt;bits/stdc++.h&gt;
using namespace std;

int a[100000];

int main() {
    int n;
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
    sort(a, a + n);
    int pos = a[n / 2];
    int ans = 0;
    for (int i = 0; i &lt; n; i++)  ans += abs(pos - a[i]);
    cout &lt;&lt; ans &lt;&lt; endl;
}
</code></pre><ul><li><a href=https://leetcode-cn.com/problems/reverse-pairs/ target=_blank rel=noopener>493.翻转对</a>
<strong>重点</strong></li></ul><p>（Hard）半年内出题频次：</p><table><thead><tr><th style=text-align:center>Amazon</th><th style=text-align:center>Google</th><th style=text-align:center>Facebook</th></tr></thead><tbody><tr><td style=text-align:center>4</td><td style=text-align:center>4</td><td style=text-align:center>2</td></tr></tbody></table><pre><code class=language-go>// 官方其他解法：树状数组，（参考 327. 区间和的个数 官方题解更多解法）
// 训练营写法
func reversePairs(nums []int) (ans int) {
	mergeSort(nums, 0, len(nums)-1, &amp;ans)
	return ans
}

func mergeSort(nums []int, left, right int, count *int) {
	if left &gt;= right {
		return
	}
	mid := left + (right - left) &gt;&gt; 1
	mergeSort(nums, left, mid, count)
	mergeSort(nums, mid + 1, right, count)
	counter(nums, left, mid , right, count)
	merge(nums, left, mid, right)
}

func counter(nums []int, left, mid, right int, count *int) {
	j := mid + 1 // j := mid 
	for i := left; i &lt;= mid; i++ {
		for j &lt;= right &amp;&amp; nums[i] &gt; 2 * nums[j] { // for j &lt;= right &amp;&amp; nums[i] &gt; 2 * nums[j + 1] {
			j++
		}
		*count += j - mid - 1 // *count += j - mid
	}
}

func merge(nums []int, left, mid, right int)  {
	tmp := make([]int, right - left + 1)
	i, j := left, mid + 1
	for k := 0; k &lt; len(tmp); k++ {
		if j &gt; right || (i &lt;= mid &amp;&amp; nums[i] &lt;= nums[j]) {
			tmp[k], i = nums[i], i + 1
		} else {
			tmp[k], j = nums[j], j + 1
		}
	}
	for k, v := range tmp {
		nums[left+k] = v
	}
}
</code></pre><p>简化归并：https://leetcode-cn.com/submissions/detail/261660445/</p><pre><code class=language-go>func reversePairs(nums []int) int {
    return mergeSort(nums, 0, len(nums) - 1)
}

func mergeSort(nums []int, left int, right int) int {
   if left &gt;= right {
        return 0
    }
    mid := left + (right - left) &gt;&gt; 1
    cnt := mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)
    // 计算翻转对，并归并
    cache := make([]int, right - left + 1)
    c, i, l := 0, left, left
    for j := mid + 1; j &lt;= right; j, c = j + 1, c + 1 {
        for i &lt;= mid &amp;&amp; nums[i] &lt;= nums[j] * 2 {
            i++
        }
        for ; l &lt;= mid &amp;&amp; nums[l] &lt; nums[j]; l, c = l + 1, c + 1 {
            cache[c] = nums[l]
        }
        cache[c] = nums[j]
        cnt += mid - i + 1 // i -&gt; mid 是 ok 的
    }
    for ; l &lt;= mid; l, c = l + 1, c + 1 {
        cache[c] = nums[l]
    }
    // 合并
    for i, n := 0, right - left + 1; i &lt; n; i++ {
        nums[left + i] = cache[i]
    }
    return cnt
}
</code></pre><p>标准归并：https://leetcode-cn.com/submissions/detail/261652038/</p><pre><code class=language-go>// 使用归并排序统计
func reversePairs(nums []int) int {
    res := make([]int,len(nums))
    count := 0
    mergeSort(nums, res, 0, len(res)-1, &amp;count)
    return count
}

func mergeSort(nums, res []int, start, end int, count *int)  {
    if start &gt;= end {
        return 
    }

    mid := start + (end - start) &gt;&gt; 1
    mergeSort(nums, res, start, mid, count)
    mergeSort(nums, res, mid+1, end, count)
    counter(nums, start, end, count)
    merge(nums, res, start, end)
}

func counter(nums []int, start, end int, count *int) {
    mid := start + (end - start) &gt;&gt; 1
    l1, l2 := start, mid + 1
    for l1 &lt;= mid &amp;&amp; l2 &lt;= end {
        if nums[l1] &gt; 2 * nums[l2] {
            *count += mid - l1 + 1
            l2++
        } else {
            l1++
        }
    }
}

func merge(nums, res []int,start,end int) {
    //遍历指针
    mid := start + (end - start) &gt;&gt; 1
    index1,index2 := start, mid+1
    t := start
    for index1 &lt;= mid &amp;&amp; index2 &lt;= end{
        if nums[index1] &lt;= nums[index2]{
            res[t] = nums[index1]
            index1++; t++
        }else{
            res[t] = nums[index2]
            index2++; t++
            //此时右边的数小于左边的数，记录逆序对
        }
    }
    // 补全剩余的数字
    for index1 &lt;= mid{
        res[t] = nums[index1]
        index1++; t++
    }
    for index2 &lt;= end {
        res[t] = nums[index2]
        index2++; t++
    }

    for start &lt;= end {
        nums[start] = res[start]
        start++
    }
}
</code></pre><p>官方简化归并：https://leetcode-cn.com/submissions/detail/126933753/</p><pre><code class=language-go>func reversePairs(nums []int) int {
    n := len(nums)
    if n &lt;= 1 {
        return 0
    }

    n1 := append([]int(nil), nums[:n/2]...)
    n2 := append([]int(nil), nums[n/2:]...)
    cnt := reversePairs(n1) + reversePairs(n2) // 递归完毕后，n1 和 n2 均为有序

    // 统计重要翻转对 (i,j) 的数量
    // 由于 n1 和 n2 均为有序，可以用两个指针同时遍历
    j := 0
    for _, v := range n1 {
        for j &lt; len(n2) &amp;&amp; v &gt; 2*n2[j] {
            j++
        }
        cnt += j
    }

    // n1 和 n2 归并填入 nums
    p1, p2 := 0, 0
    for i := range nums {
        if p1 &lt; len(n1) &amp;&amp; (p2 == len(n2) || n1[p1] &lt;= n2[p2]) {
            nums[i] = n1[p1]
            p1++
        } else {
            nums[i] = n2[p2]
            p2++
        }
    }
    return cnt
}
</code></pre></article><div class="-mx-2 mt-4 flex flex-col border-t px-2 pt-4 md:flex-row md:justify-between"><div><span class="text-primary-text block font-bold">上一页</span>
<a href=/study/2021algorithm/week04/ class=block>第四周 深度优先搜索、广度优先搜索、二叉堆、二叉搜索树</a></div><div class="mt-4 md:mt-0 md:text-right"><span class="text-primary-text block font-bold">下一页</span>
<a href=/study/2021algorithm/week06/ class=block>第六周 贪心、动态规划</a></div></div></div><div class="hidden lg:block lg:w-1/4"><div class="bg-secondary-bg
prose sticky top-16 z-10 hidden px-6 py-4 lg:block"><h3>本页内容</h3></div><div class="sticky-toc
border-s
hidden px-6 pb-6 lg:block"><nav id=TableOfContents><ul><li><a href=#本周作业>本周作业</a></li><li><a href=#实战例题>实战例题</a><ul><li><a href=#第-9-课-二分>第 9 课 二分</a><ul><li><a href=#二分查找>二分查找</a></li><li><a href=#三分查找>三分查找</a></li><li><a href=#二分答案>二分答案</a></li></ul></li><li><a href=#第-10-课-排序>第 10 课 排序</a><ul><li><a href=#排序>排序</a></li></ul></li></ul></li></ul></nav></div><script>window.addEventListener("DOMContentLoaded",()=>{enableStickyToc()})</script></div></div></div></div></div><script>document.addEventListener("DOMContentLoaded",()=>{hljs.highlightAll(),changeSidebarHeight(),switchDocToc()})</script></div></div></main><footer class=pl-scrollbar><div class="mx-auto w-full max-w-screen-xl"><div class="text-center p-6 pin-b"><p class="text-sm text-tertiary-text">&copy; 2021 <a href=https://blog.lbbniu.com/>lbbniu</a>
&#183; Powered by the <a href=https://github.com/wangchucheng/hugo-eureka class=hover:text-eureka>Eureka</a> theme for <a href=https://gohugo.io class=hover:text-eureka>Hugo</a></p></div></div></footer></body></html>