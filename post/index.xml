<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>文章列表 on lbbniu</title><link>/post/</link><description>Recent content in 文章列表 on lbbniu</description><generator>Hugo -- gohugo.io</generator><language>zh</language><managingEditor>lbbniu@gmail.com (lbbniu)</managingEditor><webMaster>lbbniu@gmail.com (lbbniu)</webMaster><copyright>&amp;copy; 2021 &lt;a href="https://blog.lbbniu.com/">lbbniu&lt;/a></copyright><lastBuildDate>Sat, 20 Nov 2021 17:18:16 +0800</lastBuildDate><atom:link href="/post/index.xml" rel="self" type="application/rss+xml"/><item><title>模板-标题</title><link>/2024/01/15/uri-addr/</link><pubDate>Mon, 15 Jan 2024 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2024/01/15/uri-addr/</guid><description>关注公众号获得更多精彩文章</description></item><item><title>写给go开发者的Tars教程-拦截器</title><link>/2024/01/06/tarsgo-middleware/</link><pubDate>Sat, 06 Jan 2024 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2024/01/06/tarsgo-middleware/</guid><description>本篇为【写给go开发者的Tars教程】系列第三篇
第一篇：Tars协议基础 第二篇：通信模式 第三篇：拦截器
TarsGo的拦截器和其他框架的拦截器（也称middleware）作用是一样的。利用拦截器我们可以在不侵入业务逻辑的前提下修改或者记录服务端或客户端的请求与响应，利用拦截器我们可以实现诸如日志记录、权限认证、限流、链路追踪等诸多功能。拦截器可以分别应用在服务端和客户端，所以TarsGo总共为我们提供了多种拦截器，下面我们进行一一介绍。
服务端拦截器（过滤器） 处理前后拦截器（过滤器） 拦截器定义如下：
// Dispatch server side Dispatch type Dispatch func(context.Context, interface{}, *requestf.RequestPacket, *requestf.ResponsePacket, bool) error // ServerFilter is used for add Filter for server dispatcher ,for implementing plugins like opentracing. type ServerFilter func(ctx context.Context, d Dispatch, f interface{}, req *requestf.RequestPacket, resp *requestf.ResponsePacket, withContext bool) (err error) 注册服务端拦截器的方法如下：
func RegisterServerFilter(f ServerFilter) // 注册服务端拦截器，只能注册一个 func RegisterPreServerFilter(f ServerFilter) // 注册服务端处理前拦截器，可多个 func RegisterPostServerFilter(f ServerFilter) // 注册服务端处理后拦截器，可多个 不推荐上面三种注册方法来注册拦截件，将在1.5版本后彻底废弃移除，推荐使用下面介绍的中间件实现对应的逻辑。
示例：
// 注册服务端过滤器 tars.RegisterServerFilter(func(ctx context.Context, d tars.</description></item><item><title>一篇文章精通php多版本管理工具：phpbrew</title><link>/2024/01/04/phpbrew/</link><pubDate>Thu, 04 Jan 2024 22:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2024/01/04/phpbrew/</guid><description>大家好，我是lbbniu。
今天给大家介绍以下 Uber 开源的静态分析工具 NilAway，下面开鲁。
最近 Uber 开发和开源了一个挺不错的静态分析工具 NilAway：
NilAway是一个静态分析工具，旨在通过在编译时而不是运行时捕获nil panic来帮助开发人员避免在生产中出现这种情况。NilAway类似于标准的nilness分析器，但它采用更复杂和强大的静态分析技术来跟踪包内和跨包的nil流，并报告错误，为用户提供更轻松的调试nilness流程。
NilAway具有三个关键特性，使其脱颖而出：
完全自动化：NilAway配备有推理引擎，因此除了标准的Go代码之外，它不需要从开发人员那里获取任何其他信息（例如注释）。 速度快：我们设计NilAway为快速且可扩展，适用于大型代码库。在我们的测量中，启用NilAway时构建时间开销不到5%。我们还在不断应用优化来进一步减少其占用空间。 实用性：它不能阻止代码中所有可能的nil panic，但它可以捕获我们在生产中观察到的大多数潜在nil panic，使NilAway在实用性和构建时间开销之间保持良好平衡。 安装 NilAway是使用标准的go/analysis框架实现的，因此易于与现有的分析驱动程序集成（例如golangci-lint、nogo或作为独立检查器运行）。下面是将NilAway作为独立检查器运行的说明。更多集成支持将很快添加。
独立检查器 通过以下命令从源代码安装二进制文件：
go install go.uber.org/nilaway/cmd/nilaway@latest 然后，通过以下命令运行linter：
nilaway ./... 代码示例 案例一 让我们看一些示例，了解NilAway如何帮助防止nil panic。
// Example 1: var p *P if someCondition { p = &amp;amp;P{} } print(p.f) // nilness reports NO error here, but NilAway does. 在这个示例中，局部变量p仅在someCondition为true时初始化。在字段访问p.f时，如果someCondition为false，则可能发生panic。NilAway能够捕获这个潜在的nil导致的panic并报告以下错误：
go.uber.org/example.go:12:9: error: Potential nil panic detected. Observed nil flow from source to dereference point: -&amp;gt; go.uber.org/example.go:12:9: unassigned variable `p` accessed field `f` 如果我们使用nil检查（if p !</description></item><item><title>用Golang助力表妹轻松实现自动化办公！（完整代码附后）</title><link>/2023/12/10/goalng-execl/</link><pubDate>Sun, 10 Dec 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/12/10/goalng-execl/</guid><description>Hello，大家好，我是lbbniu~
今天有一个有趣的编程需求要分享，这次的灵感来源于我可爱的表妹。简单来说，我们将利用Golang对Excel文件进行批量处理，达到高效自动化办公的目的。
一、具体需求 手上有一系列N个表格，每个表格都有相同的结构，看起来就像这样：
任务是将所有表中的数据汇总，按照每个人的得分和积分进行合计，然后按总积分排名。在总积分相同的情况下，名次也相同但不是连续的排序。如果总积分和名次都相同，再按总得分降序展示，但不改变排名。
结果如下图所示：
二、Golang开发 首先，让我们引入需要的包：
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;log&amp;quot; &amp;quot;path/filepath&amp;quot; &amp;quot;sort&amp;quot; &amp;quot;github.com/tealeg/xlsx&amp;quot; ) 接下来，获取所有Excel文件的路径：
func getExcelFiles() []string { files, err := filepath.Glob(&amp;quot;./样例数据/*.xlsx&amp;quot;) if err != nil { log.Fatal(err) } return files } 然后，将各表数据合并到主结构体：
// Record 结构体表示每个人的记录 type Record struct { Name string Monthly int Points int Ranking int } func getCellValue(cell *xlsx.Cell) int { value, err := cell.Int() if err != nil { log.Fatal(err) } return value } func mergeData(files []string) []Record { var mergedData []Record for _, file := range files { // 读取Excel文件 xlFile, err := xlsx.</description></item><item><title>写给go开发者的Tars教程-Tars协议基础</title><link>/2023/06/18/tarsgo-protocol/</link><pubDate>Sun, 18 Jun 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/06/18/tarsgo-protocol/</guid><description>简介 Tars这个名字取自于电影&amp;quot;星际穿越&amp;quot;中的机器人，它是基于名字服务使用Tars协议的高性能RPC开发框架，配套一体化的运营管理平台，并通过伸缩调度，实现运维半托管服务。
Tars是腾讯从2008年到今天一直在使用的后台逻辑层的统一应用框架TAF（Total Application Framework），目前支持C++、Java、PHP、Nodejs、Go语言。该框架为用户提供了涉及到开发、运维、以及测试的一整套解决方案，帮助一个产品或者服务快速开发、部署、测试、上线。 它集可扩展协议编解码、高性能RPC通信框架、名字路由与发现、发布监控、日志统计、配置管理等于一体，通过它可以快速用微服务的方式构建自己的稳定可靠的分布式应用，并实现完整有效的服务治理。
目前该框架在腾讯内部，各大核心业务都在使用，颇受欢迎，基于该框架部署运行的服务节点规模达到上万个。
支持平台 目前运行的操作系统平台如下：
Linux
Mac(&amp;gt;=2.1.0 support)
支持语言 目前支持的开发语言如下：
C++
Java
Nodejs
PHP
Go
版本管理 Tars由多种模块组成, 分散在多个仓库中, 并且基础框架版本和语言版本可以独立发展, 鉴于此, 从2.1.0版本开始, 框架的版本TAG打在TarsFramework仓库上, 不再体现在Tars这个仓库上.
Tars IDL 所谓序列化通俗来说就是把内存的一段数据转化成二进制并存储或者通过网络传输，而读取磁盘或另一端收到后可以在内存中重建这段数据
1、tars协议是跨语言跨平台的序列化协议。
2、tars协议本身也可以被用于非RPC场景，如存储
json、 xml都是一种序列化的方式，只是他们不需要提前预定义idl，且具备可读性，当然他们传输的体积也因此较大，可以说是各有优劣。
关键字 void,struct,bool,byte,short,int,double,float,long,string,vector,map,key,routekey,module,interface,out,require,optional,false,true,enum,const 注释 采用 c++的注释规范：
//表示注释一行 /**/表示注释范围中的所有代码。 基本类型 基本类型会涉及到不同语言和编码方式，这里只整理tars和go类型对照表
.tars Type Go Type Notes void 函数无返回值 只能在函数的返回值表示 bool bool 布尔类型 byte int8 有符号字符 unsigned byte uint8 无符号字符 short int16 有符号短整型 unsigned short uint16 无符号短整形 int int32 有符号整型 unsigned int uint32 无符号整形 long int64 有符号长整型 float float32 32位浮点数 double float64 64位浮点数 string string 字符串 复杂类型 .</description></item><item><title>写给Go开发者的Tars教程-通信模式</title><link>/2023/06/18/tarsgo-rpc/</link><pubDate>Sun, 18 Jun 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/06/18/tarsgo-rpc/</guid><description>本篇为【写给Go开发者的Tars教程系列】第二篇
第一篇：Tars协议基础 第二篇：通信模式 上一篇介绍了如何编写 Tars 的 idl，并使用 idl 生成了 TarsGo RPC 的代码，现在来看看如何编写客户端和服务端的代码
Tars 示例 IDL module order { struct Order { 1 require string id; 2 optional vector&amp;lt;string&amp;gt; items; 3 optional string description; 4 require float price; 5 optional string destination; }; interface OrderManagement { Order getOrder(string orderId); }; }; 生成 go 协议编解码代码 tars2go -outdir=. \ -module=github.com/lbbniu/TarsGo-tutorial \ proto/order.tars order ├── order.go └── OrderManagement.tars.go proto └── order.tars server 实现 服务端开发 1、由 Tars 文件生成的 Go 代码中包含了 interface 的接口定义，它和我们定义的 idl 是吻合的</description></item><item><title>Redis Cluster vs Codis Slot Rebalance 算法</title><link>/2023/03/26/redis-cluster-vs-codis-slot-rebalance-%E7%AE%97%E6%B3%95/</link><pubDate>Sun, 26 Mar 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/03/26/redis-cluster-vs-codis-slot-rebalance-%E7%AE%97%E6%B3%95/</guid><description>Redis Cluster Slot Rebalance算法 迁移原则 尽可能的均匀分配Slots； 尽量减少迁移的Slots的数量； Slots分配方案 计算集群的总权重，节点数量； 计算每个集群节点需要移出或移入的槽数，balance 如果为正数代表需要移出的槽数，如果为负数代表需要出入槽数； 把weightedNodes 根据 balance 排序从小到大； 执行槽位移动，并更新集群节点 balance； 代码实现 static int clusterManagerCommandRebalance(int argc, char **argv) { int port = 0; char *ip = NULL; clusterManagerNode **weightedNodes = NULL; list *involved = NULL; if (!getClusterHostFromCmdArgs(argc, argv, &amp;amp;ip, &amp;amp;port)) goto invalid_args; clusterManagerNode *node = clusterManagerNewNode(ip, port, 0); if (!clusterManagerLoadInfoFromNode(node)) return 0; int result = 1, i; if (config.cluster_manager_command.weight != NULL) { for (i = 0; i &amp;lt; config.cluster_manager_command.weight_argc; i++) { char *name = config.</description></item><item><title>Golang语法的25个练习题：21至25题</title><link>/2023/02/24/uri-addr/</link><pubDate>Fri, 24 Feb 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/02/24/uri-addr/</guid><description>题目21：三个数取最大数 己知数字a，b，c分别为10，6，18
找出a，b，c中最大的数字(不借助函数以及列表等方式)
我们知道函数max可以直接获取到最大值，或者可以把数字添加到列表里，通过排序也能获取到最大数字，我们单纯使用if分支来实现
package main import &amp;quot;fmt&amp;quot; func main() { a, b, c := 10, 6, 8 max := a if max &amp;lt; b { max = b } if max &amp;lt; c { max = c } fmt.Println(max) } 题目22：因子之和“完数” 什么是因子？
因子就是所有可以整除这个数的数字，包括1但不包括这个数自身。比如8的因子有1，2，4
什么是完数？
一个数如果恰好等于它的因子之和，这个数就称为“完数”，打印输出1000以内的完数，例如6=1+2+3，6就是“完数
package main import &amp;quot;fmt&amp;quot; func main() { for i := 1; i &amp;lt; 1000; i++ { if i == factorSum(i) { fmt.Println(&amp;quot;//&amp;quot;, i) } } // output: // 6 // 28 // 496 } func factorSum(n int) int { sum := 0 for i := 1; i &amp;lt; n; i++ { if n%i == 0 { sum += i } } return sum } 题目23：递归阶乘求和 一个正整数的阶乘(factorial)是所有小于及等于该数的正整数之积，并且0的阶乘为1</description></item><item><title>Golang语法的25个练习题：16至20题</title><link>/2023/02/23/uri-addr/</link><pubDate>Thu, 23 Feb 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/02/23/uri-addr/</guid><description>题目16：大衍数列 中国古代文献中，曾记载过“大衍数列”，主要用于解释中国传统文化中的太极衍生原理
它的前几项是：0、2、4、8、12、18、24、32、40、50&amp;hellip;
其规律是：偶数项，是序号平方再除2，奇数项，是序号平方减1再除2。
打印大衍数列的前100项
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;math&amp;quot; ) func main() { for i := 1; i &amp;lt;= 100; i++ { var a int if i%2 == 0 { // 偶数 a = int(math.Pow(float64(i), 2)) / 2 } else { // 奇数 a = (int(math.Pow(float64(i), 2)) - 1) / 2 } fmt.Println(&amp;quot;//&amp;quot;, a) } // 0 // 2 // 4 // 8 // 12 // 18 // 24 // 32 // 40 // 50 } 题目17：单词分析 小蓝正在学习一门神奇的语言，这门语言中的单词都是由小写英文字母组成，有些单词很长，远远超过正常英文单词的长度。小蓝学了很长时间也记不住一些单词，他准备不再完全记忆这些单词，而是根据单词中哪个字母出现得最多来分辨单词 现在，请你帮助小蓝，给了一个单词后，帮助他找到出现最多的字母和这个字母出现的次数 其实就是让你输入一段字符串后，得到当前字符串出现最多的字母和它的次数 输入：HelloWorld 输出： l 3 我们可以对当前的字符串进行循环迭代，然后把字符串当前每个字符当作key值，把它存到字典里面，如果当前key在字典里面，我们就让它加一，如果不在那我们就让它的次数初始化为1，最终我们再从字典找到次数最多的key值和value值 package main import &amp;quot;fmt&amp;quot; func main() { analyseWords(&amp;quot;helloworld&amp;quot;) // l 3 } func analyseWords(word string) { wordDict := map[rune]int{} var ( count int ch rune ) for _, c := range word { wordDict[c]++ if wordDict[c] &amp;gt; count { count, ch = wordDict[c], c } } fmt.</description></item><item><title>Golang语法的25个练习题：11至15题</title><link>/2023/02/22/uri-addr/</link><pubDate>Wed, 22 Feb 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/02/22/uri-addr/</guid><description>题目11：剪刀石头布 游戏开始，初始状态下用户和电脑都有100分，赢一局+10分，输一局-10分。当用户为0分时，游戏结束，提示游戏结束，比赛输了，当用户为200分时，游戏结束，提示游戏结束，赢得比赛、每轮比赛都输出当前的分数
1代表剪刀 2代表石头 3代表布
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;math/rand&amp;quot; &amp;quot;os&amp;quot; &amp;quot;strconv&amp;quot; &amp;quot;strings&amp;quot; &amp;quot;time&amp;quot; ) var ( gameInfo = map[int]string{ 1: &amp;quot;剪刀&amp;quot;, 2: &amp;quot;石头&amp;quot;, 3: &amp;quot;布&amp;quot;, } score = 100 ) func main() { fmt.Println(strings.Repeat(&amp;quot;=&amp;quot;, 60)) fmt.Println(strings.Repeat(&amp;quot; &amp;quot;, 20), &amp;quot;剪刀石头布游戏&amp;quot;) fmt.Println(&amp;quot;1代表剪刀 2代表石头 3代表布&amp;quot;) for { rd := rand.New(rand.NewSource(time.Now().UnixNano())) robotsChoice := rd.Intn(3) if robotsChoice == 0 { robotsChoice++ } userChoice, err := input(&amp;quot;请出拳&amp;quot;) if err != nil { fmt.Println(err) continue } if _, ok := gameInfo[userChoice]; !</description></item><item><title>Golang语法的25个练习题：6至10题</title><link>/2023/02/15/uri-addr/</link><pubDate>Wed, 15 Feb 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/02/15/uri-addr/</guid><description>题目6：闰年问题升级版 输入年月日，输出该日期是否是闰年，并且输出该日期是此年份的第几天
闰年判断条件：
能被4整除，并且不能被100整除 能被400整除 两个条件满足任意一个就为闰年 算法思路
接收用户输入的年月日，创建保存12个月份天数的列表 根据年份判断是否是闰年，如果是把二月份设为29天，否则把二月份设为28天 根据月份和日期统计是当年的第几天 package main import ( &amp;quot;fmt&amp;quot; &amp;quot;log&amp;quot; &amp;quot;os&amp;quot; &amp;quot;strconv&amp;quot; ) func main() { year, err := input(&amp;quot;请输入年份&amp;quot;) if err != nil { log.Fatalln(err) } month, err := input(&amp;quot;请输入月份&amp;quot;) if err != nil { log.Fatalln(err) } day, err := input(&amp;quot;请输入日期&amp;quot;) if err != nil { log.Fatalln(err) } dateList := []int{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31} countDay := day if year%4 == 0 &amp;amp;&amp;amp; year%100 !</description></item><item><title>Golang语法的25个练习题：1至5题</title><link>/2023/02/13/uri-addr/</link><pubDate>Mon, 13 Feb 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/02/13/uri-addr/</guid><description>题目1：水仙花数 水仙花数（Narcissistic number）也被称为超完全数字不变数（pluperfect digital invariant, PPDI）、自恋数、自幂数、阿姆斯壮数或阿姆斯特朗数（Armstrong number），水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身。例如：1^3 + 5^3+ 3^3 = 153。
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;math&amp;quot; ) func main() { // 写法一 for i := 100; i &amp;lt; 1000; i++ { // 取百位数字 123//100=1 // 取十位数字 123//10=12 12%10=2 // 取个位数字 123%10=3 i1, i2, i3 := i/100, i/10%10, i%10 if int(math.Pow(float64(i1), 3)+math.Pow(float64(i2), 3)+math.Pow(float64(i3), 3)) == i { fmt.Printf(&amp;quot;%d是水仙花数\n&amp;quot;, i) // 153 是水仙花数 // 370 是水仙花数 // 371 是水仙花数 // 407 是水仙花数 } } // 写法二 for i := 1000; i &amp;lt; 10000; i++ { sum := 0 for k := i; k &amp;gt; 0; k = k / 10 { // 个十百 sum += int(math.</description></item><item><title>一篇文章精通php多版本管理工具：phpbrew</title><link>/2023/01/04/phpbrew/</link><pubDate>Wed, 04 Jan 2023 22:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/01/04/phpbrew/</guid><description>phpbrew是一个工具，可以在$HOME目录中构建和安装多个PHP版本。
phpbrew的功能包括：
将配置选项简化为变体，不再担心路径问题。 使用不同的变体构建PHP，如PDO、mysql、sqlite、debug等。 编译Apache PHP模块，并按不同版本分开。 在个人目录中构建和安装PHP，无需root权限。 轻松切换版本，与bash/zsh shell集成。 自动功能检测。 轻松在当前环境中安装和启用PHP扩展。 在系统范围内安装多个PHP。 针对HomeBrew和MacPorts的路径检测优化。 要求 请查看 Requirement 在开始之前。你需要安装一些用于构建 PHP 的开发包。
安装 只需下载它：
curl -L -O https://github.com/phpbrew/phpbrew/releases/latest/download/phpbrew.phar chmod +x phpbrew.phar 然后，你可以将其安装到 bin 文件夹中：
sudo mv phpbrew.phar /usr/local/bin/phpbrew 确保在你的 $PATH 环境变量中有 /usr/local/bin。
设置 初始化一个用于你的 shell 环境的 bash 脚本：
phpbrew init 将以下行添加到你的 .bashrc 或 .zshrc 文件：
[[ -e ~/.phpbrew/bashrc ]] &amp;amp;&amp;amp; source ~/.phpbrew/bashrc 设置查找前缀 你可以设置你首选的用于查找库的默认前缀，可用选项有 macports、homebrew、debian、ubuntu 或自定义路径：
对于 Homebrew 用户：
phpbrew lookup-prefix homebrew 对于 Macports 用户：
phpbrew lookup-prefix macports 基本用法 列出已知版本：</description></item><item><title>polaris-go 源码走读</title><link>/2022/10/28/polaris-go/</link><pubDate>Fri, 28 Oct 2022 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2022/10/28/polaris-go/</guid><description>provider 实例化ProviderAPI NewProviderAPI() -&amp;gt; 根据默认配置文件./polaris.yaml 实例化 api.newProviderAPI-&amp;gt;api.newProviderAPIByConfig-&amp;gt;api.InitContextByConfig-&amp;gt;[api.newProviderAPIByContext]-&amp;gt;&amp;amp;providerAPI{rawAPI: p} NewProviderAPIByFile(path string) -&amp;gt; 根据指定配置文件实例化 api.newProviderAPIByFile-&amp;gt;api.InitContextByFile-&amp;gt;api.InitContextByStream-&amp;gt;api.InitContextByConfig-&amp;gt;[api.newProviderAPIByContext]-&amp;gt;&amp;amp;providerAPI{rawAPI: p} NewProviderAPIByConfig(cfg config.Configuration) -&amp;gt; 根据指定配置实例化 api.newProviderAPIByConfig-&amp;gt;api.InitContextByConfig-&amp;gt;[api.newProviderAPIByContext] NewProviderAPIByContext(context api.SDKContext) -&amp;gt; 根据指定api.SDKContext实例化 api.newProviderAPIByContext-&amp;gt;&amp;amp;providerAPI{rawAPI: p} NewProviderAPIByAddress(address &amp;hellip;string) -&amp;gt; 根据指定 polaris-server 地址实例化 api.newProviderAPIByAddress-&amp;gt;[config.NewDefaultConfiguration]-&amp;gt;api.newProviderAPIByConfig-&amp;gt;api.InitContextByConfig-&amp;gt;[api.newProviderAPIByContext]-&amp;gt;&amp;amp;providerAPI{rawAPI: p} 以上所有方法最终都会走到api.newProviderAPIByContex方法, 然后返回&amp;amp;providerAPI{rawAPI: p}
![image-20221104120449226](/Users/lbbniu/Library/Application Support/typora-user-images/image-20221104120449226.png)
相关接口定义 // ProviderAPI CL5服务端API的主接口 type ProviderAPI interface { // RegisterInstance // minimum supported version of polaris-server is v1.10.0 RegisterInstance(instance *InstanceRegisterRequest) (*model.InstanceRegisterResponse, error) // Deregister synchronize the anti registration service Deregister(instance *InstanceDeRegisterRequest) error // Destroy the api is destroyed and cannot be called again Destroy() } RegisterInstance // providerAPI 调用者对外函数实现 type providerAPI struct { rawAPI api.</description></item><item><title>Go 实战训练营——开源项目学习计划</title><link>/2022/06/26/open-source-study/</link><pubDate>Sun, 26 Jun 2022 14:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2022/06/26/open-source-study/</guid><description>Go 实战训练营0期： https://shimo.im/docs/3GP6Kwsdm5It9UOV Go实战训练营1期： https://shimo.im/docs/rqizHOhKFrUQKG42/read 开源项目 Web： Beego：https://github.com/beego/beego httprouter：https://github.com/julienschmidt/httprouter Gin：https://github.com/gin-gonic/gin 微服务： Dubbo-go：https://github.com/apache/dubbo-go Kratos：https://github.com/go-kratos/kratos gRPC：https://github.com/grpc/grpc-go orm： GORM：https://github.com/go-gorm/gorm ENT：https://github.com/ent/ent redsync：https://github.com/go-redsync/redsync bytebufferpool：https://github.com/valyala/bytebufferpool errgroup： https://cs.opensource.google/go/x/sync https://pkg.go.dev/golang.org/x/sync/errgroup 关注公众号获得更多精彩文章</description></item><item><title>【腾讯云 Finops Crane 集训营】EHPA控制器核心源码分析</title><link>/2022/02/15/crane-ehpa-code/</link><pubDate>Tue, 15 Feb 2022 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2022/02/15/crane-ehpa-code/</guid><description>官方文档：https://gocrane.io/ Github： https://github.com/gocrane/crane 启动流程 main 函数 craned 启动入口在cmd/craned/main.go文件中，main方法代码如下
func main() { logs.InitLogs() defer logs.FlushLogs() ctx := signals.SetupSignalHandler() if err := app.NewManagerCommand(ctx).Execute(); err != nil { fmt.Fprintf(os.Stderr, &amp;quot;%v\n&amp;quot;, err) os.Exit(1) } } 下面进行逐行分析：
2~3 行初始化日志，历史defer在程序退出前刷新缓存区 5行通过controller-runtime包获取信号监听可取消的context 7行创建cobra.Command命令行实例并直接调用Execute方法启动应用，如果出错退出程序 app.NewManagerCommand方法在cmd/craned/app/manager.go文件中，函数中主要是创建Options和cobra.Command，并初始化命令行参数选项。cobra.Command在执行的时候回调用cmd/craned/app/manager.go文件中的Run函数。
Run 函数 下面来重点分析下Run函数。代码如下：
// Run runs the craned with options. This should never exit. func Run(ctx context.Context, opts *options.Options) error { config := ctrl.GetConfigOrDie() config.QPS = float32(opts.ApiQps) config.Burst = opts.ApiBurst ctrlOptions := ctrl.Options{ Scheme: scheme, MetricsBindAddress: opts.MetricsAddr, Port: 9443, HealthProbeBindAddress: opts.</description></item><item><title>hugoio</title><link>/2022/02/15/uri-addr/</link><pubDate>Tue, 15 Feb 2022 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2022/02/15/uri-addr/</guid><description>https://github.com/gohugoio/hugo/blob/0f8dc47037/hugolib/page__meta.go for k, v := range frontmatter { loki := strings.ToLower(k) if loki == &amp;quot;published&amp;quot; { // Intentionally undocumented vv, err := cast.ToBoolE(v) if err == nil { published = &amp;amp;vv } // published may also be a date continue } if pm.s.frontmatterHandler.IsDateKey(loki) { continue } switch loki { case &amp;quot;title&amp;quot;: pm.title = cast.ToString(v) pm.params[loki] = pm.title case &amp;quot;linktitle&amp;quot;: pm.linkTitle = cast.ToString(v) pm.params[loki] = pm.linkTitle case &amp;quot;summary&amp;quot;: pm.summary = cast.ToString(v) pm.params[loki] = pm.summary case &amp;quot;description&amp;quot;: pm.</description></item><item><title>pushgateway group清理</title><link>/2022/02/15/pushgateway-group%E6%B8%85%E7%90%86/</link><pubDate>Tue, 15 Feb 2022 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2022/02/15/pushgateway-group%E6%B8%85%E7%90%86/</guid><description>trap 'echo &amp;quot;got sigterm&amp;quot; ; exit 0' SIGTERM EXPIRATION_SECONDS=${EXPIRATION_SECONDS:-600} PGW_URL=${PGW_URL:-http://10.176.78.78:9091} function convert_to_standardnotation(){ # convert number from scientific notation to standar d( ie '1.5383780136826127e+09' ) printf '%.0f' $1 } function extract_pushgateway_variable(){ local -r _METRIC=$1 local -r _VARNAME=$2 #echo 'push_time_seconds{instance=&amp;quot;10.32.32.7&amp;quot;,job=&amp;quot;bk_jenkins&amp;quot;} 1.5383802210997093e+09' | sed -r 's/.*instance=&amp;quot;([^&amp;quot;]*).*/\1/g' echo $_METRIC | sed -r &amp;quot;s/.*${_VARNAME}=\&amp;quot;([^\&amp;quot;]*).*/\\1/g&amp;quot; # sample usage : # extract_pushgateway_variable 'push_time_seconds{instance=&amp;quot;10.32.32.7&amp;quot;,job=&amp;quot;bk_jenkins&amp;quot;} 1.5383802210997093e+09' 'instance' } function extract_pushgateway_uri(){ local -r _METRIC=$1 #echo 'push_time_seconds{instance=&amp;quot;10.32.32.7&amp;quot;,job=&amp;quot;bk_jenkins&amp;quot;} 1.5383802210997093e+09' | awk -F{ '{print $2}' | awk -F} '{print $1}' | sed -e &amp;quot;s/[=,]/\//g&amp;quot; -e &amp;quot;s/\&amp;quot;//g&amp;quot; metricJob=$(extract_pushgateway_variable &amp;quot;$_METRIC&amp;quot; 'job') echo $_METRIC | awk -F{ '{print $2}' | awk -F} '{print $1}' | sed -e &amp;quot;s/[=,]/\//g&amp;quot; -e &amp;quot;s/\&amp;quot;//g&amp;quot; -e &amp;quot;s/job\///g&amp;quot; -e &amp;quot;s/${metricJob}\///g&amp;quot; -e &amp;quot;s/instance\/\///g&amp;quot; # sample usage : # extract_pushgateway_uri 'push_time_seconds{instance=&amp;quot;10.</description></item><item><title>如何实现 Service Weaver 部署器</title><link>/2022/02/15/deployers/</link><pubDate>Tue, 15 Feb 2022 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2022/02/15/deployers/</guid><description>声明 作者能力有限，如感觉有翻译不准确的请移步原文。
原文地址：https://serviceweaver.dev/blog/deployers.html 。
Service Weaver 允许您以多种不同的方式部署应用程序。例如，您可以在单个进程 、跨多个进程 或云 中部署应用程序。毫不奇怪，部署 Service Weaver 应用程序的代码称为deployer。这篇博文解释了部署器是什么以及如何实施部署器。我们假设您熟悉如何编写 Service Weaver 应用程序。如果不是，我们建议您阅读分步教程 。
概述 Service Weaver 应用程序由许多组件 组成。该应用程序被编译成单个应用程序二进制文件。部署者通过多次运行二进制文件来部署应用程序，通常是跨多台机器。二进制文件的每个实例都运行组件的一个子集。为了了解要运行哪些组件，二进制链接在一个称为 weavelet 的小型后台代理中，部署者使用envelope与之通信。如下图所示。
在这篇博文中，我们提供了对weavelets、deployers和envelopes的高级概述。然后，我们通过完全从头开始实施多进程部署程序，深入了解它们的工作原理。
Weavelets 要了解部署器，我们必须首先了解小波。Service Weaver 应用程序被编译成单个可执行二进制文件。链接到二进制文件中的 Service Weaver 库包括一个称为weavelet的小代理，它是在您调用 weaver.Init 时创建的。Weavelet 的主要职责是启动和管理一组组件。
部署 Service Weaver 应用程序时，不只有一个 weavelet。如果有只有一个，Service Weaver 应用程序就不会非常分散。相反，部署人员会多次运行您的二进制文件——在不同机器上的不同进程中以启动多个 weavelet，这些 weavelet 协同工作以执行您的分布式应用程序。
每个 weavelet 都承载一组可能不同的组件。因为组件是复制的，所以一个组件可能由多个weavelets托管。例如，考虑一个包含组件A、B和的应用程序C。下图显示了一个由三个weavelets组成的示例部署。weavelet 1 托管组件A和B；weavelet 2 承载组件B和 C，weavelet 3 承载组件C。
您还会注意到每个小波都有一个唯一的网络地址。Weavelets 使用这些地址来执行远程方法调用。例如，假设图中 weavelet 1上的A组件想要调用组件C 上的方法。weavelet 1 将联系地址 2.2.2.2 上的 weavelet 2 或地址 3.3.3.3 上的 weavelet 3 以执行该方法。
部署者 部署者通过启动和管理一组 weavelet 来分发 Service Weaver 应用程序。管理 weavelet 涉及与 (1) 组件、(2) 侦听器和 (3) 遥测相关的三个主要职责。</description></item><item><title>使用docker搭建 tars 开发环境</title><link>/2022/02/15/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA-tars-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link><pubDate>Tue, 15 Feb 2022 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2022/02/15/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA-tars-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid><description>docker pull tarscloud/framework docker run -d --net=host -e MYSQL_HOST=xxxxx -e MYSQL_ROOT_PASSWORD=xxxxx \ -eREBUILD=false -eINET=eth0 -eSLAVE=false \ -v/data/tars:/data/tars \ -v/etc/localtime:/etc/localtime \ tarscloud/framework # custom docker run -d -eMYSQL_HOST=192.168.1.10 -eMYSQL_USER=root -p 3000:3000 -p 18993:18993 \ -eMYSQL_ROOT_PASSWORD=lbbniu@yang0321 \ -eREBUILD=true -eINET=eth0 -eSLAVE=false \ --name tarsframework \ tarscloud/framework docker run -d -eMYSQL_HOST=10.14.166.155 -eMYSQL_USER=root -p 3000:3000 \ -eMYSQL_ROOT_PASSWORD=123456 \ -eREBUILD=false -eINET=eth0 -eSLAVE=false \ --name tarsframework \ tarscloud/framework docker run -ti --rm tarscloud/framework bash docker pull tarscloud/tars docker run -d --net=host -e MYSQL_HOST=xxxxx -e MYSQL_ROOT_PASSWORD=xxxxx \ -eREBUILD=false -eINET=eth0 -eSLAVE=false \ -v/data/tars:/data/tars \ -v/etc/localtime:/etc/localtime \ tarscloud/tars # custom docker run -d --net=host -e MYSQL_HOST=xxxxx -e MYSQL_ROOT_PASSWORD=xxxxx \ -eREBUILD=false -eINET=eth0 -eSLAVE=false \ -v/data/tars:/data/tars \ -v/etc/localtime:/etc/localtime \ tarscloud/tars docker run -d \ --name=tars-framework \ --net=host \ -e MYSQL_HOST=&amp;quot;10.</description></item><item><title>写给Go开发者的Tars教程-Context</title><link>/2022/02/15/tarsgo-context/</link><pubDate>Tue, 15 Feb 2022 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2022/02/15/tarsgo-context/</guid><description>关注公众号获得更多精彩文章</description></item><item><title>管理多版本 Go 安装</title><link>/2021/11/23/%E7%AE%A1%E7%90%86%E5%A4%9A%E7%89%88%E6%9C%AC-go-%E5%AE%89%E8%A3%85/</link><pubDate>Tue, 23 Nov 2021 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2021/11/23/%E7%AE%A1%E7%90%86%E5%A4%9A%E7%89%88%E6%9C%AC-go-%E5%AE%89%E8%A3%85/</guid><description>管理 Go 安装 目录 安装多个 Go 版本 卸载 Go Linux / macOS / FreeBSD 视窗 本主题介绍如何在同一台机器上安装多个版本的 Go，以及如何卸载 Go。
有关安装的其他内容，您可能对以下内容感兴趣：
下载和安装 ——最简单的安装和运行方式。 从源代码安装 Go—— 如何检查源代码、在您自己的机器上构建它们并运行它们。 安装多个 Go 版本 您可以在同一台机器上安装多个 Go 版本。例如，您可能希望在多个 Go 版本上测试您的代码。有关可以通过这种方式安装的版本列表，请参阅下载页面 。
**注意：**要使用此处描述的方法进行安装，您需要安装git 。
要安装其他 Go 版本，请运行go install命令 ，指定要安装的版本的下载位置。以下示例说明了版本 1.10.7：
# go version &amp;lt; 1.17 $ go get -u golang.org/dl/go1.10.7 # go version &amp;gt;= 1.17 $ go install golang.org/dl/go1.10.7@latest $ go1.10.7 download	要使用新下载的版本运行go命令，请将版本号附加到go命令中，如下所示：
$ go1.10.7 version go version go1.10.7 linux/amd64 当您安装了多个版本时，您可以发现每个版本的安装位置，查看版本的GOROOT值。例如，运行如下命令：
$ go1.10.7 env GOROOT 要卸载下载的版本，只需删除其GOROOT环境变量和 goX.</description></item><item><title>微明互动负责参与项目</title><link>/2021/11/20/%E5%BE%AE%E6%98%8E%E4%BA%92%E5%8A%A8%E8%B4%9F%E8%B4%A3%E5%8F%82%E4%B8%8E%E9%A1%B9%E7%9B%AE/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2021/11/20/%E5%BE%AE%E6%98%8E%E4%BA%92%E5%8A%A8%E8%B4%9F%E8%B4%A3%E5%8F%82%E4%B8%8E%E9%A1%B9%E7%9B%AE/</guid><description>2014-2016项目 云热卖 app38 联联 app45 李宁酷跑 app46 htc新渴望 app47 沃尔玛动态贺卡生成器 app49 联信 app50 第九屏 app52/d9ping htc新渴望8 app53 六推云平台 app54 搜狗极限科考 app55 360安全第一 app57 红旗 app59 海尔智慧答题 app60 多喜爱手机端 app61 联想thinkpad app62 斯巴鲁汽车 app64 联想thinkpad 联想禁止随地办公 app66 苏泊尔厨具 app70 亚马逊2048 app71 王老吉疯狂2048 app73 联想刮刮乐 app74 淘手游网站改版（YII框架） 巴布豆（手机和pc） app75 htc one m8申请 app76 高德地图lbs大赛 app77 htc one预约（手机和pc） app78 华为Meta7手机 app79 51jobs统计数据 app80 海尔口袋体验馆 app81 丰田一期 相信自己 app83 htc五月天 app84 海尔问题查询 app85 丰田二期项目 app86 特百惠 app87 特百惠外带小萌 app89 一汽大众 app90 搜狗手机活动项目 app91 全球购 微信项目（微信支付） app92 thinkphp intel大赛项目 app94 联通邀请函 app95 百佳手机 app96 IBM下载中心 app97 2015.</description></item><item><title>处理 Go 中的 'connection reset by peer' 错误</title><link>/2022/07/28/connection-reset-by-peer/</link><pubDate>Thu, 28 Jul 2022 17:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2022/07/28/connection-reset-by-peer/</guid><description>原文链接：https://gosamples.dev/connection-reset-by-peer/ 这connection reset by peer是在另一端（对等方）意外关闭连接时发生的TCP/IP错误。 当你从你的一端发送一个数据包，但另一端崩溃并强行关闭与RST 数据包的连接而不是TCP FIN 正常情况下用于关闭连接的连接时，就会发生这种情况。在 Go 中，您可以connection reset by peer通过检查对等方返回的错误是否等于 来检测syscall.ECONNRESET 。
重现connection reset by peer错误 我们可以通过创建执行以下操作的服务器和客户端来重现错误：
服务器读取一个字节然后关闭连接 客户端发送超过一个字节 如果服务器使用套接字接收缓冲区中的剩余字节关闭连接，则RST向客户端发送一个数据包。当客户端试图从这样一个关闭的连接中读取时，它会得到connection reset by peer错误。
请参阅以下示例，该示例模拟了此行为。
package main import ( &amp;quot;errors&amp;quot; &amp;quot;log&amp;quot; &amp;quot;net&amp;quot; &amp;quot;os&amp;quot; &amp;quot;syscall&amp;quot; &amp;quot;time&amp;quot; ) func server() { listener, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;:8080&amp;quot;) if err != nil { log.Fatal(err) } defer listener.Close() conn, err := listener.Accept() if err != nil { log.Fatal(&amp;quot;server&amp;quot;, err) os.Exit(1) } data := make([]byte, 1) if _, err := conn.</description></item><item><title>云原生时代的CoreDNS学习指南 笔记</title><link>/2022/07/11/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%97%B6%E4%BB%A3%E7%9A%84coredns%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E7%AC%94%E8%AE%B0/</link><pubDate>Mon, 11 Jul 2022 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2022/07/11/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%97%B6%E4%BB%A3%E7%9A%84coredns%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E7%AC%94%E8%AE%B0/</guid><description>主文件格式的记录一般是以下格式：
[NAME] [TTL] [CLASS] TYPE RDATA NAME字段包含资源记录附加的域名。它可以是以“.”结尾的完全限定域名（Fully Qualified Domain Name，FQDN），也可以是不以“.”结尾的相对域名。相对域名被解释为以当前的源结尾，在默认情况下，它是区域数据文件描述的区域的域名。
TTL字段指定了资源记录的生存时间值，该值控制递归DNS服务器可以缓存该记录的时间。TTL是一个32位整数表示的秒数，除此之外，你还可以使用扩展因子表示TTL，如“s”表示秒、“m”表示分钟、“h”表示小时、“d”表示天、“w”表示周。例如，“1d”表示1天，“30m”表示30分钟，“1h30m”表示1小时30分钟。
CLASS字段几乎总是IN，代表互联网，因此IN作为默认值也就不足为奇了。此外确实还有其他的值，如用于ChaosNet的CH和用于Hesiod的HS。
安装etcd rm -rf /tmp/etcd-data.tmp &amp;amp;&amp;amp; mkdir -p /tmp/etcd-data.tmp &amp;amp;&amp;amp; \ docker run \ -p 2379:2379 \ -p 2380:2380 \ --mount type=bind,source=/tmp/etcd-data.tmp,destination=/etcd-data \ --name etcd-gcr-v3.5.4 \ quay.io/coreos/etcd:v3.5.4 \ /usr/local/bin/etcd \ --name s1 \ --data-dir /etcd-data \ --listen-client-urls http://0.0.0.0:2379 \ --advertise-client-urls http://0.0.0.0:2379 \ --listen-peer-urls http://0.0.0.0:2380 \ --initial-advertise-peer-urls http://0.0.0.0:2380 \ --initial-cluster s1=http://0.0.0.0:2380 \ --initial-cluster-token tkn \ --initial-cluster-state new \ --log-level info \ --logger zap \ --log-outputs stderr 关注公众号获得更多精彩文章</description></item><item><title>Google SRE</title><link>/2022/06/21/google-sre/</link><pubDate>Tue, 21 Jun 2022 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2022/06/21/google-sre/</guid><description>第4章 服务质量目标 服务质量术语 服务质量指标（SLI）—— indicator 服务质量目标（SLO）——Objective 服务质量协议（SLA）——Agreement 单词 指标（indicator） 持久性（durability） 可用性（availability） 目标（Objective） 协议（Agreement） 第5章 减少琐事 4个黄金指标 延迟、流量、错误和饱和度（saturation）
第7章 自动化 自动化工具：Puppet、Chef、cfengine
Chubby服务器
第10章基于时间序列数据进行有效报警 监控：Pormetheus、Riemann、Heka和Bosun
time-series 第11章 on-call轮值 最理想的方法论是这样的：在有足够数据支撑的时候按步骤解决问题，同时不停地审视和验证目前所有的假设。
最重要的资源有：
● 清晰的问题升级路线。
● 清晰定义的应急事件处理步骤。
● 无指责，对事不对人的文化氛围。
第12章 有效的故障排查手段 1.对通用的故障排查过程的理解（不依靠任何特定系统）。
2.对发生故障的系统的足够了解
读者应该小心避免： ● 关注了错误的系统现象，或者错误地理解了系统现象的含义。这样会在错误的方向上浪费时间。
● 不能正确修改系统的配置信息、输入信息或者系统运行环境，造成不能安全和有效地测试假设。
● 将问题过早地归结为极为不可能的因素（例如认为是宇宙射线造成数据变化，虽然有可能发生，但是并不应该在解决问题初期做这个假设），或者念念不忘之前曾经发生过的系统问题，认为一旦发生过一次，就有可能再次发生。
● 试图解决与当前系统问题相关的一些问题，却没有认识到这些其实只是巧合，或者这些问题其实是由于当前系统的问题造成的。（比如发现数据库压力大的情况下，环境温度也有所上升，于是试图解决环境温度问题。）
Dapper 提供了非常有用的了解分布式系统工作情况的一种方式
单词 监测指标（telemetry）
定位（triage）
相关性（correlation）
因果关系（causation）
问题分解（Divide &amp;amp; Conquer）
对分法（bisection）
第14章 紧急事故管理 一次流程管理良好的事故 第17章 测试可靠性 传统测试 单元测试（unit test） 集成测试（integration test） 依赖注入（dependency injection） 系统测试（system test） 冒烟测试（smoke test）：冒烟测试有时也被称为理性测试 性能测试（performance test） 回归测试（regression test） 生产测试 变更发布与测试 配置测试 金丝雀测试 第18章 SRE 部门中的软件工程实践 Auxon 案例 基于意图的容量规划 1.</description></item><item><title>Hugo + Github Actions 实现自动化部署</title><link>/2021/11/20/hugo--github-actions-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</link><pubDate>Sat, 20 Nov 2021 20:33:21 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2021/11/20/hugo--github-actions-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</guid><description>参考连接 Hugo + Github Actions 实现自动化部署 GitHub Actions 实战 - 用 Hugo 自动构建 搭建 GitHub Pages HUGO + Github + Github Action持续集成部署个人博客 使用 Markdown 在 hugo 帖子内容中创建带有 &amp;rsquo;target=&amp;quot;_blank&amp;quot;&amp;rsquo; 的链接吗？ 您需要在/layouts/_default/_markup/ called处创建一个新文件render-link.html
在该文件中，您可以将其自定义为：
&amp;lt;a href=&amp;quot;{{ .Destination | safeURL }}&amp;quot;{{ with .Title}} title=&amp;quot;{{ . }}&amp;quot;{{ end }}{{ if strings.HasPrefix .Destination &amp;quot;http&amp;quot; }} target=&amp;quot;_blank&amp;quot; rel=&amp;quot;noopener&amp;quot;{{ end }}&amp;gt;{{ .Text | safeHTML }}&amp;lt;/a&amp;gt; 以下是会发生的情况：
- [link1](../something/ title=&amp;quot;title&amp;quot;) =&amp;gt; &amp;lt;a href=&amp;quot;../something/&amp;quot; title=&amp;quot;title&amp;quot;&amp;gt;link1&amp;lt;/a&amp;gt; - [link2](https://example.com) =&amp;gt; &amp;lt;a href=&amp;quot;https://example.com&amp;quot;&amp;gt;link2&amp;lt;/a&amp;gt; 它只会将其添加到带有“http”和“https”的 URL。
渲染挂钩的文档可在此处获得：https://gohugo.io/templates/render-hooks/ 关注公众号获得更多精彩文章</description></item><item><title>Docker修改默认网段</title><link>/2021/11/20/docker%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E7%BD%91%E6%AE%B5/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2021/11/20/docker%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E7%BD%91%E6%AE%B5/</guid><description>cat /etc/docker/daemon.json { &amp;quot;registry-mirrors&amp;quot;: [ &amp;quot;https://mirror.ccs.tencentyun.com&amp;quot; ], &amp;quot;bip&amp;quot;:&amp;quot;192.168.100.1/24&amp;quot; } 关注公众号获得更多精彩文章</description></item><item><title>fabric一些简单用法总结</title><link>/2021/11/20/fabric%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2021/11/20/fabric%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</guid><description>1.支持中文
#!/usr/bin/python env # -*- coding: utf-8 -*- 2.支持颜色
from fabric.colors import * print(red(&amp;quot;红色&amp;quot;) + green(&amp;quot;绿色&amp;quot;，bold=False) + blue(&amp;quot;蓝色&amp;quot;,bold=True) + white(&amp;quot;白色&amp;quot;) + yellow(&amp;quot;黄色&amp;quot;) + cyan(&amp;quot;蓝绿色&amp;quot;) + magenta(&amp;quot;品红色&amp;quot;)) 3.设置主机组及账号密码
主机密码不同时：
env.hosts = ['tomcat@192.168.244.128','tomcat@192.168.244.129'] env.passwords = {'tomcat@192.168.244.128:22':'111111','tomcat@192.168.244.129:22':'111111'} 主机密码相同时:
env.hosts=[ 'tomcat@192.168.244.128:22', 'tomcat@192.168.244.129:22', ] env.password = '1111' 使用ssh keyfile:
env.key_filename = ['/opt/fab/server_key'] env.user = 'tomcat' env.password = '111111' env.port = '2862' 4.运行shell命令
在本地运行命令:
local('pwd') local('set -m ; /etc/init.d/tomcat restart') # 如果是脚本，要加set -m 支持后台执行并返回状态，否则会报错 在服务器上运行命令:
run('uname -a') 5.切换目录执行
with cd('/opt/tomcat') run('set -m ; .</description></item><item><title>nginx lua直接阶段</title><link>/2021/11/20/nginx-lua%E7%9B%B4%E6%8E%A5%E9%98%B6%E6%AE%B5/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2021/11/20/nginx-lua%E7%9B%B4%E6%8E%A5%E9%98%B6%E6%AE%B5/</guid><description>对刚接触Ngx_lua的读者来说，可能会存在下面两个困惑。
1、Lua在Nginx的哪些阶段可以执行代码？ 2、Lua在Nginx的每个阶段可以执行哪些操作？
只有理解了这两个问题，才能在业务中巧妙地利用Ngx_Lua来完成各项需求。
Nginx的11个执行阶段，每个阶段都有自己能够执行的指令，并可以实现不同的功能。Ngx_Lua的功能大部分是基于Nginx这11个执行阶段开发和配置的，Lua代码在这些指令块中执行，并依赖于它们的执行顺序。本章将对Ngx_Lua的执行阶段进行一一讲解。
一、 init_by_lua_block init_by_lua_block是init_by_lua的替代版本，在OpenResty 1.9.3.1或Lua-Nginx-Modulev 0.9.17之前使用的都是init_by_lua。init_by_lua_block比init_by_lua更灵活，所以建议优先选用init_by_lua_block。 本章中的执行阶段都采用*_block格式的指令，后续不再说明。
1.1　阶段说明 语法：init_by_lua_block {lua-script-str} 配置环境：http 阶段：loading-config 含义：当Nginx的master进程加载Nginx配置文件（加载或重启Nginx进程）时，会在全局的Lua VM（Virtual Machine，虚拟机）层上运行 指定的代码，每次当Nginx获得HUP（即Hangup）重载信号加载进程时，代码都会被重新执行。
1.2　初始化配置 在loading-config阶段一般会执行如下操作。 1．初始化Lua全局变量，特别适合用来处理在启动master进程时就要求存在的数据，对CPU消耗较多的功能也可以在此处处理。 2．预加载模块。 3．初始化lua_shared_dict共享内存的数据（关于共享内存详见第10章）。 示例如下：
user webuser webuser; worker_processes 1; worker_rlimit_nofile 10240; events { use epoll; worker_connections 10240; } http { include mime.types; default_type application/octet-stream; log_format main '$remote_addr-$remote_user[$time_local] &amp;quot;$request&amp;quot; ' '$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; ' '&amp;quot;$http_user_agent&amp;quot; &amp;quot;$http_x_forwarded_for&amp;quot; &amp;quot;$request_time&amp;quot; &amp;quot;$upstream_addr $upstream_status $upstream_response_time&amp;quot; &amp;quot;upstream_time_sum:$upstream_time_sum&amp;quot; &amp;quot;jk_uri:$jk_uri&amp;quot;'; access_log logs/access.log main; sendfile on; keepalive_timeout 65; lua_package_path &amp;quot;/usr/local/nginx_1.12.2/conf/lua_modules/?.lua;;&amp;quot;; lua_package_cpath &amp;quot;/usr/local/nginx_1.</description></item><item><title>OpenVpn搭建</title><link>/2021/11/20/openvpn%E6%90%AD%E5%BB%BA/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2021/11/20/openvpn%E6%90%AD%E5%BB%BA/</guid><description>初始化 # 证书密码见服务器 mm.md # 创建目录 mkdir -p /data/openvpn/conf # 初始化 openvpn 配置 docker run -v /data/openvpn:/etc/openvpn --rm kylemanna/openvpn ovpn_genconfig -u udp://vpn.lbbniu.com # 初始化证书 根据提示数据证书密码和组织名称 docker run -v /data/openvpn:/etc/openvpn --rm -ti kylemanna/openvpn ovpn_initpki # 增加用户 docker run -v /data/openvpn:/etc/openvpn --rm -ti kylemanna/openvpn easyrsa build-client-full lbbniu nopass # 导出用户配置文件 docker run -v /data/openvpn:/etc/openvpn --rm -ti kylemanna/openvpn ovpn_getclient lbbniu &amp;gt; /data/openvpn/conf/lbbniu.ovpn # 启动服务 docker run --name openvpn -v /data/openvpn:/etc/openvpn -d -p 1194:1194/udp --cap-add=NET_ADMIN kylemanna/openvpn 添加用户脚本 #!/bin/bash # openvpn_useradd.</description></item><item><title>静态博客工具</title><link>/2021/11/20/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2021/11/20/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7/</guid><description> ruby 编写的 Jekyll [GitHub Pages支持]
Node.js 编写的 Hexo
Vue.js 编写的 vuepress
Go 编写的 Hugo
Python 编写的 Pelican
以及更人性化的 Gridea
GitHub Pages 搭建教程 hugo相关博客</description></item><item><title/><link>/1/01/01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/1/01/01/</guid><description/></item></channel></rss>