<!doctype html><html lang=zh dir=ltr><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Google SRE | lbbniu</title>
<meta name=generator content="Hugo Eureka 0.9.3"><link rel=stylesheet href=/css/eureka.min.9cec6350e37e534b0338fa9a085bf06855de3b0f2dcf857e792e5e97b07ea905d4d5513db554cbc26a9c3da622bae92d.css><script defer src=/js/eureka.min.fa9a6bf6d7a50bb635b4cca7d2ba5cf3dfb095ae3798773f1328f7950028b48c17d06276594e1b5f244a25a6c969a705.js></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&amp;family=Noto+Serif+SC:wght@400;600;700&amp;display=swap" as=style onload='this.onload=null,this.rel="stylesheet"'><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/styles/github.min.css media=print onload='this.media="all",this.onload=null' crossorigin><script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/highlight.min.js crossorigin></script><script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/dart.min.js crossorigin></script><script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/php.min.js crossorigin></script><script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/java.min.js crossorigin></script><script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/go.min.js crossorigin></script><script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/python.min.js crossorigin></script><link rel=stylesheet href=/css/highlightjs.min.2958991528e43eb6fc9b8c4f2b8e052f79c4010718e1d1e888a777620e9ee63021c2c57ec7417a3108019bb8c41943e6.css media=print onload='this.media="all",this.onload=null'><script defer type=text/javascript src=/js/fontawesome.min.35973bea57658ef0dd22ad59ea4642b6c8c67af62bed8659ac326d284ef285a6657cdbcf57d3b2910e7e992f2b20426e.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ media=print onload='this.media="all",this.onload=null' crossorigin><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script><script defer src=https://cdn.jsdelivr.net/npm/mermaid@8.14.0/dist/mermaid.min.js integrity=sha384-atOyb0FxAgN9LyAc6PEf9BjgwLISyansgdH8/VXQH8p2o5vfrRgmGIJ2Sg22L0A0 crossorigin></script><link rel=icon type=image/png sizes=32x32 href=/images/icon_hu46eef4dc61dcf438cf488ad55e1d2c12_638750_32x32_fill_box_center_3.png><link rel=apple-touch-icon sizes=180x180 href=/images/icon_hu46eef4dc61dcf438cf488ad55e1d2c12_638750_180x180_fill_box_center_3.png><meta name=description content="SRE: Google运维解密"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"文章列表","item":"/post/"},{"@type":"ListItem","position":2,"name":"Google SRE","item":"/2022/06/21/google-sre/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"/2022/06/21/google-sre/"},"headline":"Google SRE | lbbniu","datePublished":"2022-06-21T17:18:16+08:00","dateModified":"2024-01-08T23:58:46+08:00","wordCount":494,"publisher":{"@type":"Person","name":"lbbniu","logo":{"@type":"ImageObject","url":"/images/icon.gif"}},"description":"SRE: Google运维解密"}</script><meta property="og:title" content="Google SRE | lbbniu"><meta property="og:type" content="article"><meta property="og:image" content="/images/icon.png"><meta property="og:url" content="/2022/06/21/google-sre/"><meta property="og:description" content="SRE: Google运维解密"><meta property="og:locale" content="zh"><meta property="og:site_name" content="lbbniu"><meta property="article:published_time" content="2022-06-21T17:18:16+08:00"><meta property="article:modified_time" content="2024-01-08T23:58:46+08:00"><meta property="article:section" content="post"><meta property="article:tag" content="google"><meta property="article:tag" content="sre"><body class="flex min-h-screen flex-col"><header class="min-h-16 pl-scrollbar bg-secondary-bg fixed z-50 flex w-full items-center shadow-sm"><div class="mx-auto w-full max-w-screen-xl"><script>let storageColorScheme=localStorage.getItem("lightDarkMode");((storageColorScheme=="Auto"||storageColorScheme==null)&&window.matchMedia("(prefers-color-scheme: dark)").matches||storageColorScheme=="Dark")&&document.getElementsByTagName("html")[0].classList.add("dark")</script><nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0"><a href=/ class="me-6 text-primary-text text-xl font-bold">lbbniu</a>
<button id=navbar-btn class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
<i class="fas fa-bars"></i></button><div id=target class="hidden block md:flex md:grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20"><div class="md:flex md:h-16 text-sm md:grow pb-4 md:pb-0 border-b md:border-b-0"><a href=/post/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">文章</a>
<a href=/cloud-native/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">云原生</a>
<a href=/study/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">算法学习</a>
<a href=/docs/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">Go学习训练营</a>
<a href=/tags/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">标签</a></div><div class=flex><div class="relative pt-4 md:pt-0"><div class="cursor-pointer hover:text-eureka" id=lightDarkMode><i class="fas fa-adjust"></i></div><div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id=is-open></div><div class="absolute flex flex-col start-0 md:start-auto end-auto md:end-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40" id=lightDarkOptions><span class="px-4 py-1 hover:text-eureka" name=Light>浅色</span>
<span class="px-4 py-1 hover:text-eureka" name=Dark>深色</span>
<span class="px-4 py-1 hover:text-eureka" name=Auto>自动</span></div></div></div></div><div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id=is-open-mobile></div></nav><script>let element=document.getElementById("lightDarkMode");storageColorScheme==null||storageColorScheme=="Auto"?document.addEventListener("DOMContentLoaded",()=>{window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",switchDarkMode)}):storageColorScheme=="Light"?(element.firstElementChild.classList.remove("fa-adjust"),element.firstElementChild.setAttribute("data-icon","sun"),element.firstElementChild.classList.add("fa-sun")):storageColorScheme=="Dark"&&(element.firstElementChild.classList.remove("fa-adjust"),element.firstElementChild.setAttribute("data-icon","moon"),element.firstElementChild.classList.add("fa-moon")),document.addEventListener("DOMContentLoaded",()=>{getcolorscheme(),switchBurger()})</script></div></header><main class="grow pt-16"><div class=pl-scrollbar><div class="mx-auto w-full max-w-screen-xl lg:px-4 xl:px-8"><div class="grid grid-cols-2 gap-4 lg:grid-cols-8 lg:pt-12"><div class="lg:col-start-2 bg-secondary-bg col-span-2 rounded px-6 py-8 lg:col-span-6"><article class=prose><h1 class=mb-4>Google SRE</h1><div class="text-tertiary-text not-prose mt-2 flex flex-row flex-wrap items-center"><div class="me-6 my-2"><i class="fas fa-calendar me-1"></i>
<span>2022-06-21</span></div><div class="me-6 my-2"><i class="fas fa-clock me-1"></i>
<span>3分钟阅读时长</span></div></div><h2 id=第4章-服务质量目标>第4章 服务质量目标</h2><h3 id=服务质量术语>服务质量术语</h3><ul><li>服务质量指标（SLI）—— indicator</li><li>服务质量目标（SLO）——Objective</li><li>服务质量协议（SLA）——Agreement</li></ul><h3 id=单词>单词</h3><ul><li>指标（indicator）</li><li>持久性（durability）</li><li>可用性（availability）</li><li>目标（Objective）</li><li>协议（Agreement）</li></ul><h2 id=第5章-减少琐事>第5章 减少琐事</h2><h3 id=4个黄金指标>4个黄金指标</h3><p>延迟、流量、错误和饱和度（saturation）</p><h2 id=第7章-自动化>第7章 自动化</h2><p>自动化工具：Puppet、Chef、cfengine</p><p>Chubby服务器</p><h2 id=第10章基于时间序列数据进行有效报警>第10章基于时间序列数据进行有效报警</h2><p>监控：Pormetheus、Riemann、Heka和Bosun</p><ul><li>time-series</li></ul><h2 id=第11章-on-call轮值>第11章 on-call轮值</h2><p>最理想的方法论是这样的：在有足够数据支撑的时候按步骤解决问题，同时不停地审视和验证目前所有的假设。</p><p>最重要的资源有：</p><p>● 清晰的问题升级路线。</p><p>● 清晰定义的应急事件处理步骤。</p><p>● 无指责，对事不对人的文化氛围。</p><h2 id=第12章-有效的故障排查手段>第12章 有效的故障排查手段</h2><p>1.对通用的故障排查过程的理解（不依靠任何特定系统）。</p><p>2.对发生故障的系统的足够了解</p><h3 id=读者应该小心避免>读者应该小心避免：</h3><p>● 关注了错误的系统现象，或者错误地理解了系统现象的含义。这样会在错误的方向上浪费时间。</p><p>● 不能正确修改系统的配置信息、输入信息或者系统运行环境，造成不能安全和有效地测试假设。</p><p>● 将问题过早地归结为极为不可能的因素（例如认为是宇宙射线造成数据变化，虽然有可能发生，但是并不应该在解决问题初期做这个假设），或者念念不忘之前曾经发生过的系统问题，认为一旦发生过一次，就有可能再次发生。</p><p>● 试图解决与当前系统问题相关的一些问题，却没有认识到这些其实只是巧合，或者这些问题其实是由于当前系统的问题造成的。（比如发现数据库压力大的情况下，环境温度也有所上升，于是试图解决环境温度问题。）</p><h3 id=dapper>Dapper</h3><p>提供了非常有用的了解分布式系统工作情况的一种方式</p><h3 id=单词-1>单词</h3><p>监测指标（telemetry）</p><p>定位（triage）</p><p>相关性（correlation）</p><p>因果关系（causation）</p><p>问题分解（Divide & Conquer）</p><p>对分法（bisection）</p><h2 id=第14章-紧急事故管理>第14章 紧急事故管理</h2><h3 id=一次流程管理良好的事故httpswereadqqcomwebreader72c323007190dfe972c1295k5fd32dd02725fd0b37cd75e><a href=https://weread.qq.com/web/reader/72c323007190dfe972c1295k5fd32dd02725fd0b37cd75e target=_blank rel=noopener>一次流程管理良好的事故</a></h3><h2 id=第17章-测试可靠性>第17章 测试可靠性</h2><ul><li>传统测试<ul><li>单元测试（unit test）</li><li>集成测试（integration test）<ul><li>依赖注入（dependency injection）</li></ul></li><li>系统测试（system test）<ul><li>冒烟测试（smoke test）：冒烟测试有时也被称为理性测试</li><li>性能测试（performance test）</li><li>回归测试（regression test）</li></ul></li></ul></li><li>生产测试<ul><li>变更发布与测试</li><li>配置测试</li><li>金丝雀测试</li></ul></li></ul><h2 id=第18章-sre-部门中的软件工程实践>第18章 SRE 部门中的软件工程实践</h2><h3 id=auxon-案例>Auxon 案例</h3><h4 id=基于意图的容量规划>基于意图的容量规划</h4><h5 id=1我需要50个cpu的资源必须在集群xyz中为服务foo使用>1.我需要50个CPU的资源，必须在集群X、Y、Z中，为服务Foo使用。</h5><p>这是一个具体的资源请求，但是，为什么我们需要这么多资源，同时一定要在这三个集群中？</p><h5 id=2我需要50个cpu的资源在地理区域yyyy中的任意三个集群中为服务foo使用>2.我需要50个CPU的资源，在地理区域YYYY中的任意三个集群中，为服务Foo使用。</h5><p>这项请求增加了更多的选择自由度，也更容易被满足，但是仍然没有解释这项请求背后的原因，为什么我们需要这么多资源，以及为什么需要三个集群？</p><h5 id=3我想要满足foo在每个地理区域的需求增长同时保障n2冗余度>3.我想要满足Foo在每个地理区域的需求增长，同时保障N+2冗余度。</h5><p>现在有了更多的选择自由度，同时我们可以更好地理解如果Foo没有获得相应的资源，究竟会造成什么后果。</p><h5 id=4我们想要将foo以99999的可靠度运行>4.我们想要将Foo以99.999%的可靠度运行。</h5><p>这是相对更抽象的一个需求，当容量得不到满足时的后果也更清楚了：可靠性会下降。而且我们从中获得了更多的选择自由度：也许以N+2运行并不是足够的，或者并不是最优化的情况，其他的某种部署计划是更合适的。</p><h3 id=短语>短语</h3><ul><li><p>需求编排（bin-pack）</p></li><li><p>最佳压缩（bin-packing）</p></li><li><p>电子表格（spreadsheet）</p></li><li><p>过期（stale）</p></li><li><p>数据信息（Performance Data）</p></li><li><p>资源供给（Resource Supply）</p></li><li><p>资源价格（Resource Pricing）</p></li><li><p>意图配置信息（Intent Config）</p></li><li><p>通用型人才（generalist）</p></li><li><p>专家（specialist）</p></li><li><p>运维研究（operation research）</p></li><li><p>量化分析（quantitate analysis）</p></li></ul><h2 id=第19章-前端服务器负载均衡>第19章 前端服务器负载均衡</h2><h3 id=使用dns进行负载均衡>使用DNS进行负载均衡</h3><ul><li>anycast DNS服务器</li><li>OpenDNS</li></ul><h3 id=负载均衡虚ip>负载均衡：虚IP</h3><ul><li>内部采用更大的MTU来避免碎片重组</li></ul><h3 id=短语-1>短语</h3><ul><li>权威域名服务器（authoritive nameserver）</li><li>递归解析器（recursive nameserver）</li><li>网络负载均衡器（network loadbalancer）</li><li>一致性哈希（consistent hashing）</li><li>包封装（encapsulation）</li><li>碎片重组（Fragmentation）</li></ul><h2 id=第20章-数据中心内部的负载均衡系统>第20章 数据中心内部的负载均衡系统</h2><h3 id=跛脚鸭状态>跛脚鸭状态</h3><p>停止过程通常按照以下步骤进行：</p><p>1.任务编排系统发送一个SIGTERM信号给该任务。</p><p>2.后端任务进入跛脚鸭状态，同时请求它的所有客户端发送请求给其他后端任务。这通过SIGTERM信号处理程序中调用RPC实现中的API完成。</p><p>3.任何在后端进入跛脚鸭状态时正在进行的请求（或者在进入状态之后，但是其他客户端收到通知之前）仍会继续进行。</p><p>4.随着请求回复被发送回客户端，该后端任务的活跃请求逐渐降低为0。</p><p>5.在配置的时间过后，该后端程序要么自己干净地退出，要么任务编排系统主动杀掉它。该时间应该被设置为一个足够大的值，以便一般的请求可以有足够的时间完成。每个服务的该数值都不同，一般来说取决于客户端的复杂程度，10s到150s是一个不错的选择。</p><h3 id=利用划分子集限制连接池大小>利用划分子集限制连接池大小</h3><p>子集划分：限制某个客户端任务需要连接的后端任务数量。</p><h4 id=确定性算法>确定性算法</h4><pre><code class=language-python>def Subset(backends, client_id, subset_size):
    subset_count = len(backends) / subset_size
    
    # 将客户端划分为多轮，每一轮计算使用同样的随机排列的列表
    round = client_id / subset_count
    random.seed(round)
    random.shuffle(backends)
    
    # subset_id 代表了目前的客户端
    subset_id = client_id % subset_count
    
    start = subset_id * subset_size
    return backends[start:start+subset_size]
</code></pre><h3 id=负载均衡策略>负载均衡策略</h3><h4 id=简单轮询算法>简单轮询算法</h4><h5 id=分配不均因素>分配不均因素：</h5><ul><li><p>子集过小</p></li><li><p>请求处理成本不同</p></li><li><p>物理服务器的差异</p></li><li><p>无法预知的性能因素</p><ul><li>坏邻居</li><li>任务重启</li></ul></li></ul><h4 id=最闲轮询策略>最闲轮询策略</h4><ul><li>活跃请求的数量并不一定是后端容量的代表</li><li>每个客户端的活跃请求不包括其他客户端发往同一个后端的请求</li></ul><h4 id=加权轮询策略>加权轮询策略</h4><p>加权轮询策略通过在决策过程中加入后端提供的信息，是一个针对简单轮询策略和最闲轮询策略的加强。</p><p>加权轮询策略理论上很简单：每个客户端为子集中的每个后端任务保持一个“能力”值。请求仍以轮询方式分发，但是客户端会按能力值权重比例调节。在收到每个回复之后（包括健康检查的回复），<strong>后端会在回复中提供当前观察到的请求速率、每秒错误值，以及目前资源利用率</strong>（一般来说，是CPU使用率）。<strong>客户端根据目前成功请求的数量，以及对应的资源利用率成本进行周期性调节，以选择更好的后端任务处理</strong>。<strong>失败的请求也会记录在内，对未来的决策造成影响</strong>。</p><h2 id=第21章-应对过载>第21章 应对过载</h2><h3 id=自适应节流的技术来实现客户端节流>自适应节流的技术来实现客户端节流</h3><p>具体地说，每个客户端记录过去两分钟内的以下信息：</p><p>**请求数量（requests）**应用层代码发出的所有请求的数量总计（指运行于自适应节流系统之上的应用代码）。</p><p>**请求接受数量（accepts）**后端任务接受的请求数量。</p><p>在常规情况下，这两个值是相等的。随着后端任务开始拒绝请求，请求接受数量开始比请求数量小了。客户端可以继续发送请求直到requests=K * accepts，一旦超过这个限制，客户端开始自行节流，新的请求会在本地直接以一定概率被拒绝（在客户端内部），概率使用公式21-1进行计算：</p><p><strong>客户端请求拒绝概率:</strong> max(0, (requests-K*accepts)/(requests+1))</p><p>对那些处理请求消耗的资源和拒绝请求的资源相差无几的系统来说，允许用50%的资源来发送拒绝请求可能是不合理的。在这种情况下，解决方案很简单：通过修改客户端中算法的accepts的倍值K（例如，2）就可解决：</p><p>● 降低该倍值会使自适应节流算法更加激进。</p><p>● 增加该倍值会使该算法变得不再那么激进。</p><p>举例来说，假设将客户端请求的上限从request=2 * accepts调整为request=1.1*accepts，那么就意味着每10个后端请求之中只有1个会被拒绝。</p><p>一般来说推荐采用K=2，通过允许后端接收到比期望值更多的请求，浪费了一定数量的后端资源，但是却加快了后端状态到客户端的传递速度。举例来说，后端停止拒绝该客户端的请求之后，所有客户端检测到这个变化的耗时就会减小。</p><h3 id=重要性>重要性</h3><h4 id=4个级别>4个级别</h4><ul><li>最重要 CRITICAL_PLUS</li><li>重要 CRITICAL</li><li>可丢弃的SHEDDABLE_PLUS</li><li>可丢弃的SHEDDABLE</li></ul><h3 id=资源利用率信号>资源利用率信号</h3><p>cpu</p><p>内存</p><h3 id=处理过载错误>处理过载错误</h3><p>数据中心中的大量后端任务都处于过载状态</p><p>数据中心中的一小部分后端任务处于过载状态</p><h3 id=连接造成的负载>连接造成的负载</h3><p>RPC协议需要不活跃的客户端定期执行健康检查。当某个连接空闲一段可配置的时间后，客户端放弃TCP连接，转为UDP健康检查。不幸的是，这种行为会对大量请求率很低的客户端造成问题：健康检查需要比实际处理请求更多的资源。通过仔细调节连接参数（如，大幅降低健康检查频率）或者动态创建和销毁连接可以优化这些场景</p><p>处理突发性的新连接请求是另外一个（相关的）问题。我们观察到，超大规模的批处理任务会在短时间内建立大量的客户端。协商和维护这些超大数量的连接可以造成整个后端的过载。在我们的经验里，以下策略可以帮助消除这些问题：</p><p>● 将负载传递给跨数据中心负载均衡算法。在这种情况下，过载请求会被转移到其他数据中心。</p><p>● 强制要求批处理任务使用某些特定的批处理代理后端任务，这些代理仅仅转发请求，同时将回复转发给客户端。</p><h3 id=单词短语>单词短语</h3><ul><li>全局过载（global overload）</li><li>重要性（criticality）</li><li>利用率（utilization）</li><li>执行器负载均值（executor load average）</li><li>数性衰变算法（exponential decay）</li></ul><p>如何利用不同的技术手段（确定性算法、加权轮询、客户端侧的节流、用户配额等）更平均地将负载分散到数据中心。</p><h2 id=第22章-处理连锁故障>第22章 处理连锁故障</h2><h3 id=防止软件服务器过载>防止软件服务器过载</h3><ul><li>提供降级结果</li><li>在过载情况下主动拒绝请求</li><li>上层系统应该主动拒绝请求</li><li>进行容量规划</li></ul><h4 id=速率限制可以具体在以下位置实现>速率限制可以具体在以下位置实现：</h4><ul><li><p>在反向代理层，通过针对请求的某种特性进行数量限制（如IP地址），来缓解和避免拒绝服务攻击，避免攻击性客户端的影响。</p></li><li><p>在负载均衡器层，在服务进入全局过载时主动丢弃请求。取决于该服务的实现和复杂度，这种丢弃可能是针对所有请求的（丢弃超过X QPS 的所有请求），或者是有选择性的（丢弃非最近用户发来的请求，或者丢弃低优先级请求，如背景同步请求，但是保留用户交互型请求）。</p></li><li><p>在每个任务自身，避免负载均衡层的随机扰动导致软件服务器过载。</p></li></ul><h4 id=队列管理>队列管理</h4><h4 id=流量抛弃和优雅降级>流量抛弃和优雅降级</h4><p>流量抛弃（load shedding）是指在软件服务器临近过载时，主动抛弃一定量的负载。目标是避免该软件服务器出现内存超限，健康检查失败，延迟大幅升高，或者其他过载造成的现象。也就是使软件服务器在负载极限时，尽可能地再多做一些有用的工作。</p><ul><li>可控延迟算法（CodDel）</li></ul><p>优雅降级（graceful degradation）可在流量抛弃的基础上进一步减少服务器的工作量。在某些应用程序中，是可以通过降低回复的质量来大幅减少所需的计算量或者所需的计算时间的。例如，一个搜索类型的应用可能在过载情况下仅仅搜索保存在内存中的数据，而不是搜索全部存在硬盘上的数据。该服务或者可以采用一种不那么精确（但是更快）的算法来进行结果排序。</p><p>评估流量抛弃或者优雅降级时，需要考虑以下几点：</p><ul><li>确定具体采用哪个指标作为流量评估和优雅降级的决定性指标（如，CPU用量、延迟、队列长度、线程数量、是否该服务可以自动进行降级，或者需要人工干预）。</li><li>当服务进入降级模式时，需要执行什么动作？</li><li>流量抛弃或者优雅降级应该在服务的哪一层实现？是否需要在整个服务的每一层都实现，还是可以选择某个高层面的关键节点来实现？</li></ul><p>当评估和具体实施的时候，还需要考虑以下几点：</p><ul><li>优雅降级不应该经常被触发—通常触发条件显示了容量规划的失误，或者是出现了意料之外的负载转移。整个降级系统应该简单、易懂，尤其是在不经常使用的情况下。</li><li>记住，代码中平时不会使用的代码路径（通常来说）是不工作的。在稳定运行状态下，优雅降级不会经常触发，意味着在这个模式下的运维经验很少，对这个模式的问题也不够熟悉，这就会升高这种模式的危险性。我们可以通过定期针对一小部分的服务压力测试以便更多地触发这个模式，保证这个模式还能正常工作。</li><li>监控系统应该在进入这种模式的软件服务器过多时报警。</li><li>复杂的流量抛弃和优雅降级系统本身就可能造成问题—过于复杂的逻辑可能会导致软件服务器以外的服务进入降级模式运行，甚至进入反馈循环。设计时应该实现一种简单的关闭降级模式，或者是快速调节参数的方式。将这个配置文件存储在一个强一致性的存储系统（如 Chubby）中，每个软件服务器都可以订阅改变，可以提高部署速度，但是同时也会增加整个系统的同步性风险（如果配置文件有问题，全部服务器同时都会受到影响）。</li></ul><h4 id=重试>重试</h4><p>当发送自动重试时，需要将如下部分考虑在内：</p><ul><li>大部分后端保护策略都适用于此。尤其是，对系统进行测试可以提前显现问题，同时优雅降级可以将重试对后端的影响降低。</li><li>一定要使用随机化的、指数型递增的重试周期。</li><li>限制每个请求的重试次数。不要将请求无限重试。</li><li>考虑使用一个全局重试预算。</li><li>从多个视角重新审视该服务，决定是否需要在某个级别上进行重试。</li><li>使用明确的返回代码，同时详细考虑每个错误模式应该如何处理。</li></ul><h4 id=请求延迟和截止时间>请求延迟和截止时间</h4><ul><li>选择截止时间</li></ul><p>设置一个截止时间通常是明智的。不设置截止时间，或者设置一个非常长的截止时间通常会导致某些短暂的、已经消失的问题继续消耗服务器资源，直到重启。</p><ul><li>超过截止时间</li></ul><p>很多连锁故障场景下的一个常见问题是软件服务器正在消耗大量资源处理那些早已经超过客户端截止时间的请求。这样的结果是，服务器消耗大量资源没有做任何有价值的工作，回复已经被取消的RPC是没有意义的。</p><ul><li>截止时间传递</li></ul><p>与其在发送RPC给后端服务器时自拟一个截止时间，不如让软件服务器采用截止时间传递和取消传递的策略。</p><p><strong>请求延迟的双峰分布（Bimodal）</strong> 解决指导思想</p><h3 id=慢启动和冷缓存>慢启动和冷缓存</h3><p>如果缓存对服务造成了很大的影响，[76]可能要采取以下几种策略中的一种或多种</p><ul><li>过量配备（overprovision）该服务</li><li>使用通用的连锁故障避免手段</li><li>当为一个集群增加负载时，需要缓慢增加</li></ul><h3 id=连锁故障的触发条件>连锁故障的触发条件</h3><ul><li>进程崩溃</li><li>进程更新</li><li>新的发布</li><li>自然增长</li><li>计划中或计划外的不可用</li><li>请求特征的变化</li><li>资源限制</li></ul><h3 id=连锁故障的测试>连锁故障的测试</h3><p>应该针对服务进行压力测试，通过对重载下服务行为的观察可以确定该服务在负载很重的情况下是否会进入连锁故障模式。</p><ul><li>测试直到出现故障，还要继续测试<ul><li>应该测试一个组件在过载之后再恢复到正常水平的行为状态</li></ul></li><li>测试最常用的客户端</li><li>测试非关键性后端</li></ul><h3 id=解决连锁故障的立即步骤>解决连锁故障的立即步骤</h3><ul><li><p>增加资源</p></li><li><p>停止健康检查导致的任务死亡</p><ul><li>进程任务的健康检查（“这个进程是否响应请求”）</li><li>服务级别的健康检查（“该进程是否能够回复这种类型的请求”）</li></ul></li><li><p>重启软件服务器</p><ul><li>Java服务器处于GC死亡螺旋中</li><li>某些正在处理的请求因为没有截止时间设置而正在消耗资源</li><li>死锁</li></ul></li><li><p>丢弃流量</p><ol><li>解决最初的触发原因（如增加容量）。</li><li>将负载降低到一定水平，使得崩溃停止。考虑在这里激进一些，如果整个服务都在崩溃循环中，那么可以考虑降低流量到1%的水平。</li><li>允许大部分的软件服务器恢复健康。</li><li>逐渐提升负载水平。</li></ol></li><li><p>进入降级模式</p></li><li><p>消除批处理负载</p></li><li><p>消除有害的流量</p></li></ul><h3 id=小结>小结</h3><p>在请求失败的时候重试、负载自动转移、自动杀掉不健康的服务器、增加缓存以提高性能或者降低延迟：这些手段原本都是为了优化正常情况下的服务性能，但是也可能会提高大规模的服务故障的几率。</p><h3 id=短语-2>短语</h3><ul><li>优雅降级（graceful degradation）</li><li>流量抛弃（load shedding）</li><li>异常请求（malformed request）</li><li>截止时间（deadline）</li><li>存储系统 Chubby</li><li>硬黏性或软黏性（hard/soft stickiness）</li></ul><h2 id=第23章-管理关键状态利用分布式共识来提高可靠性>第23章 管理关键状态：利用分布式共识来提高可靠性</h2><ul><li><p>Paxos 协议、Raft、Zab、 Mencius</p></li><li><p>ZooKeeper、Consul，以及 etcd</p></li><li><p>Google的Chubby 服务</p></li></ul><p>ACID数据存储语义（原子性、一致性、隔离性和持久性）</p><p><strong>BASE</strong>：基本可用、软状态、最终一致性（basically available、soft state、eventual consistency）</p><p><strong>拜占庭式问题</strong>：指的是当某个进程由于程序Bug或者恶意行为发送不正确的消息的问题，这种问题相对来说处理成本更高，同时也更少见。</p><p>分布式共识系统的某些区域需要特别关注，包括以下几项:</p><ul><li>始终落后的副本</li><li>领头人角色是否存在</li><li>领头人角色变化的次数</li><li>共识交易记录数字</li><li>吞吐量和延迟</li></ul><p>为了更好地理解系统性能，以及帮助进行故障排查，我们还要监控以下几点：</p><ul><li>针对提议接收时间的延迟分布。</li><li>系统不同部分之间观察到的网络延迟。</li><li>接收者在持久化日志上花费的时间。</li><li>系统每秒处理的字节数。</li></ul><p><strong>每当读者见到领头人选举、关键共享状态，或者分布式锁的时候，一定要想起分布式共识：任何其他的方案都是系统中的一枚定时炸弹，随时可能爆炸。</strong></p><h3 id=短语-3>短语</h3><ul><li><p>领头人选举（leader election）</p></li><li><p>多主复制（multimaster replication）</p></li><li><p>谣言协议（gossip）</p></li><li><p>异步式分布式共识（asynchronous distributed consensus）</p></li><li><p>拜占庭式（Byzantine）</p></li><li><p>崩溃不可恢复（crash-fail）</p></li><li><p>崩溃可恢复（crash-recover）</p></li><li><p>角斗士（dueling proposers）</p></li><li><p>提案（proposal）</p></li><li><p>提案者（proposer）</p></li><li><p>接收者（acceptor）</p></li><li><p>法定租约（qurom leases）</p></li><li><p>故障域（failure domain）</p></li></ul><h2 id=第24章-分布式周期性任务系统>第24章 分布式周期性任务系统</h2><p>分布式Cron系统的核心是Paxos协议，一个在分布式不可靠系统达成一致的算法。Paxos协议的使用，以及对大型、分布式环境中任务失败模式的分析使得Google可以构建出一个非常可靠的Cron服务。</p><p>惊群效应（thundering herd）:根据用户的配置，Cron服务可能会造成数据中心用量的大幅增加。当人们想要配置一个“每日任务”时，他们通常会配置该任务在午夜时运行。这个配置可能在一台机器上还可行，但是当你的任务会产生数千个MapReduce工作进程的时候就不可行了。尤其是当其他30个团队也按照同样的配置在同一个数据中心来运行每日任务呢？</p><h3 id=短语-4>短语</h3><ul><li>惊群效应（thundering herd）</li></ul><h2 id=第25章-数据处理流水线>第25章 数据处理流水线</h2><p>本章提出了一个崭新的、更可靠的、更易扩展的领头人-追随者模式，可以用来替代处理海量数据的周期性流水线模型</p><h3 id=惊群效应>惊群效应</h3><p>对一个足够大的周期性流水线来说，每一次运行，可能有几千个工作进程立即启动。如果一个服务器上有太多工作进程，或者这些工作进程配置错误，并用错误的方法重试等，可能会导致所运行的物理服务器过载，甚至于分布式集群服务也会过载，网络基础设施等也会出现问题。</p><h3 id=摩尔负载模式>摩尔负载模式</h3><p>该问题是指两个或者更多的流水线任务同时运行时，某些执行过程重叠，导致它们同时消耗某个共享资源。这个问题也会在持续性流水线中出现，但是在负载比较平衡的时候就很少出现了。</p><h3 id=workflow为正确性提供了4点保障>Workflow为正确性提供了4点保障：</h3><ul><li>配置文件本身作为屏障，这样可以保障工作进程的输出永远与配置一致。</li><li>所有的工作结果都必须由当前拥有租约的进程提交。</li><li>工作进程的输出文件都是全局唯一命名的。</li><li>客户端和服务器会在每次操作的时候校验“主任务”的令牌。</li></ul><h3 id=短语-5>短语</h3><ul><li>数据流水线（data pipeline）</li><li>协程（coroutine）</li><li>DTSS通信文件</li><li>UNIX管道</li><li>ETL 管道</li><li>“简单的，单相流水线”（simple,one-phase pipeline）</li><li>多相流水线（multiphase pipeline）</li><li>深度（depth）</li><li>“令人羞愧的并发性”（embarrassingly parallel）</li><li>挤走（preemption）</li><li>“摩尔负载模式”（Moiré Load Pattern）</li><li>“流式系统”（system prevalence）</li></ul><h2 id=第26章-数据完整性读写一致>第26章 数据完整性：读写一致</h2><p>大多数云计算应用都是优化以下5项的某种组合：在线时间、延迟、规模、创新速度和隐私。</p><p><strong>备份与存档</strong>最重要的区别就是，备份是可以直接被应用程序重新加载的。</p><p><strong>存档</strong>的目的是将数据长时间安全保存，以满足审核、取证和合规要求。在这些情况下的数据恢复通常不需要满足服务的在线率要求。例如，我们可能需要将财务交易数据保存七年时间。为了达到这个目标，我们可以每个月将累积的审核日志迁移到离线的、异地的长期存档存储系统上。读取和恢复这样的信息可能需要一周时间，在长达一个月的财务审核过程中，这是可以接受的。</p><p>相对存档，当灾难来临的时候，数据必须从真实的备份中快速恢复，最好能维持服务在线率的要求。否则的话，受影响的用户将由于数据问题无法使用应用程序，直到数据恢复过程完成。</p><h3 id=云计算环境下的需求>云计算环境下的需求</h3><p>云计算环境引入了一系列独特的技术难点：</p><ul><li>如果该环境使用了混合交易型和非交易型的备份和恢复方案，那么最终恢复的数据不一定是正确的。</li><li>如果某个服务必须在不停机的情况下更新，那么不同版本的逻辑可能同时并行操作数据。</li><li>如果所有其他有交互关系的服务不是同步更新的，那么在更新过程中各服务的不同版本之间可能会有多种组合，那么就更加增大了数据意外丢失和损坏发生的概率。</li></ul><p>API又必须可靠，以及支持以下特性：</p><ul><li>数据本地性和缓存。</li><li>本地和全局的数据分布。</li><li>强一致性与/或最终一致性。</li><li>数据持久性、备份与灾难恢复。</li></ul><h3 id=google-sre保障数据完整性的手段>Google SRE保障数据完整性的手段</h3><h4 id=第一层是软删除soft-deletion或者是某些api提供的懒删除机制>第一层是软删除（soft deletion）（或者是某些API提供的“懒删除”机制）。</h4><p>这种类型的保护在实践中被证实是针对意外数据删除的有效手段。</p><ul><li>应用中实现一个回收站机制，作为用户错误的主要防护手段。</li><li>软删除机制是针对开发者错误的主要防范手段，以及用户错误的次要防范手段。</li><li>在面向开发者的服务中，懒删除机制是针对内部开发者错误的主要防范手段，是针对外部开发者错误的次要防范手段。</li></ul><h4 id=第二层是备份和对应的恢复机制>第二层，是备份和对应的恢复机制。</h4><ul><li>使用哪种备份和还原方法。</li><li>通过全量或者增量备份建立恢复点（restore point）的频率。</li><li>备份的存储位置。</li><li>备份的保留时间。</li></ul><h4 id=第三层早期预警>第三层：早期预警。</h4><p>数据完整性的挑战：</p><ul><li>不同的数据存储之间的引用完整性。</li><li>数据结构的改变。</li><li>旧代码。</li><li>无停机时间的数据迁移。</li><li>与其他服务接口的不断变化。</li></ul><p>一个有效的带外数据校验系统需要下列元素：</p><ul><li>校验任务的管理。</li><li>监控、报警和监控台页面。</li><li>限速功能。</li><li>调试排错工具。</li><li>生产应急应对手册。</li><li>校验器容易使用的数据校验API。</li></ul><p>在这三层中，如果同时还有复制机制，那么在某些场景下对数据恢复是很有用的（但是数据恢复计划不应该依赖于复制机制）。</p><h4 id=确保数据恢复策略可以正常工作>确保数据恢复策略可以正常工作</h4><p><strong>只有真正进行恢复操作之后，才能确定到底能否恢复最新数据。</strong></p><p>数据恢复计划中需要覆盖的点是很多的：</p><ul><li>备份数据是否是完整的、正确的—还是空的？</li><li>我们是否有足够的物理机资源来完整地完成整个恢复过程：包括运行恢复任务本身，真正恢复数据，以及数据后处理任务？</li><li>整个数据恢复过程能否在合理的时间内完成？</li><li>是否在数据恢复过程中监控状态信息？</li><li>恢复过程是否依赖于某些无法控制的元素—例如某个不是24×7 随时可以使用的异地存储媒介？</li></ul><h3 id=短语-6>短语</h3><ul><li>数据完整性（data integrity）</li><li>可用率（availability）</li><li>“引用完整性”（referential integrity）</li></ul><h2 id=关注公众号获得更多精彩文章>关注公众号获得更多精彩文章</h2><p><img src=https://typora.lbbniu.com/typora/qrcode_for_gh_4ab47aa64a20_258.jpg alt=公众号：程序员大兵></p></article><div class=my-4><a href=/tags/google/ class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#google</a>
<a href=/tags/sre/ class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#sre</a></div><div class="-mx-2 mt-4 flex flex-col border-t px-2 pt-4 md:flex-row md:justify-between"><div><span class="text-primary-text block font-bold">上一页</span>
<a href=/2022/07/11/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%97%B6%E4%BB%A3%E7%9A%84coredns%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E7%AC%94%E8%AE%B0/ class=block>云原生时代的CoreDNS学习指南 笔记</a></div><div class="mt-4 md:mt-0 md:text-right"><span class="text-primary-text block font-bold">下一页</span>
<a href=/2021/11/20/hugo--github-actions-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/ class=block>Hugo + Github Actions 实现自动化部署</a></div></div></div></div><script>document.addEventListener("DOMContentLoaded",()=>{hljs.highlightAll()})</script></div></div></main><footer class=pl-scrollbar><div class="mx-auto w-full max-w-screen-xl"><div class="text-center p-6 pin-b"><p class="text-sm text-tertiary-text">&copy; 2021 <a href=https://blog.lbbniu.com/>lbbniu</a>
&#183; Powered by the <a href=https://github.com/wangchucheng/hugo-eureka class=hover:text-eureka>Eureka</a> theme for <a href=https://gohugo.io class=hover:text-eureka>Hugo</a></p></div></div></footer></body></html>