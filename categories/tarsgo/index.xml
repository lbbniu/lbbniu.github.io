<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TarsGo on lbbniu</title><link>/categories/tarsgo/</link><description>Recent content in TarsGo on lbbniu</description><generator>Hugo -- gohugo.io</generator><language>zh</language><managingEditor>lbbniu@gmail.com (lbbniu)</managingEditor><webMaster>lbbniu@gmail.com (lbbniu)</webMaster><copyright>&amp;copy; 2021 &lt;a href="https://blog.lbbniu.com/">lbbniu&lt;/a></copyright><lastBuildDate>Wed, 10 Jan 2024 15:20:00 +0800</lastBuildDate><atom:link href="/categories/tarsgo/index.xml" rel="self" type="application/rss+xml"/><item><title>写给Go开发者的Tars教程-超时控制</title><link>/2024/01/10/tarsgo-timeout/</link><pubDate>Wed, 10 Jan 2024 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2024/01/10/tarsgo-timeout/</guid><description>本篇为【写给go开发者的Tars教程】系列第六篇
第一篇：Tars协议基础 第二篇：通信模式 第三篇：拦截器 第四篇：错误处理 第五篇：context/status 第六篇：超时控制
本系列将持续更新，欢迎关注👏获取实时通知
导言
一个合理的超时时间是非常必要的，它能提高用户体验，提高服务器的整体性能，是服务治理的常见手段之一
为什么要设置超时 用户体验：很多RPC都是由用户侧发起，如果请求不设置超时时间或者超时时间不合理，会导致用户一直处于白屏或者请求中的状态，影响用户的体验
资源利用：一个RPC会占用两端（服务端与客户端）端口、cpu、内存等一系列的资源，不合理的超时时间会导致RPC占用的资源迟迟不能被释放，因而影响服务器稳定性
综上，一个合理的超时时间是非常必要的。在一些要求更高的服务中，我们还需要针对DNS解析、连接建立，读、写等设置更精细的超时时间。除了设置静态的超时时间，根据当前系统状态、服务链路等设置自适应的动态超时时间也是服务治理中一个常见的方案。
客户端的超时 连接超时 还记得我们怎么在客户端创建的么？
comm := tars.GetCommunicator() client := new(order.OrderManagement) obj := &amp;quot;Test.OrderServer.OrderObj@tcp -h 127.0.0.1 -p 8080 -t 60000&amp;quot; comm.StringToProxy(obj, client) // order, err := client.GetOrderWithContext(ctx, &amp;quot;1&amp;quot;) // if err != nil { // panic(err) // } 如果目标地址tcp -h 127.0.0.1 -p 8080 -t 60000无法建立连接，comm.StringToProxy会出现错误或panic么？这里直接放结论：不会的，TarsGo只有在发生RPC调用时才会创建连接，并不会阻塞在这里，如果RPC调用时连接没有创建成功会在RPC调用中报错。
如果我们想控制连接创建时的超时时间该怎么做呢？
可以修改Tars服务的启动配置文件对应的配置项来完成，目前也只能通过配置文件进配置。默认链接超时时间为3000毫秒，如下所示配置值为毫秒时间戳。
&amp;lt;tars&amp;gt; &amp;lt;application&amp;gt; &amp;lt;client&amp;gt; # 默认值为3000毫秒 clientdialtimeout=3000 &amp;lt;/client&amp;gt; &amp;lt;/application&amp;gt; &amp;lt;/tars&amp;gt; 服务调用的超时 和上面连接超时的配置类似。也可以通过配置文件进行配置。如下所示：
&amp;lt;tars&amp;gt; &amp;lt;application&amp;gt; &amp;lt;client&amp;gt; # 默认值为3000毫秒 async-invoke-timeout=3000 &amp;lt;/client&amp;gt; &amp;lt;/application&amp;gt; &amp;lt;/tars&amp;gt; 同时XXXWithContext服务调用的第一个参数均是context.</description></item><item><title>写给Go开发者的Tars教程-context/status</title><link>/2024/01/09/tarsgo-context/</link><pubDate>Tue, 09 Jan 2024 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2024/01/09/tarsgo-context/</guid><description>本篇为【写给go开发者的Tars教程】系列第五篇
第一篇：Tars协议基础 第二篇：通信模式 第三篇：拦截器 第四篇：错误处理 第五篇：context/status
本系列将持续更新，欢迎关注👏获取实时通知
导语
和在普通HTTP请求中一样，TarsGo提供了在每一次RPC中携带上下文的结构：context和status。在Go语言中，它与context.Context紧密结合，帮助我们实现服务端与客户端之间互相传递信息。其中status主要用于框架底层传递一些框架特性相关的数据。
什么是 context？ TarsGo 的 context和status的简单理解，就是 HTTP Header 中的 key-value 对
context和status 都是以 key-value 的形式存储数据的，其中 key 和 value都是 string 类型。 context和status 使得 client 和 server 能够为对方提供关于本次调用的一些信息，就像一次HTTP请求的Request Header和Response Header一样 HTTP Header 的生命周期是一次 HTTP 请求，那么 context和status 的生命周期就是一次 RPC 调用 context和status 创建 🌲 直接使用make即可： context := make(map[string]string) status := make(map[string]string) 🌲 直接使用map初始化方式： context := map[string]string{&amp;quot;key1&amp;quot;:&amp;quot;value1&amp;quot;,&amp;quot;key2&amp;quot;:&amp;quot;value2&amp;quot;} status := map[string]string{&amp;quot;key1&amp;quot;:&amp;quot;value1&amp;quot;,&amp;quot;key2&amp;quot;:&amp;quot;value2&amp;quot;} context和status 发送和接受 让我们再次回顾下tars文件和生成出来的client与server端的接口
module order { struct Order { 1 require string id; 2 optional vector&amp;lt;string&amp;gt; items; 3 optional string description; 4 require float price; 5 optional string destination; }; interface OrderManagement { Order getOrder(string orderId); }; }; type OrderManagement struct { servant m.</description></item><item><title>写给go开发者的Tars教程-错误处理</title><link>/2024/01/08/tarsgo-errors/</link><pubDate>Mon, 08 Jan 2024 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2024/01/08/tarsgo-errors/</guid><description>本篇为【写给go开发者的Tars教程】系列第四篇
第一篇：Tars协议基础 第二篇：通信模式 第三篇：拦截器 第四篇：错误处理
本系列将持续更新，欢迎关注👏获取实时通知
基本错误处理 首先回顾下tars文件和生成出来的client与server端的接口
module order { struct Order { 1 require string id; 2 optional vector&amp;lt;string&amp;gt; items; 3 optional string description; 4 require float price; 5 optional string destination; }; interface OrderManagement { Order getOrder(string orderId); }; }; type OrderManagement struct { servant m.Servant } func (obj *OrderManagement) GetOrder(orderId string, opts ...map[string]string) (Order, error) { return obj.GetOrderWithContext(context.Background(), orderId, opts...) } func (obj *OrderManagement) GetOrderWithContext(tarsCtx context.Context, orderId string, opts ...map[string]string) (ret Order, err error) { // .</description></item><item><title>写给go开发者的Tars教程-拦截器</title><link>/2024/01/07/tarsgo-middleware/</link><pubDate>Sun, 07 Jan 2024 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2024/01/07/tarsgo-middleware/</guid><description>本篇为【写给go开发者的Tars教程】系列第三篇
第一篇：Tars协议基础 第二篇：通信模式 第三篇：拦截器
TarsGo的拦截器和其他框架的拦截器（也称middleware）作用是一样的。利用拦截器我们可以在不侵入业务逻辑的前提下修改或者记录服务端或客户端的请求与响应，利用拦截器我们可以实现诸如日志记录、权限认证、限流、链路追踪等诸多功能。拦截器可以分别应用在服务端和客户端，所以TarsGo总共为我们提供了多种拦截器，下面我们进行一一介绍。
服务端拦截器（过滤器） 处理前后拦截器（过滤器） 拦截器定义如下：
// Dispatch server side Dispatch type Dispatch func(context.Context, interface{}, *requestf.RequestPacket, *requestf.ResponsePacket, bool) error // ServerFilter is used for add Filter for server dispatcher ,for implementing plugins like opentracing. type ServerFilter func(ctx context.Context, d Dispatch, f interface{}, req *requestf.RequestPacket, resp *requestf.ResponsePacket, withContext bool) (err error) 注册服务端拦截器的方法如下：
func RegisterServerFilter(f ServerFilter) // 注册服务端拦截器，只能注册一个 func RegisterPreServerFilter(f ServerFilter) // 注册服务端处理前拦截器，可多个 func RegisterPostServerFilter(f ServerFilter) // 注册服务端处理后拦截器，可多个 不推荐上面三种注册方法来注册拦截件，将在1.5版本后彻底废弃移除，推荐使用下面介绍的中间件实现对应的逻辑。
示例：
// 注册服务端过滤器 tars.RegisterServerFilter(func(ctx context.Context, d tars.</description></item><item><title>写给go开发者的Tars教程-Tars协议基础</title><link>/2023/06/18/tarsgo-protocol/</link><pubDate>Sun, 18 Jun 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/06/18/tarsgo-protocol/</guid><description>简介 Tars这个名字取自于电影&amp;quot;星际穿越&amp;quot;中的机器人，它是基于名字服务使用Tars协议的高性能RPC开发框架，配套一体化的运营管理平台，并通过伸缩调度，实现运维半托管服务。
Tars是腾讯从2008年到今天一直在使用的后台逻辑层的统一应用框架TAF（Total Application Framework），目前支持C++、Java、PHP、Nodejs、Go语言。该框架为用户提供了涉及到开发、运维、以及测试的一整套解决方案，帮助一个产品或者服务快速开发、部署、测试、上线。 它集可扩展协议编解码、高性能RPC通信框架、名字路由与发现、发布监控、日志统计、配置管理等于一体，通过它可以快速用微服务的方式构建自己的稳定可靠的分布式应用，并实现完整有效的服务治理。
目前该框架在腾讯内部，各大核心业务都在使用，颇受欢迎，基于该框架部署运行的服务节点规模达到上万个。
支持平台 目前运行的操作系统平台如下：
Linux
Mac(&amp;gt;=2.1.0 support)
支持语言 目前支持的开发语言如下：
C++
Java
Nodejs
PHP
Go
版本管理 Tars由多种模块组成, 分散在多个仓库中, 并且基础框架版本和语言版本可以独立发展, 鉴于此, 从2.1.0版本开始, 框架的版本TAG打在TarsFramework仓库上, 不再体现在Tars这个仓库上.
Tars IDL 所谓序列化通俗来说就是把内存的一段数据转化成二进制并存储或者通过网络传输，而读取磁盘或另一端收到后可以在内存中重建这段数据
1、tars协议是跨语言跨平台的序列化协议。
2、tars协议本身也可以被用于非RPC场景，如存储
json、 xml都是一种序列化的方式，只是他们不需要提前预定义idl，且具备可读性，当然他们传输的体积也因此较大，可以说是各有优劣。
关键字 void,struct,bool,byte,short,int,double,float,long,string,vector,map,key,routekey,module,interface,out,require,optional,false,true,enum,const 注释 采用 c++的注释规范：
//表示注释一行 /**/表示注释范围中的所有代码。 基本类型 基本类型会涉及到不同语言和编码方式，这里只整理tars和go类型对照表
.tars Type Go Type Notes void 函数无返回值 只能在函数的返回值表示 bool bool 布尔类型 byte int8 有符号字符 unsigned byte uint8 无符号字符 short int16 有符号短整型 unsigned short uint16 无符号短整形 int int32 有符号整型 unsigned int uint32 无符号整形 long int64 有符号长整型 float float32 32位浮点数 double float64 64位浮点数 string string 字符串 复杂类型 .</description></item><item><title>写给Go开发者的Tars教程-通信模式</title><link>/2023/06/18/tarsgo-rpc/</link><pubDate>Sun, 18 Jun 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/06/18/tarsgo-rpc/</guid><description>本篇为【写给Go开发者的Tars教程系列】第二篇
第一篇：Tars协议基础 第二篇：通信模式 上一篇介绍了如何编写 Tars 的 idl，并使用 idl 生成了 TarsGo RPC 的代码，现在来看看如何编写客户端和服务端的代码
Tars 示例 IDL module order { struct Order { 1 require string id; 2 optional vector&amp;lt;string&amp;gt; items; 3 optional string description; 4 require float price; 5 optional string destination; }; interface OrderManagement { Order getOrder(string orderId); }; }; 生成 go 协议编解码代码 tars2go -outdir=. \ -module=github.com/lbbniu/TarsGo-tutorial \ proto/order.tars order ├── order.go └── OrderManagement.tars.go proto └── order.tars server 实现 服务端开发 1、由 Tars 文件生成的 Go 代码中包含了 interface 的接口定义，它和我们定义的 idl 是吻合的</description></item><item><title>使用docker搭建 tars 开发环境</title><link>/2022/02/15/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA-tars-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link><pubDate>Tue, 15 Feb 2022 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2022/02/15/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA-tars-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid><description>docker pull tarscloud/framework docker run -d --net=host -e MYSQL_HOST=xxxxx -e MYSQL_ROOT_PASSWORD=xxxxx \ -eREBUILD=false -eINET=eth0 -eSLAVE=false \ -v/data/tars:/data/tars \ -v/etc/localtime:/etc/localtime \ tarscloud/framework # custom docker run -d -eMYSQL_HOST=192.168.1.10 -eMYSQL_USER=root -p 3000:3000 -p 18993:18993 \ -eMYSQL_ROOT_PASSWORD=lbbniu@yang0321 \ -eREBUILD=true -eINET=eth0 -eSLAVE=false \ --name tarsframework \ tarscloud/framework docker run -d -eMYSQL_HOST=10.14.166.155 -eMYSQL_USER=root -p 3000:3000 \ -eMYSQL_ROOT_PASSWORD=123456 \ -eREBUILD=false -eINET=eth0 -eSLAVE=false \ --name tarsframework \ tarscloud/framework docker run -ti --rm tarscloud/framework bash docker pull tarscloud/tars docker run -d --net=host -e MYSQL_HOST=xxxxx -e MYSQL_ROOT_PASSWORD=xxxxx \ -eREBUILD=false -eINET=eth0 -eSLAVE=false \ -v/data/tars:/data/tars \ -v/etc/localtime:/etc/localtime \ tarscloud/tars # custom docker run -d --net=host -e MYSQL_HOST=xxxxx -e MYSQL_ROOT_PASSWORD=xxxxx \ -eREBUILD=false -eINET=eth0 -eSLAVE=false \ -v/data/tars:/data/tars \ -v/etc/localtime:/etc/localtime \ tarscloud/tars docker run -d \ --name=tars-framework \ --net=host \ -e MYSQL_HOST=&amp;quot;10.</description></item></channel></rss>