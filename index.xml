<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>lbbniu</title><link>/</link><description>Recent content on lbbniu</description><generator>Hugo -- gohugo.io</generator><language>zh</language><managingEditor>lbbniu@gmail.com (lbbniu)</managingEditor><webMaster>lbbniu@gmail.com (lbbniu)</webMaster><copyright>&amp;copy; 2021 &lt;a href="https://blog.lbbniu.com/">lbbniu&lt;/a></copyright><lastBuildDate>Mon, 15 Jan 2024 15:20:00 +0800</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>面试中算法题目</title><link>/study/leetcode/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98/</guid><description>云账户 /** 给定一个包括 '('，')'，'{'，'}'，'['，']' 和'*'干扰字符的字符串，判断字符串是否有效。 例： {**[*()*(**)**]**} 输出true {**[**)**(**]**} 输出false */ 快手 260. 只出现一次的数字 III 腾讯 168. Excel表列名称 72. 编辑距离 字节 package main import &amp;quot;fmt&amp;quot; func calc(x, y int) int { fmt.Println(x, y, x+y) return x + y } func main() { a := 1 b := 2 defer calc(a, calc(a, b)) a = 0 defer calc(a, calc(a, b)) } 200. 岛屿数量 128. 最长连续序列 某部门面试题 //a_0 = [1] //a_1 = [a_0, 2, a_0] = [1,2,1] //a_2 = [a_1, 3, a_1] = [1,2,1,3,1,2,1] //a_n = [a_{n-1}, n+1, a_{n-1}] // //a_n.</description></item><item><title>预习</title><link>/study/algorithm/php/00%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E9%A2%84%E4%B9%A0/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/php/00%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E9%A2%84%E4%B9%A0/</guid><description>预习 第一课 预习 第二课 预习知识点 数组：为什么很多编程语言中数组都从 0 开始编号？ 链表：如何实现 LRU 缓存淘汰算法? 链表：如何轻松写出正确的链表代码？ 跳表：为什么 Redis 一定要用跳表来实现有序集合？ 预习题目 移动零 盛最多水的容器 爬楼梯 三数之和 环形链表</description></item><item><title>模板-标题</title><link>/2024/01/15/uri-addr/</link><pubDate>Mon, 15 Jan 2024 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2024/01/15/uri-addr/</guid><description>关注公众号获得更多精彩文章</description></item><item><title>写给Go开发者的Tars教程-context/status</title><link>/2024/01/09/tarsgo-context/</link><pubDate>Tue, 09 Jan 2024 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2024/01/09/tarsgo-context/</guid><description>本篇为【写给go开发者的Tars教程】系列第五篇
第一篇：Tars协议基础 第二篇：通信模式 第三篇：拦截器 第四篇：错误处理 第五篇：context/status
本系列将持续更新，欢迎关注👏获取实时通知
导语
和在普通HTTP请求中一样，TarsGo提供了在每一次RPC中携带上下文的结构：context和status。在Go语言中，它与context.Context紧密结合，帮助我们实现服务端与客户端之间互相传递信息。其中status主要用于框架底层传递一些框架特性相关的数据。
什么是 context？ TarsGo 的 context和status的简单理解，就是 HTTP Header 中的 key-value 对
context和status 都是以 key-value 的形式存储数据的，其中 key 和 value都是 string 类型。 context和status 使得 client 和 server 能够为对方提供关于本次调用的一些信息，就像一次HTTP请求的Request Header和Response Header一样 HTTP Header 的生命周期是一次 HTTP 请求，那么 context和status 的生命周期就是一次 RPC 调用 context和status 创建 🌲 直接使用make即可： context := make(map[string]string) status := make(map[string]string) 🌲 直接使用map初始化方式： context := map[string]string{&amp;quot;key1&amp;quot;:&amp;quot;value1&amp;quot;,&amp;quot;key2&amp;quot;:&amp;quot;value2&amp;quot;} status := map[string]string{&amp;quot;key1&amp;quot;:&amp;quot;value1&amp;quot;,&amp;quot;key2&amp;quot;:&amp;quot;value2&amp;quot;} context和status 发送和接受 让我们再次回顾下tars文件和生成出来的client与server端的接口
module order { struct Order { 1 require string id; 2 optional vector&amp;lt;string&amp;gt; items; 3 optional string description; 4 require float price; 5 optional string destination; }; interface OrderManagement { Order getOrder(string orderId); }; }; type OrderManagement struct { servant m.</description></item><item><title>写给go开发者的Tars教程-错误处理</title><link>/2024/01/08/tarsgo-errors/</link><pubDate>Mon, 08 Jan 2024 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2024/01/08/tarsgo-errors/</guid><description>本篇为【写给go开发者的Tars教程】系列第四篇
第一篇：Tars协议基础 第二篇：通信模式 第三篇：拦截器 第四篇：错误处理
本系列将持续更新，欢迎关注👏获取实时通知
基本错误处理 首先回顾下tars文件和生成出来的client与server端的接口
module order { struct Order { 1 require string id; 2 optional vector&amp;lt;string&amp;gt; items; 3 optional string description; 4 require float price; 5 optional string destination; }; interface OrderManagement { Order getOrder(string orderId); }; }; type OrderManagement struct { servant m.Servant } func (obj *OrderManagement) GetOrder(orderId string, opts ...map[string]string) (Order, error) { return obj.GetOrderWithContext(context.Background(), orderId, opts...) } func (obj *OrderManagement) GetOrderWithContext(tarsCtx context.Context, orderId string, opts ...map[string]string) (ret Order, err error) { // .</description></item><item><title>写给go开发者的Tars教程-拦截器</title><link>/2024/01/07/tarsgo-middleware/</link><pubDate>Sun, 07 Jan 2024 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2024/01/07/tarsgo-middleware/</guid><description>本篇为【写给go开发者的Tars教程】系列第三篇
第一篇：Tars协议基础 第二篇：通信模式 第三篇：拦截器
TarsGo的拦截器和其他框架的拦截器（也称middleware）作用是一样的。利用拦截器我们可以在不侵入业务逻辑的前提下修改或者记录服务端或客户端的请求与响应，利用拦截器我们可以实现诸如日志记录、权限认证、限流、链路追踪等诸多功能。拦截器可以分别应用在服务端和客户端，所以TarsGo总共为我们提供了多种拦截器，下面我们进行一一介绍。
服务端拦截器（过滤器） 处理前后拦截器（过滤器） 拦截器定义如下：
// Dispatch server side Dispatch type Dispatch func(context.Context, interface{}, *requestf.RequestPacket, *requestf.ResponsePacket, bool) error // ServerFilter is used for add Filter for server dispatcher ,for implementing plugins like opentracing. type ServerFilter func(ctx context.Context, d Dispatch, f interface{}, req *requestf.RequestPacket, resp *requestf.ResponsePacket, withContext bool) (err error) 注册服务端拦截器的方法如下：
func RegisterServerFilter(f ServerFilter) // 注册服务端拦截器，只能注册一个 func RegisterPreServerFilter(f ServerFilter) // 注册服务端处理前拦截器，可多个 func RegisterPostServerFilter(f ServerFilter) // 注册服务端处理后拦截器，可多个 不推荐上面三种注册方法来注册拦截件，将在1.5版本后彻底废弃移除，推荐使用下面介绍的中间件实现对应的逻辑。
示例：
// 注册服务端过滤器 tars.RegisterServerFilter(func(ctx context.Context, d tars.</description></item><item><title>一篇文章精通php多版本管理工具：phpbrew</title><link>/2024/01/04/phpbrew/</link><pubDate>Thu, 04 Jan 2024 22:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2024/01/04/phpbrew/</guid><description>大家好，我是lbbniu。
今天给大家介绍以下 Uber 开源的静态分析工具 NilAway，下面开鲁。
最近 Uber 开发和开源了一个挺不错的静态分析工具 NilAway：
NilAway是一个静态分析工具，旨在通过在编译时而不是运行时捕获nil panic来帮助开发人员避免在生产中出现这种情况。NilAway类似于标准的nilness分析器，但它采用更复杂和强大的静态分析技术来跟踪包内和跨包的nil流，并报告错误，为用户提供更轻松的调试nilness流程。
NilAway具有三个关键特性，使其脱颖而出：
完全自动化：NilAway配备有推理引擎，因此除了标准的Go代码之外，它不需要从开发人员那里获取任何其他信息（例如注释）。 速度快：我们设计NilAway为快速且可扩展，适用于大型代码库。在我们的测量中，启用NilAway时构建时间开销不到5%。我们还在不断应用优化来进一步减少其占用空间。 实用性：它不能阻止代码中所有可能的nil panic，但它可以捕获我们在生产中观察到的大多数潜在nil panic，使NilAway在实用性和构建时间开销之间保持良好平衡。 安装 NilAway是使用标准的go/analysis框架实现的，因此易于与现有的分析驱动程序集成（例如golangci-lint、nogo或作为独立检查器运行）。下面是将NilAway作为独立检查器运行的说明。更多集成支持将很快添加。
独立检查器 通过以下命令从源代码安装二进制文件：
go install go.uber.org/nilaway/cmd/nilaway@latest 然后，通过以下命令运行linter：
nilaway ./... 代码示例 案例一 让我们看一些示例，了解NilAway如何帮助防止nil panic。
// Example 1: var p *P if someCondition { p = &amp;amp;P{} } print(p.f) // nilness reports NO error here, but NilAway does. 在这个示例中，局部变量p仅在someCondition为true时初始化。在字段访问p.f时，如果someCondition为false，则可能发生panic。NilAway能够捕获这个潜在的nil导致的panic并报告以下错误：
go.uber.org/example.go:12:9: error: Potential nil panic detected. Observed nil flow from source to dereference point: -&amp;gt; go.uber.org/example.go:12:9: unassigned variable `p` accessed field `f` 如果我们使用nil检查（if p !</description></item><item><title>用Golang助力表妹轻松实现自动化办公！（完整代码附后）</title><link>/2023/12/10/goalng-execl/</link><pubDate>Sun, 10 Dec 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/12/10/goalng-execl/</guid><description>Hello，大家好，我是lbbniu~
今天有一个有趣的编程需求要分享，这次的灵感来源于我可爱的表妹。简单来说，我们将利用Golang对Excel文件进行批量处理，达到高效自动化办公的目的。
一、具体需求 手上有一系列N个表格，每个表格都有相同的结构，看起来就像这样：
任务是将所有表中的数据汇总，按照每个人的得分和积分进行合计，然后按总积分排名。在总积分相同的情况下，名次也相同但不是连续的排序。如果总积分和名次都相同，再按总得分降序展示，但不改变排名。
结果如下图所示：
二、Golang开发 首先，让我们引入需要的包：
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;log&amp;quot; &amp;quot;path/filepath&amp;quot; &amp;quot;sort&amp;quot; &amp;quot;github.com/tealeg/xlsx&amp;quot; ) 接下来，获取所有Excel文件的路径：
func getExcelFiles() []string { files, err := filepath.Glob(&amp;quot;./样例数据/*.xlsx&amp;quot;) if err != nil { log.Fatal(err) } return files } 然后，将各表数据合并到主结构体：
// Record 结构体表示每个人的记录 type Record struct { Name string Monthly int Points int Ranking int } func getCellValue(cell *xlsx.Cell) int { value, err := cell.Int() if err != nil { log.Fatal(err) } return value } func mergeData(files []string) []Record { var mergedData []Record for _, file := range files { // 读取Excel文件 xlFile, err := xlsx.</description></item><item><title>写给go开发者的Tars教程-Tars协议基础</title><link>/2023/06/18/tarsgo-protocol/</link><pubDate>Sun, 18 Jun 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/06/18/tarsgo-protocol/</guid><description>简介 Tars这个名字取自于电影&amp;quot;星际穿越&amp;quot;中的机器人，它是基于名字服务使用Tars协议的高性能RPC开发框架，配套一体化的运营管理平台，并通过伸缩调度，实现运维半托管服务。
Tars是腾讯从2008年到今天一直在使用的后台逻辑层的统一应用框架TAF（Total Application Framework），目前支持C++、Java、PHP、Nodejs、Go语言。该框架为用户提供了涉及到开发、运维、以及测试的一整套解决方案，帮助一个产品或者服务快速开发、部署、测试、上线。 它集可扩展协议编解码、高性能RPC通信框架、名字路由与发现、发布监控、日志统计、配置管理等于一体，通过它可以快速用微服务的方式构建自己的稳定可靠的分布式应用，并实现完整有效的服务治理。
目前该框架在腾讯内部，各大核心业务都在使用，颇受欢迎，基于该框架部署运行的服务节点规模达到上万个。
支持平台 目前运行的操作系统平台如下：
Linux
Mac(&amp;gt;=2.1.0 support)
支持语言 目前支持的开发语言如下：
C++
Java
Nodejs
PHP
Go
版本管理 Tars由多种模块组成, 分散在多个仓库中, 并且基础框架版本和语言版本可以独立发展, 鉴于此, 从2.1.0版本开始, 框架的版本TAG打在TarsFramework仓库上, 不再体现在Tars这个仓库上.
Tars IDL 所谓序列化通俗来说就是把内存的一段数据转化成二进制并存储或者通过网络传输，而读取磁盘或另一端收到后可以在内存中重建这段数据
1、tars协议是跨语言跨平台的序列化协议。
2、tars协议本身也可以被用于非RPC场景，如存储
json、 xml都是一种序列化的方式，只是他们不需要提前预定义idl，且具备可读性，当然他们传输的体积也因此较大，可以说是各有优劣。
关键字 void,struct,bool,byte,short,int,double,float,long,string,vector,map,key,routekey,module,interface,out,require,optional,false,true,enum,const 注释 采用 c++的注释规范：
//表示注释一行 /**/表示注释范围中的所有代码。 基本类型 基本类型会涉及到不同语言和编码方式，这里只整理tars和go类型对照表
.tars Type Go Type Notes void 函数无返回值 只能在函数的返回值表示 bool bool 布尔类型 byte int8 有符号字符 unsigned byte uint8 无符号字符 short int16 有符号短整型 unsigned short uint16 无符号短整形 int int32 有符号整型 unsigned int uint32 无符号整形 long int64 有符号长整型 float float32 32位浮点数 double float64 64位浮点数 string string 字符串 复杂类型 .</description></item><item><title>写给Go开发者的Tars教程-通信模式</title><link>/2023/06/18/tarsgo-rpc/</link><pubDate>Sun, 18 Jun 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/06/18/tarsgo-rpc/</guid><description>本篇为【写给Go开发者的Tars教程系列】第二篇
第一篇：Tars协议基础 第二篇：通信模式 上一篇介绍了如何编写 Tars 的 idl，并使用 idl 生成了 TarsGo RPC 的代码，现在来看看如何编写客户端和服务端的代码
Tars 示例 IDL module order { struct Order { 1 require string id; 2 optional vector&amp;lt;string&amp;gt; items; 3 optional string description; 4 require float price; 5 optional string destination; }; interface OrderManagement { Order getOrder(string orderId); }; }; 生成 go 协议编解码代码 tars2go -outdir=. \ -module=github.com/lbbniu/TarsGo-tutorial \ proto/order.tars order ├── order.go └── OrderManagement.tars.go proto └── order.tars server 实现 服务端开发 1、由 Tars 文件生成的 Go 代码中包含了 interface 的接口定义，它和我们定义的 idl 是吻合的</description></item><item><title>Redis Cluster vs Codis Slot Rebalance 算法</title><link>/2023/03/26/redis-cluster-vs-codis-slot-rebalance-%E7%AE%97%E6%B3%95/</link><pubDate>Sun, 26 Mar 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/03/26/redis-cluster-vs-codis-slot-rebalance-%E7%AE%97%E6%B3%95/</guid><description>Redis Cluster Slot Rebalance算法 迁移原则 尽可能的均匀分配Slots； 尽量减少迁移的Slots的数量； Slots分配方案 计算集群的总权重，节点数量； 计算每个集群节点需要移出或移入的槽数，balance 如果为正数代表需要移出的槽数，如果为负数代表需要出入槽数； 把weightedNodes 根据 balance 排序从小到大； 执行槽位移动，并更新集群节点 balance； 代码实现 static int clusterManagerCommandRebalance(int argc, char **argv) { int port = 0; char *ip = NULL; clusterManagerNode **weightedNodes = NULL; list *involved = NULL; if (!getClusterHostFromCmdArgs(argc, argv, &amp;amp;ip, &amp;amp;port)) goto invalid_args; clusterManagerNode *node = clusterManagerNewNode(ip, port, 0); if (!clusterManagerLoadInfoFromNode(node)) return 0; int result = 1, i; if (config.cluster_manager_command.weight != NULL) { for (i = 0; i &amp;lt; config.cluster_manager_command.weight_argc; i++) { char *name = config.</description></item><item><title>Golang语法的25个练习题：21至25题</title><link>/2023/02/24/uri-addr/</link><pubDate>Fri, 24 Feb 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/02/24/uri-addr/</guid><description>题目21：三个数取最大数 己知数字a，b，c分别为10，6，18
找出a，b，c中最大的数字(不借助函数以及列表等方式)
我们知道函数max可以直接获取到最大值，或者可以把数字添加到列表里，通过排序也能获取到最大数字，我们单纯使用if分支来实现
package main import &amp;quot;fmt&amp;quot; func main() { a, b, c := 10, 6, 8 max := a if max &amp;lt; b { max = b } if max &amp;lt; c { max = c } fmt.Println(max) } 题目22：因子之和“完数” 什么是因子？
因子就是所有可以整除这个数的数字，包括1但不包括这个数自身。比如8的因子有1，2，4
什么是完数？
一个数如果恰好等于它的因子之和，这个数就称为“完数”，打印输出1000以内的完数，例如6=1+2+3，6就是“完数
package main import &amp;quot;fmt&amp;quot; func main() { for i := 1; i &amp;lt; 1000; i++ { if i == factorSum(i) { fmt.Println(&amp;quot;//&amp;quot;, i) } } // output: // 6 // 28 // 496 } func factorSum(n int) int { sum := 0 for i := 1; i &amp;lt; n; i++ { if n%i == 0 { sum += i } } return sum } 题目23：递归阶乘求和 一个正整数的阶乘(factorial)是所有小于及等于该数的正整数之积，并且0的阶乘为1</description></item><item><title>Golang语法的25个练习题：16至20题</title><link>/2023/02/23/uri-addr/</link><pubDate>Thu, 23 Feb 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/02/23/uri-addr/</guid><description>题目16：大衍数列 中国古代文献中，曾记载过“大衍数列”，主要用于解释中国传统文化中的太极衍生原理
它的前几项是：0、2、4、8、12、18、24、32、40、50&amp;hellip;
其规律是：偶数项，是序号平方再除2，奇数项，是序号平方减1再除2。
打印大衍数列的前100项
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;math&amp;quot; ) func main() { for i := 1; i &amp;lt;= 100; i++ { var a int if i%2 == 0 { // 偶数 a = int(math.Pow(float64(i), 2)) / 2 } else { // 奇数 a = (int(math.Pow(float64(i), 2)) - 1) / 2 } fmt.Println(&amp;quot;//&amp;quot;, a) } // 0 // 2 // 4 // 8 // 12 // 18 // 24 // 32 // 40 // 50 } 题目17：单词分析 小蓝正在学习一门神奇的语言，这门语言中的单词都是由小写英文字母组成，有些单词很长，远远超过正常英文单词的长度。小蓝学了很长时间也记不住一些单词，他准备不再完全记忆这些单词，而是根据单词中哪个字母出现得最多来分辨单词 现在，请你帮助小蓝，给了一个单词后，帮助他找到出现最多的字母和这个字母出现的次数 其实就是让你输入一段字符串后，得到当前字符串出现最多的字母和它的次数 输入：HelloWorld 输出： l 3 我们可以对当前的字符串进行循环迭代，然后把字符串当前每个字符当作key值，把它存到字典里面，如果当前key在字典里面，我们就让它加一，如果不在那我们就让它的次数初始化为1，最终我们再从字典找到次数最多的key值和value值 package main import &amp;quot;fmt&amp;quot; func main() { analyseWords(&amp;quot;helloworld&amp;quot;) // l 3 } func analyseWords(word string) { wordDict := map[rune]int{} var ( count int ch rune ) for _, c := range word { wordDict[c]++ if wordDict[c] &amp;gt; count { count, ch = wordDict[c], c } } fmt.</description></item><item><title>Golang语法的25个练习题：11至15题</title><link>/2023/02/22/uri-addr/</link><pubDate>Wed, 22 Feb 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/02/22/uri-addr/</guid><description>题目11：剪刀石头布 游戏开始，初始状态下用户和电脑都有100分，赢一局+10分，输一局-10分。当用户为0分时，游戏结束，提示游戏结束，比赛输了，当用户为200分时，游戏结束，提示游戏结束，赢得比赛、每轮比赛都输出当前的分数
1代表剪刀 2代表石头 3代表布
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;math/rand&amp;quot; &amp;quot;os&amp;quot; &amp;quot;strconv&amp;quot; &amp;quot;strings&amp;quot; &amp;quot;time&amp;quot; ) var ( gameInfo = map[int]string{ 1: &amp;quot;剪刀&amp;quot;, 2: &amp;quot;石头&amp;quot;, 3: &amp;quot;布&amp;quot;, } score = 100 ) func main() { fmt.Println(strings.Repeat(&amp;quot;=&amp;quot;, 60)) fmt.Println(strings.Repeat(&amp;quot; &amp;quot;, 20), &amp;quot;剪刀石头布游戏&amp;quot;) fmt.Println(&amp;quot;1代表剪刀 2代表石头 3代表布&amp;quot;) for { rd := rand.New(rand.NewSource(time.Now().UnixNano())) robotsChoice := rd.Intn(3) if robotsChoice == 0 { robotsChoice++ } userChoice, err := input(&amp;quot;请出拳&amp;quot;) if err != nil { fmt.Println(err) continue } if _, ok := gameInfo[userChoice]; !</description></item><item><title>Golang语法的25个练习题：6至10题</title><link>/2023/02/15/uri-addr/</link><pubDate>Wed, 15 Feb 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/02/15/uri-addr/</guid><description>题目6：闰年问题升级版 输入年月日，输出该日期是否是闰年，并且输出该日期是此年份的第几天
闰年判断条件：
能被4整除，并且不能被100整除 能被400整除 两个条件满足任意一个就为闰年 算法思路
接收用户输入的年月日，创建保存12个月份天数的列表 根据年份判断是否是闰年，如果是把二月份设为29天，否则把二月份设为28天 根据月份和日期统计是当年的第几天 package main import ( &amp;quot;fmt&amp;quot; &amp;quot;log&amp;quot; &amp;quot;os&amp;quot; &amp;quot;strconv&amp;quot; ) func main() { year, err := input(&amp;quot;请输入年份&amp;quot;) if err != nil { log.Fatalln(err) } month, err := input(&amp;quot;请输入月份&amp;quot;) if err != nil { log.Fatalln(err) } day, err := input(&amp;quot;请输入日期&amp;quot;) if err != nil { log.Fatalln(err) } dateList := []int{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31} countDay := day if year%4 == 0 &amp;amp;&amp;amp; year%100 !</description></item><item><title>Golang语法的25个练习题：1至5题</title><link>/2023/02/13/uri-addr/</link><pubDate>Mon, 13 Feb 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/02/13/uri-addr/</guid><description>题目1：水仙花数 水仙花数（Narcissistic number）也被称为超完全数字不变数（pluperfect digital invariant, PPDI）、自恋数、自幂数、阿姆斯壮数或阿姆斯特朗数（Armstrong number），水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身。例如：1^3 + 5^3+ 3^3 = 153。
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;math&amp;quot; ) func main() { // 写法一 for i := 100; i &amp;lt; 1000; i++ { // 取百位数字 123//100=1 // 取十位数字 123//10=12 12%10=2 // 取个位数字 123%10=3 i1, i2, i3 := i/100, i/10%10, i%10 if int(math.Pow(float64(i1), 3)+math.Pow(float64(i2), 3)+math.Pow(float64(i3), 3)) == i { fmt.Printf(&amp;quot;%d是水仙花数\n&amp;quot;, i) // 153 是水仙花数 // 370 是水仙花数 // 371 是水仙花数 // 407 是水仙花数 } } // 写法二 for i := 1000; i &amp;lt; 10000; i++ { sum := 0 for k := i; k &amp;gt; 0; k = k / 10 { // 个十百 sum += int(math.</description></item><item><title>一篇文章精通php多版本管理工具：phpbrew</title><link>/2023/01/04/phpbrew/</link><pubDate>Wed, 04 Jan 2023 22:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/01/04/phpbrew/</guid><description>phpbrew是一个工具，可以在$HOME目录中构建和安装多个PHP版本。
phpbrew的功能包括：
将配置选项简化为变体，不再担心路径问题。 使用不同的变体构建PHP，如PDO、mysql、sqlite、debug等。 编译Apache PHP模块，并按不同版本分开。 在个人目录中构建和安装PHP，无需root权限。 轻松切换版本，与bash/zsh shell集成。 自动功能检测。 轻松在当前环境中安装和启用PHP扩展。 在系统范围内安装多个PHP。 针对HomeBrew和MacPorts的路径检测优化。 要求 请查看 Requirement 在开始之前。你需要安装一些用于构建 PHP 的开发包。
安装 只需下载它：
curl -L -O https://github.com/phpbrew/phpbrew/releases/latest/download/phpbrew.phar chmod +x phpbrew.phar 然后，你可以将其安装到 bin 文件夹中：
sudo mv phpbrew.phar /usr/local/bin/phpbrew 确保在你的 $PATH 环境变量中有 /usr/local/bin。
设置 初始化一个用于你的 shell 环境的 bash 脚本：
phpbrew init 将以下行添加到你的 .bashrc 或 .zshrc 文件：
[[ -e ~/.phpbrew/bashrc ]] &amp;amp;&amp;amp; source ~/.phpbrew/bashrc 设置查找前缀 你可以设置你首选的用于查找库的默认前缀，可用选项有 macports、homebrew、debian、ubuntu 或自定义路径：
对于 Homebrew 用户：
phpbrew lookup-prefix homebrew 对于 Macports 用户：
phpbrew lookup-prefix macports 基本用法 列出已知版本：</description></item><item><title>polaris-go 源码走读</title><link>/2022/10/28/polaris-go/</link><pubDate>Fri, 28 Oct 2022 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2022/10/28/polaris-go/</guid><description>provider 实例化ProviderAPI NewProviderAPI() -&amp;gt; 根据默认配置文件./polaris.yaml 实例化 api.newProviderAPI-&amp;gt;api.newProviderAPIByConfig-&amp;gt;api.InitContextByConfig-&amp;gt;[api.newProviderAPIByContext]-&amp;gt;&amp;amp;providerAPI{rawAPI: p} NewProviderAPIByFile(path string) -&amp;gt; 根据指定配置文件实例化 api.newProviderAPIByFile-&amp;gt;api.InitContextByFile-&amp;gt;api.InitContextByStream-&amp;gt;api.InitContextByConfig-&amp;gt;[api.newProviderAPIByContext]-&amp;gt;&amp;amp;providerAPI{rawAPI: p} NewProviderAPIByConfig(cfg config.Configuration) -&amp;gt; 根据指定配置实例化 api.newProviderAPIByConfig-&amp;gt;api.InitContextByConfig-&amp;gt;[api.newProviderAPIByContext] NewProviderAPIByContext(context api.SDKContext) -&amp;gt; 根据指定api.SDKContext实例化 api.newProviderAPIByContext-&amp;gt;&amp;amp;providerAPI{rawAPI: p} NewProviderAPIByAddress(address &amp;hellip;string) -&amp;gt; 根据指定 polaris-server 地址实例化 api.newProviderAPIByAddress-&amp;gt;[config.NewDefaultConfiguration]-&amp;gt;api.newProviderAPIByConfig-&amp;gt;api.InitContextByConfig-&amp;gt;[api.newProviderAPIByContext]-&amp;gt;&amp;amp;providerAPI{rawAPI: p} 以上所有方法最终都会走到api.newProviderAPIByContex方法, 然后返回&amp;amp;providerAPI{rawAPI: p}
![image-20221104120449226](/Users/lbbniu/Library/Application Support/typora-user-images/image-20221104120449226.png)
相关接口定义 // ProviderAPI CL5服务端API的主接口 type ProviderAPI interface { // RegisterInstance // minimum supported version of polaris-server is v1.10.0 RegisterInstance(instance *InstanceRegisterRequest) (*model.InstanceRegisterResponse, error) // Deregister synchronize the anti registration service Deregister(instance *InstanceDeRegisterRequest) error // Destroy the api is destroyed and cannot be called again Destroy() } RegisterInstance // providerAPI 调用者对外函数实现 type providerAPI struct { rawAPI api.</description></item><item><title>剑指 Offer 03 数组中重复的数字</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/</guid><description>剑指 Offer 03 数组中重复的数字 找出数组中重复的数字。
在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
示例 1：
输入： [2, 3, 1, 0, 2, 5, 3] 输出：2 或 3 &amp;nbsp;
限制：
2 &amp;lt;= n &amp;lt;= 100000
func findRepeatNumber(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof</description></item><item><title>剑指 Offer II 001 整数除法</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/xoh6oh/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/xoh6oh/</guid><description>剑指 Offer II 001 整数除法 给定两个整数 a 和 b ，求它们的除法的商 a/b ，要求不得使用乘号 &amp;#39;*&amp;#39;、除号 &amp;#39;/&amp;#39; 以及求余符号 &amp;#39;%&amp;#39;&amp;nbsp;。
&amp;nbsp;
注意：
整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8&amp;nbsp;以及&amp;nbsp;truncate(-2.7335) = -2 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [&amp;minus;231,&amp;nbsp;231&amp;minus;1]。本题中，如果除法结果溢出，则返回 231&amp;nbsp;&amp;minus; 1 &amp;nbsp;
示例 1：
输入：a = 15, b = 2 输出：7 解释：15/2 = truncate(7.5) = 7 示例 2：
输入：a = 7, b = -3 输出：-2 解释：7/-3 = truncate(-2.33333..) = -2 示例 3：
输入：a = 0, b = 1 输出：0 示例 4：
输入：a = 1, b = 1 输出：1 &amp;nbsp;</description></item><item><title>面试题 01.01 判定字符是否唯一</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/is-unique-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/is-unique-lcci/</guid><description>面试题 01.01 判定字符是否唯一 实现一个算法，确定一个字符串 s 的所有字符是否全都不同。
示例 1：
输入: s = "leetcode" 输出: false 示例 2：
输入: s = "abc" 输出: true 限制：
0 &amp;lt;= len(s) &amp;lt;= 100 s[i]仅包含小写字母 如果你不使用额外的数据结构，会很加分。 func isUnique(astr string) bool { } LeetCode题库地址 https://leetcode.cn/problems/is-unique-lcci</description></item><item><title>Go 实战训练营——开源项目学习计划</title><link>/2022/06/26/open-source-study/</link><pubDate>Sun, 26 Jun 2022 14:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2022/06/26/open-source-study/</guid><description>Go 实战训练营0期： https://shimo.im/docs/3GP6Kwsdm5It9UOV Go实战训练营1期： https://shimo.im/docs/rqizHOhKFrUQKG42/read 开源项目 Web： Beego：https://github.com/beego/beego httprouter：https://github.com/julienschmidt/httprouter Gin：https://github.com/gin-gonic/gin 微服务： Dubbo-go：https://github.com/apache/dubbo-go Kratos：https://github.com/go-kratos/kratos gRPC：https://github.com/grpc/grpc-go orm： GORM：https://github.com/go-gorm/gorm ENT：https://github.com/ent/ent redsync：https://github.com/go-redsync/redsync bytebufferpool：https://github.com/valyala/bytebufferpool errgroup： https://cs.opensource.google/go/x/sync https://pkg.go.dev/golang.org/x/sync/errgroup 关注公众号获得更多精彩文章</description></item><item><title>【腾讯云 Finops Crane 集训营】EHPA控制器核心源码分析</title><link>/2022/02/15/crane-ehpa-code/</link><pubDate>Tue, 15 Feb 2022 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2022/02/15/crane-ehpa-code/</guid><description>官方文档：https://gocrane.io/ Github： https://github.com/gocrane/crane 启动流程 main 函数 craned 启动入口在cmd/craned/main.go文件中，main方法代码如下
func main() { logs.InitLogs() defer logs.FlushLogs() ctx := signals.SetupSignalHandler() if err := app.NewManagerCommand(ctx).Execute(); err != nil { fmt.Fprintf(os.Stderr, &amp;quot;%v\n&amp;quot;, err) os.Exit(1) } } 下面进行逐行分析：
2~3 行初始化日志，历史defer在程序退出前刷新缓存区 5行通过controller-runtime包获取信号监听可取消的context 7行创建cobra.Command命令行实例并直接调用Execute方法启动应用，如果出错退出程序 app.NewManagerCommand方法在cmd/craned/app/manager.go文件中，函数中主要是创建Options和cobra.Command，并初始化命令行参数选项。cobra.Command在执行的时候回调用cmd/craned/app/manager.go文件中的Run函数。
Run 函数 下面来重点分析下Run函数。代码如下：
// Run runs the craned with options. This should never exit. func Run(ctx context.Context, opts *options.Options) error { config := ctrl.GetConfigOrDie() config.QPS = float32(opts.ApiQps) config.Burst = opts.ApiBurst ctrlOptions := ctrl.Options{ Scheme: scheme, MetricsBindAddress: opts.MetricsAddr, Port: 9443, HealthProbeBindAddress: opts.</description></item><item><title>hugoio</title><link>/2022/02/15/uri-addr/</link><pubDate>Tue, 15 Feb 2022 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2022/02/15/uri-addr/</guid><description>https://github.com/gohugoio/hugo/blob/0f8dc47037/hugolib/page__meta.go for k, v := range frontmatter { loki := strings.ToLower(k) if loki == &amp;quot;published&amp;quot; { // Intentionally undocumented vv, err := cast.ToBoolE(v) if err == nil { published = &amp;amp;vv } // published may also be a date continue } if pm.s.frontmatterHandler.IsDateKey(loki) { continue } switch loki { case &amp;quot;title&amp;quot;: pm.title = cast.ToString(v) pm.params[loki] = pm.title case &amp;quot;linktitle&amp;quot;: pm.linkTitle = cast.ToString(v) pm.params[loki] = pm.linkTitle case &amp;quot;summary&amp;quot;: pm.summary = cast.ToString(v) pm.params[loki] = pm.summary case &amp;quot;description&amp;quot;: pm.</description></item><item><title>pushgateway group清理</title><link>/2022/02/15/pushgateway-group%E6%B8%85%E7%90%86/</link><pubDate>Tue, 15 Feb 2022 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2022/02/15/pushgateway-group%E6%B8%85%E7%90%86/</guid><description>trap 'echo &amp;quot;got sigterm&amp;quot; ; exit 0' SIGTERM EXPIRATION_SECONDS=${EXPIRATION_SECONDS:-600} PGW_URL=${PGW_URL:-http://10.176.78.78:9091} function convert_to_standardnotation(){ # convert number from scientific notation to standar d( ie '1.5383780136826127e+09' ) printf '%.0f' $1 } function extract_pushgateway_variable(){ local -r _METRIC=$1 local -r _VARNAME=$2 #echo 'push_time_seconds{instance=&amp;quot;10.32.32.7&amp;quot;,job=&amp;quot;bk_jenkins&amp;quot;} 1.5383802210997093e+09' | sed -r 's/.*instance=&amp;quot;([^&amp;quot;]*).*/\1/g' echo $_METRIC | sed -r &amp;quot;s/.*${_VARNAME}=\&amp;quot;([^\&amp;quot;]*).*/\\1/g&amp;quot; # sample usage : # extract_pushgateway_variable 'push_time_seconds{instance=&amp;quot;10.32.32.7&amp;quot;,job=&amp;quot;bk_jenkins&amp;quot;} 1.5383802210997093e+09' 'instance' } function extract_pushgateway_uri(){ local -r _METRIC=$1 #echo 'push_time_seconds{instance=&amp;quot;10.32.32.7&amp;quot;,job=&amp;quot;bk_jenkins&amp;quot;} 1.5383802210997093e+09' | awk -F{ '{print $2}' | awk -F} '{print $1}' | sed -e &amp;quot;s/[=,]/\//g&amp;quot; -e &amp;quot;s/\&amp;quot;//g&amp;quot; metricJob=$(extract_pushgateway_variable &amp;quot;$_METRIC&amp;quot; 'job') echo $_METRIC | awk -F{ '{print $2}' | awk -F} '{print $1}' | sed -e &amp;quot;s/[=,]/\//g&amp;quot; -e &amp;quot;s/\&amp;quot;//g&amp;quot; -e &amp;quot;s/job\///g&amp;quot; -e &amp;quot;s/${metricJob}\///g&amp;quot; -e &amp;quot;s/instance\/\///g&amp;quot; # sample usage : # extract_pushgateway_uri 'push_time_seconds{instance=&amp;quot;10.</description></item><item><title>如何实现 Service Weaver 部署器</title><link>/2022/02/15/deployers/</link><pubDate>Tue, 15 Feb 2022 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2022/02/15/deployers/</guid><description>声明 作者能力有限，如感觉有翻译不准确的请移步原文。
原文地址：https://serviceweaver.dev/blog/deployers.html 。
Service Weaver 允许您以多种不同的方式部署应用程序。例如，您可以在单个进程 、跨多个进程 或云 中部署应用程序。毫不奇怪，部署 Service Weaver 应用程序的代码称为deployer。这篇博文解释了部署器是什么以及如何实施部署器。我们假设您熟悉如何编写 Service Weaver 应用程序。如果不是，我们建议您阅读分步教程 。
概述 Service Weaver 应用程序由许多组件 组成。该应用程序被编译成单个应用程序二进制文件。部署者通过多次运行二进制文件来部署应用程序，通常是跨多台机器。二进制文件的每个实例都运行组件的一个子集。为了了解要运行哪些组件，二进制链接在一个称为 weavelet 的小型后台代理中，部署者使用envelope与之通信。如下图所示。
在这篇博文中，我们提供了对weavelets、deployers和envelopes的高级概述。然后，我们通过完全从头开始实施多进程部署程序，深入了解它们的工作原理。
Weavelets 要了解部署器，我们必须首先了解小波。Service Weaver 应用程序被编译成单个可执行二进制文件。链接到二进制文件中的 Service Weaver 库包括一个称为weavelet的小代理，它是在您调用 weaver.Init 时创建的。Weavelet 的主要职责是启动和管理一组组件。
部署 Service Weaver 应用程序时，不只有一个 weavelet。如果有只有一个，Service Weaver 应用程序就不会非常分散。相反，部署人员会多次运行您的二进制文件——在不同机器上的不同进程中以启动多个 weavelet，这些 weavelet 协同工作以执行您的分布式应用程序。
每个 weavelet 都承载一组可能不同的组件。因为组件是复制的，所以一个组件可能由多个weavelets托管。例如，考虑一个包含组件A、B和的应用程序C。下图显示了一个由三个weavelets组成的示例部署。weavelet 1 托管组件A和B；weavelet 2 承载组件B和 C，weavelet 3 承载组件C。
您还会注意到每个小波都有一个唯一的网络地址。Weavelets 使用这些地址来执行远程方法调用。例如，假设图中 weavelet 1上的A组件想要调用组件C 上的方法。weavelet 1 将联系地址 2.2.2.2 上的 weavelet 2 或地址 3.3.3.3 上的 weavelet 3 以执行该方法。
部署者 部署者通过启动和管理一组 weavelet 来分发 Service Weaver 应用程序。管理 weavelet 涉及与 (1) 组件、(2) 侦听器和 (3) 遥测相关的三个主要职责。</description></item><item><title>使用docker搭建 tars 开发环境</title><link>/2022/02/15/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA-tars-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link><pubDate>Tue, 15 Feb 2022 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2022/02/15/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA-tars-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid><description>docker pull tarscloud/framework docker run -d --net=host -e MYSQL_HOST=xxxxx -e MYSQL_ROOT_PASSWORD=xxxxx \ -eREBUILD=false -eINET=eth0 -eSLAVE=false \ -v/data/tars:/data/tars \ -v/etc/localtime:/etc/localtime \ tarscloud/framework # custom docker run -d -eMYSQL_HOST=192.168.1.10 -eMYSQL_USER=root -p 3000:3000 -p 18993:18993 \ -eMYSQL_ROOT_PASSWORD=lbbniu@yang0321 \ -eREBUILD=true -eINET=eth0 -eSLAVE=false \ --name tarsframework \ tarscloud/framework docker run -d -eMYSQL_HOST=10.14.166.155 -eMYSQL_USER=root -p 3000:3000 \ -eMYSQL_ROOT_PASSWORD=123456 \ -eREBUILD=false -eINET=eth0 -eSLAVE=false \ --name tarsframework \ tarscloud/framework docker run -ti --rm tarscloud/framework bash docker pull tarscloud/tars docker run -d --net=host -e MYSQL_HOST=xxxxx -e MYSQL_ROOT_PASSWORD=xxxxx \ -eREBUILD=false -eINET=eth0 -eSLAVE=false \ -v/data/tars:/data/tars \ -v/etc/localtime:/etc/localtime \ tarscloud/tars # custom docker run -d --net=host -e MYSQL_HOST=xxxxx -e MYSQL_ROOT_PASSWORD=xxxxx \ -eREBUILD=false -eINET=eth0 -eSLAVE=false \ -v/data/tars:/data/tars \ -v/etc/localtime:/etc/localtime \ tarscloud/tars docker run -d \ --name=tars-framework \ --net=host \ -e MYSQL_HOST=&amp;quot;10.</description></item><item><title>第01周：微服务</title><link>/docs/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/week01/</link><pubDate>Tue, 25 Jan 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/week01/</guid><description>Golang 基础语法和 Web 框架起步 代码地址：flycash/toy-web: 用于极客时间 go 基础课程 (github.com)
关注公众号获得更多精彩文章</description></item><item><title>预习</title><link>/study/algorithm/go/week00/</link><pubDate>Tue, 30 Nov 2021 13:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/go/week00/</guid><description>第1课 | 数据结构与算法总览 参考链接 算法训练营第 4 期学员谭帅的作业 （提取码：ykyn） 课后作业 绘制自己的数据结构和算法脑图 用脑图的方式把知识的脉络串联起来，不管对于学习新知识还是巩固已有知识，都是一种很好的学习方式。同学们可以将目前自己所掌握的数据结构和算法知识绘制成脑图，在绘制过程中可以查阅资料，补充目前掌握欠缺的部分，找到自己薄弱的地方。后面再通过课程的学习和刻意练习，动态地将自己绘制的脑图逐步补充、完善，从而达到真正的融会贯通。
脑图绘制工具不限，同学们需要按时将作业提交到班级 GitHub 中。
第2课 | 训练准备和复杂度分析 1. 训练环境设置、编码技巧和Code Style 参考链接 Windows Microsoft New Terminal VS Code Themes 教你打造一款颜值逆天的 VS Code 炫酷的 VS Code 毛玻璃效果 自顶向下的编程方式 自顶向下编程的 LeetCode 例题 2. 时间复杂度和空间复杂度分析 参考链接 如何理解算法时间复杂度的表示法 Master theorem 主定理 下周预习 预习知识点 数组：为什么很多编程语言中数组都从 0 开始编号？ 链表：如何实现 LRU 缓存淘汰算法? 链表：如何轻松写出正确的链表代码？ 跳表：为什么 Redis 一定要用跳表来实现有序集合？ 预习题目 移动零 盛最多水的容器 爬楼梯 三数之和 环形链表</description></item><item><title>第一周 数组、链表、栈、队列</title><link>/study/2021algorithm/week01/</link><pubDate>Thu, 25 Nov 2021 10:30:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/2021algorithm/week01/</guid><description>题目数：19
本周作业 66.加一 （Easy）半年内出题频次： Facebook 字节跳动 微软 Amazon 快手 美团 Google 腾讯 华为 百度 0 0 3 3 0 0 4 0 0 0 // 写法一，面试推荐写法 func plusOne(digits []int) []int { n := len(digits) for i := n - 1; i &amp;gt;=0; i-- { digits[i] = (digits[i] + 1) % 10 if digits[i] != 0 { return digits } } ans := make([]int, n + 1) ans[0] = 1 return ans } // 写法二： func plusOne(digits []int) []int { for i := len(digits) - 1; i &amp;gt;= 0; i-- { // 统计9的个数 if digits[i] !</description></item><item><title>第一课Go程序怎么跑起来的</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/01%E7%AC%AC%E4%B8%80%E8%AF%BEgo%E7%A8%8B%E5%BA%8F%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/</link><pubDate>Tue, 23 Nov 2021 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/01%E7%AC%AC%E4%B8%80%E8%AF%BEgo%E7%A8%8B%E5%BA%8F%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/</guid><description>怎么学习？ https://xargin.com/how-to-learn 找程序入口 gdb info files readelf -h cutter[可视化工具] dlv 理解可执⾏⽂件 本节课涉及的⼯具都准备在Dockerfile⾥了，⼤家可以⾃⾏实验
2200000000 FROM centos RUN yum install golang -y \ &amp;amp;&amp;amp; yum install dlv -y \ &amp;amp;&amp;amp; yum install binutils -y \ &amp;amp;&amp;amp; yum install vim -y \ &amp;amp;&amp;amp; yum install gdb -y 编译方法 # 编译方法 docker build -t test . docker run -it --rm test bash Linux的可执⾏⽂件ELF(Executable and Linkable Format)为例，ELF由⼏部分构成：
ELF header Section header Sections 参考连接 https://github.com/corkaami/pics Go进程的启动与初始化 游戏：人力资源机器
环境变量：GOMAXPROCS
调度组件与调度循环 goroutine的⽣产端 https://www.figma.com/proto/gByIPDf4nRr6No4dNYjn3e/bootstrap?page-id=242%3A7&amp;amp;nodeid=242%3A215&amp;amp;viewport=516%2C209%2C0.07501539587974548&amp;amp;scaling=scale-down-width goroutine的消费端 https://www.</description></item><item><title>管理多版本 Go 安装</title><link>/2021/11/23/%E7%AE%A1%E7%90%86%E5%A4%9A%E7%89%88%E6%9C%AC-go-%E5%AE%89%E8%A3%85/</link><pubDate>Tue, 23 Nov 2021 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2021/11/23/%E7%AE%A1%E7%90%86%E5%A4%9A%E7%89%88%E6%9C%AC-go-%E5%AE%89%E8%A3%85/</guid><description>管理 Go 安装 目录 安装多个 Go 版本 卸载 Go Linux / macOS / FreeBSD 视窗 本主题介绍如何在同一台机器上安装多个版本的 Go，以及如何卸载 Go。
有关安装的其他内容，您可能对以下内容感兴趣：
下载和安装 ——最简单的安装和运行方式。 从源代码安装 Go—— 如何检查源代码、在您自己的机器上构建它们并运行它们。 安装多个 Go 版本 您可以在同一台机器上安装多个 Go 版本。例如，您可能希望在多个 Go 版本上测试您的代码。有关可以通过这种方式安装的版本列表，请参阅下载页面 。
**注意：**要使用此处描述的方法进行安装，您需要安装git 。
要安装其他 Go 版本，请运行go install命令 ，指定要安装的版本的下载位置。以下示例说明了版本 1.10.7：
# go version &amp;lt; 1.17 $ go get -u golang.org/dl/go1.10.7 # go version &amp;gt;= 1.17 $ go install golang.org/dl/go1.10.7@latest $ go1.10.7 download	要使用新下载的版本运行go命令，请将版本号附加到go命令中，如下所示：
$ go1.10.7 version go version go1.10.7 linux/amd64 当您安装了多个版本时，您可以发现每个版本的安装位置，查看版本的GOROOT值。例如，运行如下命令：
$ go1.10.7 env GOROOT 要卸载下载的版本，只需删除其GOROOT环境变量和 goX.</description></item><item><title>Go进阶训练班营</title><link>/docs/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/0%E6%9C%9F%E7%AD%94%E7%96%91/</link><pubDate>Tue, 23 Nov 2021 10:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/0%E6%9C%9F%E7%AD%94%E7%96%91/</guid><description>1期答疑 整理
第一周答疑文档 https://shimo.im/docs/prWppTp6qKPgrHwY 第二周答疑文档 https://shimo.im/docs/J8yqjXTpQ9Jq6yHP 第三周答疑文档 https://shimo.im/docs/QwCpDVXgctQKhrq3 第四章答疑文档 https://shimo.im/docs/cTrTCpk8d69Vh8Tv 四期领教：https://shimo.im/docs/ckKygv6yRkXD3C8D
大明面试八股文：
https://github.com/flycash/interview-baguwen 关注公众号获得更多精彩文章</description></item><item><title>第1周</title><link>/study/algorithm/php/01%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%80%E5%91%A8/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/php/01%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%80%E5%91%A8/</guid><description>第一周 第三课|数组、链表、跳表 参考链接 Java 源码分析（ArrayList） Linked List 的标准实现代码 [Linked List 示例代码](http://www.cs.cmu.edu/~adamchik/15-121/lectures/Linked Lists/code/LinkedList.java) Java 源码分析（LinkedList） LRU Cache - Linked list： LRU 缓存机制 Redis - Skip List：跳跃表 、为啥 Redis 使用跳表（Skip List）而不是使用 Red-Black？ Array 实战题目 11. 盛最多水的容器 //方法一： 暴力求解 双循环 class Solution { /** * @param Integer[] $height * @return Integer */ function maxArea($height) { $max = 0; $len = count($height); for ($i = 0; $i &amp;lt; $len - 1; $i++) { for ($j = $i + 1; $j &amp;lt; $len; $j++) { $area = ($j - $i) * min($height[$i], $height[$j]); $max = $area &amp;lt; $max ?</description></item><item><title>第1周 数组、链表、跳表</title><link>/study/algorithm/go/week01/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/go/week01/</guid><description>题目数量：16
第三课|数组、链表、跳表 1. 数组、链表、跳表的基本实现和特性 参考链接 Java 源码分析（ArrayList） Linked List 的标准实现代码 [Linked List 示例代码](http://www.cs.cmu.edu/~adamchik/15-121/lectures/Linked Lists/code/LinkedList.java)
Java 源码分析（LinkedList） LRU Cache - Linked list： LRU 缓存机制 Redis - Skip List：跳跃表 、为啥 Redis 使用跳表（Skip List）而不是使用 Red-Black？ 2. 实战题目解析：移动零 3. 实战题目解析：盛水最多的容器、爬楼梯 Array 实战题目 11. 盛最多水的容器 // 双指针 283. 移动零 // 双指针 70. 爬楼梯 15. 三数之和 (高频老题） // 排序 + 双指针 4. 实战题目解析：3数之和、环形链表 两数之和题目： https://leetcode-cn.com/problems/two-sum/ Linked List 实战题目 206. 反转链表 使用递归函数，一直递归到链表的最后一个结点，该结点就是反转后的头结点，记作 ret .
此后，每次函数在返回的过程中，让当前结点的下一个结点的 next 指针指向当前节点。
同时让当前结点的 next 指针指向 NULL ，从而实现从链表尾部开始的局部反转</description></item><item><title>微明互动负责参与项目</title><link>/2021/11/20/%E5%BE%AE%E6%98%8E%E4%BA%92%E5%8A%A8%E8%B4%9F%E8%B4%A3%E5%8F%82%E4%B8%8E%E9%A1%B9%E7%9B%AE/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2021/11/20/%E5%BE%AE%E6%98%8E%E4%BA%92%E5%8A%A8%E8%B4%9F%E8%B4%A3%E5%8F%82%E4%B8%8E%E9%A1%B9%E7%9B%AE/</guid><description>2014-2016项目 云热卖 app38 联联 app45 李宁酷跑 app46 htc新渴望 app47 沃尔玛动态贺卡生成器 app49 联信 app50 第九屏 app52/d9ping htc新渴望8 app53 六推云平台 app54 搜狗极限科考 app55 360安全第一 app57 红旗 app59 海尔智慧答题 app60 多喜爱手机端 app61 联想thinkpad app62 斯巴鲁汽车 app64 联想thinkpad 联想禁止随地办公 app66 苏泊尔厨具 app70 亚马逊2048 app71 王老吉疯狂2048 app73 联想刮刮乐 app74 淘手游网站改版（YII框架） 巴布豆（手机和pc） app75 htc one m8申请 app76 高德地图lbs大赛 app77 htc one预约（手机和pc） app78 华为Meta7手机 app79 51jobs统计数据 app80 海尔口袋体验馆 app81 丰田一期 相信自己 app83 htc五月天 app84 海尔问题查询 app85 丰田二期项目 app86 特百惠 app87 特百惠外带小萌 app89 一汽大众 app90 搜狗手机活动项目 app91 全球购 微信项目（微信支付） app92 thinkphp intel大赛项目 app94 联通邀请函 app95 百佳手机 app96 IBM下载中心 app97 2015.</description></item><item><title>剑指 Offer 04 二维数组中的查找</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-wei-shu-zu-zhong-de-cha-zhao-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-wei-shu-zu-zhong-de-cha-zhao-lcof/</guid><description>剑指 Offer 04 二维数组中的查找 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
示例:
现有矩阵 matrix 如下：
[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。
给定 target = 20，返回 false。
限制：
0 &lt;= n &lt;= 1000
0 &lt;= m &lt;= 1000
注意：本题与主站 240 题相同：https://leetcode-cn.com/problems/search-a-2d-matrix-ii/
func findNumberIn2DArray(matrix [][]int, target int) bool { } LeetCode题库地址 https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof</description></item><item><title>剑指 Offer II 002 二进制加法</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/jfetk5/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/jfetk5/</guid><description>剑指 Offer II 002 二进制加法 给定两个 01 字符串&amp;nbsp;a&amp;nbsp;和&amp;nbsp;b&amp;nbsp;，请计算它们的和，并以二进制字符串的形式输出。
输入为 非空 字符串且只包含数字&amp;nbsp;1&amp;nbsp;和&amp;nbsp;0。
&amp;nbsp;
示例&amp;nbsp;1:
输入: a = &amp;quot;11&amp;quot;, b = &amp;quot;10&amp;quot; 输出: &amp;quot;101&amp;quot; 示例&amp;nbsp;2:
输入: a = &amp;quot;1010&amp;quot;, b = &amp;quot;1011&amp;quot; 输出: &amp;quot;10101&amp;quot; &amp;nbsp;
提示：
每个字符串仅由字符 &amp;#39;0&amp;#39; 或 &amp;#39;1&amp;#39; 组成。 1 &amp;lt;= a.length, b.length &amp;lt;= 10^4 字符串如果不是 &amp;quot;0&amp;quot; ，就都不含前导零。 &amp;nbsp;
注意：本题与主站 67&amp;nbsp;题相同：https://leetcode-cn.com/problems/add-binary/
func addBinary(a string, b string) string { } LeetCode题库地址 https://leetcode.cn/problems/JFETK5</description></item><item><title>面试题 01.02 判定是否互为字符重排</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/check-permutation-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/check-permutation-lcci/</guid><description>面试题 01.02 判定是否互为字符重排 给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。
示例 1：
输入: s1 = &amp;quot;abc&amp;quot;, s2 = &amp;quot;bca&amp;quot; 输出: true 示例 2：
输入: s1 = &amp;quot;abc&amp;quot;, s2 = &amp;quot;bad&amp;quot; 输出: false 说明：
0 &amp;lt;= len(s1) &amp;lt;= 100 0 &amp;lt;= len(s2) &amp;lt;= 100 func CheckPermutation(s1 string, s2 string) bool { } LeetCode题库地址 https://leetcode.cn/problems/check-permutation-lcci</description></item><item><title>第02周：异常处理</title><link>/docs/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/week02/</link><pubDate>Tue, 25 Jan 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/week02/</guid><description>本周作业（必交） 我们在数据库操作的时候，比如 dao 层中当遇到一个 sql.ErrNoRows 的时候，是否应该 Wrap 这个 error，抛给上层。为什么，应该怎么做请写出代码？ References https://www.infoq.cn/news/2012/11/go-error-handle/ https://golang.org/doc/faq#exceptions https://www.ardanlabs.com/blog/2014/10/error-handling-in-go-part-i.html https://www.ardanlabs.com/blog/2014/11/error-handling-in-go-part-ii.html https://www.ardanlabs.com/blog/2017/05/design-philosophy-on-logging.html https://medium.com/gett-engineering/error-handling-in-go-53b8a7112d04 https://medium.com/gett-engineering/error-handling-in-go-1-13-5ee6d1e0a55c https://rauljordan.com/2020/07/06/why-go-error-handling-is-awesome.html https://morsmachine.dk/error-handling https://crawshaw.io/blog/xerrors https://dave.cheney.net/2012/01/18/why-go-gets-exceptions-right https://dave.cheney.net/2015/01/26/errors-and-exceptions-redux https://dave.cheney.net/2014/11/04/error-handling-vs-exceptions-redux https://dave.cheney.net/2014/12/24/inspecting-errors https://dave.cheney.net/2016/04/07/constant-errors https://dave.cheney.net/2019/01/27/eliminate-error-handling-by-eliminating-errors https://dave.cheney.net/2016/06/12/stack-traces-and-the-errors-package https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully https://blog.golang.org/errors-are-values https://blog.golang.org/error-handling-and-go https://blog.golang.org/go1.13-errors https://commandcenter.blogspot.com/2017/12/error-handling-in-upspin.html 关注公众号获得更多精彩文章</description></item><item><title>第二课 Go语法背后的秘密</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/02%E7%AC%AC%E4%BA%8C%E8%AF%BEgo%E8%AF%AD%E6%B3%95%E8%83%8C%E5%90%8E%E7%9A%84%E7%A7%98%E5%AF%86/</link><pubDate>Wed, 15 Dec 2021 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/02%E7%AC%AC%E4%BA%8C%E8%AF%BEgo%E8%AF%AD%E6%B3%95%E8%83%8C%E5%90%8E%E7%9A%84%E7%A7%98%E5%AF%86/</guid><description> go build -x hello.go 语法分析 https://astexplorer.net GOSSAFUNC=funcname go builld x.go
编译过程 https://godbolt.org go tool compile -S ./hello.go | grep &amp;ldquo;hello.go:5&amp;rdquo;
go tool objdump ./x
goyacc
课上推荐资源 https://xargin.com/addr-of-empty-struct-may-not-eq/ https://xargin.com/go1-17-new-calling-convention/ https://elasticsearch.cn/article/114 Github https://github.com/cch123/elasticsql https://github.com/cch123/parser_example https://github.com/go-internals-cn/go-internals https://github.com/grantseltzer/weaver https://github.com/YYCoder/protobuf-thrift https://github.com/vitessio/vitess https://github.com/xwb1989/sqlparser Dash 文档工具
电子书渠道 libgen、z-lib
关注公众号获得更多精彩文章</description></item><item><title>第二周 哈希表、集合、映射、前缀和、差分、双指针扫描</title><link>/study/2021algorithm/week02/</link><pubDate>Thu, 25 Nov 2021 10:30:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/2021algorithm/week02/</guid><description>题目数：16
本周作业 811.子域名访问计数 （Easy）半年内出题频次：
Wayfair Roblox 9 2 func subdomainVisits(cpdomains []string) (ans []string) { h := map[string]int{} for _, cpdomain := range cpdomains { cp := strings.Split(cpdomain, &amp;quot; &amp;quot;) count, _ := strconv.Atoi(cp[0]) domains := strings.Split(cp[1], &amp;quot;.&amp;quot;) cur := &amp;quot;&amp;quot; for i := len(domains) - 1; i &amp;gt;= 0; i-- { if cpdomain == &amp;quot;&amp;quot; { cur = domains[i] } else { cur = domains[i] + &amp;quot;.&amp;quot; + cur } h[cur] += count } } for domain, cnt := range h { ans = append(ans, fmt.</description></item><item><title>第2周</title><link>/study/algorithm/php/02%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%BA%8C%E5%91%A8/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/php/02%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%BA%8C%E5%91%A8/</guid><description>第2周 第4课 | 栈、队列、优先队列、双端队列 参考链接 Java 的 PriorityQueue 文档 Java 的 Stack 源码 Java 的 Queue 源码 Python 的 heapq 高性能的 container 库 预习题目 20. 有效的括号 class Solution { /** * 方法一：栈(spl标准库) * @param String $s * @return Boolean */ function isValid($s) { //构造哈希表 $map = [')'=&amp;gt;'(', ']'=&amp;gt;'[', '}'=&amp;gt;'{']; $stack = new SplStack(); for ($i = 0, $len = strlen($s); $i &amp;lt; $len; $i++) { if (!isset($map[$s[$i]])) { $stack-&amp;gt;push($s[$i]); } else if (!$stack-&amp;gt;count() || $stack-&amp;gt;pop() !</description></item><item><title>第2周 栈、队列、哈希表</title><link>/study/algorithm/go/week02/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/go/week02/</guid><description>题目数量：9+
第4课 | 栈、队列、优先队列、双端队列 1. 栈和队列的实现与特性 参考链接 Java 的 PriorityQueue 文档 Java 的 Stack 源码 Java 的 Queue 源码 Python 的 heapq 高性能的 container 库 2. 实战题目解析：有效的括号、最小栈等问题 预习题目 20. 有效的括号 // 方法一：用map，最优写法 func isValid(s string) bool { n := len(s) if n % 2 != 0 { return false } mp := map[byte]byte{ ')': '(', ']': '[', '}': '{', } stack := []byte{} for i := range s { //课替换 for i := 0; i &amp;lt; n; i++ { if mp[s[i]] &amp;gt; 0 { if len(stack) == 0 || stack[len(stack) - 1] !</description></item><item><title>剑指 Offer 05 替换空格</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ti-huan-kong-ge-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ti-huan-kong-ge-lcof/</guid><description>剑指 Offer 05 替换空格 请实现一个函数，把字符串 s 中的每个空格替换成&amp;quot;%20&amp;quot;。
&amp;nbsp;
示例 1：
输入：s = &amp;quot;We are happy.&amp;quot; 输出：&amp;quot;We%20are%20happy.&amp;quot; &amp;nbsp;
限制：
0 &amp;lt;= s 的长度 &amp;lt;= 10000
func replaceSpace(s string) string { } LeetCode题库地址 https://leetcode.cn/problems/ti-huan-kong-ge-lcof</description></item><item><title>剑指 Offer II 003 前 n 个数字二进制中 1 的个数</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/w3tcbm/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/w3tcbm/</guid><description>剑指 Offer II 003 前 n 个数字二进制中 1 的个数 给定一个非负整数 n&amp;nbsp;，请计算 0 到 n 之间的每个数字的二进制表示中 1 的个数，并输出一个数组。
&amp;nbsp;
示例 1:
输入: n = 2 输出: [0,1,1] 解释: 0 --&amp;gt; 0 1 --&amp;gt; 1 2 --&amp;gt; 10 示例&amp;nbsp;2:
输入: n = 5 输出: [0,1,1,2,1,2] 解释: 0 --&amp;gt; 0 1 --&amp;gt; 1 2 --&amp;gt; 10 3 --&amp;gt; 11 4 --&amp;gt; 100 5 --&amp;gt; 101 &amp;nbsp;
说明 :
0 &amp;lt;= n &amp;lt;= 105 &amp;nbsp;
进阶:
给出时间复杂度为&amp;nbsp;O(n*sizeof(integer))&amp;nbsp;的解答非常容易。但你可以在线性时间&amp;nbsp;O(n)&amp;nbsp;内用一趟扫描做到吗？ 要求算法的空间复杂度为&amp;nbsp;O(n)&amp;nbsp;。 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的&amp;nbsp;__builtin_popcount&amp;nbsp;）来执行此操作。 &amp;nbsp;</description></item><item><title>面试题 01.03 URL化</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/string-to-url-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/string-to-url-lcci/</guid><description>面试题 01.03 URL化 URL化。编写一种方法，将字符串中的空格全部替换为%20。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用Java实现的话，请使用字符数组实现，以便直接在数组上操作。）
示例 1：
输入："Mr John Smith ", 13 输出："Mr%20John%20Smith" 示例 2：
输入：" ", 5 输出："%20%20%20%20%20" 提示：
字符串长度在 [0, 500000] 范围内。 func replaceSpaces(S string, length int) string { } LeetCode题库地址 https://leetcode.cn/problems/string-to-url-lcci</description></item><item><title>第03周：并行编程</title><link>/docs/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/week03/</link><pubDate>Tue, 25 Jan 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/week03/</guid><description>本周作业（必交） 基于 errgroup 实现一个 http server 的启动和关闭 ，以及 linux signal 信号的注册和处理，要保证能够一个退出，全部注销退出。 References https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html https://www.ardanlabs.com/blog/2014/01/concurrency-goroutines-and-gomaxprocs.html https://dave.cheney.net/practical-go/presentations/qcon-china.html#_concurrency https://golang.org/ref/mem https://blog.csdn.net/caoshangpa/article/details/78853919 https://blog.csdn.net/qcrao/article/details/92759907 https://cch123.github.io/ooo/ https://blog.golang.org/codelab-share https://dave.cheney.net/2018/01/06/if-aligned-memory-writes-are-atomic-why-do-we-need-the-sync-atomic-package http://blog.golang.org/race-detector https://dave.cheney.net/2014/06/27/ice-cream-makers-and-data-races https://www.ardanlabs.com/blog/2014/06/ice-cream-makers-and-data-races-part-ii.html https://medium.com/a-journey-with-go/go-how-to-reduce-lock-contention-with-the-atomic-package-ba3b2664b549 https://medium.com/a-journey-with-go/go-discovery-of-the-trace-package-e5a821743c3c https://medium.com/a-journey-with-go/go-mutex-and-starvation-3f4f4e75ad50 https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html https://medium.com/a-journey-with-go/go-buffered-and-unbuffered-channels-29a107c00268 https://medium.com/a-journey-with-go/go-ordering-in-select-statements-fd0ff80fd8d6 https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html https://www.ardanlabs.com/blog/2014/02/the-nature-of-channels-in-go.html https://www.ardanlabs.com/blog/2013/10/my-channel-select-bug.html https://blog.golang.org/io2013-talk-concurrency https://blog.golang.org/waza-talk https://blog.golang.org/io2012-videos https://blog.golang.org/concurrency-timeouts https://blog.golang.org/pipelines https://www.ardanlabs.com/blog/2014/02/running-queries-concurrently-against.html https://blogtitle.github.io/go-advanced-concurrency-patterns-part-3-channels/ https://www.ardanlabs.com/blog/2013/05/thread-pooling-in-go-programming.html https://www.ardanlabs.com/blog/2013/09/pool-go-routines-to-process-task.html https://blogtitle.github.io/categories/concurrency/ https://medium.com/a-journey-with-go/go-context-and-cancellation-by-propagation-7a808bbc889c https://blog.golang.org/context https://www.ardanlabs.com/blog/2019/09/context-package-semantics-in-go.html https://golang.org/ref/spec#Channel_types https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view https://medium.com/a-journey-with-go/go-context-and-cancellation-by-propagation-7a808bbc889c https://blog.golang.org/context https://www.ardanlabs.com/blog/2019/09/context-package-semantics-in-go.html https://golang.org/doc/effective_go.html#concurrency https://zhuanlan.zhihu.com/p/34417106?hmsr=toutiao.io https://talks.golang.org/2014/gotham-context.slide#1 https://medium.com/@cep21/how-to-correctly-use-context-context-in-go-1-7-8f2c0fafdf39 关注公众号获得更多精彩文章</description></item><item><title>第三课 神奇的内置数据结构</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/03%E7%AC%AC%E4%B8%89%E8%AF%BE%E7%A5%9E%E5%A5%87%E7%9A%84%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Wed, 15 Dec 2021 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/03%E7%AC%AC%E4%B8%89%E8%AF%BE%E7%A5%9E%E5%A5%87%E7%9A%84%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>参考资料 Github https://github.com/go-internals-cn/go-internals https://github.com/grantseltzer/weaver gopsutil、top、runtime.MemStats
关注公众号获得更多精彩文章</description></item><item><title>第3周 树、递归、分治、回溯</title><link>/study/algorithm/go/week03/</link><pubDate>Thu, 02 Dec 2021 09:39:29 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/go/week03/</guid><description>题目数量：29+
第6课 | 树、二叉树、二叉搜索树 1. 树、二叉树、二叉搜索树的实现和特性 参考链接 二叉搜索树 Demo 思考题 树的面试题解法一般都是递归，为什么？ 说明：同学们可以将自己的思考写在课程下方的留言区一起讨论，也可以写在第 2 周的学习总结中。
2. 实战题目解析：二叉树的中序遍历 参考链接 树的遍历 Demo 实战题目 / 课后作业 94. 二叉树的中序遍历 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 递归 func inorderTraversal1(root *TreeNode) []int { var inorder func (root *TreeNode) var res []int inorder = func (root *TreeNode) { if root == nil { return } inorder(root.</description></item><item><title>第三周 递归、分治、树与图</title><link>/study/2021algorithm/week03/</link><pubDate>Mon, 29 Nov 2021 22:30:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/2021algorithm/week03/</guid><description>题目数：23
本周作业 23.合并K 个升序链表 （Hard） (要求：用分治实现，不要用堆) 半年内出题频次： Facebook 字节跳动 微软 Amazon Google Apple 滴滴 Bloomberg 快手 百度 22 26 16 44 5 8 3 4 3 2 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ // 方法一：分治 渐进时间复杂度：O(kn×logk)，空间复杂度：O(logk) func mergeKLists(lists []*ListNode) *ListNode { n := len(lists) if n == 0 { return nil } else if n == 1 { return lists[0] } else if n == 2 { return mergeTwoList(lists[0], lists[1]) } mid := n &amp;gt;&amp;gt; 1 return mergeTwoList(mergeKLists(lists[:mid]), mergeKLists(lists[mid:])) } func mergeTwoList(l1, l2 *ListNode) *ListNode { dummy := &amp;amp;ListNode{} pre := dummy for l1 !</description></item><item><title>第3周</title><link>/study/algorithm/php/03%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%89%E5%91%A8/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/php/03%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%89%E5%91%A8/</guid><description>第3周 第6课 | 树、二叉树、二叉搜索树 1. 树、二叉树、二叉搜索树的实现和特性 参考链接 二叉搜索树 Demo 思考题 树的面试题解法一般都是递归，为什么？ 说明：同学们可以将自己的思考写在课程下方的留言区一起讨论，也可以写在第 2 周的学习总结中。
2. 实战题目解析：二叉树的中序遍历 参考链接 树的遍历 Demo 实战题目 / 课后作业 94. 二叉树的中序遍历 /** * Definition for a binary tree node. * class TreeNode { * public $val = null; * public $left = null; * public $right = null; * function __construct($value) { $this-&amp;gt;val = $value; } * } */ class Solution { private $values = []; /** * 方法一：递归 * @param TreeNode $root * @return Integer[] */ function inorderTraversal1($root) { $this-&amp;gt;inorder($root); return $this-&amp;gt;values; } function inorder($root) { if ($root) { $this-&amp;gt;inorder($root-&amp;gt;left); $this-&amp;gt;values[] = $root-&amp;gt;val; $this-&amp;gt;inorder($root-&amp;gt;right); } } /** * 方法二：迭代 * @param TreeNode $root * @return Integer[] */ function inorderTraversal2($root) { $stack = $res = []; while ($root || $stack) { while ($root) { $stack[] = $root; $root = $root-&amp;gt;left; } $root = array_pop($stack); $res[] = $root-&amp;gt;val; $root = $root-&amp;gt;right; } return $res; } /** * 方法三：颜色标记法 * @param TreeNode $root * @return Integer[] */ function inorderTraversal3($root) { $white = 0; $gray = 1; $stack = [[$white, $root]]; $res = []; while ($stack) { [$color, $node ] = array_pop($stack); if (!</description></item><item><title>剑指 Offer 06 从尾到头打印链表</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/cong-wei-dao-tou-da-yin-lian-biao-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/cong-wei-dao-tou-da-yin-lian-biao-lcof/</guid><description>剑指 Offer 06 从尾到头打印链表 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
&amp;nbsp;
示例 1：
输入：head = [1,3,2] 输出：[2,3,1] &amp;nbsp;
限制：
0 &amp;lt;= 链表长度 &amp;lt;= 10000
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reversePrint(head *ListNode) []int { } LeetCode题库地址 https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof</description></item><item><title>剑指 Offer II 004 只出现一次的数字</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/wgki4k/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/wgki4k/</guid><description>剑指 Offer II 004 只出现一次的数字 给你一个整数数组&amp;nbsp;nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。
&amp;nbsp;
示例 1：
输入：nums = [2,2,3,2] 输出：3 示例 2：
输入：nums = [0,1,0,1,0,1,100] 输出：100 &amp;nbsp;
提示：
1 &amp;lt;= nums.length &amp;lt;= 3 * 104 -231 &amp;lt;= nums[i] &amp;lt;= 231 - 1 nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 &amp;nbsp;
进阶：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
&amp;nbsp;
注意：本题与主站 137&amp;nbsp;题相同：https://leetcode-cn.com/problems/single-number-ii/
func singleNumber(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/WGki4K</description></item><item><title>面试题 01.04 回文排列</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/palindrome-permutation-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/palindrome-permutation-lcci/</guid><description>面试题 01.04 回文排列 给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。
回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。
回文串不一定是字典当中的单词。
&amp;nbsp;
示例1：
输入：&amp;quot;tactcoa&amp;quot; 输出：true（排列有&amp;quot;tacocat&amp;quot;、&amp;quot;atcocta&amp;quot;，等等） &amp;nbsp;
func canPermutePalindrome(s string) bool { } LeetCode题库地址 https://leetcode.cn/problems/palindrome-permutation-lcci</description></item><item><title>第04周：Go工程化实践</title><link>/docs/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/week04/</link><pubDate>Tue, 15 Feb 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/week04/</guid><description>本周作业（必交） 按照自己的构想，写一个项目满足基本的目录结构和工程，代码需要包含对数据层、业务层、API 注册，以及 main 函数对于服务的注册和启动，信号处理，使用 Wire 构建依赖。可以使用自己熟悉的框架。 References https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html https://www.ardanlabs.com/blog/2017/02/design-philosophy-on-packaging.html https://github.com/golang-standards/project-layout https://github.com/golang-standards/project-layout/blob/master/README_zh.md https://www.cnblogs.com/zxf330301/p/6534643.html https://blog.csdn.net/k6T9Q8XKs6iIkZPPIFq/article/details/109192475?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160561008419724839224387%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;amp;request_id=160561008419724839224387&amp;amp;biz_id=0&amp;amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-6-109192475.first_rank_ecpm_v3_pc_rank_v2&amp;amp;utm_term=阿里技术专家详解DDD系列&amp;amp;spm=1018.2118.3001.4449 https://blog.csdn.net/chikuai9995/article/details/100723540?biz_id=102&amp;amp;utm_term=阿里技术专家详解DDD系列&amp;amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-100723540&amp;amp;spm=1018.2118.3001.4449 https://blog.csdn.net/Taobaojishu/article/details/101444324?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160561008419724838528569%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;amp;request_id=160561008419724838528569&amp;amp;biz_id=0&amp;amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-101444324.first_rank_ecpm_v3_pc_rank_v2&amp;amp;utm_term=阿里技术专家详解DDD系列&amp;amp;spm=1018.2118.3001.4449 https://blog.csdn.net/taobaojishu/article/details/106152641 https://cloud.google.com/apis/design/errors https://kb.cnblogs.com/page/520743/ https://zhuanlan.zhihu.com/p/105466656 https://zhuanlan.zhihu.com/p/105648986 https://zhuanlan.zhihu.com/p/106634373 https://zhuanlan.zhihu.com/p/107347593 https://zhuanlan.zhihu.com/p/109048532 https://zhuanlan.zhihu.com/p/110252394 https://www.jianshu.com/p/dfa427762975 https://www.citerus.se/go-ddd/ https://www.citerus.se/part-2-domain-driven-design-in-go/ https://www.citerus.se/part-3-domain-driven-design-in-go/ https://www.jianshu.com/p/dfa427762975 https://www.jianshu.com/p/5732b69bd1a1 https://www.cnblogs.com/qixuejia/p/10789612.html https://www.cnblogs.com/qixuejia/p/4390086.html https://www.cnblogs.com/qixuejia/p/10789621.html https://zhuanlan.zhihu.com/p/46603988 https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wrappers.proto https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html https://blog.csdn.net/taobaojishu/article/details/106152641 https://apisyouwonthate.com/blog/creating-good-api-errors-in-rest-graphql-and-grpc https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html https://www.youtube.com/watch?v=oL6JBUk6tj0 https://github.com/zitryss/go-sample https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md https://medium.com/@eminetto/clean-architecture-using-golang-b63587aa5e3f https://hackernoon.com/golang-clean-archithecture-efd6d7c43047 https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1 https://medium.com/wtf-dial/wtf-dial-domain-model-9655cd523182 https://hackernoon.com/golang-clean-archithecture-efd6d7c43047 https://hackernoon.com/trying-clean-architecture-on-golang-2-44d615bf8fdf https://manuel.kiessling.net/2012/09/28/applying-the-clean-architecture-to-go-applications/ https://github.com/katzien/go-structure-examples https://www.youtube.com/watch?v=MzTcsI6tn-0 https://www.appsdeveloperblog.com/dto-to-entity-and-entity-to-dto-conversion/ https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/ https://github.com/google/wire/blob/master/docs/best-practices.md https://github.com/google/wire/blob/master/docs/guide.md https://blog.golang.org/wire https://github.com/google/wire https://www.ardanlabs.com/blog/2019/03/integration-testing-in-go-executing-tests-with-docker.html https://www.ardanlabs.com/blog/2019/10/integration-testing-in-go-set-up-and-writing-tests.html https://blog.golang.org/examples https://blog.golang.org/subtests https://blog.golang.org/cover https://blog.golang.org/module-compatibility https://blog.golang.org/v2-go-modules https://blog.golang.org/publishing-go-modules https://blog.golang.org/module-mirror-launch https://blog.golang.org/migrating-to-go-modules https://blog.golang.org/using-go-modules https://blog.golang.org/modules2019 https://blog.codecentric.de/en/2017/08/gomock-tutorial/ https://pkg.go.dev/github.com/golang/mock/gomock https://medium.com/better-programming/a-gomock-quick-start-guide-71bee4b3a6f1 关注公众号获得更多精彩文章</description></item><item><title>第四课 编程语言与操作系统的桥梁</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/04%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A1%A5%E6%A2%81/</link><pubDate>Wed, 22 Dec 2021 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/04%E7%AC%AC%E5%9B%9B%E8%AF%BE%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A1%A5%E6%A2%81/</guid><description>关注公众号获得更多精彩文章</description></item><item><title>第4周 DFS、BFS、贪心、二分查找</title><link>/study/algorithm/go/week04/</link><pubDate>Mon, 20 Dec 2021 22:42:54 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/go/week04/</guid><description>题目数量：20
第9课 | 深度优先搜索和广度优先搜索 1. 深度优先搜索、广度优先搜索的实现和特性 参考链接 DFS 代码模板（递归写法、非递归写法） BFS 代码模板 2. 实战题目解析：二叉树的层次遍历等问题 实战题目 102. 二叉树的层序遍历 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // bfs func levelOrder(root *TreeNode) (res [][]int) { if root == nil { return nil } queue := []*TreeNode{root} for len(queue) &amp;gt; 0 { level := []int{} for size := len(queue); size &amp;gt; 0; size-- { node := queue[0] queue = queue[1:] level = append(level, node.</description></item><item><title>第四周 深度优先搜索、广度优先搜索、二叉堆、二叉搜索树</title><link>/study/2021algorithm/week04/</link><pubDate>Mon, 06 Dec 2021 08:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/2021algorithm/week04/</guid><description>题目数：13
本周作业 130.被围绕的区域 （Medium）半年内出题频次： 百度 字节跳动 华为 Amazon Google 6 2 2 4 7 // 公用方向定义 var ( dx = [4]int{1, -1, 0, 0} dy = [4]int{0, 0, 1, -1} ) // 方法一：dfs 和 bfs 从上下，左右边界处理进行加速 // dfs 深度优先遍历 var n, m int func solve(board [][]byte) { if len(board) == 0 || len(board[0]) == 0 { return } n, m = len(board), len(board[0]) // 第一列和最后一列 for i := 0; i &amp;lt; n; i++ { dfs(board, i, 0) dfs(board, i, m-1) } // 第一行和最后一行 for i := 1; i &amp;lt; m - 1; i++ { dfs(board, 0, i) dfs(board, n-1, i) } for i := 0; i &amp;lt; n; i++ { for j := 0; j &amp;lt; m; j++ { if board[i][j] == 'A' { board[i][j] = 'O' } else if board[i][j] == 'O' { board[i][j] = 'X' } } } } func dfs(board [][]byte, x, y int) { if x &amp;lt; 0 || x &amp;gt;= n || y &amp;lt; 0 || y &amp;gt;= m || board[x][y] !</description></item><item><title>第4周</title><link>/study/algorithm/php/04%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%9B%9B%E5%91%A8/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/php/04%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%9B%9B%E5%91%A8/</guid><description>第4周 第9课 | 深度优先搜索和广度优先搜索 1. 深度优先搜索、广度优先搜索的实现和特性 参考链接 DFS 代码模板（递归写法、非递归写法） 递归写法
visited = set() def dfs(node, visited): if node in visited: # terminator # already visited return visited.add(node) # process current node here. ... for next_node in node.children(): if next_node not in visited: dfs(next_node, visited) 非递归写法
def DFS(self, tree): if tree.root is None: return [] visited, stack = [], [tree.root] while stack: node = stack.pop() visited.add(node) process (node) nodes = generate_related_nodes(node) stack.push(nodes) # other processing work .</description></item><item><title>第4周总结</title><link>/study/algorithm/php/04%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%9B%9B%E5%91%A8%E6%80%BB%E7%BB%93/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/php/04%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%9B%9B%E5%91%A8%E6%80%BB%E7%BB%93/</guid><description>DFS 代码模板（递归写法、非递归写法） 递归写法
visited = set() def dfs(node, visited): if node in visited: # terminator # already visited return visited.add(node) # process current node here. ... for next_node in node.children(): if next_node not in visited: dfs(next_node, visited) 非递归写法
def DFS(self, tree): if tree.root is None: return [] visited, stack = [], [tree.root] while stack: node = stack.pop() visited.add(node) process (node) nodes = generate_related_nodes(node) stack.push(nodes) # other processing work ... BFS 代码模板 def BFS(graph, start, end): visited = set() queue = [] queue.</description></item><item><title>剑指 Offer 07 重建二叉树</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zhong-jian-er-cha-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zhong-jian-er-cha-shu-lcof/</guid><description>剑指 Offer 07 重建二叉树 输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。
假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
示例 1:
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] Output: [3,9,20,null,null,15,7] 示例 2:
Input: preorder = [-1], inorder = [-1] Output: [-1] 限制：
0 &lt;= 节点个数 &lt;= 5000
注意：本题与主站 105 题重复：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func buildTree(preorder []int, inorder []int) *TreeNode { } LeetCode题库地址 https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof</description></item><item><title>剑指 Offer II 005 单词长度的最大乘积</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/asey1i/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/asey1i/</guid><description>剑指 Offer II 005 单词长度的最大乘积 给定一个字符串数组&amp;nbsp;words，请计算当两个字符串 words[i] 和 words[j] 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。
&amp;nbsp;
示例&amp;nbsp;1:
输入: words = [&amp;quot;abcw&amp;quot;,&amp;quot;baz&amp;quot;,&amp;quot;foo&amp;quot;,&amp;quot;bar&amp;quot;,&amp;quot;fxyz&amp;quot;,&amp;quot;abcdef&amp;quot;] 输出: 16 解释: 这两个单词为 &amp;quot;abcw&amp;quot;, &amp;quot;fxyz&amp;quot;。它们不包含相同字符，且长度的乘积最大。 示例 2:
输入: words = [&amp;quot;a&amp;quot;,&amp;quot;ab&amp;quot;,&amp;quot;abc&amp;quot;,&amp;quot;d&amp;quot;,&amp;quot;cd&amp;quot;,&amp;quot;bcd&amp;quot;,&amp;quot;abcd&amp;quot;] 输出: 4 解释: 这两个单词为 &amp;quot;ab&amp;quot;, &amp;quot;cd&amp;quot;。 示例 3:
输入: words = [&amp;quot;a&amp;quot;,&amp;quot;aa&amp;quot;,&amp;quot;aaa&amp;quot;,&amp;quot;aaaa&amp;quot;] 输出: 0 解释: 不存在这样的两个单词。 &amp;nbsp;
提示：
2 &amp;lt;= words.length &amp;lt;= 1000 1 &amp;lt;= words[i].length &amp;lt;= 1000 words[i]&amp;nbsp;仅包含小写字母 &amp;nbsp;
注意：本题与主站 318&amp;nbsp;题相同：https://leetcode-cn.com/problems/maximum-product-of-word-lengths/
func maxProduct(words []string) int { } LeetCode题库地址 https://leetcode.cn/problems/aseY1I</description></item><item><title>面试题 01.05 一次编辑</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/one-away-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/one-away-lcci/</guid><description>面试题 01.05 一次编辑 字符串有三种编辑操作:插入一个英文字符、删除一个英文字符或者替换一个英文字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。
&amp;nbsp;
示例&amp;nbsp;1:
输入: first = "pale" second = "ple" 输出: True &amp;nbsp;
示例&amp;nbsp;2:
输入: first = "pales" second = "pal" 输出: False func oneEditAway(first string, second string) bool { } LeetCode题库地址 https://leetcode.cn/problems/one-away-lcci</description></item><item><title>第05周：微服务可用性设计</title><link>/docs/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/week05/</link><pubDate>Tue, 15 Feb 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/week05/</guid><description>本周作业（必交） 参考 Hystrix 实现一个滑动窗口计数器。 References http://www.360doc.com/content/16/1124/21/31263000_609259745.shtml http://www.infoq.com/cn/articles/basis-frameworkto-implement-micro-service/ http://www.infoq.com/cn/news/2017/04/linkerd-celebrates-one-year https://medium.com/netflix-techblog/netflix-edge-load-balancing-695308b5548c https://mp.weixin.qq.com/s?__biz=MzAwNjQwNzU2NQ==&amp;mid=402841629&amp;idx=1&amp;sn=f598fec9b370b8a6f2062233b31122e0&amp;mpshare=1&amp;scene=23&amp;srcid=0404qP0fH8zRiIiFzQBiuzuU#rd https://mp.weixin.qq.com/s?__biz=MzIzMzk2NDQyMw==&amp;mid=2247486641&amp;idx=1&amp;sn=1660fb41b0c5b8d8d6eacdfc1b26b6a6&amp;source=41#wechat_redirect https://blog.acolyer.org/2018/11/16/overload-control-for-scaling-wechat-microservices/ https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf https://github.com/alibaba/Sentinel/wiki/系统负载保护 https://blog.csdn.net/okiwilldoit/article/details/81738782 http://alex-ii.github.io/notes/2019/02/13/predictive_load_balancing.html https://blog.csdn.net/m0_38106113/article/details/81542863 关注公众号获得更多精彩文章</description></item><item><title>第五课 Go 语言的内存管理和拉垃圾回收</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/05%E7%AC%AC%E4%BA%94%E8%AF%BEgo-%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E6%8B%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link><pubDate>Wed, 22 Dec 2021 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/05%E7%AC%AC%E4%BA%94%E8%AF%BEgo-%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E6%8B%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid><description>内存逃逸分析： cmd/compile/internal/escape.go
test：/master/test
go build -gcflags=&amp;quot;-m&amp;quot; escapge.go 书 垃圾回收的算法与实现 垃圾回收算法手册（章节1、2、7、11.8、12.1、15、19.6） 关注公众号获得更多精彩文章</description></item><item><title>第5周 期中考试</title><link>/study/algorithm/go/week05/</link><pubDate>Mon, 20 Dec 2021 22:42:54 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/go/week05/</guid><description>期中考试 各位同学，经过四周学习，我们要考察一下自己的掌握程度了。本周为【期中周】，安排如下：
👉考试形式：考试平台为 LeetCode，共 17 道题：其中包括 15 道单项选择题，2 道编程题，考试时长 3 小时。3 小时内可多次修改和提交，最终全部完成后点击“结束考试”即可。 注意：为保证评测体验，需要使用 Chrome 浏览器 注意：考试前不要尝试进入系统，进入系统即开始计时，3 小时为不间断计时，关闭网页不会暂停，仍在继续计时 注意：每道选择题务必点击提交再进行下一题
👉考试系统须知： https://shimo.im/docs/786914580242497f 👉登陆账号密码：均为你极客时间登陆时的手机帐号，如无法登陆，请联系班主任确认。
👉考试日期：截止至 2020 年 4 月 12 日 23:59
👉考试链接： https://e.leetcode-cn.com/assessment/geekbang-0015 p.s. 四周过去了，你有什么想对我们说的？我们期待听到你的反馈、建议、吐槽、肯定等各种声音，快来告诉我们吧： https://jinshuju.net/f/1CkVmo</description></item><item><title>第三课 神奇的内置数据结构</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/04%E7%AC%AC%E4%B8%89%E5%9B%9B%E8%AF%BE%E7%AD%94%E7%96%91/</link><pubDate>Wed, 15 Dec 2021 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/04%E7%AC%AC%E4%B8%89%E5%9B%9B%E8%AF%BE%E7%AD%94%E7%96%91/</guid><description>课上推荐资源：
Benchstat go
https://github.com/gopl-zh/gopl-zh.github.com https://github.com/cznic/goyacc https://github.com/chai2010/go-ast-book java https://github.com/alibaba/arthas 关注公众号获得更多精彩文章</description></item><item><title>第五周 二分、排序</title><link>/study/2021algorithm/week05/</link><pubDate>Sun, 12 Dec 2021 08:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/2021algorithm/week05/</guid><description>题目数：20
本周作业 1011.在 D 天内送达包裹的能力 重点 （Medium）半年内出题频次：
Facebook 字节跳动 Google Amazon 14 9 3 7 // 官方题解： func shipWithinDays(weights []int, D int) int { // 确定二分查找左右边界 left, right := 0, 0 for _, w := range weights { if w &amp;gt; left { left = w } right += w } return left + sort.Search(right-left, func(x int) bool { x += left day := 1 // 需要运送的天数 sum := 0 // 当前这一天已经运送的包裹重量之和 for _, w := range weights { if sum+w &amp;gt; x { day++ sum = 0 } sum += w } return day &amp;lt;= D }) } // 官方c++版本go化 func shipWithinDays(weights []int, days int) int { left, right := weights[0], weights[0] for _, weight := range weights[1:] { if weight &amp;gt; left { left = weight } right += weight } for left &amp;lt; right { mid := (left + right) &amp;gt;&amp;gt; 1 need, cur := 1, 0 for _, weight := range weights { if cur + weight &amp;gt; mid { cur = 0 need++ } cur += weight } if need &amp;lt;= days { right = mid } else { left = mid + 1 } } return left } // 训练营 func shipWithinDays(weights []int, days int) int { low, high := weights[0], weights[0] for _, weight := range weights[1:] { if weight &amp;gt; low { low = weight } high += weight } for low &amp;lt; high { mid := (low + high) &amp;gt;&amp;gt; 1 if validate(weights, mid, days) { high = mid } else { low = mid + 1 } } return low } func validate(weights []int, weight, day int) bool { cur, curDay := 0, 1 // 注意curDay初始化为1 for _, w := range weights { if cur + w &amp;lt;= weight { cur += w } else { curDay++ cur = w } } return curDay &amp;lt;= day } 911.</description></item><item><title>剑指 Offer 09 用两个栈实现队列</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/</guid><description>剑指 Offer 09 用两个栈实现队列 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead&amp;nbsp;操作返回 -1 )
&amp;nbsp;
示例 1：
输入： [&amp;quot;CQueue&amp;quot;,&amp;quot;appendTail&amp;quot;,&amp;quot;deleteHead&amp;quot;,&amp;quot;deleteHead&amp;quot;] [[],[3],[],[]] 输出：[null,null,3,-1] 示例 2：
输入： [&amp;quot;CQueue&amp;quot;,&amp;quot;deleteHead&amp;quot;,&amp;quot;appendTail&amp;quot;,&amp;quot;appendTail&amp;quot;,&amp;quot;deleteHead&amp;quot;,&amp;quot;deleteHead&amp;quot;] [[],[],[5],[2],[],[]] 输出：[null,-1,null,null,5,2] 提示：
1 &amp;lt;= values &amp;lt;= 10000 最多会对&amp;nbsp;appendTail、deleteHead 进行&amp;nbsp;10000&amp;nbsp;次调用 type CQueue struct { } func Constructor() CQueue { } func (this *CQueue) AppendTail(value int) { } func (this *CQueue) DeleteHead() int { } /** * Your CQueue object will be instantiated and called as such: * obj := Constructor(); * obj.AppendTail(value); * param_2 := obj.</description></item><item><title>剑指 Offer II 006 排序数组中两个数字之和</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/kll5u1/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/kll5u1/</guid><description>剑指 Offer II 006 排序数组中两个数字之和 给定一个已按照 升序排列&amp;nbsp; 的整数数组&amp;nbsp;numbers ，请你从数组中找出两个数满足相加之和等于目标数&amp;nbsp;target 。
函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 0&amp;nbsp;开始计数 ，所以答案数组应当满足 0&amp;nbsp;&amp;lt;= answer[0] &amp;lt; answer[1] &amp;lt;&amp;nbsp;numbers.length&amp;nbsp;。
假设数组中存在且只存在一对符合条件的数字，同时一个数字不能使用两次。
&amp;nbsp;
示例 1：
输入：numbers = [1,2,4,6,10], target = 8 输出：[1,3] 解释：2 与 6 之和等于目标数 8 。因此 index1 = 1, index2 = 3 。 示例 2：
输入：numbers = [2,3,4], target = 6 输出：[0,2] 示例 3：
输入：numbers = [-1,0], target = -1 输出：[0,1] &amp;nbsp;
提示：
2 &amp;lt;= numbers.length &amp;lt;= 3 * 104 -1000 &amp;lt;= numbers[i] &amp;lt;= 1000 numbers 按 递增顺序 排列 -1000 &amp;lt;= target &amp;lt;= 1000 仅存在一个有效答案 &amp;nbsp;</description></item><item><title>面试题 01.06 字符串压缩</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/compress-string-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/compress-string-lcci/</guid><description>面试题 01.06 字符串压缩 字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。
示例1:
输入："aabcccccaaa" 输出："a2b1c5a3" 示例2:
输入："abbccd" 输出："abbccd" 解释："abbccd"压缩后为"a1b2c2d1"，比原字符串长度更长。 提示：
字符串长度在[0, 50000]范围内。 func compressString(S string) string { } LeetCode题库地址 https://leetcode.cn/problems/compress-string-lcci</description></item><item><title>第06周：评论系统架构设计</title><link>/docs/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/week06/</link><pubDate>Tue, 01 Mar 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/week06/</guid><description>关注公众号获得更多精彩文章</description></item><item><title>第六课 并发编程最佳实践实</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/06%E7%AC%AC%E5%85%AD%E8%AF%BE%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%AE%9E/</link><pubDate>Fri, 14 Jan 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/06%E7%AC%AC%E5%85%AD%E8%AF%BE%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%AE%9E/</guid><description>关注公众号获得更多精彩文章</description></item><item><title>第六周 贪心、动态规划</title><link>/study/2021algorithm/week06/</link><pubDate>Sat, 25 Dec 2021 08:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/2021algorithm/week06/</guid><description>题目数：14
本周作业 70.爬楼梯 （Easy）半年内出题频次：
Facebook 字节跳动 微软 Amazon 华为 百度 Google 腾讯 LinkedIn Apple 2 17 9 19 3 2 10 4 2 3 // 方法一：记忆化搜索 var mp = map[int]int{} func climbStairs(n int) int { if n &amp;lt;= 2 { return n } if k, ok := mp[n]; ok { return k } count := climbStairs(n - 1) + climbStairs(n - 2) mp[n] = count return mp[n] } // 方法二：标准动态规划 func climbStairs(n int) int { dp := make([]int, n+1) dp[1] = 1 dp[2] = 2 for i := 3; i &amp;lt;= n; i++ { dp[i] = dp[i-1] + dp[i-2] } return dp[n] } // 方法三：简化dp func climbStairs(n int) int { i, j := 1, 1 for k := 2; k &amp;lt;= n; k++ { i, j = j, i + j } return j } // 官方题解 func climbStairs(n int) int { p, q, r := 0, 0, 1 for i := 1; i &amp;lt;= n; i++ { p = q q = r r = p + q } return r } // 方法四：通项公式 func climbStairs(n int) int { sqrt5 := math.</description></item><item><title>第6周</title><link>/study/algorithm/php/06%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%85%AD%E5%91%A8/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/php/06%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%85%AD%E5%91%A8/</guid><description>第12课 | 动态规划 1. 动态规划的实现及关键点 参考链接 递归代码模板 # Python 代码模板 def recursion(level, param1, param2, ...): # recursion terminator if level &amp;gt; MAX_LEVEL: process_result return # process logic in current level process(level, data...) # drill down self.recursion(level + 1, p1, ...) # reverse the current level status if needed //Java 代码模板 public void recur(int level, int param) { // terminator if (level &amp;gt; MAX_LEVEL) { // process result return; // process current logic process(level, param); // drill down recur( level: level + 1, newParam); // restore current status } 分治代码模板 def divide_conquer(problem, param1, param2, .</description></item><item><title>第6周 动态规划</title><link>/study/algorithm/go/week06/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/go/week06/</guid><description>题目数量：25+
第12课 动态规划 1.动态规划的实现与关键点 参考连接 递归代码模板 # go 代码模板 func recursion(level int, param1, param2, ...) { # recursion terminator if level &amp;gt; MAX_LEVEL { process_result return } # process logic in current level process(level, data...) # drill down recursion(level + 1, p1, ...) # reverse the current level status if needed } 分治代码模板 func divide_conquer(problem, param1, param2, ...) { # recursion terminator if problem == nil { print_result return } # prepare data data = prepare_data(problem) subproblems = split_problem(problem, data) # conquer subproblems subresult1 = divide_conquer(subproblems[0], p1, .</description></item><item><title>剑指 Offer 10- I 斐波那契数列</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/fei-bo-na-qi-shu-lie-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/fei-bo-na-qi-shu-lie-lcof/</guid><description>剑指 Offer 10- I 斐波那契数列 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：
F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N > 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
示例 1：
输入：n = 2 输出：1 示例 2：
输入：n = 5 输出：5 提示：
0 &lt;= n &lt;= 100 func fib(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof</description></item><item><title>剑指 Offer II 007 数组中和为 0 的三个数</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/1fgaju/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/1fgaju/</guid><description>剑指 Offer II 007 数组中和为 0 的三个数 给定一个包含 n 个整数的数组&amp;nbsp;nums，判断&amp;nbsp;nums&amp;nbsp;中是否存在三个元素&amp;nbsp;a ，b ，c ，使得&amp;nbsp;a + b + c = 0 ？请找出所有和为 0 且&amp;nbsp;不重复&amp;nbsp;的三元组。
&amp;nbsp;
示例 1：
输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 示例 2：
输入：nums = [] 输出：[] 示例 3：
输入：nums = [0] 输出：[] &amp;nbsp;
提示：
0 &amp;lt;= nums.length &amp;lt;= 3000 -105 &amp;lt;= nums[i] &amp;lt;= 105 &amp;nbsp;
注意：本题与主站 15&amp;nbsp;题相同：https://leetcode-cn.com/problems/3sum/
func threeSum(nums []int) [][]int { } LeetCode题库地址 https://leetcode.cn/problems/1fGaJU</description></item><item><title>面试题 01.07 旋转矩阵</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/rotate-matrix-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/rotate-matrix-lcci/</guid><description>面试题 01.07 旋转矩阵 给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。
不占用额外内存空间能否做到？
示例 1:
给定 matrix = [ [1,2,3], [4,5,6], [7,8,9] ], 原地旋转输入矩阵，使其变为: [ [7,4,1], [8,5,2], [9,6,3] ] 示例 2:
给定 matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], 原地旋转输入矩阵，使其变为: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ] 注意：本题与主站 48 题相同：https://leetcode-cn.com/problems/rotate-image/
func rotate(matrix [][]int) { } LeetCode题库地址 https://leetcode.cn/problems/rotate-matrix-lcci</description></item><item><title>第07周：历史记录架构设计</title><link>/docs/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/week07/</link><pubDate>Tue, 01 Mar 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/week07/</guid><description>hbase https://www.jianshu.com/p/b23800d9b227 https://zhuanlan.zhihu.com/p/145551967 https://cloud.tencent.com/developer/article/1632053 http://abloz.com/hbase/book.html#quickstart 关注公众号获得更多精彩文章</description></item><item><title>第七课 社区优秀开源框架对比</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/07%E7%AC%AC%E4%B8%83%E8%AF%BE%E7%A4%BE%E5%8C%BA%E4%BC%98%E7%A7%80%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/</link><pubDate>Fri, 14 Jan 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/07%E7%AC%AC%E4%B8%83%E8%AF%BE%E7%A4%BE%E5%8C%BA%E4%BC%98%E7%A7%80%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/</guid><description> https://jaycechant.info/2020/go-bindata-golang-static-resources-embedding/ 关注公众号获得更多精彩文章</description></item><item><title>第七周 动态规划</title><link>/study/2021algorithm/week07/</link><pubDate>Sun, 26 Dec 2021 21:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/2021algorithm/week07/</guid><description>题目数：21
本周作业 完全平方数 （Medium）
要求：完全平方数看作物品，体积为 n，价值为 1，用背包 DP 的思想解题
半年内出题频次：
Facebook 字节跳动 Amazon 腾讯 eBay Google Apple VMware 5 6 5 2 2 3 2 2 跳跃游戏 （Medium）半年内出题频次：
Facebook 字节跳动 微软 Amazon 华为 Oracle Apple 高盛集团 涂鸦智能 5 14 3 14 2 4 2 3 2 跳跃游戏 II （Medium）
要求：用动态规划解题，并与之前的贪心解法做对比
半年内出题频次：
Facebook 字节跳动 微软 Amazon 华为 Google Apple 6 5 4 17 7 3 5 最长回文子序列 （Medium）半年内出题频次：
Facebook 字节跳动 LinkedIn Amazon 2 6 6 5 二叉树中的最大路径和 （Hard）半年内出题频次：</description></item><item><title>第7周 字典树和并查集、高级搜索、红黑树和AVL树</title><link>/study/algorithm/go/week07/</link><pubDate>Mon, 20 Dec 2021 22:42:54 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/go/week07/</guid><description>题目数量：17
第13课 | 字典树和并查集 1. Trie树的基本实现和特性 参考链接 二叉树的层次遍历 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // bfs func levelOrder(root *TreeNode) (res [][]int) { if root == nil { return res } queue := []*TreeNode{root} for len(queue) &amp;gt; 0 { curLevel := []int{} for cnt := len(queue); cnt &amp;gt; 0; cnt-- { node := queue[0] queue = queue[1:] curLevel = append(curLevel, node.</description></item><item><title>第7周</title><link>/study/algorithm/php/07%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%83%E5%91%A8/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/php/07%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%83%E5%91%A8/</guid><description>第7周 第13课 | 字典树和并查集 1. Trie树的基本实现和特性 参考链接 102. 二叉树的层序遍历 /** * Definition for a binary tree node. * class TreeNode { * public $val = null; * public $left = null; * public $right = null; * function __construct($value) { $this-&amp;gt;val = $value; } * } */ class Solution { /** * bfs * @param TreeNode $root * @return Integer[][] */ function levelOrder($root) { if (!$root) return []; $queue = [$root]; $res = []; while ($queue) { $count = count($queue); $row = []; while ($count--) { $node = array_shift($queue); $row[] = $node-&amp;gt;val; $node-&amp;gt;left &amp;amp;&amp;amp; $queue[] = $node-&amp;gt;left; $node-&amp;gt;right &amp;amp;&amp;amp; $queue[] = $node-&amp;gt;right; } $res[] = $row; } return $res; } // function levelOrder($root) { if (!</description></item><item><title>剑指 Offer 10- II 青蛙跳台阶问题</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/qing-wa-tiao-tai-jie-wen-ti-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/qing-wa-tiao-tai-jie-wen-ti-lcof/</guid><description>剑指 Offer 10- II 青蛙跳台阶问题 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n&amp;nbsp;级的台阶总共有多少种跳法。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
示例 1：
输入：n = 2 输出：2 示例 2：
输入：n = 7 输出：21 示例 3：
输入：n = 0 输出：1 提示：
0 &amp;lt;= n &amp;lt;= 100 注意：本题与主站 70 题相同：https://leetcode-cn.com/problems/climbing-stairs/
&amp;nbsp;
func numWays(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof</description></item><item><title>剑指 Offer II 008 和大于等于 target 的最短子数组</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/2vg8kg/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/2vg8kg/</guid><description>剑指 Offer II 008 和大于等于 target 的最短子数组 给定一个含有&amp;nbsp;n&amp;nbsp;个正整数的数组和一个正整数 target 。
找出该数组中满足其和 &amp;ge; target 的长度最小的 连续子数组&amp;nbsp;[numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。
&amp;nbsp;
示例 1：
输入：target = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组&amp;nbsp;[4,3]&amp;nbsp;是该条件下的长度最小的子数组。 示例 2：
输入：target = 4, nums = [1,4,4] 输出：1 示例 3：
输入：target = 11, nums = [1,1,1,1,1,1,1,1] 输出：0 &amp;nbsp;
提示：
1 &amp;lt;= target &amp;lt;= 109 1 &amp;lt;= nums.length &amp;lt;= 105 1 &amp;lt;= nums[i] &amp;lt;= 105 &amp;nbsp;
进阶：
如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。 &amp;nbsp;</description></item><item><title>面试题 01.08 零矩阵</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/zero-matrix-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/zero-matrix-lcci/</guid><description>面试题 01.08 零矩阵 编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。
&amp;nbsp;
示例 1：
输入： [ [1,1,1], [1,0,1], [1,1,1] ] 输出： [ [1,0,1], [0,0,0], [1,0,1] ] 示例 2：
输入： [ [0,1,2,0], [3,4,5,2], [1,3,1,5] ] 输出： [ [0,0,0,0], [0,4,5,0], [0,3,1,0] ] func setZeroes(matrix [][]int) { } LeetCode题库地址 https://leetcode.cn/problems/zero-matrix-lcci</description></item><item><title>第08周：分布式缓存 &amp; 分布式事务</title><link>/docs/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/week08/</link><pubDate>Tue, 01 Mar 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/week08/</guid><description>本周作业（必交） 使用 redis benchmark 工具, 测试 10 20 50 100 200 1k 5k 字节 value 大小，redis get set 性能。 写入一定量的 kv 数据, 根据数据大小 1w-50w 自己评估, 结合写入前后的 info memory 信息 , 分析上述不同 value 大小下，平均每个 key 的占用内存空间。 关注公众号获得更多精彩文章</description></item><item><title>第八课 深入Web框架原理与实现</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/08%E7%AC%AC%E5%85%AB%E8%AF%BE%E6%B7%B1%E5%85%A5web%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</link><pubDate>Fri, 14 Jan 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/08%E7%AC%AC%E5%85%AB%E8%AF%BE%E6%B7%B1%E5%85%A5web%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</guid><description>关注公众号获得更多精彩文章</description></item><item><title>第八周 字典树、并查集，图论算法</title><link>/study/2021algorithm/week08/</link><pubDate>Fri, 07 Jan 2022 08:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/2021algorithm/week08/</guid><description>题目数：11
本周作业 冗余连接 （Medium）半年内出题频次： Amazon 字节跳动 3 2 岛屿数量 （Medium）半年内出题频次： Facebook 字节跳动 微软 Amazon Apple Bloomberg Google LinkedIn Oracle Shopee 12 18 44 91 10 25 22 20 6 7 要求：使用并查集而非 DFS/BFS 实现
实战例题 以下为课上实战例题
第 15 课 字典树 字典树（Trie） 实现 Trie (前缀树) （Medium）半年内出题频次： Facebook 高盛集团 微软 Amazon Apple Google Twitter 3 2 3 6 2 5 9 单词搜索 II （Hard）半年内出题频次： Twitter 字节跳动 微软 Amazon Apple Google Bloomberg Cisco 2 2 17 33 4 4 3 10 思考题 系统设计：搜索提示（自动补全） 并查集 省份数量 （Medium）半年内出题频次： Twitter Apple Amazon DoorDash 高盛集团 3 3 48 8 2 被围绕的区域 （Medium）半年内出题频次： Google 字节跳动 Microsoft Amazon 华为 Apple Bloomberg 7 2 2 3 3 2 2 超市 （Easy）（AcWing） 第 16 课 图论算法 最短路 网络延迟时间 （Medium）半年内出题频次： Google 字节跳动 Amazon Microsoft 3 2 2 3 阈值距离内邻居最少的城市 （Medium）半年内出题频次： 阿里巴巴 Apple 8 2 Dijkstra 求最短路 II （Easy）（AcWing） 最小生成树 连接所有点的最小费用 （Medium）半年内出题频次： Amazon Facebook 4 2 Contributor</description></item><item><title>第8周 位运算、布隆过滤器和LRU缓存、排序算法</title><link>/study/algorithm/go/week08/</link><pubDate>Mon, 20 Dec 2021 22:42:54 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/go/week08/</guid><description>题目数量：12
第16课 | 位运算 1. 位运算基础及实战要点 参考链接 如何从十进制转换为二进制 2. 位运算实战题目解析 参考链接 N 皇后位运算代码示例 实战题目 / 课后作业 191. 位1的个数 // 最优写法 func hammingWeight(num uint32) (cnt int) { for num &amp;gt; 0 { cnt++ num &amp;amp;= num - 1 } return cnt } // O(n) n = 32 func hammingWeight(num uint32) (cnt int) { for num &amp;gt; 0 { cnt += int(num &amp;amp; 1) num &amp;gt;&amp;gt;= 1 } return cnt } 231. 2的幂 func isPowerOfTwo(n int) bool { return n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;amp; (n - 1) == 0 } // 没有上面运行快 func isPowerOfTwo(n int) bool { return n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;amp; -n == n } //方案二： 判断是否为最大 22 的幂的约数 func isPowerOfTwo(n int) bool { const big = 1 &amp;lt;&amp;lt; 30 return n &amp;gt; 0 &amp;amp;&amp;amp; big%n == 0 } 190.</description></item><item><title>第8周</title><link>/study/algorithm/php/08%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%85%AB%E5%91%A8/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/php/08%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%85%AB%E5%91%A8/</guid><description>第8周 第16课 | 位运算 1. 位运算基础及实战要点 参考链接 如何从十进制转换为二进制 2. 位运算实战题目解析 参考链接 N 皇后位运算代码示例 def totalNQueens(self, n): if n &amp;lt; 1: return [] self.count = 0 self.DFS(n, 0, 0, 0, 0) return self.count def DFS(self, n, row, cols, pie, na): # recursion terminator if row &amp;gt;= n: self.count += 1 return bits = (~(cols | pie | na)) &amp;amp; ((1 &amp;lt;&amp;lt; n) — 1) # 得到当前所有的空位 while bits: p = bits &amp;amp; —bits # 取到最低位的1 bits = bits &amp;amp; (bits — 1) # 表示在p位置上放入皇后 self.</description></item><item><title>剑指 Offer 11 旋转数组的最小数字</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/</guid><description>剑指 Offer 11 旋转数组的最小数字 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
给你一个可能存在&amp;nbsp;重复&amp;nbsp;元素值的数组&amp;nbsp;numbers&amp;nbsp;，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组&amp;nbsp;[3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。&amp;nbsp;&amp;nbsp;
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。
&amp;nbsp;
示例 1：
输入：numbers = [3,4,5,1,2] 输出：1 示例 2：
输入：numbers = [2,2,2,0,1] 输出：0 &amp;nbsp;
提示：
n == numbers.length 1 &amp;lt;= n &amp;lt;= 5000 -5000 &amp;lt;= numbers[i] &amp;lt;= 5000 numbers 原来是一个升序排序的数组，并进行了 1 至 n 次旋转 注意：本题与主站 154 题相同：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/
func minArray(numbers []int) int { } LeetCode题库地址 https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof</description></item><item><title>剑指 Offer II 009 乘积小于 K 的子数组</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/zvavxx/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/zvavxx/</guid><description>剑指 Offer II 009 乘积小于 K 的子数组 给定一个正整数数组&amp;nbsp;nums和整数 k&amp;nbsp;，请找出该数组内乘积小于&amp;nbsp;k&amp;nbsp;的连续的子数组的个数。
&amp;nbsp;
示例 1:
输入: nums = [10,5,2,6], k = 100 输出: 8 解释: 8 个乘积小于 100 的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。 需要注意的是 [10,5,2] 并不是乘积小于100的子数组。 示例 2:
输入: nums = [1,2,3], k = 0 输出: 0 &amp;nbsp;
提示:&amp;nbsp;
1 &amp;lt;= nums.length &amp;lt;= 3 * 104 1 &amp;lt;= nums[i] &amp;lt;= 1000 0 &amp;lt;= k &amp;lt;= 106 &amp;nbsp;
注意：本题与主站 713&amp;nbsp;题相同：https://leetcode-cn.com/problems/subarray-product-less-than-k/&amp;nbsp;
func numSubarrayProductLessThanK(nums []int, k int) int { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 01.09 字符串轮转</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/string-rotation-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/string-rotation-lcci/</guid><description>面试题 01.09 字符串轮转 字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。
示例1:
输入：s1 = &amp;quot;waterbottle&amp;quot;, s2 = &amp;quot;erbottlewat&amp;quot; 输出：True 示例2:
输入：s1 = &amp;quot;aa&amp;quot;, s2 = &amp;quot;aba&amp;quot; 输出：False 提示：
字符串长度在[0, 100000]范围内。 说明:
你能只调用一次检查子串的方法吗？ func isFlipedString(s1 string, s2 string) bool { } LeetCode题库地址 https://leetcode.cn/problems/string-rotation-lcci</description></item><item><title>第九周：Go语言实践-网络编程</title><link>/docs/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/week09/</link><pubDate>Tue, 01 Mar 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/week09/</guid><description>本周作业（必交） 总结几种 socket 粘包的解包方式：fix length/delimiter based/length field based frame decoder。尝试举例其应用。 实现一个从 socket connection 中解码出 goim 协议的解码器。 关注公众号获得更多精彩文章</description></item><item><title>第九周 字符串处理、高级搜索</title><link>/study/2021algorithm/week09/</link><pubDate>Tue, 18 Jan 2022 23:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/2021algorithm/week09/</guid><description>题目数：30+
本周作业 基础问题 转换成小写字母 （Easy）半年内出题频次： Amazon 2 最后一个单词的长度 （Easy）半年内出题频次： Bloomberg 2 宝石与石头 （Easy）半年内出题频次： Amazon Facebook Google 2 2 2 字符串中的第一个唯一字符 （Easy）半年内出题频次： Facebook Bloomberg 微软 Amazon Google Apple 华为 PayPal 高盛集团 12 9 7 24 6 3 2 2 16 最长公共前缀 （Easy）半年内出题频次： Facebook 字节跳动 微软 Amazon 华为 百度 Google Bloomberg Intel Apple 13 18 7 15 2 4 3 7 2 11 字符串操作 反转字符串 （Easy）半年内出题频次： Facebook 字节跳动 微软 Amazon Google Apple Oracle 2 2 5 3 2 5 2 翻转字符串里的单词 （Medium）半年内出题频次： Facebook 字节跳动 微软 Amazon 百度 Bloomberg Apple LinkedIn Oracle 4 3 23 5 2 3 2 2 2 仅仅反转字母 （Easy）半年内出题频次： 微软 Apple 2 2 同构 / 异位词系列问题 同构字符串 （Easy）半年内出题频次： Amazon LinkedIn Google 字节跳动 7 6 4 3 有效的字母异位词 （Easy）半年内出题频次： Facebook Bloomberg 微软 Google Apple 2 13 5 2 3 字母异位词分组 （Medium）半年内出题频次： Facebook 高盛集团 微软 Amazon Apple eBay Google PayPal Apple VMware 7 14 19 34 4 4 3 3 4 5 找到字符串中所有字母异位词 （Medium）半年内出题频次： Facebook 字节跳动 微软 Amazon Google PayPal 2 2 10 8 2 2 字符串 + 动态规划 通配符匹配 （Hard）半年内出题频次： Facebook 字节跳动 微软 Google Amazon Bloomberg 6 4 6 2 5 2 二进制矩阵中的最短路径 （Medium）半年内出题频次： Facebook Google Amazon 微软 字节跳动 Bloomberg 18 7 11 3 2 2 自己选择合适的算法解答 （普通 BFS？双向 BFS？A*？）</description></item><item><title>第九课 框架之上的业务分层</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/09%E7%AC%AC%E4%B9%9D%E8%AF%BE%E6%A1%86%E6%9E%B6%E4%B9%8B%E4%B8%8A%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%88%86%E5%B1%82/</link><pubDate>Fri, 14 Jan 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/09%E7%AC%AC%E4%B9%9D%E8%AF%BE%E6%A1%86%E6%9E%B6%E4%B9%8B%E4%B8%8A%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%88%86%E5%B1%82/</guid><description>关注公众号获得更多精彩文章</description></item><item><title>第9周</title><link>/study/algorithm/php/09%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B9%9D%E5%91%A8/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/php/09%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B9%9D%E5%91%A8/</guid><description>第9周 第19课 | 高级动态规划 1. 动态规划、状态转移方程串讲 参考链接 70.爬楼梯 class Solution { /** * 动态规划解法 * Binets 方法 和 斐波那契公式 时间复杂度为O(log(N)) * @param Integer $n * @return Integer */ function climbStairs($n) { if ($n &amp;lt;= 2) return $n; $first = 1; $second = 2; for ($i = 3; $i &amp;lt;= $n; $i++) { $tmp = $first + $second; $first = $second; $second = $tmp; } return $second; } } //斐波那契公式 public class Solution { public int climbStairs(int n) { double sqrt5=Math.</description></item><item><title>第9周 高级动态规划、字符串算法</title><link>/study/algorithm/go/week09/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/go/week09/</guid><description>题目数量：35+
第19课 | 高级动态规划 1. 动态规划、状态转移方程串讲 参考链接 70.爬楼梯 func climbStairs(n int) int { p, q := 1, 1 for i := 2; i &amp;lt;= n; i++ { p, q = q, p + q } return q } 62.不同路径 // 方法一： 标准二维dp func uniquePaths(m int, n int) int { dp := make([][]int, m) for i := range dp { dp[i] = make([]int, n) dp[i][0] = 1 } for i := 0; i &amp;lt; n; i++ { dp[0][i] = 1 } for i := 1; i &amp;lt; m; i++ { for j := 1; j &amp;lt; n; j++ { dp[i][j] = dp[i-1][j] + dp[i][j-1] } } return dp[m-1][n-1] } // 方法二：高级一维dp func uniquePaths(m int, n int) int { dp := make([]int, n) for i := range dp { dp[i] = 1 } for i := 1; i &amp;lt; m; i++ { for j := 1; j &amp;lt; n; j++ { dp[j] += dp[j-1] } } return dp[n-1] } 63.</description></item><item><title>剑指 Offer 12 矩阵中的路径</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ju-zhen-zhong-de-lu-jing-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ju-zhen-zhong-de-lu-jing-lcof/</guid><description>剑指 Offer 12 矩阵中的路径 给定一个&amp;nbsp;m x n 二维字符网格&amp;nbsp;board 和一个字符串单词&amp;nbsp;word 。如果&amp;nbsp;word 存在于网格中，返回 true ；否则，返回 false 。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
&amp;nbsp;
例如，在下面的 3×4 的矩阵中包含单词 "ABCCED"（单词中的字母已标出）。
&amp;nbsp;
示例 1：
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED" 输出：true 示例 2：
输入：board = [["a","b"],["c","d"]], word = "abcd" 输出：false &amp;nbsp;
提示：
m == board.length n = board[i].length 1 &amp;lt;= m, n &amp;lt;= 6 1 &amp;lt;= word.length &amp;lt;= 15 board 和 word 仅由大小写英文字母组成 注意：本题与主站 79 题相同：https://leetcode-cn.com/problems/word-search/
func exist(board [][]byte, word string) bool { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer II 010 和为 k 的子数组</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/qtmn0o/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/qtmn0o/</guid><description>剑指 Offer II 010 和为 k 的子数组 给定一个整数数组和一个整数&amp;nbsp;k ，请找到该数组中和为&amp;nbsp;k&amp;nbsp;的连续子数组的个数。
&amp;nbsp;
示例 1：
输入:nums = [1,1,1], k = 2 输出: 2 解释: 此题 [1,1] 与 [1,1] 为两种不同的情况 示例 2：
输入:nums = [1,2,3], k = 3 输出: 2 &amp;nbsp;
提示:
1 &amp;lt;= nums.length &amp;lt;= 2 * 104 -1000 &amp;lt;= nums[i] &amp;lt;= 1000 -107&amp;nbsp;&amp;lt;= k &amp;lt;= 107
&amp;nbsp;
注意：本题与主站 560&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/subarray-sum-equals-k/
func subarraySum(nums []int, k int) int { } LeetCode题库地址 https://leetcode.cn/problems/QTMn0o</description></item><item><title>面试题 02.01 移除重复节点</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/remove-duplicate-node-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/remove-duplicate-node-lcci/</guid><description>面试题 02.01 移除重复节点 编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。
示例1:
输入：[1, 2, 3, 3, 2, 1] 输出：[1, 2, 3] 示例2:
输入：[1, 1, 1, 1, 2] 输出：[1, 2] 提示：
链表长度在[0, 20000]范围内。 链表元素在[0, 20000]范围内。 进阶：
如果不得使用临时缓冲区，该怎么解决？
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeDuplicateNodes(head *ListNode) *ListNode { } LeetCode题库地址 https://leetcode.cn/problems/remove-duplicate-node-lcci</description></item><item><title>第十周：日志&amp;指标&amp;链路追踪</title><link>/docs/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/week10/</link><pubDate>Tue, 01 Mar 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/week10/</guid><description>关注公众号获得更多精彩文章</description></item><item><title>第十周 平衡二叉树、跳跃表、树状数组与线段树、实战技巧、总结回顾</title><link>/study/2021algorithm/week10/</link><pubDate>Tue, 18 Jan 2022 23:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/2021algorithm/week10/</guid><description>题目数：16
本周作业 尝试用语言内置的有序集合库，或写一棵平衡树，来解决 滑动窗口最大值 （Hard）半年内出题频次： Facebook 字节跳动 微软 Amazon DoorDash 高盛集团 Google 拼多多 Apple Twittter 13 9 4 41 12 9 7 2 2 2 尝试用语言内置的有序集合库，或写一棵平衡树，来解决 [邻值查找]（AcWing）( https://www.acwing.com/problem/content/138/ )（Medium） 设计跳表（选做） （Hard） 2 年内出题频次： Facebook 字节跳动 微软 Databricks 2 3 3 2 普通平衡树（选做） （Medium）（AcWing） 掉落的方块 （Hard） 1~2 年出过此题： 青牛软件 Uber 微软 Amazon Square Facebook Google - 实战例题 以下为课上实战例题
第 20 课 树状数组与线段树 树状数组 区域和检索 - 数组可修改 （Medium）半年内出题频次： Google Facebook Amazon 5 2 5 线段树 一个简单的整数问题 2 （Hard）（AcWing） 离散化 区间和的个数 （Hard）半年内出题频次： 字节跳动 Amazon 2 2 第 21 课 实战技巧、总结回顾 位运算 位 1 的个数 （Easy）半年内出题频次： Facebook 微软 Cisco 2 5 2 2 的幂 （Easy）半年内出题频次： Google Apple 英伟达 2 3 2 颠倒二进制位 （Easy）半年内出题频次： 微软 Amazon 2 2 比特位计数 （Easy）半年内出题频次： 字节跳动 Google 2 4 Pow(x, n) （Medium）半年内出题频次： Facebook LinkedIn 微软 Amazon Google Apple Bloomberg 字节跳动 高盛集团 快手 67 7 5 4 5 4 4 2 2 2 N 皇后 （Hard）半年内出题频次： Facebook 字节跳动 微软 Amazon 爱奇艺 Apple 微软 Bloomberg 2 6 7 9 4 3 4 2 解数独 （Hard）半年内出题频次： Apple Bloomberg 微软 Amazon Google DoorDash 4 2 4 8 5 27 期末串讲 天际线问题 （Hard）半年内出题频次： Facebook Google 微软 Amazon 字节跳动 Apple 5 4 3 3 2 2 包含每个查询的最小区间 1~2 年出过此题： Google Uber Apple</description></item><item><title>第十课如何写出优雅的Go代码</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/10%E7%AC%AC%E5%8D%81%E8%AF%BE%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%BC%98%E9%9B%85%E7%9A%84go%E4%BB%A3%E7%A0%81/</link><pubDate>Fri, 14 Jan 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/10%E7%AC%AC%E5%8D%81%E8%AF%BE%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%BC%98%E9%9B%85%E7%9A%84go%E4%BB%A3%E7%A0%81/</guid><description> effective-go
50 shades
100 Go Mistakes (How to Avoid Them)
awesome-go
golint golangci-lint go fmt go vet gocyclo 圈复杂度检查 ineffassign misspell reviewdog
《重构》第二版第三章 bad smell
《代码大全》表驱动章节
参考学习资料 goreportcard.com https://golang.com/cmd/vet https://github.com/kisielk/errcheck https://github.com/timakin/bodyclose https://github.com/gostaticanalysis/sqlrows https://github.com/analysis-tools-dev/static-analysis https://xargin.com/about-livinig-doc/ https://www.jetbrains.com/help/go/using-the-testify-toolkit.html#compare-expected-and-actual-values https://github.com/golang/go/wiki/TableDrivenTests https://segment.com/blog/5-advanced-testing-techniques-in-go/ https://stackoverflow.com/questions/42102496/testing-a-grpc-service https://github.com/smartystreets/goconvey https://github.com/onsi/ginkgo https://blog.csdn.net/zwqjoy/article/details/79474196 https://juejin.cn/post/6844903837875208205 Go programming language第11章
https://github.com/gopl-zh/gopl-zh.github.com PingCAP的failpoint
https://github.com/pingcap/failpoint failpoint的设计与实现
https://juejin.cn/post/6844903837875208205 GoConvey测试
https://blog.csdn.net/zwqjoy/article/details/79474196 ginkgo测试
https://semaphoreci.com/community/tutorials/getting-started-with-bdd-in-go-using-ginkgo Didi的Go流量录制、流量回放⽅案
https://github.com/didi/sharingan 关注公众号获得更多精彩文章</description></item><item><title>第10周 期末串讲、期末考试、毕业刷题路线</title><link>/study/algorithm/go/week10/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/go/week10/</guid><description>题目数量：77+
期末串讲 参考连接 Big O Cheat Sheet 算法训练营第 4 期学员谭帅的脑图作业 （提取码：ykyn）
Steve Jobs 演讲 期末考试 👉考试形式：考试平台为 LeetCode。 共 10 道单选题（每题 3 分）、2 道多选题（每题 5 分）、2 道编程题（每题 20 分）和 4 道附加选择题（每题 5 分），考试时长 3 小时。3 小时内可多次修改和提交，最终全部完成后点击“结束考试”即可。
注意：为保证评测体验，需要使用 Chrome 浏览器 注意：考试前不要尝试进入系统，进入系统即开始计时，3 小时为不间断计时，关闭网页不会暂停，仍在继续计时 注意：每道选择题务必点击提交再进行下一题
👉考试系统须知： https://shimo.im/docs/786914580242497f 👉登陆账号密码：均为你极客时间登陆时的手机帐号，如无法登陆，请联系班主任确认。
👉考试日期：截止至 2020 年 5 月 24 日 23:59
👉考试链接： https://e.leetcode-cn.com/assessment/geekbang-0019 本周是大家学习的最后一周，训练营学习服务团队希望能得到大家的建议和反馈，动动你的小手，填一下问卷吧！👉 https://jinshuju.net/f/ER0LhF 另外，如果你想换工作，不知道怎么写简历，可以看下这篇文章。
毕业刷题路线 首先，恭喜各位同学从极客大学算法训练营毕业，相信 70 天的刻意练习给你带来了不少改变。但是毕业后的练习还不能停止，除了课上老师讲授的题目和布置的作业，这里还有一份“左耳朵耗子”陈皓老师和超哥分享的毕业刷题路线，助你在训练营结束后持续练习。
基础 两数之和 （简单） 有效的括号 （简单） 字符串解码 （中等） LRU 缓存机制 （困难） 实现 Trie（前缀树） （中等） 添加与搜索单词 - 数据结构设计 （中等） 单词搜索 II （困难） 找不同 （简单） 单词规律 （简单） 字符串中的第一个唯一字符 （简单） 无重复字符的最长子串 （中等） 最小覆盖子串 （困难） 合并两个有序链表 （简单） 环形链表 （简单） 环形链表 II （中等） 反转链表 （简单） 反转链表 II （中等） 旋转链表 （中等） 排序链表 链表中倒数第 k 个节点 两两交换链表中的节点 （中等） 按奇偶排序数组 （简单） 按奇偶排序数组 II （简单） 有序数组的平方 （简单） 山脉数组的峰顶索引 （简单） 搜索旋转排序数组 （困难） 搜索旋转排序数组 II （中等） 寻找旋转排序数组中的最小值 （中等） 寻找旋转排序数组中的最小值 II （困难） 搜索二维矩阵 （中等） 等式方程的可满足性 （中等） 朋友圈 （中等） 账户合并 （中等） 深度优先搜索 二叉树的最大深度 （简单） 路径总和 （简单） 路径总和 II （中等） 被围绕的区域 （中等） 岛屿数量 （中等） 岛屿的最大面积 （中等） 在二叉树中分配硬币 （中等） 回溯 括号生成 （中等） N 皇后 （困难） N 皇后 II （困难） 解数独 （中等） 不同路径 III （困难） 单词搜索 （中等） 分治 搜索二维矩阵 II （中等） 合并 K 个排序链表 （中等） 为运算表达式设计优先级 （中等） 给表达式添加运算符 （困难） 数组中的第 K 个最大元素 （中等） 最接近原点的 K 个点 （中等） 鸡蛋掉落 （困难） 动态规划 使用最小花费爬楼梯 （简单） 爬楼梯 （简单） 不同路径 （简单） 最小路径和 （中等） 最大子序和 （简单） 乘积最大子数组 （中等） 买卖股票的最佳时机 （简单） 买卖股票的最佳时机 II （简单） 买卖股票的最佳时机 III （困难） 买卖股票的最佳时机 IV （困难） 最佳买卖股票时机含冷冻期 （中等） 买卖股票的最佳时机含手续费 （中等） 零钱兑换 （中等） 零钱兑换 II （中等） 编辑距离 （困难） 不同的子序列 （困难） 柱状图中最大的矩形 （困难） 最大矩形 （困难） 最大正方形 （中等） 最低票价 （中等） 区域和检索 - 数组不可变 （简单） 二维区域和检索 - 矩阵不可变 （中等） 最长上升子序列 （中等） 鸡蛋掉落 （困难）</description></item><item><title>剑指 Offer 13 机器人的运动范围</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ji-qi-ren-de-yun-dong-fan-wei-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ji-qi-ren-de-yun-dong-fan-wei-lcof/</guid><description>剑指 Offer 13 机器人的运动范围 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？
&amp;nbsp;
示例 1：
输入：m = 2, n = 3, k = 1 输出：3 示例 2：
输入：m = 3, n = 1, k = 0 输出：1 提示：
1 &amp;lt;= n,m &amp;lt;= 100 0 &amp;lt;= k&amp;nbsp;&amp;lt;= 20 func movingCount(m int, n int, k int) int { } LeetCode题库地址 https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof</description></item><item><title>剑指 Offer II 011 0 和 1 个数相同的子数组</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/a1nyos/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/a1nyos/</guid><description>剑指 Offer II 011 0 和 1 个数相同的子数组 给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。
&amp;nbsp;
示例 1：
输入: nums = [0,1] 输出: 2 说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。 示例 2：
输入: nums = [0,1,0] 输出: 2 说明: [0, 1] (或 [1, 0]) 是具有相同数量 0 和 1 的最长连续子数组。 &amp;nbsp;
提示：
1 &amp;lt;= nums.length &amp;lt;= 105 nums[i] 不是 0 就是 1 &amp;nbsp;
注意：本题与主站 525&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/contiguous-array/
func findMaxLength(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/A1NYOS</description></item><item><title>面试题 02.02 返回倒数第 k 个节点</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/kth-node-from-end-of-list-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/kth-node-from-end-of-list-lcci/</guid><description>面试题 02.02 返回倒数第 k 个节点 实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。
注意：本题相对原题稍作改动
示例：
输入： 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5 和 k = 2 输出： 4 说明：
给定的 k&amp;nbsp;保证是有效的。
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func kthToLast(head *ListNode, k int) int { } LeetCode题库地址 https://leetcode.cn/problems/kth-node-from-end-of-list-lcci</description></item><item><title>面试题13 机器人的运动范围</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ji-qi-ren-de-yun-dong-fan-wei-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ji-qi-ren-de-yun-dong-fan-wei-lcof/</guid><description>面试题13 机器人的运动范围 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？
&amp;nbsp;
示例 1：
输入：m = 2, n = 3, k = 1 输出：3 示例 2：
输入：m = 3, n = 1, k = 0 输出：1 提示：
1 &amp;lt;= n,m &amp;lt;= 100 0 &amp;lt;= k&amp;nbsp;&amp;lt;= 20 func movingCount(m int, n int, k int) int { } LeetCode题库地址 https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof</description></item><item><title>第十一周：DNS &amp; CDN &amp; 多活架构</title><link>/docs/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/week11/</link><pubDate>Tue, 01 Mar 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/week11/</guid><description>关注公众号获得更多精彩文章</description></item><item><title>毕业刷新路径</title><link>/study/2021algorithm/final/</link><pubDate>Wed, 19 Jan 2022 08:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/2021algorithm/final/</guid><description>首先，恭喜各位同学从极客时间算法训练营毕业！
相信 70 天的刻意练习给你带来了不少改变。但是毕业后的练习还不能停止，除了课上老师讲授的题目和布置的作业，这里还有一份“左耳朵耗子”陈皓老师分享的毕业刷题路线，助你在训练营结束后持续练习。
基础 两数之和 （简单） 有效的括号 （简单） 字符串解码 （中等） LRU 缓存机制 （困难） 实现 Trie（前缀树） （中等） 添加与搜索单词 - 数据结构设计 （中等） 单词搜索 II （困难） 找不同 （简单） 单词规律 （简单） 字符串中的第一个唯一字符 （简单） 无重复字符的最长子串 （中等） 最小覆盖子串 （困难） 合并两个有序链表 （简单） 环形链表 （简单） 环形链表 II （中等） 反转链表 （简单） 反转链表 II （中等） 旋转链表 （中等） 排序链表 链表中倒数第 k 个节点 两两交换链表中的节点 （中等） 按奇偶排序数组 （简单） 按奇偶排序数组 II （简单） 有序数组的平方 （简单） 山脉数组的峰顶索引 （简单） 搜索旋转排序数组 （困难） 搜索旋转排序数组 II （中等） 寻找旋转排序数组中的最小值 （中等） 寻找旋转排序数组中的最小值 II （困难） 搜索二维矩阵 （中等） 等式方程的可满足性 （中等） 朋友圈 （中等） 账户合并 （中等） 深度优先搜索 二叉树的最大深度 （简单） 路径总和 （简单） 路径总和 II （中等） 被围绕的区域 （中等） 岛屿数量 （中等） 岛屿的最大面积 （中等） 在二叉树中分配硬币 （中等） 回溯 括号生成 （中等） N 皇后 （困难） N 皇后 II （困难） 解数独 （中等） 不同路径 III （困难） 单词搜索 （中等） 分治 搜索二维矩阵 II （中等） 合并 K 个排序链表 （中等） 为运算表达式设计优先级 （中等） 给表达式添加运算符 （困难） 数组中的第 K 个最大元素 （中等） 最接近原点的 K 个点 （中等） 鸡蛋掉落 （困难） 动态规划 使用最小花费爬楼梯 （简单） 爬楼梯 （简单） 不同路径 （简单） 最小路径和 （中等） 最大子序和 （简单） 乘积最大子数组 （中等） 买卖股票的最佳时机 （简单） 买卖股票的最佳时机 II （简单） 买卖股票的最佳时机 III （困难） 买卖股票的最佳时机 IV （困难） 最佳买卖股票时机含冷冻期 （中等） 买卖股票的最佳时机含手续费 （中等） 零钱兑换 （中等） 零钱兑换 II （中等） 编辑距离 （困难） 不同的子序列 （困难） 柱状图中最大的矩形 （困难） 最大矩形 （困难） 最大正方形 （中等） 最低票价 （中等） 区域和检索 - 数组不可变 （简单） 二维区域和检索 - 矩阵不可变 （中等） 最长上升子序列 （中等） 鸡蛋掉落 （困难）</description></item><item><title>第十一课 设计互联网高并发数据中台</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/11%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AF%BE%E8%AE%BE%E8%AE%A1%E4%BA%92%E8%81%94%E7%BD%91%E9%AB%98%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0/</link><pubDate>Fri, 14 Jan 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/11%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AF%BE%E8%AE%BE%E8%AE%A1%E4%BA%92%E8%81%94%E7%BD%91%E9%AB%98%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0/</guid><description>关注公众号获得更多精彩文章</description></item><item><title>剑指 Offer 14- I 剪绳子</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/jian-sheng-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/jian-sheng-zi-lcof/</guid><description>剑指 Offer 14- I 剪绳子 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&amp;gt;1并且m&amp;gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
示例 1：
输入: 2 输出: 1 解释: 2 = 1 + 1, 1 &amp;times; 1 = 1 示例&amp;nbsp;2:
输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 &amp;times;&amp;nbsp;3 &amp;times;&amp;nbsp;4 = 36 提示：
2 &amp;lt;= n &amp;lt;= 58 注意：本题与主站 343 题相同：https://leetcode-cn.com/problems/integer-break/
func cuttingRope(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/jian-sheng-zi-lcof</description></item><item><title>剑指 Offer II 012 左右两边子数组的和相等</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/tvdfij/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/tvdfij/</guid><description>剑指 Offer II 012 左右两边子数组的和相等 给你一个整数数组&amp;nbsp;nums ，请计算数组的 中心下标 。
数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。
如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。
如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。
&amp;nbsp;
示例 1：
输入：nums = [1,7,3,6,5,6] 输出：3 解释： 中心下标是 3 。 左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ， 右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。 示例 2：
输入：nums = [1, 2, 3] 输出：-1 解释： 数组中不存在满足此条件的中心下标。 示例 3：
输入：nums = [2, 1, -1] 输出：0 解释： 中心下标是 0 。 左侧数之和 sum = 0 ，（下标 0 左侧不存在元素）， 右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。 &amp;nbsp;</description></item><item><title>面试题 02.03 删除中间节点</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/delete-middle-node-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/delete-middle-node-lcci/</guid><description>面试题 02.03 删除中间节点 若链表中的某个节点，既不是链表头节点，也不是链表尾节点，则称其为该链表的「中间节点」。
假定已知链表的某一个中间节点，请实现一种算法，将该节点从链表中删除。
例如，传入节点 c（位于单向链表 a->b->c->d->e->f 中），将其删除后，剩余链表为 a->b->d->e->f
示例：
输入：节点 5 （位于单向链表 4->5->1->9 中） 输出：不返回任何数据，从链表中删除传入的节点 5，使链表变为 4->1->9 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func deleteNode(node *ListNode) { } LeetCode题库地址 https://leetcode.cn/problems/delete-middle-node-lcci</description></item><item><title>第十二周：消息队列 - Kafka</title><link>/docs/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/week12/</link><pubDate>Tue, 01 Mar 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/week12/</guid><description>关注公众号获得更多精彩文章</description></item><item><title>第十二课 成为Go语言性能调优专家</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/12%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AF%BE%E6%88%90%E4%B8%BAgo%E8%AF%AD%E8%A8%80%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%93%E5%AE%B6/</link><pubDate>Fri, 14 Jan 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/12%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AF%BE%E6%88%90%E4%B8%BAgo%E8%AF%AD%E8%A8%80%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%93%E5%AE%B6/</guid><description>关注公众号获得更多精彩文章</description></item><item><title>剑指 Offer 14- II 剪绳子 II</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/jian-sheng-zi-ii-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/jian-sheng-zi-ii-lcof/</guid><description>剑指 Offer 14- II 剪绳子 II 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m&amp;nbsp;段（m、n都是整数，n&amp;gt;1并且m&amp;gt;1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
&amp;nbsp;
示例 1：
输入: 2 输出: 1 解释: 2 = 1 + 1, 1 &amp;times; 1 = 1 示例&amp;nbsp;2:
输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 &amp;times;&amp;nbsp;3 &amp;times;&amp;nbsp;4 = 36 &amp;nbsp;
提示：
2 &amp;lt;= n &amp;lt;= 1000 注意：本题与主站 343 题相同：https://leetcode-cn.com/problems/integer-break/
func cuttingRope(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/jian-sheng-zi-ii-lcof</description></item><item><title>剑指 Offer II 013 二维子矩阵的和</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/o4ndxx/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/o4ndxx/</guid><description>剑指 Offer II 013 二维子矩阵的和 给定一个二维矩阵 matrix，以下类型的多个请求：
计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1,&amp;nbsp;col1) ，右下角为 (row2,&amp;nbsp;col2) 。 实现 NumMatrix 类：
NumMatrix(int[][] matrix)&amp;nbsp;给定整数矩阵 matrix 进行初始化 int sumRegion(int row1, int col1, int row2, int col2)&amp;nbsp;返回左上角 (row1,&amp;nbsp;col1)&amp;nbsp;、右下角&amp;nbsp;(row2,&amp;nbsp;col2)&amp;nbsp;的子矩阵的元素总和。 &amp;nbsp;
示例 1：
输入: [&amp;quot;NumMatrix&amp;quot;,&amp;quot;sumRegion&amp;quot;,&amp;quot;sumRegion&amp;quot;,&amp;quot;sumRegion&amp;quot;] [[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]] 输出: [null, 8, 11, 12] 解释: NumMatrix numMatrix = new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]]); numMatrix.sumRegion(2, 1, 4, 3); // return 8 (红色矩形框的元素总和) numMatrix.sumRegion(1, 1, 2, 2); // return 11 (绿色矩形框的元素总和) numMatrix.sumRegion(1, 2, 2, 4); // return 12 (蓝色矩形框的元素总和) &amp;nbsp;
提示：
m == matrix.length n == matrix[i].</description></item><item><title>面试题 02.04 分割链表</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/partition-list-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/partition-list-lcci/</guid><description>面试题 02.04 分割链表 给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。
你不需要&amp;nbsp;保留&amp;nbsp;每个分区中各节点的初始相对位置。
&amp;nbsp;
示例 1：
输入：head = [1,4,3,2,5,2], x = 3 输出：[1,2,2,4,3,5] 示例 2：
输入：head = [2,1], x = 2 输出：[1,2] &amp;nbsp;
提示：
链表中节点的数目在范围 [0, 200] 内 -100 &amp;lt;= Node.val &amp;lt;= 100 -200 &amp;lt;= x &amp;lt;= 200 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func partition(head *ListNode, x int) *ListNode { } LeetCode题库地址 https://leetcode.</description></item><item><title>第十三周：Go语言实践-Runtime</title><link>/docs/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/week13/</link><pubDate>Tue, 01 Mar 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/week13/</guid><description>毕业项目 对当下自己项目中的业务，进行一个微服务改造，需要考虑如下技术点：
微服务架构（BFF、Service、Admin、Job、Task 分模块） API 设计（包括 API 定义、错误码规范、Error 的使用） gRPC 的使用 Go 项目工程化（项目结构、DI、代码分层、ORM 框架） 并发的使用（errgroup 的并行链路请求） 微服务中间件的使用（ELK、Opentracing、Prometheus、Kafka） 缓存的使用优化（一致性处理、Pipeline 优化） 关注公众号获得更多精彩文章</description></item><item><title>第十三课 分布式服务的拆分难题</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/13%E7%AC%AC%E5%8D%81%E4%B8%89%E8%AF%BE%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%8B%86%E5%88%86%E9%9A%BE%E9%A2%98/</link><pubDate>Fri, 14 Jan 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/13%E7%AC%AC%E5%8D%81%E4%B8%89%E8%AF%BE%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%8B%86%E5%88%86%E9%9A%BE%E9%A2%98/</guid><description>关注公众号获得更多精彩文章</description></item><item><title>剑指 Offer 15 二进制中1的个数</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-jin-zhi-zhong-1de-ge-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-jin-zhi-zhong-1de-ge-shu-lcof/</guid><description>剑指 Offer 15 二进制中1的个数 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为 汉明重量).）。
提示：
请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。 示例 1：
输入：n = 11 (控制台输入 00000000000000000000000000001011) 输出：3 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。 示例 2：
输入：n = 128 (控制台输入 00000000000000000000000010000000) 输出：1 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。 示例 3：
输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3） 输出：31 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。 提示：
输入必须是长度为 32 的 二进制串 。 注意：本题与主站 191 题相同：https://leetcode-cn.com/problems/number-of-1-bits/
func hammingWeight(num uint32) int { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer II 014 字符串中的变位词</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/mpnail/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/mpnail/</guid><description>剑指 Offer II 014 字符串中的变位词 给定两个字符串&amp;nbsp;s1&amp;nbsp;和&amp;nbsp;s2，写一个函数来判断 s2 是否包含 s1&amp;nbsp;的某个变位词。
换句话说，第一个字符串的排列之一是第二个字符串的 子串 。
&amp;nbsp;
示例 1：
输入: s1 = &amp;quot;ab&amp;quot; s2 = &amp;quot;eidbaooo&amp;quot; 输出: True 解释: s2 包含 s1 的排列之一 (&amp;quot;ba&amp;quot;). 示例 2：
输入: s1= &amp;quot;ab&amp;quot; s2 = &amp;quot;eidboaoo&amp;quot; 输出: False &amp;nbsp;
提示：
1 &amp;lt;= s1.length, s2.length &amp;lt;= 104 s1 和 s2 仅包含小写字母 &amp;nbsp;
注意：本题与主站 567&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/permutation-in-string/
func checkInclusion(s1 string, s2 string) bool { } LeetCode题库地址 https://leetcode.cn/problems/MPnaiL</description></item><item><title>面试题 02.05 链表求和</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sum-lists-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sum-lists-lcci/</guid><description>面试题 02.05 链表求和 给定两个用链表表示的整数，每个节点包含一个数位。
这些数位是反向存放的，也就是个位排在链表首部。
编写函数对这两个整数求和，并用链表形式返回结果。
&amp;nbsp;
示例：
输入：(7 -&amp;gt; 1 -&amp;gt; 6) + (5 -&amp;gt; 9 -&amp;gt; 2)，即617 + 295 输出：2 -&amp;gt; 1 -&amp;gt; 9，即912 进阶：思考一下，假设这些数位是正向存放的，又该如何解决呢?
示例：
输入：(6 -&amp;gt; 1 -&amp;gt; 7) + (2 -&amp;gt; 9 -&amp;gt; 5)，即617 + 295 输出：9 -&amp;gt; 1 -&amp;gt; 2，即912 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { } LeetCode题库地址 https://leetcode.</description></item><item><title>第十四课 一线互联网公司的CI/CD实践</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/14%E7%AC%AC%E5%8D%81%E5%9B%9B%E8%AF%BE%E4%B8%80%E7%BA%BF%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E7%9A%84cicd%E5%AE%9E%E8%B7%B5/</link><pubDate>Fri, 14 Jan 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/14%E7%AC%AC%E5%8D%81%E5%9B%9B%E8%AF%BE%E4%B8%80%E7%BA%BF%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E7%9A%84cicd%E5%AE%9E%E8%B7%B5/</guid><description>关注公众号获得更多精彩文章</description></item><item><title>剑指 Offer 16 数值的整数次方</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zhi-de-zheng-shu-ci-fang-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zhi-de-zheng-shu-ci-fang-lcof/</guid><description>剑指 Offer 16 数值的整数次方 实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。
示例 1：
输入：x = 2.00000, n = 10 输出：1024.00000 示例 2：
输入：x = 2.10000, n = 3 输出：9.26100 示例 3：
输入：x = 2.00000, n = -2 输出：0.25000 解释：2-2 = 1/22 = 1/4 = 0.25 提示：
-100.0 &lt; x &lt; 100.0 -231 &lt;= n &lt;= 231-1 -104 &lt;= xn &lt;= 104 注意：本题与主站 50 题相同：https://leetcode-cn.com/problems/powx-n/
func myPow(x float64, n int) float64 { } LeetCode题库地址 https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof</description></item><item><title>剑指 Offer II 015 字符串中的所有变位词</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/vabmrr/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/vabmrr/</guid><description>剑指 Offer II 015 字符串中的所有变位词 给定两个字符串&amp;nbsp;s&amp;nbsp;和&amp;nbsp;p，找到&amp;nbsp;s&amp;nbsp;中所有 p 的&amp;nbsp;变位词&amp;nbsp;的子串，返回这些子串的起始索引。不考虑答案输出的顺序。
变位词 指字母相同，但排列不同的字符串。
&amp;nbsp;
示例&amp;nbsp;1：
输入: s = &amp;quot;cbaebabacd&amp;quot;, p = &amp;quot;abc&amp;quot; 输出: [0,6] 解释: 起始索引等于 0 的子串是 &amp;quot;cba&amp;quot;, 它是 &amp;quot;abc&amp;quot; 的变位词。 起始索引等于 6 的子串是 &amp;quot;bac&amp;quot;, 它是 &amp;quot;abc&amp;quot; 的变位词。 &amp;nbsp;示例 2：
输入: s = &amp;quot;abab&amp;quot;, p = &amp;quot;ab&amp;quot; 输出: [0,1,2] 解释: 起始索引等于 0 的子串是 &amp;quot;ab&amp;quot;, 它是 &amp;quot;ab&amp;quot; 的变位词。 起始索引等于 1 的子串是 &amp;quot;ba&amp;quot;, 它是 &amp;quot;ab&amp;quot; 的变位词。 起始索引等于 2 的子串是 &amp;quot;ab&amp;quot;, 它是 &amp;quot;ab&amp;quot; 的变位词。 &amp;nbsp;
提示:
1 &amp;lt;= s.length, p.length &amp;lt;= 3 * 104 s&amp;nbsp;和 p 仅包含小写字母 &amp;nbsp;</description></item><item><title>面试题 02.06 回文链表</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/palindrome-linked-list-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/palindrome-linked-list-lcci/</guid><description>面试题 02.06 回文链表 编写一个函数，检查输入的链表是否是回文的。
&amp;nbsp;
示例 1：
输入： 1-&amp;gt;2 输出： false 示例 2：
输入： 1-&amp;gt;2-&amp;gt;2-&amp;gt;1 输出： true &amp;nbsp;
进阶：
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func isPalindrome(head *ListNode) bool { } LeetCode题库地址 https://leetcode.cn/problems/palindrome-linked-list-lcci</description></item><item><title>第十五课 微服务的监控和可观测序</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/15%E7%AC%AC%E5%8D%81%E4%BA%94%E8%AF%BE%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%9B%91%E6%8E%A7%E5%92%8C%E5%8F%AF%E8%A7%82%E6%B5%8B%E5%BA%8F/</link><pubDate>Mon, 10 Jan 2022 13:40:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/15%E7%AC%AC%E5%8D%81%E4%BA%94%E8%AF%BE%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%9B%91%E6%8E%A7%E5%92%8C%E5%8F%AF%E8%A7%82%E6%B5%8B%E5%BA%8F/</guid><description>Metrics Prometheus 默认端口9090 Counter【计数类】、Gauge【状态数据】、Summary【分位数据】、Histogram【直方图】 Pushgateway 默认端口9091 Alertmanager 告警模块 Google 的Monarch Traces Logs 关注公众号获得更多精彩文章</description></item><item><title>剑指 Offer 17 打印从1到最大的n位数</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/</guid><description>剑指 Offer 17 打印从1到最大的n位数 输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。
示例 1:
输入: n = 1 输出: [1,2,3,4,5,6,7,8,9] &amp;nbsp;
说明：
用返回一个整数列表来代替打印 n 为正整数 func printNumbers(n int) []int { } LeetCode题库地址 https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof</description></item><item><title>剑指 Offer II 016 不含重复字符的最长子字符串</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/wtcae1/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/wtcae1/</guid><description>剑指 Offer II 016 不含重复字符的最长子字符串 给定一个字符串 s ，请你找出其中不含有重复字符的&amp;nbsp;最长连续子字符串&amp;nbsp;的长度。
&amp;nbsp;
示例&amp;nbsp;1:
输入: s = &amp;quot;abcabcbb&amp;quot; 输出: 3 解释: 因为无重复字符的最长子字符串是 &amp;quot;abc&amp;quot;，所以其长度为 3。 示例 2:
输入: s = &amp;quot;bbbbb&amp;quot; 输出: 1 解释: 因为无重复字符的最长子字符串是 &amp;quot;b&amp;quot;，所以其长度为 1。 示例 3:
输入: s = &amp;quot;pwwkew&amp;quot; 输出: 3 解释: 因为无重复字符的最长子串是&amp;nbsp;&amp;quot;wke&amp;quot;，所以其长度为 3。 &amp;nbsp; 请注意，你的答案必须是 子串 的长度，&amp;quot;pwke&amp;quot;&amp;nbsp;是一个子序列，不是子串。 示例 4:
输入: s = &amp;quot;&amp;quot; 输出: 0 &amp;nbsp;
提示：
0 &amp;lt;= s.length &amp;lt;= 5 * 104 s&amp;nbsp;由英文字母、数字、符号和空格组成 &amp;nbsp;
注意：本题与主站 3&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/
func lengthOfLongestSubstring(s string) int { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 02.07 链表相交</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/intersection-of-two-linked-lists-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/intersection-of-two-linked-lists-lcci/</guid><description>面试题 02.07 链表相交 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。
图示两个链表在节点 c1 开始相交：
题目数据 保证 整个链式结构中不存在环。
注意，函数返回结果后，链表必须 保持其原始结构 。
示例 1：
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Intersected at '8' 解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2：
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Intersected at '2' 解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。 在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3：</description></item><item><title>第十六课微服务基础设施-服务发现、检索、定时任务、MQ</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/16%E7%AC%AC%E5%8D%81%E5%85%AD%E8%AF%BE%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%A3%80%E7%B4%A2%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1mq/</link><pubDate>Mon, 10 Jan 2022 13:40:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/16%E7%AC%AC%E5%8D%81%E5%85%AD%E8%AF%BE%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%A3%80%E7%B4%A2%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1mq/</guid><description>MQ Kafka
Pulsar
关注公众号获得更多精彩文章</description></item><item><title>剑指 Offer 18 删除链表的节点</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shan-chu-lian-biao-de-jie-dian-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shan-chu-lian-biao-de-jie-dian-lcof/</guid><description>剑指 Offer 18 删除链表的节点 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。
返回删除后的链表的头节点。
注意：此题对比原题有改动
示例 1:
输入: head = [4,5,1,9], val = 5 输出: [4,1,9] 解释: 给定你链表中值为&amp;nbsp;5&amp;nbsp;的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 1 -&amp;gt; 9. 示例 2:
输入: head = [4,5,1,9], val = 1 输出: [4,5,9] 解释: 给定你链表中值为&amp;nbsp;1&amp;nbsp;的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 5 -&amp;gt; 9. &amp;nbsp;
说明：
题目保证链表中节点的值互不相同 若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func deleteNode(head *ListNode, val int) *ListNode { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer II 017 含有所有字符的最短字符串</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/m1oytv/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/m1oytv/</guid><description>剑指 Offer II 017 含有所有字符的最短字符串 给定两个字符串 s 和&amp;nbsp;t 。返回 s 中包含&amp;nbsp;t&amp;nbsp;的所有字符的最短子字符串。如果 s 中不存在符合条件的子字符串，则返回空字符串 &amp;quot;&amp;quot; 。
如果 s 中存在多个符合条件的子字符串，返回任意一个。
&amp;nbsp;
注意： 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
&amp;nbsp;
示例 1：
输入：s = &amp;quot;ADOBECODEBANC&amp;quot;, t = &amp;quot;ABC&amp;quot; 输出：&amp;quot;BANC&amp;quot; 解释：最短子字符串 &amp;quot;BANC&amp;quot; 包含了字符串 t 的所有字符 &amp;#39;A&amp;#39;、&amp;#39;B&amp;#39;、&amp;#39;C&amp;#39; 示例 2：
输入：s = &amp;quot;a&amp;quot;, t = &amp;quot;a&amp;quot; 输出：&amp;quot;a&amp;quot; 示例 3：
输入：s = &amp;quot;a&amp;quot;, t = &amp;quot;aa&amp;quot; 输出：&amp;quot;&amp;quot; 解释：t 中两个字符 &amp;#39;a&amp;#39; 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。 &amp;nbsp;
提示：
1 &amp;lt;= s.length, t.length &amp;lt;= 105 s 和 t 由英文字母组成 &amp;nbsp;</description></item><item><title>面试题 02.08 环路检测</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/linked-list-cycle-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/linked-list-cycle-lcci/</guid><description>面试题 02.08 环路检测 给定一个链表，如果它是有环链表，实现一个算法返回环路的开头节点。若环不存在，请返回 null。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。
&amp;nbsp;
示例 1：
输入：head = [3,2,0,-4], pos = 1 输出：tail connects to node index 1 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2：
输入：head = [1,2], pos = 0 输出：tail connects to node index 0 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3：
输入：head = [1], pos = -1 输出：no cycle 解释：链表中没有环。 &amp;nbsp;
进阶：
你是否可以不用额外空间解决此题？ &amp;nbsp;
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func detectCycle(head *ListNode) *ListNode { } LeetCode题库地址 https://leetcode.</description></item><item><title>第十七课 大型互联网公司的稳定性密码</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/17%E7%AC%AC%E5%8D%81%E4%B8%83%E8%AF%BE%E5%A4%A7%E5%9E%8B%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%AF%86%E7%A0%81/</link><pubDate>Fri, 14 Jan 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/17%E7%AC%AC%E5%8D%81%E4%B8%83%E8%AF%BE%E5%A4%A7%E5%9E%8B%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%AF%86%E7%A0%81/</guid><description>混沌工程 ChaosBlade
Chaos Mesh
关注公众号获得更多精彩文章</description></item><item><title>剑指 Offer 19 正则表达式匹配</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zheng-ze-biao-da-shi-pi-pei-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zheng-ze-biao-da-shi-pi-pei-lcof/</guid><description>剑指 Offer 19 正则表达式匹配 请实现一个函数用来匹配包含&amp;#39;. &amp;#39;和&amp;#39;*&amp;#39;的正则表达式。模式中的字符&amp;#39;.&amp;#39;表示任意一个字符，而&amp;#39;*&amp;#39;表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&amp;quot;aaa&amp;quot;与模式&amp;quot;a.a&amp;quot;和&amp;quot;ab*ac*a&amp;quot;匹配，但与&amp;quot;aa.a&amp;quot;和&amp;quot;ab*a&amp;quot;均不匹配。
示例 1:
输入: s = &amp;quot;aa&amp;quot; p = &amp;quot;a&amp;quot; 输出: false 解释: &amp;quot;a&amp;quot; 无法匹配 &amp;quot;aa&amp;quot; 整个字符串。 示例 2:
输入: s = &amp;quot;aa&amp;quot; p = &amp;quot;a*&amp;quot; 输出: true 解释:&amp;nbsp;因为 &amp;#39;*&amp;#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &amp;#39;a&amp;#39;。因此，字符串 &amp;quot;aa&amp;quot; 可被视为 &amp;#39;a&amp;#39; 重复了一次。 示例&amp;nbsp;3:
输入: s = &amp;quot;ab&amp;quot; p = &amp;quot;.*&amp;quot; 输出: true 解释:&amp;nbsp;&amp;quot;.*&amp;quot; 表示可匹配零个或多个（&amp;#39;*&amp;#39;）任意字符（&amp;#39;.&amp;#39;）。 示例 4:
输入: s = &amp;quot;aab&amp;quot; p = &amp;quot;c*a*b&amp;quot; 输出: true 解释:&amp;nbsp;因为 &amp;#39;*&amp;#39; 表示零个或多个，这里 &amp;#39;c&amp;#39; 为 0 个, &amp;#39;a&amp;#39; 被重复一次。因此可以匹配字符串 &amp;quot;aab&amp;quot;。 示例 5:</description></item><item><title>剑指 Offer II 018 有效的回文</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/xltzeq/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/xltzeq/</guid><description>剑指 Offer II 018 有效的回文 给定一个字符串 s ，验证 s&amp;nbsp;是否是&amp;nbsp;回文串&amp;nbsp;，只考虑字母和数字字符，可以忽略字母的大小写。
本题中，将空字符串定义为有效的&amp;nbsp;回文串&amp;nbsp;。
&amp;nbsp;
示例 1:
输入: s = &amp;quot;A man, a plan, a canal: Panama&amp;quot; 输出: true 解释：&amp;quot;amanaplanacanalpanama&amp;quot; 是回文串 示例 2:
输入: s = &amp;quot;race a car&amp;quot; 输出: false 解释：&amp;quot;raceacar&amp;quot; 不是回文串 &amp;nbsp;
提示：
1 &amp;lt;= s.length &amp;lt;= 2 * 105 字符串 s 由 ASCII 字符组成 &amp;nbsp;
注意：本题与主站 125&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/valid-palindrome/
func isPalindrome(s string) bool { } LeetCode题库地址 https://leetcode.cn/problems/XltzEq</description></item><item><title>面试题 03.01 三合一</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/three-in-one-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/three-in-one-lcci/</guid><description>面试题 03.01 三合一 三合一。描述如何只用一个数组来实现三个栈。
你应该实现push(stackNum, value)、pop(stackNum)、isEmpty(stackNum)、peek(stackNum)方法。stackNum表示栈下标，value表示压入的值。
构造函数会传入一个stackSize参数，代表每个栈的大小。
示例1:
输入： ["TripleInOne", "push", "push", "pop", "pop", "pop", "isEmpty"] [[1], [0, 1], [0, 2], [0], [0], [0], [0]] 输出： [null, null, null, 1, -1, -1, true] 说明：当栈为空时`pop, peek`返回-1，当栈满时`push`不压入元素。 示例2:
输入： ["TripleInOne", "push", "push", "push", "pop", "pop", "pop", "peek"] [[2], [0, 1], [0, 2], [0, 3], [0], [0], [0], [0]] 输出： [null, null, null, null, 2, 1, -1, -1] &amp;nbsp;
提示：
0 &amp;lt;= stackNum &amp;lt;= 2 type TripleInOne struct { } func Constructor(stackSize int) TripleInOne { } func (this *TripleInOne) Push(stackNum int, value int) { } func (this *TripleInOne) Pop(stackNum int) int { } func (this *TripleInOne) Peek(stackNum int) int { } func (this *TripleInOne) IsEmpty(stackNum int) bool { } /** * Your TripleInOne object will be instantiated and called as such: * obj := Constructor(stackSize); * obj.</description></item><item><title>第十八课 Cloud Native Go</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/18%E7%AC%AC%E5%8D%81%E5%85%AB%E8%AF%BEcloud-native-go/</link><pubDate>Fri, 14 Jan 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/18%E7%AC%AC%E5%8D%81%E5%85%AB%E8%AF%BEcloud-native-go/</guid><description>参考 https://github.com/lorin/resilience-engineering https://sre.google 安全容器：gVisor、katacontainer
sealos、minikube
etcd运维平台：kstone
《深入剖析kubernetes》
《DevSecOps 实战》
Caddy
https://dengxiaolong.com/caddy/zh/ https://caddyserver.com/docs/ 云原生 ingress：envoy Contour maglev 论文
https://blog.csdn.net/chenyulancn/article/details/79019457 SDN 关注公众号获得更多精彩文章</description></item><item><title>剑指 Offer 20 表示数值的字符串</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/</guid><description>剑指 Offer 20 表示数值的字符串 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。
数值（按顺序）可以分成以下几个部分：
若干空格 一个 小数 或者 整数 （可选）一个 'e' 或 'E' ，后面跟着一个 整数 若干空格 小数（按顺序）可以分成以下几个部分：
（可选）一个符号字符（'+' 或 '-'） 下述格式之一： 至少一位数字，后面跟着一个点 '.' 至少一位数字，后面跟着一个点 '.' ，后面再跟着至少一位数字 一个点 '.' ，后面跟着至少一位数字 整数（按顺序）可以分成以下几个部分：
（可选）一个符号字符（'+' 或 '-'） 至少一位数字 部分数值列举如下：
["+100", "5e2", "-123", "3.1416", "-1E-16", "0123"] 部分非数值列举如下：
["12e", "1a3.14", "1.2.3", "+-5", "12e+5.4"] 示例 1：
输入：s = "0" 输出：true 示例 2：
输入：s = "e" 输出：false 示例 3：
输入：s = "." 输出：false 示例 4：
输入：s = " .1 " 输出：true 提示：</description></item><item><title>剑指 Offer II 019 最多删除一个字符得到回文</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/rqku0d/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/rqku0d/</guid><description>剑指 Offer II 019 最多删除一个字符得到回文 给定一个非空字符串&amp;nbsp;s，请判断如果&amp;nbsp;最多 从字符串中删除一个字符能否得到一个回文字符串。
&amp;nbsp;
示例 1:
输入: s = &amp;quot;aba&amp;quot; 输出: true 示例 2:
输入: s = &amp;quot;abca&amp;quot; 输出: true 解释: 可以删除 &amp;quot;c&amp;quot; 字符 或者 &amp;quot;b&amp;quot; 字符 示例 3:
输入: s = &amp;quot;abc&amp;quot; 输出: false &amp;nbsp;
提示:
1 &amp;lt;= s.length &amp;lt;= 105 s 由小写英文字母组成 &amp;nbsp;
注意：本题与主站 680&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/valid-palindrome-ii/
func validPalindrome(s string) bool { } LeetCode题库地址 https://leetcode.cn/problems/RQku0D</description></item><item><title>面试题 03.02 栈的最小值</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/min-stack-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/min-stack-lcci/</guid><description>面试题 03.02 栈的最小值 请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。
示例：MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); --> 返回 -3.
minStack.pop();
minStack.top(); --> 返回 0.
minStack.getMin(); --> 返回 -2.
type MinStack struct { } /** initialize your data structure here. */ func Constructor() MinStack { } func (this *MinStack) Push(x int) { } func (this *MinStack) Pop() { } func (this *MinStack) Top() int { } func (this *MinStack) GetMin() int { } /** * Your MinStack object will be instantiated and called as such: * obj := Constructor(); * obj.</description></item><item><title>第十九课 Go语言前沿实时剖析</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/19%E7%AC%AC%E5%8D%81%E4%B9%9D%E8%AF%BEgo%E8%AF%AD%E8%A8%80%E5%89%8D%E6%B2%BF%E5%AE%9E%E6%97%B6%E5%89%96%E6%9E%90/</link><pubDate>Fri, 14 Jan 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/19%E7%AC%AC%E5%8D%81%E4%B9%9D%E8%AF%BEgo%E8%AF%AD%E8%A8%80%E5%89%8D%E6%B2%BF%E5%AE%9E%E6%97%B6%E5%89%96%E6%9E%90/</guid><description>关注公众号获得更多精彩文章</description></item><item><title>剑指 Offer 21 调整数组顺序使奇数位于偶数前面</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/</guid><description>剑指 Offer 21 调整数组顺序使奇数位于偶数前面 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。
&amp;nbsp;
示例：
输入：nums =&amp;nbsp;[1,2,3,4] 输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一。 &amp;nbsp;
提示：
0 &amp;lt;= nums.length &amp;lt;= 50000 0 &amp;lt;= nums[i] &amp;lt;= 10000 func exchange(nums []int) []int { } LeetCode题库地址 https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof</description></item><item><title>剑指 Offer II 020 回文子字符串的个数</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/a7vohd/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/a7vohd/</guid><description>剑指 Offer II 020 回文子字符串的个数 给定一个字符串 s ，请计算这个字符串中有多少个回文子字符串。
具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。
&amp;nbsp;
示例 1：
输入：s = "abc" 输出：3 解释：三个回文子串: "a", "b", "c" 示例 2：
输入：s = "aaa" 输出：6 解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa" &amp;nbsp;
提示：
1 &amp;lt;= s.length &amp;lt;= 1000 s 由小写英文字母组成 &amp;nbsp;
注意：本题与主站 647 题相同：https://leetcode-cn.com/problems/palindromic-substrings/&amp;nbsp;
func countSubstrings(s string) int { } LeetCode题库地址 https://leetcode.cn/problems/a7VOhD</description></item><item><title>面试题 03.03 堆盘子</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/stack-of-plates-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/stack-of-plates-lcci/</guid><description>面试题 03.03 堆盘子 堆盘子。设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构SetOfStacks，模拟这种行为。SetOfStacks应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，SetOfStacks.push()和SetOfStacks.pop()应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）。 进阶：实现一个popAt(int index)方法，根据指定的子栈，执行pop操作。
当某个栈为空时，应当删除该栈。当栈中没有元素或不存在该栈时，pop，popAt&amp;nbsp;应返回 -1.
示例1:
输入： [&amp;quot;StackOfPlates&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;popAt&amp;quot;, &amp;quot;pop&amp;quot;, &amp;quot;pop&amp;quot;] [[1], [1], [2], [1], [], []] 输出： [null, null, null, 2, 1, -1] 示例2:
输入： [&amp;quot;StackOfPlates&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;popAt&amp;quot;, &amp;quot;popAt&amp;quot;, &amp;quot;popAt&amp;quot;] [[2], [1], [2], [3], [0], [0], [0]] 输出： [null, null, null, null, 2, 1, 3] type StackOfPlates struct { } func Constructor(cap int) StackOfPlates { } func (this *StackOfPlates) Push(val int) { } func (this *StackOfPlates) Pop() int { } func (this *StackOfPlates) PopAt(index int) int { } /** * Your StackOfPlates object will be instantiated and called as such: * obj := Constructor(cap); * obj.</description></item><item><title>第二十课 Go 语言与未来架构</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/20%E7%AC%AC%E4%BA%8C%E5%8D%81%E8%AF%BEgo%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%9C%AA%E6%9D%A5%E6%9E%B6%E6%9E%84/</link><pubDate>Fri, 14 Jan 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/20%E7%AC%AC%E4%BA%8C%E5%8D%81%E8%AF%BEgo%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%9C%AA%E6%9D%A5%E6%9E%B6%E6%9E%84/</guid><description>Service Mesh cds (Cluster discovery service) eds (Endpotin discovery service) lds (Listener discovery service) rds (Route discovery service) 组件 xDS protoc
Envoy
MOSN
Istio
Dapr（Distributed Application Runtime）
Mecha架构 http2&amp;amp;3学习手册: https://github.com/bagder/http2-explained https://http2-explained.haxx.se/zh https://github.com/bagder/http3-explained https://http3-explained.haxx.se/zh https://cloud.google.com/traffic-director/docs/proxyless-overview https://isovalent.com/blog/post/2021-12-08-ebpf-servicemesh 练习 Dapr 搭建hello world
dapr 文档: https://docs.dapr.io/zh-hans/ 关注公众号获得更多精彩文章</description></item><item><title>剑指 Offer 22 链表中倒数第k个节点</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/</guid><description>剑指 Offer 22 链表中倒数第k个节点 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。
例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。
示例：
给定一个链表: 1->2->3->4->5, 和 k = 2. 返回链表 4->5. /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func getKthFromEnd(head *ListNode, k int) *ListNode { } LeetCode题库地址 https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof</description></item><item><title>剑指 Offer II 021 删除链表的倒数第 n 个结点</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/slwz0r/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/slwz0r/</guid><description>剑指 Offer II 021 删除链表的倒数第 n 个结点 给定一个链表，删除链表的倒数第&amp;nbsp;n&amp;nbsp;个结点，并且返回链表的头结点。
&amp;nbsp;
示例 1：
输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 示例 2：
输入：head = [1], n = 1 输出：[] 示例 3：
输入：head = [1,2], n = 1 输出：[1] &amp;nbsp;
提示：
链表中结点的数目为 sz 1 &amp;lt;= sz &amp;lt;= 30 0 &amp;lt;= Node.val &amp;lt;= 100 1 &amp;lt;= n &amp;lt;= sz &amp;nbsp;
进阶：能尝试使用一趟扫描实现吗？
&amp;nbsp;
注意：本题与主站 19&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeNthFromEnd(head *ListNode, n int) *ListNode { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 03.04 化栈为队</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/implement-queue-using-stacks-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/implement-queue-using-stacks-lcci/</guid><description>面试题 03.04 化栈为队 实现一个MyQueue类，该类用两个栈来实现一个队列。
示例：MyQueue queue = new MyQueue();
queue.push(1);
queue.push(2);
queue.peek(); // 返回 1
queue.pop(); // 返回 1
queue.empty(); // 返回 false
说明：
你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size 和 is empty 操作是合法的。你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。
type MyQueue struct { } /** Initialize your data structure here. */ func Constructor() MyQueue { } /** Push element x to the back of queue. */ func (this *MyQueue) Push(x int) { } /** Removes the element from in front of queue and returns that element.</description></item><item><title>第十八课 以go-micro为例讲讲抽象【二期内容】</title><link>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/21%E7%AC%AC%E5%8D%81%E5%85%AB%E8%AF%BE-%E4%BB%A5go-micro%E4%B8%BA%E4%BE%8B%E8%AE%B2%E8%AE%B2%E6%8A%BD%E8%B1%A1%E4%BA%8C%E6%9C%9F/</link><pubDate>Sat, 12 Mar 2022 13:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/docs/go%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E6%88%98%E8%90%A5/21%E7%AC%AC%E5%8D%81%E5%85%AB%E8%AF%BE-%E4%BB%A5go-micro%E4%B8%BA%E4%BE%8B%E8%AE%B2%E8%AE%B2%E6%8A%BD%E8%B1%A1%E4%BA%8C%E6%9C%9F/</guid><description>参考链接 依赖反转相关 righting software 读书笔记 关注公众号获得更多精彩文章</description></item><item><title>剑指 Offer 24 反转链表</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/fan-zhuan-lian-biao-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/fan-zhuan-lian-biao-lcof/</guid><description>剑指 Offer 24 反转链表 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。
&amp;nbsp;
示例:
输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL 输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL &amp;nbsp;
限制：
0 &amp;lt;= 节点个数 &amp;lt;= 5000
&amp;nbsp;
注意：本题与主站 206 题相同：https://leetcode-cn.com/problems/reverse-linked-list/
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { } LeetCode题库地址 https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof</description></item><item><title>剑指 Offer II 022 链表中环的入口节点</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/c32eov/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/c32eov/</guid><description>剑指 Offer II 022 链表中环的入口节点 给定一个链表，返回链表开始入环的第一个节点。 从链表的头节点开始沿着 next 指针进入环的第一个节点为环的入口节点。如果链表无环，则返回&amp;nbsp;null。
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。
说明：不允许修改给定的链表。
&amp;nbsp;
示例 1：
输入：head = [3,2,0,-4], pos = 1 输出：返回索引为 1 的链表节点 解释：链表中有一个环，其尾部连接到第二个节点。 示例&amp;nbsp;2：
输入：head = [1,2], pos = 0 输出：返回索引为 0 的链表节点 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3：
输入：head = [1], pos = -1 输出：返回 null 解释：链表中没有环。 &amp;nbsp;
提示：
链表中节点的数目范围在范围 [0, 104] 内 -105 &amp;lt;= Node.val &amp;lt;= 105 pos 的值为 -1 或者链表中的一个有效索引 &amp;nbsp;
进阶：是否可以使用 O(1) 空间解决此题？
&amp;nbsp;</description></item><item><title>面试题 03.05 栈排序</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sort-of-stacks-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sort-of-stacks-lcci/</guid><description>面试题 03.05 栈排序 栈排序。 编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：push、pop、peek 和 isEmpty。当栈为空时，peek&amp;nbsp;返回 -1。
示例1:
输入： [&amp;quot;SortedStack&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;peek&amp;quot;, &amp;quot;pop&amp;quot;, &amp;quot;peek&amp;quot;] [[], [1], [2], [], [], []] 输出： [null,null,null,1,null,2] 示例2:
输入： [&amp;quot;SortedStack&amp;quot;, &amp;quot;pop&amp;quot;, &amp;quot;pop&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;pop&amp;quot;, &amp;quot;isEmpty&amp;quot;] [[], [], [], [1], [], []] 输出： [null,null,null,null,null,true] 说明:
栈中的元素数目在[0, 5000]范围内。 type SortedStack struct { } func Constructor() SortedStack { } func (this *SortedStack) Push(val int) { } func (this *SortedStack) Pop() { } func (this *SortedStack) Peek() int { } func (this *SortedStack) IsEmpty() bool { } /** * Your SortedStack object will be instantiated and called as such: * obj := Constructor(); * obj.</description></item><item><title>剑指 Offer 25 合并两个排序的链表</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/</guid><description>剑指 Offer 25 合并两个排序的链表 输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。
示例1：
输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4 输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4 限制：
0 &amp;lt;= 链表长度 &amp;lt;= 1000
注意：本题与主站 21 题相同：https://leetcode-cn.com/problems/merge-two-sorted-lists/
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { } LeetCode题库地址 https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof</description></item><item><title>剑指 Offer II 023 两个链表的第一个重合节点</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/3u1wk4/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/3u1wk4/</guid><description>剑指 Offer II 023 两个链表的第一个重合节点 给定两个单链表的头节点&amp;nbsp;headA 和 headB ，请找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。
图示两个链表在节点 c1 开始相交：
题目数据 保证 整个链式结构中不存在环。
注意，函数返回结果后，链表必须 保持其原始结构 。
&amp;nbsp;
示例 1：
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Intersected at &amp;#39;8&amp;#39; 解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例&amp;nbsp;2：
输入：intersectVal&amp;nbsp;= 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Intersected at &amp;#39;2&amp;#39; 解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。 在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例&amp;nbsp;3：</description></item><item><title>面试题 03.06 动物收容所</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/animal-shelter-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/animal-shelter-lcci/</guid><description>面试题 03.06 动物收容所 动物收容所。有家动物收容所只收容狗与猫，且严格遵守&amp;ldquo;先进先出&amp;rdquo;的原则。在收养该收容所的动物时，收养人只能收养所有动物中&amp;ldquo;最老&amp;rdquo;（由其进入收容所的时间长短而定）的动物，或者可以挑选猫或狗（同时必须收养此类动物中&amp;ldquo;最老&amp;rdquo;的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如enqueue、dequeueAny、dequeueDog和dequeueCat。允许使用Java内置的LinkedList数据结构。
enqueue方法有一个animal参数，animal[0]代表动物编号，animal[1]代表动物种类，其中 0 代表猫，1 代表狗。
dequeue*方法返回一个列表[动物编号, 动物种类]，若没有可以收养的动物，则返回[-1,-1]。
示例1:
输入： [&amp;quot;AnimalShelf&amp;quot;, &amp;quot;enqueue&amp;quot;, &amp;quot;enqueue&amp;quot;, &amp;quot;dequeueCat&amp;quot;, &amp;quot;dequeueDog&amp;quot;, &amp;quot;dequeueAny&amp;quot;] [[], [[0, 0]], [[1, 0]], [], [], []] 输出： [null,null,null,[0,0],[-1,-1],[1,0]] 示例2:
输入： [&amp;quot;AnimalShelf&amp;quot;, &amp;quot;enqueue&amp;quot;, &amp;quot;enqueue&amp;quot;, &amp;quot;enqueue&amp;quot;, &amp;quot;dequeueDog&amp;quot;, &amp;quot;dequeueCat&amp;quot;, &amp;quot;dequeueAny&amp;quot;] [[], [[0, 0]], [[1, 0]], [[2, 1]], [], [], []] 输出： [null,null,null,null,[2,1],[0,0],[1,0]] 说明:
收纳所的最大容量为20000 type AnimalShelf struct { } func Constructor() AnimalShelf { } func (this *AnimalShelf) Enqueue(animal []int) { } func (this *AnimalShelf) DequeueAny() []int { } func (this *AnimalShelf) DequeueDog() []int { } func (this *AnimalShelf) DequeueCat() []int { } /** * Your AnimalShelf object will be instantiated and called as such: * obj := Constructor(); * obj.</description></item><item><title>剑指 Offer 26 树的子结构</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-de-zi-jie-gou-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-de-zi-jie-gou-lcof/</guid><description>剑指 Offer 26 树的子结构 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)
B是A的子结构， 即 A中有出现和B相同的结构和节点值。
例如:
给定的树 A:
&amp;nbsp; &amp;nbsp; &amp;nbsp;3
&amp;nbsp; &amp;nbsp; / \
&amp;nbsp; &amp;nbsp;4 &amp;nbsp; 5
&amp;nbsp; / \
&amp;nbsp;1 &amp;nbsp; 2
给定的树 B：
&amp;nbsp; &amp;nbsp;4&amp;nbsp;
&amp;nbsp; /
&amp;nbsp;1
返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。
示例 1：
输入：A = [1,2,3], B = [3,1] 输出：false 示例 2：
输入：A = [3,4,5,1,2], B = [4,1] 输出：true 限制：
0 &amp;lt;= 节点个数 &amp;lt;= 10000
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isSubStructure(A *TreeNode, B *TreeNode) bool { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer II 024 反转链表</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/uhnkqh/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/uhnkqh/</guid><description>剑指 Offer II 024 反转链表 给定单链表的头节点 head ，请反转链表，并返回反转后的链表的头节点。
&amp;nbsp;
示例 1：
输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1] 示例 2：
输入：head = [1,2] 输出：[2,1] 示例 3：
输入：head = [] 输出：[] &amp;nbsp;
提示：
链表中节点的数目范围是 [0, 5000] -5000 &amp;lt;= Node.val &amp;lt;= 5000 &amp;nbsp;
进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？
&amp;nbsp;
注意：本题与主站 206&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/reverse-linked-list/
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { } LeetCode题库地址 https://leetcode.cn/problems/UHnkqh</description></item><item><title>面试题 04.01 节点间通路</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/route-between-nodes-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/route-between-nodes-lcci/</guid><description>面试题 04.01 节点间通路 节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。
示例1:
输入：n = 3, graph = [[0, 1], [0, 2], [1, 2], [1, 2]], start = 0, target = 2 输出：true 示例2:
输入：n = 5, graph = [[0, 1], [0, 2], [0, 4], [0, 4], [0, 1], [1, 3], [1, 4], [1, 3], [2, 3], [3, 4]], start = 0, target = 4 输出 true 提示：
节点数量n在[0, 1e5]范围内。 节点编号大于等于 0 小于 n。 图中可能存在自环和平行边。 func findWhetherExistsPath(n int, graph [][]int, start int, target int) bool { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer 27 二叉树的镜像</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-shu-de-jing-xiang-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-shu-de-jing-xiang-lcof/</guid><description>剑指 Offer 27 二叉树的镜像 请完成一个函数，输入一个二叉树，该函数输出它的镜像。
例如输入：
&amp;nbsp; &amp;nbsp; &amp;nbsp;4
&amp;nbsp; &amp;nbsp;/ &amp;nbsp; \
&amp;nbsp; 2 &amp;nbsp; &amp;nbsp; 7
&amp;nbsp;/ \ &amp;nbsp; / \
1 &amp;nbsp; 3 6 &amp;nbsp; 9
镜像输出：
&amp;nbsp; &amp;nbsp; &amp;nbsp;4
&amp;nbsp; &amp;nbsp;/ &amp;nbsp; \
&amp;nbsp; 7 &amp;nbsp; &amp;nbsp; 2
&amp;nbsp;/ \ &amp;nbsp; / \
9 &amp;nbsp; 6 3&amp;nbsp; &amp;nbsp;1
&amp;nbsp;
示例 1：
输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1] &amp;nbsp;
限制：
0 &amp;lt;= 节点个数 &amp;lt;= 1000
注意：本题与主站 226 题相同：https://leetcode-cn.com/problems/invert-binary-tree/
/** * Definition for a binary tree node.</description></item><item><title>剑指 Offer II 025 链表中的两数相加</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/lmsnwu/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/lmsnwu/</guid><description>剑指 Offer II 025 链表中的两数相加 给定两个 非空链表 l1和 l2&amp;nbsp;来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。
可以假设除了数字 0 之外，这两个数字都不会以零开头。
&amp;nbsp;
示例1：
输入：l1 = [7,2,4,3], l2 = [5,6,4] 输出：[7,8,0,7] 示例2：
输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[8,0,7] 示例3：
输入：l1 = [0], l2 = [0] 输出：[0] &amp;nbsp;
提示：
链表的长度范围为 [1, 100] 0 &amp;lt;= node.val &amp;lt;= 9 输入数据保证链表代表的数字无前导 0 &amp;nbsp;
进阶：如果输入链表不能修改该如何处理？换句话说，不能对列表中的节点进行翻转。
&amp;nbsp;
注意：本题与主站 445&amp;nbsp;题相同：https://leetcode-cn.com/problems/add-two-numbers-ii/
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 04.02 最小高度树</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/minimum-height-tree-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/minimum-height-tree-lcci/</guid><description>面试题 04.02 最小高度树 给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。
示例:给定有序数组: [-10,-3,0,5,9],
一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：
0 / &amp;#92 -3 9 / / -10 5 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func sortedArrayToBST(nums []int) *TreeNode { } LeetCode题库地址 https://leetcode.cn/problems/minimum-height-tree-lcci</description></item><item><title>剑指 Offer 28 对称的二叉树</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/dui-cheng-de-er-cha-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/dui-cheng-de-er-cha-shu-lcof/</guid><description>剑指 Offer 28 对称的二叉树 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。
例如，二叉树&amp;nbsp;[1,2,2,3,4,4,3] 是对称的。
&amp;nbsp; &amp;nbsp; 1
&amp;nbsp; &amp;nbsp;/ \
&amp;nbsp; 2 &amp;nbsp; 2
&amp;nbsp;/ \ / \
3 &amp;nbsp;4 4 &amp;nbsp;3
但是下面这个&amp;nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:
&amp;nbsp; &amp;nbsp; 1
&amp;nbsp; &amp;nbsp;/ \
&amp;nbsp; 2 &amp;nbsp; 2
&amp;nbsp; &amp;nbsp;\ &amp;nbsp; \
&amp;nbsp; &amp;nbsp;3 &amp;nbsp; &amp;nbsp;3
&amp;nbsp;
示例 1：
输入：root = [1,2,2,3,4,4,3] 输出：true 示例 2：
输入：root = [1,2,2,null,3,null,3] 输出：false &amp;nbsp;
限制：
0 &amp;lt;= 节点个数 &amp;lt;= 1000
注意：本题与主站 101 题相同：https://leetcode-cn.com/problems/symmetric-tree/
/** * Definition for a binary tree node.</description></item><item><title>剑指 Offer II 026 重排链表</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/lgjmqu/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/lgjmqu/</guid><description>剑指 Offer II 026 重排链表 给定一个单链表 L 的头节点 head ，单链表 L 表示为：
&amp;nbsp;L0&amp;nbsp;&amp;rarr; L1&amp;nbsp;&amp;rarr; &amp;hellip; &amp;rarr; Ln-1&amp;nbsp;&amp;rarr; Ln&amp;nbsp;
请将其重新排列后变为：
L0&amp;nbsp;&amp;rarr;&amp;nbsp;Ln&amp;nbsp;&amp;rarr;&amp;nbsp;L1&amp;nbsp;&amp;rarr;&amp;nbsp;Ln-1&amp;nbsp;&amp;rarr;&amp;nbsp;L2&amp;nbsp;&amp;rarr;&amp;nbsp;Ln-2&amp;nbsp;&amp;rarr; &amp;hellip;
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
&amp;nbsp;
示例 1:
输入: head = [1,2,3,4] 输出: [1,4,2,3] 示例 2:
输入: head = [1,2,3,4,5] 输出: [1,5,2,4,3] &amp;nbsp;
提示：
链表的长度范围为 [1, 5 * 104] 1 &amp;lt;= node.val &amp;lt;= 1000 &amp;nbsp;
注意：本题与主站 143&amp;nbsp;题相同：https://leetcode-cn.com/problems/reorder-list/&amp;nbsp;
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reorderList(head *ListNode) { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 04.03 特定深度节点链表</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/list-of-depth-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/list-of-depth-lcci/</guid><description>面试题 04.03 特定深度节点链表 给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 D，则会创建出 D 个链表）。返回一个包含所有深度的链表的数组。
&amp;nbsp;
示例：
输入：[1,2,3,4,5,null,7,8] 1 / \ 2 3 / \ \ 4 5 7 / 8 输出：[[1],[2,3],[4,5,7],[8]] /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func listOfDepth(tree *TreeNode) []*ListNode { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer 29 顺时针打印矩阵</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shun-shi-zhen-da-yin-ju-zhen-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shun-shi-zhen-da-yin-ju-zhen-lcof/</guid><description>剑指 Offer 29 顺时针打印矩阵 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。
&amp;nbsp;
示例 1：
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,3,6,9,8,7,4,5] 示例 2：
输入：matrix =&amp;nbsp;[[1,2,3,4],[5,6,7,8],[9,10,11,12]] 输出：[1,2,3,4,8,12,11,10,9,5,6,7] &amp;nbsp;
限制：
0 &amp;lt;= matrix.length &amp;lt;= 100 0 &amp;lt;= matrix[i].length&amp;nbsp;&amp;lt;= 100 注意：本题与主站 54 题相同：https://leetcode-cn.com/problems/spiral-matrix/
func spiralOrder(matrix [][]int) []int { } LeetCode题库地址 https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof</description></item><item><title>剑指 Offer II 027 回文链表</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/amhzsa/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/amhzsa/</guid><description>剑指 Offer II 027 回文链表 给定一个链表的 头节点&amp;nbsp;head&amp;nbsp;，请判断其是否为回文链表。
如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。
&amp;nbsp;
示例 1：
输入: head = [1,2,3,3,2,1] 输出: true 示例 2：
输入: head = [1,2] 输出: false &amp;nbsp;
提示：
链表 L 的长度范围为 [1, 105] 0&amp;nbsp;&amp;lt;= node.val &amp;lt;= 9 &amp;nbsp;
进阶：能否用&amp;nbsp;O(n) 时间复杂度和 O(1) 空间复杂度解决此题？
&amp;nbsp;
注意：本题与主站 234&amp;nbsp;题相同：https://leetcode-cn.com/problems/palindrome-linked-list/
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func isPalindrome(head *ListNode) bool { } LeetCode题库地址 https://leetcode.cn/problems/aMhZSa</description></item><item><title>面试题 04.04 检查平衡性</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/check-balance-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/check-balance-lcci/</guid><description>面试题 04.04 检查平衡性 实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过 1。
示例 1:给定二叉树 [3,9,20,null,null,15,7]
3
/ &amp;#92
9 20
/ &amp;#92
15 7
返回 true 。示例 2:
给定二叉树 [1,2,2,3,3,null,null,4,4]
1
/ &amp;#92
2 2
/ &amp;#92
3 3
/ &amp;#92
4 4
返回 false 。 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isBalanced(root *TreeNode) bool { } LeetCode题库地址 https://leetcode.cn/problems/check-balance-lcci</description></item><item><title>剑指 Offer 30 包含min函数的栈</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/bao-han-minhan-shu-de-zhan-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/bao-han-minhan-shu-de-zhan-lcof/</guid><description>剑指 Offer 30 包含min函数的栈 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。
&amp;nbsp;
示例:
MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.min(); --&amp;gt; 返回 -3. minStack.pop(); minStack.top(); --&amp;gt; 返回 0. minStack.min(); --&amp;gt; 返回 -2. &amp;nbsp;
提示：
各函数的调用总次数不超过 20000 次 &amp;nbsp;
注意：本题与主站 155 题相同：https://leetcode-cn.com/problems/min-stack/
type MinStack struct { } /** initialize your data structure here. */ func Constructor() MinStack { } func (this *MinStack) Push(x int) { } func (this *MinStack) Pop() { } func (this *MinStack) Top() int { } func (this *MinStack) Min() int { } /** * Your MinStack object will be instantiated and called as such: * obj := Constructor(); * obj.</description></item><item><title>剑指 Offer II 028 展平多级双向链表</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/qv1da2/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/qv1da2/</guid><description>剑指 Offer II 028 展平多级双向链表 多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。
给定位于列表第一级的头节点，请扁平化列表，即将这样的多级双向链表展平成普通的双向链表，使所有结点出现在单级双链表中。
&amp;nbsp;
示例 1：
输入：head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12] 输出：[1,2,3,7,8,11,12,9,10,4,5,6] 解释： 输入的多级列表如下图所示： 扁平化后的链表如下图： 示例 2：
输入：head = [1,2,null,3] 输出：[1,3,2] 解释： 输入的多级列表如下图所示： 1---2---NULL | 3---NULL 示例 3：
输入：head = [] 输出：[] &amp;nbsp;
如何表示测试用例中的多级链表？
以 示例 1 为例：
1---2---3---4---5---6--NULL | 7---8---9---10--NULL | 11--12--NULL 序列化其中的每一级之后：
[1,2,3,4,5,6,null] [7,8,9,10,null] [11,12,null] 为了将每一级都序列化到一起，我们需要每一级中添加值为 null 的元素，以表示没有节点连接到上一级的上级节点。
[1,2,3,4,5,6,null] [null,null,7,8,9,10,null] [null,11,12,null] 合并所有序列化结果，并去除末尾的 null 。
[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12] &amp;nbsp;
提示：
节点数目不超过 1000 1 &amp;lt;= Node.val &amp;lt;= 10^5 &amp;nbsp;
注意：本题与主站 430&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/
/** * Definition for a Node.</description></item><item><title>面试题 04.05 合法二叉搜索树</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/legal-binary-search-tree-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/legal-binary-search-tree-lcci/</guid><description>面试题 04.05 合法二叉搜索树 实现一个函数，检查一棵二叉树是否为二叉搜索树。
示例 1:输入:
2
/ &amp;#92
1 3
输出: true
示例 2:输入:
5
/ &amp;#92
1 4
/ &amp;#92
3 6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
根节点的值为 5 ，但是其右子节点值为 4 。 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isValidBST(root *TreeNode) bool { } LeetCode题库地址 https://leetcode.cn/problems/legal-binary-search-tree-lcci</description></item><item><title>剑指 Offer 31 栈的压入、弹出序列</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zhan-de-ya-ru-dan-chu-xu-lie-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zhan-de-ya-ru-dan-chu-xu-lie-lcof/</guid><description>剑指 Offer 31 栈的压入、弹出序列 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。
&amp;nbsp;
示例 1：
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1] 输出：true 解释：我们可以按以下顺序执行： push(1), push(2), push(3), push(4), pop() -&amp;gt; 4, push(5), pop() -&amp;gt; 5, pop() -&amp;gt; 3, pop() -&amp;gt; 2, pop() -&amp;gt; 1 示例 2：
输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2] 输出：false 解释：1 不能在 2 之前弹出。 &amp;nbsp;
提示：
0 &amp;lt;= pushed.length == popped.length &amp;lt;= 1000 0 &amp;lt;= pushed[i], popped[i] &amp;lt; 1000 pushed&amp;nbsp;是&amp;nbsp;popped&amp;nbsp;的排列。 注意：本题与主站 946 题相同：https://leetcode-cn.com/problems/validate-stack-sequences/
func validateStackSequences(pushed []int, popped []int) bool { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer II 029 排序的循环链表</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/4ueaj6/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/4ueaj6/</guid><description>剑指 Offer II 029 排序的循环链表 给定循环单调非递减列表中的一个点，写一个函数向这个列表中插入一个新元素&amp;nbsp;insertVal ，使这个列表仍然是循环升序的。
给定的可以是这个列表中任意一个顶点的指针，并不一定是这个列表中最小元素的指针。
如果有多个满足条件的插入位置，可以选择任意一个位置插入新的值，插入后整个列表仍然保持有序。
如果列表为空（给定的节点是 null），需要创建一个循环有序列表并返回这个节点。否则。请返回原先给定的节点。
&amp;nbsp;
示例 1：
&amp;nbsp;
输入：head = [3,4,1], insertVal = 2 输出：[3,4,1,2] 解释：在上图中，有一个包含三个元素的循环有序列表，你获得值为 3 的节点的指针，我们需要向表中插入元素 2 。新插入的节点应该在 1 和 3 之间，插入之后，整个列表如上图所示，最后返回节点 3 。 示例 2：
输入：head = [], insertVal = 1 输出：[1] 解释：列表为空（给定的节点是 null），创建一个循环有序列表并返回这个节点。 示例 3：
输入：head = [1], insertVal = 0 输出：[1,0] &amp;nbsp;
提示：
0 &amp;lt;= Number of Nodes &amp;lt;= 5 * 10^4 -10^6 &amp;lt;= Node.val &amp;lt;= 10^6 -10^6 &amp;lt;=&amp;nbsp;insertVal &amp;lt;= 10^6 &amp;nbsp;
注意：本题与主站 708&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.</description></item><item><title>面试题 04.06 后继者</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/successor-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/successor-lcci/</guid><description>面试题 04.06 后继者 设计一个算法，找出二叉搜索树中指定节点的&amp;ldquo;下一个&amp;rdquo;节点（也即中序后继）。
如果指定节点没有对应的&amp;ldquo;下一个&amp;rdquo;节点，则返回null。
示例 1:
输入: root = [2,1,3], p = 1 2 / \ 1 3 输出: 2 示例 2:
输入: root = [5,3,6,2,4,null,null,1], p = 6 5 / \ 3 6 / \ 2 4 / 1 输出: null /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func inorderSuccessor(root *TreeNode, p *TreeNode) *TreeNode { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer 32 - I 从上到下打印二叉树</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/</guid><description>剑指 Offer 32 - I 从上到下打印二叉树 从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。
&amp;nbsp;
例如:
给定二叉树:&amp;nbsp;[3,9,20,null,null,15,7],
3 / \ 9 20 / \ 15 7 返回：
[3,9,20,15,7] &amp;nbsp;
提示：
节点总数 &amp;lt;= 1000 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func levelOrder(root *TreeNode) []int { } LeetCode题库地址 https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof</description></item><item><title>剑指 Offer II 030 插入、删除和随机访问都是 O(1) 的容器</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/fortpu/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/fortpu/</guid><description>剑指 Offer II 030 插入、删除和随机访问都是 O(1) 的容器 设计一个支持在平均&amp;nbsp;时间复杂度 O(1)&amp;nbsp;下，执行以下操作的数据结构：
insert(val)：当元素 val 不存在时返回 true&amp;nbsp;，并向集合中插入该项，否则返回 false 。 remove(val)：当元素 val 存在时返回 true&amp;nbsp;，并从集合中移除该项，否则返回 false&amp;nbsp;。 getRandom：随机返回现有集合中的一项。每个元素应该有&amp;nbsp;相同的概率&amp;nbsp;被返回。 &amp;nbsp;
示例 :
输入: inputs = [&amp;quot;RandomizedSet&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;remove&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;getRandom&amp;quot;, &amp;quot;remove&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;getRandom&amp;quot;] [[], [1], [2], [2], [], [1], [2], []] 输出: [null, true, false, true, 2, true, false, 2] 解释: RandomizedSet randomSet = new RandomizedSet(); // 初始化一个空的集合 randomSet.insert(1); // 向集合中插入 1 ， 返回 true 表示 1 被成功地插入 randomSet.remove(2); // 返回 false，表示集合中不存在 2 randomSet.</description></item><item><title>面试题 04.08 首个共同祖先</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/first-common-ancestor-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/first-common-ancestor-lcci/</guid><description>面试题 04.08 首个共同祖先 设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。
例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]
3 / \ 5 1 / \ / \ 6 2 0 8 / \ 7 4 示例 1:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明:
所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。 /** * Definition for a binary tree node.</description></item><item><title>剑指 Offer 32 - II 从上到下打印二叉树 II</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/</guid><description>剑指 Offer 32 - II 从上到下打印二叉树 II 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。
&amp;nbsp;
例如:
给定二叉树:&amp;nbsp;[3,9,20,null,null,15,7],
3 / \ 9 20 / \ 15 7 返回其层次遍历结果：
[ [3], [9,20], [15,7] ] &amp;nbsp;
提示：
节点总数 &amp;lt;= 1000 注意：本题与主站 102 题相同：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func levelOrder(root *TreeNode) [][]int { } LeetCode题库地址 https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof</description></item><item><title>剑指 Offer II 031 最近最少使用缓存</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/orixps/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/orixps/</guid><description>剑指 Offer II 031 最近最少使用缓存 运用所掌握的数据结构，设计和实现一个&amp;nbsp; LRU (Least Recently Used，最近最少使用) 缓存机制 。
实现 LRUCache 类：
LRUCache(int capacity) 以正整数作为容量&amp;nbsp;capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。 void put(int key, int value)&amp;nbsp;如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。 &amp;nbsp;
示例：
输入 [&amp;quot;LRUCache&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;get&amp;quot;] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]] 输出 [null, null, null, 1, null, -1, null, -1, 3, 4] 解释 LRUCache lRUCache = new LRUCache(2); lRUCache.</description></item><item><title>面试题 04.09 二叉搜索树序列</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/bst-sequences-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/bst-sequences-lcci/</guid><description>面试题 04.09 二叉搜索树序列 从左向右遍历一个数组，通过不断将其中的元素插入树中可以逐步地生成一棵二叉搜索树。
给定一个由不同节点组成的二叉搜索树 root，输出所有可能生成此树的数组。
&amp;nbsp;
示例 1:
输入: root = [2,1,3] 输出: [[2,1,3],[2,3,1]] 解释: 数组 [2,1,3]、[2,3,1] 均可以通过从左向右遍历元素插入树中形成以下二叉搜索树 &amp;nbsp; 2 &amp;nbsp; / \ &amp;nbsp; 1 3 示例&amp;nbsp;2:
输入: root = [4,1,null,null,3,2] 输出: [[4,1,3,2]] &amp;nbsp;
提示：
二叉搜索树中的节点数在&amp;nbsp;[0, 1000]&amp;nbsp;的范围内 1 &amp;lt;= 节点值&amp;nbsp;&amp;lt;= 10^6 用例保证符合要求的数组数量不超过 5000
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func BSTSequences(root *TreeNode) [][]int { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer 32 - III 从上到下打印二叉树 III</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/</guid><description>剑指 Offer 32 - III 从上到下打印二叉树 III 请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。
&amp;nbsp;
例如:
给定二叉树:&amp;nbsp;[3,9,20,null,null,15,7],
3 / \ 9 20 / \ 15 7 返回其层次遍历结果：
[ [3], [20,9], [15,7] ] &amp;nbsp;
提示：
节点总数 &amp;lt;= 1000 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func levelOrder(root *TreeNode) [][]int { } LeetCode题库地址 https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof</description></item><item><title>剑指 Offer II 032 有效的变位词</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/dkk3p7/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/dkk3p7/</guid><description>剑指 Offer II 032 有效的变位词 给定两个字符串 s 和 t ，编写一个函数来判断它们是不是一组变位词（字母异位词）。
注意：若&amp;nbsp;s 和 t&amp;nbsp;中每个字符出现的次数都相同且字符顺序不完全相同，则称&amp;nbsp;s 和 t&amp;nbsp;互为变位词（字母异位词）。
&amp;nbsp;
示例&amp;nbsp;1:
输入: s = &amp;quot;anagram&amp;quot;, t = &amp;quot;nagaram&amp;quot; 输出: true 示例 2:
输入: s = &amp;quot;rat&amp;quot;, t = &amp;quot;car&amp;quot; 输出: false 示例 3:
输入: s = &amp;quot;a&amp;quot;, t = &amp;quot;a&amp;quot; 输出: false &amp;nbsp;
提示:
1 &amp;lt;= s.length, t.length &amp;lt;= 5 * 104 s&amp;nbsp;and&amp;nbsp;t&amp;nbsp;仅包含小写字母 &amp;nbsp;
进阶:&amp;nbsp;如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？
&amp;nbsp;
注意：本题与主站 242&amp;nbsp;题相似（字母异位词定义不同）：https://leetcode-cn.com/problems/valid-anagram/
func isAnagram(s string, t string) bool { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 04.10 检查子树</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/check-subtree-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/check-subtree-lcci/</guid><description>面试题 04.10 检查子树 检查子树。你有两棵非常大的二叉树：T1，有几万个节点；T2，有几万个节点。设计一个算法，判断 T2 是否为 T1 的子树。
如果 T1 有这么一个节点 n，其子树与 T2 一模一样，则 T2 为 T1 的子树，也就是说，从节点 n 处把树砍断，得到的树与 T2 完全相同。
注意：此题相对书上原题略有改动。
示例1:
输入：t1 = [1, 2, 3], t2 = [2] 输出：true 示例2:
输入：t1 = [1, null, 2, 4], t2 = [3, 2] 输出：false 提示：
树的节点数目范围为[0, 20000]。 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func checkSubTree(t1 *TreeNode, t2 *TreeNode) bool { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer 33 二叉搜索树的后序遍历序列</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/</guid><description>剑指 Offer 33 二叉搜索树的后序遍历序列 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回&amp;nbsp;true，否则返回&amp;nbsp;false。假设输入的数组的任意两个数字都互不相同。
&amp;nbsp;
参考以下这颗二叉搜索树：
5 / \ 2 6 / \ 1 3 示例 1：
输入: [1,6,3,2,5] 输出: false 示例 2：
输入: [1,3,2,6,5] 输出: true &amp;nbsp;
提示：
数组长度 &amp;lt;= 1000 func verifyPostorder(postorder []int) bool { } LeetCode题库地址 https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof</description></item><item><title>剑指 Offer II 033 变位词组</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/sfvd7v/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/sfvd7v/</guid><description>剑指 Offer II 033 变位词组 给定一个字符串数组 strs ，将&amp;nbsp;变位词&amp;nbsp;组合在一起。 可以按任意顺序返回结果列表。
注意：若两个字符串中每个字符出现的次数都相同，则称它们互为变位词。
&amp;nbsp;
示例 1:
输入: strs = [&amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;tan&amp;quot;, &amp;quot;ate&amp;quot;, &amp;quot;nat&amp;quot;, &amp;quot;bat&amp;quot;] 输出: [[&amp;quot;bat&amp;quot;],[&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;],[&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;]] 示例 2:
输入: strs = [&amp;quot;&amp;quot;] 输出: [[&amp;quot;&amp;quot;]] 示例 3:
输入: strs = [&amp;quot;a&amp;quot;] 输出: [[&amp;quot;a&amp;quot;]] &amp;nbsp;
提示：
1 &amp;lt;= strs.length &amp;lt;= 104 0 &amp;lt;= strs[i].length &amp;lt;= 100 strs[i]&amp;nbsp;仅包含小写字母 &amp;nbsp;
注意：本题与主站 49&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/group-anagrams/
func groupAnagrams(strs []string) [][]string { } LeetCode题库地址 https://leetcode.cn/problems/sfvd7V</description></item><item><title>面试题 04.12 求和路径</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/paths-with-sum-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/paths-with-sum-lcci/</guid><description>面试题 04.12 求和路径 给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。
示例:
给定如下二叉树，以及目标和&amp;nbsp;sum = 22，
5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1 返回:
3 解释：和为 22&amp;nbsp;的路径有：[5,4,11,2], [5,8,4,5], [4,11,7] 提示：
节点总数 &amp;lt;= 10000 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func pathSum(root *TreeNode, sum int) int { } LeetCode题库地址 https://leetcode.cn/problems/paths-with-sum-lcci</description></item><item><title>剑指 Offer 34 二叉树中和为某一值的路径</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/</guid><description>剑指 Offer 34 二叉树中和为某一值的路径 给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。
叶子节点 是指没有子节点的节点。
&amp;nbsp;
示例 1：
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 输出：[[5,4,11,2],[5,8,4,5]] 示例 2：
输入：root = [1,2,3], targetSum = 5 输出：[] 示例 3：
输入：root = [1,2], targetSum = 0 输出：[] &amp;nbsp;
提示：
树中节点总数在范围 [0, 5000] 内 -1000 &amp;lt;= Node.val &amp;lt;= 1000 -1000 &amp;lt;= targetSum &amp;lt;= 1000 注意：本题与主站 113&amp;nbsp;题相同：https://leetcode-cn.com/problems/path-sum-ii/
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func pathSum(root *TreeNode, target int) [][]int { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer II 034 外星语言是否排序</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/lwyvbb/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/lwyvbb/</guid><description>剑指 Offer II 034 外星语言是否排序 某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。
给定一组用外星语书写的单词 words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，返回 true；否则，返回 false。
&amp;nbsp;
示例 1：
输入：words = [&amp;quot;hello&amp;quot;,&amp;quot;leetcode&amp;quot;], order = &amp;quot;hlabcdefgijkmnopqrstuvwxyz&amp;quot; 输出：true 解释：在该语言的字母表中，&amp;#39;h&amp;#39; 位于 &amp;#39;l&amp;#39; 之前，所以单词序列是按字典序排列的。 示例 2：
输入：words = [&amp;quot;word&amp;quot;,&amp;quot;world&amp;quot;,&amp;quot;row&amp;quot;], order = &amp;quot;worldabcefghijkmnpqstuvxyz&amp;quot; 输出：false 解释：在该语言的字母表中，&amp;#39;d&amp;#39; 位于 &amp;#39;l&amp;#39; 之后，那么 words[0] &amp;gt; words[1]，因此单词序列不是按字典序排列的。 示例 3：
输入：words = [&amp;quot;apple&amp;quot;,&amp;quot;app&amp;quot;], order = &amp;quot;abcdefghijklmnopqrstuvwxyz&amp;quot; 输出：false 解释：当前三个字符 &amp;quot;app&amp;quot; 匹配时，第二个字符串相对短一些，然后根据词典编纂规则 &amp;quot;apple&amp;quot; &amp;gt; &amp;quot;app&amp;quot;，因为 &amp;#39;l&amp;#39; &amp;gt; &amp;#39;&amp;empty;&amp;#39;，其中 &amp;#39;&amp;empty;&amp;#39; 是空白字符，定义为比任何其他字符都小（更多信息）。 &amp;nbsp;
提示：
1 &amp;lt;= words.length &amp;lt;= 100 1 &amp;lt;= words[i].length &amp;lt;= 20 order.</description></item><item><title>面试题 05.01 插入</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/insert-into-bits-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/insert-into-bits-lcci/</guid><description>面试题 05.01 插入 给定两个整型数字 N 与 M，以及表示比特位置的 i 与 j（i &lt;= j，且从 0 位开始计算）。
编写一种方法，使 M 对应的二进制数字插入 N 对应的二进制数字的第 i ~ j 位区域，不足之处用 0 补齐。具体插入过程如图所示。
题目保证从 i 位到 j 位足以容纳 M， 例如： M = 10011，则 i～j 区域至少可容纳 5 位。
示例1:
输入：N = 1024(10000000000), M = 19(10011), i = 2, j = 6 输出：N = 1100(10001001100) 示例2:
输入： N = 0, M = 31(11111), i = 0, j = 4 输出：N = 31(11111) func insertBits(N int, M int, i int, j int) int { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer 35 复杂链表的复制</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/fu-za-lian-biao-de-fu-zhi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/fu-za-lian-biao-de-fu-zhi-lcof/</guid><description>剑指 Offer 35 复杂链表的复制 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。
&amp;nbsp;
示例 1：
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]] 输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 示例 2：
输入：head = [[1,1],[2,1]] 输出：[[1,1],[2,1]] 示例 3：
输入：head = [[3,null],[3,0],[3,null]] 输出：[[3,null],[3,0],[3,null]] 示例 4：
输入：head = [] 输出：[] 解释：给定的链表为空（空指针），因此返回 null。 &amp;nbsp;
提示：
-10000 &amp;lt;= Node.val &amp;lt;= 10000 Node.random&amp;nbsp;为空（null）或指向链表中的节点。 节点数目不超过 1000 。 &amp;nbsp;
注意：本题与主站 138 题相同：https://leetcode-cn.com/problems/copy-list-with-random-pointer/
&amp;nbsp;
/** * Definition for a Node. * type Node struct { * Val int * Next *Node * Random *Node * } */ func copyRandomList(head *Node) *Node { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer II 035 最小时间差</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/569nqc/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/569nqc/</guid><description>剑指 Offer II 035 最小时间差 给定一个 24 小时制（小时:分钟 &amp;quot;HH:MM&amp;quot;）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。
&amp;nbsp;
示例 1：
输入：timePoints = [&amp;quot;23:59&amp;quot;,&amp;quot;00:00&amp;quot;] 输出：1 示例 2：
输入：timePoints = [&amp;quot;00:00&amp;quot;,&amp;quot;23:59&amp;quot;,&amp;quot;00:00&amp;quot;] 输出：0 &amp;nbsp;
提示：
2 &amp;lt;= timePoints &amp;lt;= 2 * 104 timePoints[i] 格式为 &amp;quot;HH:MM&amp;quot; &amp;nbsp;
注意：本题与主站 539&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/minimum-time-difference/
func findMinDifference(timePoints []string) int { } LeetCode题库地址 https://leetcode.cn/problems/569nqc</description></item><item><title>面试题 05.02 二进制数转字符串</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/bianry-number-to-string-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/bianry-number-to-string-lcci/</guid><description>面试题 05.02 二进制数转字符串 二进制数转字符串。给定一个介于0和1之间的实数（如0.72），类型为double，打印它的二进制表达式。如果该数字无法精确地用32位以内的二进制表示，则打印“ERROR”。
示例1:
输入：0.625 输出："0.101" 示例2:
输入：0.1 输出："ERROR" 提示：0.1无法被二进制准确表示 &amp;nbsp;
提示：
32位包括输出中的 "0." 这两位。 题目保证输入用例的小数位数最多只有 6 位 func printBin(num float64) string { } LeetCode题库地址 https://leetcode.cn/problems/bianry-number-to-string-lcci</description></item><item><title>剑指 Offer 36 二叉搜索树与双向链表</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/</guid><description>剑指 Offer 36 二叉搜索树与双向链表 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。
&amp;nbsp;
为了让您更好地理解问题，以下面的二叉搜索树为例：
&amp;nbsp;
&amp;nbsp;
我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。
下图展示了上面的二叉搜索树转化成的链表。&amp;ldquo;head&amp;rdquo; 表示指向链表中有最小元素的节点。
&amp;nbsp;
&amp;nbsp;
特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。
&amp;nbsp;
注意：本题与主站 426 题相同：https://leetcode-cn.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/
注意：此题对比原题有改动。
LeetCode题库地址 https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof</description></item><item><title>剑指 Offer II 036 后缀表达式</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/8zf90g/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/8zf90g/</guid><description>剑指 Offer II 036 后缀表达式 根据 逆波兰表示法，求该后缀表达式的计算结果。
有效的算符包括&amp;nbsp;+、-、*、/&amp;nbsp;。每个运算对象可以是整数，也可以是另一个逆波兰表达式。
&amp;nbsp;
说明：
整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 &amp;nbsp;
示例&amp;nbsp;1：
输入：tokens = [&amp;quot;2&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;+&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;*&amp;quot;] 输出：9 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 示例&amp;nbsp;2：
输入：tokens = [&amp;quot;4&amp;quot;,&amp;quot;13&amp;quot;,&amp;quot;5&amp;quot;,&amp;quot;/&amp;quot;,&amp;quot;+&amp;quot;] 输出：6 解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6 示例&amp;nbsp;3：
输入：tokens = [&amp;quot;10&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;+&amp;quot;,&amp;quot;-11&amp;quot;,&amp;quot;*&amp;quot;,&amp;quot;/&amp;quot;,&amp;quot;*&amp;quot;,&amp;quot;17&amp;quot;,&amp;quot;+&amp;quot;,&amp;quot;5&amp;quot;,&amp;quot;+&amp;quot;] 输出：22 解释： 该算式转化为常见的中缀算术表达式为： ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 &amp;nbsp;</description></item><item><title>面试题 05.03 翻转数位</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/reverse-bits-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/reverse-bits-lcci/</guid><description>面试题 05.03 翻转数位 给定一个32位整数 num，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。
示例 1：
输入: num = 1775(110111011112) 输出: 8 示例 2：
输入: num = 7(01112) 输出: 4 func reverseBits(num int) int { } LeetCode题库地址 https://leetcode.cn/problems/reverse-bits-lcci</description></item><item><title>剑指 Offer 37 序列化二叉树</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/xu-lie-hua-er-cha-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/xu-lie-hua-er-cha-shu-lcof/</guid><description>剑指 Offer 37 序列化二叉树 请实现两个函数，分别用来序列化和反序列化二叉树。
你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。
提示：输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅&amp;nbsp;LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。
&amp;nbsp;
示例：
输入：root = [1,2,3,null,null,4,5] 输出：[1,2,3,null,null,4,5] &amp;nbsp;
注意：本题与主站 297 题相同：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/
LeetCode题库地址 https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof</description></item><item><title>剑指 Offer II 037 小行星碰撞</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/xagzni/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/xagzni/</guid><description>剑指 Offer II 037 小行星碰撞 给定一个整数数组 asteroids，表示在同一行的小行星。
对于数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。
找出碰撞后剩下的所有小行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。
&amp;nbsp;
示例 1：
输入：asteroids = [5,10,-5] 输出：[5,10] 解释：10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。 示例 2：
输入：asteroids = [8,-8] 输出：[] 解释：8 和 -8 碰撞后，两者都发生爆炸。 示例 3：
输入：asteroids = [10,2,-5] 输出：[10] 解释：2 和 -5 发生碰撞后剩下 -5 。10 和 -5 发生碰撞后剩下 10 。 示例 4：
输入：asteroids = [-2,-1,1,2] 输出：[-2,-1,1,2] 解释：-2 和 -1 向左移动，而 1 和 2 向右移动。 由于移动方向相同的行星不会发生碰撞，所以最终没有行星发生碰撞。 &amp;nbsp;
提示：
2 &amp;lt;= asteroids.length&amp;nbsp;&amp;lt;= 104 -1000 &amp;lt;= asteroids[i] &amp;lt;= 1000 asteroids[i] !</description></item><item><title>面试题 05.04 下一个数</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/closed-number-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/closed-number-lcci/</guid><description>面试题 05.04 下一个数 下一个数。给定一个正整数，找出与其二进制表达式中1的个数相同且大小最接近的那两个数（一个略大，一个略小）。
示例1:
输入：num = 2（或者0b10） 输出：[4, 1] 或者（[0b100, 0b1]） 示例2:
输入：num = 1 输出：[2, -1] 提示:
num的范围在[1, 2147483647]之间； 如果找不到前一个或者后一个满足条件的正数，那么输出 -1。 func findClosedNumbers(num int) []int { } LeetCode题库地址 https://leetcode.cn/problems/closed-number-lcci</description></item><item><title>剑指 Offer 38 字符串的排列</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zi-fu-chuan-de-pai-lie-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zi-fu-chuan-de-pai-lie-lcof/</guid><description>剑指 Offer 38 字符串的排列 输入一个字符串，打印出该字符串中字符的所有排列。
&amp;nbsp;
你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。
&amp;nbsp;
示例:
输入：s = &amp;quot;abc&amp;quot; 输出：[&amp;quot;abc&amp;quot;,&amp;quot;acb&amp;quot;,&amp;quot;bac&amp;quot;,&amp;quot;bca&amp;quot;,&amp;quot;cab&amp;quot;,&amp;quot;cba&amp;quot;] &amp;nbsp;
限制：
1 &amp;lt;= s 的长度 &amp;lt;= 8
func permutation(s string) []string { } LeetCode题库地址 https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof</description></item><item><title>剑指 Offer II 038 每日温度</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/iiqa4i/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/iiqa4i/</guid><description>剑指 Offer II 038 每日温度 请根据每日 气温 列表 temperatures&amp;nbsp;，重新生成一个列表，要求其对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用&amp;nbsp;0 来代替。
&amp;nbsp;
示例 1:
输入: temperatures = [73,74,75,71,69,72,76,73] 输出:&amp;nbsp;[1,1,4,2,1,1,0,0] 示例 2:
输入: temperatures = [30,40,50,60] 输出:&amp;nbsp;[1,1,1,0] 示例 3:
输入: temperatures = [30,60,90] 输出: [1,1,0] &amp;nbsp;
提示：
1 &amp;lt;=&amp;nbsp;temperatures.length &amp;lt;= 105 30 &amp;lt;=&amp;nbsp;temperatures[i]&amp;nbsp;&amp;lt;= 100 &amp;nbsp;
注意：本题与主站 739&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/daily-temperatures/
func dailyTemperatures(temperatures []int) []int { } LeetCode题库地址 https://leetcode.cn/problems/iIQa4I</description></item><item><title>面试题 05.06 整数转换</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/convert-integer-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/convert-integer-lcci/</guid><description>面试题 05.06 整数转换 整数转换。编写一个函数，确定需要改变几个位才能将整数A转成整数B。
示例1:
输入：A = 29 （或者0b11101）, B = 15（或者0b01111） 输出：2 示例2:
输入：A = 1，B = 2 输出：2 提示:
A，B范围在[-2147483648, 2147483647]之间 func convertInteger(A int, B int) int { } LeetCode题库地址 https://leetcode.cn/problems/convert-integer-lcci</description></item><item><title>剑指 Offer 39 数组中出现次数超过一半的数字</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/</guid><description>剑指 Offer 39 数组中出现次数超过一半的数字 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。
&amp;nbsp;
你可以假设数组是非空的，并且给定的数组总是存在多数元素。
&amp;nbsp;
示例&amp;nbsp;1:
输入: [1, 2, 3, 2, 2, 2, 5, 4, 2] 输出: 2 &amp;nbsp;
限制：
1 &amp;lt;= 数组长度 &amp;lt;= 50000
&amp;nbsp;
注意：本题与主站 169 题相同：https://leetcode-cn.com/problems/majority-element/
&amp;nbsp;
func majorityElement(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof</description></item><item><title>剑指 Offer II 039 直方图最大矩形面积</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/0ynmmm/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/0ynmmm/</guid><description>剑指 Offer II 039 直方图最大矩形面积 给定非负整数数组 heights&amp;nbsp;，数组中的数字用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
求在该柱状图中，能够勾勒出来的矩形的最大面积。
&amp;nbsp;
示例 1:
输入：heights = [2,1,5,6,2,3] 输出：10 解释：最大的矩形为图中红色区域，面积为 10 示例 2：
输入： heights = [2,4] 输出： 4 &amp;nbsp;
提示：
1 &amp;lt;= heights.length &amp;lt;=105 0 &amp;lt;= heights[i] &amp;lt;= 104 &amp;nbsp;
注意：本题与主站 84&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/largest-rectangle-in-histogram/
func largestRectangleArea(heights []int) int { } LeetCode题库地址 https://leetcode.cn/problems/0ynMMM</description></item><item><title>面试题 05.07 配对交换</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/exchange-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/exchange-lcci/</guid><description>面试题 05.07 配对交换 配对交换。编写程序，交换某个整数的奇数位和偶数位，尽量使用较少的指令（也就是说，位0与位1交换，位2与位3交换，以此类推）。
示例1:
输入：num = 2（或者0b10） 输出 1 (或者 0b01) 示例2:
输入：num = 3 输出：3 提示:
num的范围在[0, 2^30 - 1]之间，不会发生整数溢出。 func exchangeBits(num int) int { } LeetCode题库地址 https://leetcode.cn/problems/exchange-lcci</description></item><item><title>剑指 Offer 40 最小的k个数</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zui-xiao-de-kge-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zui-xiao-de-kge-shu-lcof/</guid><description>剑指 Offer 40 最小的k个数 输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。
&amp;nbsp;
示例 1：
输入：arr = [3,2,1], k = 2 输出：[1,2] 或者 [2,1] 示例 2：
输入：arr = [0,1,2,1], k = 1 输出：[0] &amp;nbsp;
限制：
0 &amp;lt;= k &amp;lt;= arr.length &amp;lt;= 10000 0 &amp;lt;= arr[i]&amp;nbsp;&amp;lt;= 10000 func getLeastNumbers(arr []int, k int) []int { } LeetCode题库地址 https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof</description></item><item><title>剑指 Offer II 040 矩阵中最大的矩形</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/plyxkq/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/plyxkq/</guid><description>剑指 Offer II 040 矩阵中最大的矩形 给定一个由&amp;nbsp;0 和 1&amp;nbsp;组成的矩阵 matrix&amp;nbsp;，找出只包含 1 的最大矩形，并返回其面积。
注意：此题 matrix&amp;nbsp;输入格式为一维 01 字符串数组。
&amp;nbsp;
示例 1：
输入：matrix = ["10100","10111","11111","10010"] 输出：6 解释：最大矩形如上图所示。 示例 2：
输入：matrix = [] 输出：0 示例 3：
输入：matrix = ["0"] 输出：0 示例 4：
输入：matrix = ["1"] 输出：1 示例 5：
输入：matrix = ["00"] 输出：0 &amp;nbsp;
提示：
rows == matrix.length cols == matrix[0].length 0 &amp;lt;= row, cols &amp;lt;= 200 matrix[i][j] 为 '0' 或 '1' &amp;nbsp;
注意：本题与主站 85 题相同（输入参数格式不同）：&amp;nbsp;https://leetcode-cn.com/problems/maximal-rectangle/
func maximalRectangle(matrix []string) int { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 05.08 绘制直线</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/draw-line-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/draw-line-lcci/</guid><description>面试题 05.08 绘制直线 已知一个由像素点组成的单色屏幕，每行均有 w 个像素点，所有像素点初始为 0，左上角位置为 (0,0)。
现将每行的像素点按照「每 32 个像素点」为一组存放在一个 int 中，再依次存入长度为 length 的一维数组中。
我们将在屏幕上绘制一条从点 (x1,y) 到点 (x2,y) 的直线（即像素点修改为 1），请返回绘制过后的数组。
&amp;nbsp;
注意：
用例保证屏幕宽度 w 可被 32 整除（即一个 int 不会分布在两行上） &amp;nbsp;
示例1:
输入：length = 1, w = 32, x1 = 30, x2 = 31, y = 0 输出：[3] 解释：在第 0 行的第 30 位到第 31 位画一条直线，屏幕二进制形式表示为 [00000000000000000000000000000011]，因此返回 [3] 示例2:
输入：length = 3, w = 96, x1 = 0, x2 = 95, y = 0 输出：[-1, -1, -1] 解释：由于二进制 11111111111111111111111111111111 的 int 类型代表 -1，因此返回 [-1,-1,-1] &amp;nbsp;</description></item><item><title>剑指 Offer 41 数据流中的中位数</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/</guid><description>剑指 Offer 41 数据流中的中位数 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。
例如，
[2,3,4]&amp;nbsp;的中位数是 3
[2,3] 的中位数是 (2 + 3) / 2 = 2.5
设计一个支持以下两种操作的数据结构：
void addNum(int num) - 从数据流中添加一个整数到数据结构中。 double findMedian() - 返回目前所有元素的中位数。 示例 1：
输入： [&amp;quot;MedianFinder&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;] [[],[1],[2],[],[3],[]] 输出：[null,null,null,1.50000,null,2.00000] 示例 2：
输入： [&amp;quot;MedianFinder&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;] [[],[2],[],[3],[]] 输出：[null,null,2.00000,null,2.50000] &amp;nbsp;
限制：
最多会对&amp;nbsp;addNum、findMedian 进行&amp;nbsp;50000&amp;nbsp;次调用。 注意：本题与主站 295 题相同：https://leetcode-cn.com/problems/find-median-from-data-stream/
type MedianFinder struct { } /** initialize your data structure here. */ func Constructor() MedianFinder { } func (this *MedianFinder) AddNum(num int) { } func (this *MedianFinder) FindMedian() float64 { } /** * Your MedianFinder object will be instantiated and called as such: * obj := Constructor(); * obj.</description></item><item><title>剑指 Offer II 041 滑动窗口的平均值</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/qisx9u/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/qisx9u/</guid><description>剑指 Offer II 041 滑动窗口的平均值 给定一个整数数据流和一个窗口大小，根据该滑动窗口的大小，计算滑动窗口里所有数字的平均值。
实现 MovingAverage 类：
MovingAverage(int size) 用窗口大小 size 初始化对象。 double next(int val)&amp;nbsp;成员函数 next&amp;nbsp;每次调用的时候都会往滑动窗口增加一个整数，请计算并返回数据流中最后 size 个值的移动平均值，即滑动窗口里所有数字的平均值。 &amp;nbsp;
示例：
输入： inputs = [&amp;quot;MovingAverage&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;next&amp;quot;] inputs = [[3], [1], [10], [3], [5]] 输出： [null, 1.0, 5.5, 4.66667, 6.0] 解释： MovingAverage movingAverage = new MovingAverage(3); movingAverage.next(1); // 返回 1.0 = 1 / 1 movingAverage.next(10); // 返回 5.5 = (1 + 10) / 2 movingAverage.next(3); // 返回 4.66667 = (1 + 10 + 3) / 3 movingAverage.</description></item><item><title>面试题 08.01 三步问题</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/three-steps-problem-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/three-steps-problem-lcci/</guid><description>面试题 08.01 三步问题 三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。
示例1:
输入：n = 3 输出：4 说明: 有四种走法 示例2:
输入：n = 5 输出：13 提示:
n范围在[1, 1000000]之间 func waysToStep(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/three-steps-problem-lcci</description></item><item><title>剑指 Offer 42 连续子数组的最大和</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/lian-xu-zi-shu-zu-de-zui-da-he-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/lian-xu-zi-shu-zu-de-zui-da-he-lcof/</guid><description>剑指 Offer 42 连续子数组的最大和 输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。
要求时间复杂度为O(n)。
&amp;nbsp;
示例1:
输入: nums = [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释:&amp;nbsp;连续子数组&amp;nbsp;[4,-1,2,1] 的和最大，为&amp;nbsp;6。 &amp;nbsp;
提示：
1 &amp;lt;=&amp;nbsp;arr.length &amp;lt;= 10^5 -100 &amp;lt;= arr[i] &amp;lt;= 100 注意：本题与主站 53 题相同：https://leetcode-cn.com/problems/maximum-subarray/
&amp;nbsp;
func maxSubArray(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof</description></item><item><title>剑指 Offer II 042 最近请求次数</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/h8086q/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/h8086q/</guid><description>剑指 Offer II 042 最近请求次数 写一个&amp;nbsp;RecentCounter&amp;nbsp;类来计算特定时间范围内最近的请求。
请实现 RecentCounter 类：
RecentCounter() 初始化计数器，请求数为 0 。 int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。 保证 每次对 ping 的调用都使用比之前更大的 t 值。
&amp;nbsp;
示例：
输入： inputs = [&amp;quot;RecentCounter&amp;quot;, &amp;quot;ping&amp;quot;, &amp;quot;ping&amp;quot;, &amp;quot;ping&amp;quot;, &amp;quot;ping&amp;quot;] inputs = [[], [1], [100], [3001], [3002]] 输出： [null, 1, 2, 3, 3] 解释： RecentCounter recentCounter = new RecentCounter(); recentCounter.ping(1); // requests = [1]，范围是 [-2999,1]，返回 1 recentCounter.ping(100); // requests = [1, 100]，范围是 [-2900,100]，返回 2 recentCounter.</description></item><item><title>面试题 08.02 迷路的机器人</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/robot-in-a-grid-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/robot-in-a-grid-lcci/</guid><description>面试题 08.02 迷路的机器人 设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。设计一种算法，寻找机器人从左上角移动到右下角的路径。
网格中的障碍物和空位置分别用 1 和 0 来表示。
返回一条可行的路径，路径由经过的网格的行号和列号组成。左上角为 0 行 0 列。如果没有可行的路径，返回空数组。
示例&amp;nbsp;1:
输入: [ &amp;nbsp; [0,0,0], &amp;nbsp; [0,1,0], &amp;nbsp; [0,0,0] ] 输出: [[0,0],[0,1],[0,2],[1,2],[2,2]] 解释: 输入中标粗的位置即为输出表示的路径，即 0行0列（左上角） -&amp;gt; 0行1列 -&amp;gt; 0行2列 -&amp;gt; 1行2列 -&amp;gt; 2行2列（右下角） 说明：r&amp;nbsp;和 c 的值均不超过 100。
func pathWithObstacles(obstacleGrid [][]int) [][]int { } LeetCode题库地址 https://leetcode.cn/problems/robot-in-a-grid-lcci</description></item><item><title>剑指 Offer 43 1～n 整数中 1 出现的次数</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/</guid><description>剑指 Offer 43 1～n 整数中 1 出现的次数 输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。
例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。
示例 1：
输入：n = 12 输出：5 示例 2：
输入：n = 13 输出：6 限制：
1 &lt;= n &lt; 2^31 注意：本题与主站 233 题相同：https://leetcode-cn.com/problems/number-of-digit-one/
func countDigitOne(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof</description></item><item><title>剑指 Offer II 043 往完全二叉树添加节点</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/naqhdt/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/naqhdt/</guid><description>剑指 Offer II 043 往完全二叉树添加节点 完全二叉树是每一层（除最后一层外）都是完全填充（即，节点数达到最大，第 n 层有 2n-1&amp;nbsp;个节点）的，并且所有的节点都尽可能地集中在左侧。
设计一个用完全二叉树初始化的数据结构&amp;nbsp;CBTInserter，它支持以下几种操作：
CBTInserter(TreeNode root)&amp;nbsp;使用根节点为&amp;nbsp;root&amp;nbsp;的给定树初始化该数据结构； CBTInserter.insert(int v)&amp;nbsp; 向树中插入一个新节点，节点类型为 TreeNode，值为 v 。使树保持完全二叉树的状态，并返回插入的新节点的父节点的值； CBTInserter.get_root() 将返回树的根节点。 &amp;nbsp;
示例 1：
输入：inputs = [&amp;quot;CBTInserter&amp;quot;,&amp;quot;insert&amp;quot;,&amp;quot;get_root&amp;quot;], inputs = [[[1]],[2],[]] 输出：[null,1,[1,2]] 示例 2：
输入：inputs = [&amp;quot;CBTInserter&amp;quot;,&amp;quot;insert&amp;quot;,&amp;quot;insert&amp;quot;,&amp;quot;get_root&amp;quot;], inputs = [[[1,2,3,4,5,6]],[7],[8],[]] 输出：[null,3,4,[1,2,3,4,5,6,7,8]] &amp;nbsp;
提示：
最初给定的树是完全二叉树，且包含&amp;nbsp;1&amp;nbsp;到&amp;nbsp;1000&amp;nbsp;个节点。 每个测试用例最多调用&amp;nbsp;CBTInserter.insert&amp;nbsp; 操作&amp;nbsp;10000&amp;nbsp;次。 给定节点或插入节点的每个值都在&amp;nbsp;0&amp;nbsp;到&amp;nbsp;5000&amp;nbsp;之间。 &amp;nbsp;
注意：本题与主站 919&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/complete-binary-tree-inserter/
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ type CBTInserter struct { } func Constructor(root *TreeNode) CBTInserter { } func (this *CBTInserter) Insert(v int) int { } func (this *CBTInserter) Get_root() *TreeNode { } /** * Your CBTInserter object will be instantiated and called as such: * obj := Constructor(root); * param_1 := obj.</description></item><item><title>面试题 08.03 魔术索引</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/magic-index-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/magic-index-lcci/</guid><description>面试题 08.03 魔术索引 魔术索引。 在数组A[0...n-1]中，有所谓的魔术索引，满足条件A[i] = i。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。
示例1:
输入：nums = [0, 2, 3, 4, 5] 输出：0 说明: 0下标的元素为0 示例2:
输入：nums = [1, 1, 1] 输出：1 说明:
nums长度在[1, 1000000]之间 此题为原书中的 Follow-up，即数组中可能包含重复元素的版本 func findMagicIndex(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/magic-index-lcci</description></item><item><title>剑指 Offer 44 数字序列中某一位的数字</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/</guid><description>剑指 Offer 44 数字序列中某一位的数字 数字以0123456789101112131415&amp;hellip;的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。
请写一个函数，求任意第n位对应的数字。
&amp;nbsp;
示例 1：
输入：n = 3 输出：3 示例 2：
输入：n = 11 输出：0 &amp;nbsp;
限制：
0 &amp;lt;= n &amp;lt;&amp;nbsp;2^31 注意：本题与主站 400 题相同：https://leetcode-cn.com/problems/nth-digit/
func findNthDigit(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof</description></item><item><title>剑指 Offer II 044 二叉树每层的最大值</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/hpov7l/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/hpov7l/</guid><description>剑指 Offer II 044 二叉树每层的最大值 给定一棵二叉树的根节点&amp;nbsp;root ，请找出该二叉树中每一层的最大值。
&amp;nbsp;
示例1：
输入: root = [1,3,2,5,3,null,9] 输出: [1,3,9] 解释: 1 / \ 3 2 / \ \ 5 3 9 示例2：
输入: root = [1,2,3] 输出: [1,3] 解释: 1 / \ 2 3 示例3：
输入: root = [1] 输出: [1] 示例4：
输入: root = [1,null,2] 输出: [1,2] 解释: &amp;nbsp; 1 &amp;nbsp; \ &amp;nbsp; 2 示例5：
输入: root = [] 输出: [] &amp;nbsp;
提示：
二叉树的节点个数的范围是 [0,104] -231&amp;nbsp;&amp;lt;= Node.val &amp;lt;= 231&amp;nbsp;- 1 &amp;nbsp;</description></item><item><title>面试题 08.04 幂集</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/power-set-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/power-set-lcci/</guid><description>面试题 08.04 幂集 幂集。编写一种方法，返回某集合的所有子集。集合中不包含重复的元素。
说明：解集不能包含重复的子集。
示例:
输入： nums = [1,2,3] 输出： [ [3], &amp;nbsp; [1], &amp;nbsp; [2], &amp;nbsp; [1,2,3], &amp;nbsp; [1,3], &amp;nbsp; [2,3], &amp;nbsp; [1,2], &amp;nbsp; [] ] func subsets(nums []int) [][]int { } LeetCode题库地址 https://leetcode.cn/problems/power-set-lcci</description></item><item><title>剑指 Offer 45 把数组排成最小的数</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/</guid><description>剑指 Offer 45 把数组排成最小的数 输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。
&amp;nbsp;
示例 1:
输入: [10,2] 输出: &amp;quot;102&amp;quot; 示例&amp;nbsp;2:
输入: [3,30,34,5,9] 输出: &amp;quot;3033459&amp;quot; &amp;nbsp;
提示:
0 &amp;lt; nums.length &amp;lt;= 100 说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数 拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0 func minNumber(nums []int) string { } LeetCode题库地址 https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof</description></item><item><title>剑指 Offer II 045 二叉树最底层最左边的值</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/lwunpt/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/lwunpt/</guid><description>剑指 Offer II 045 二叉树最底层最左边的值 给定一个二叉树的 根节点 root，请找出该二叉树的&amp;nbsp;最底层&amp;nbsp;最左边&amp;nbsp;节点的值。
假设二叉树中至少有一个节点。
&amp;nbsp;
示例 1:
输入: root = [2,1,3] 输出: 1 示例 2: 输入: [1,2,3,4,null,5,6,null,null,7] 输出: 7 &amp;nbsp;
提示:
二叉树的节点个数的范围是 [1,104] -231&amp;nbsp;&amp;lt;= Node.val &amp;lt;= 231&amp;nbsp;- 1&amp;nbsp; &amp;nbsp;
注意：本题与主站 513&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/find-bottom-left-tree-value/
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func findBottomLeftValue(root *TreeNode) int { } LeetCode题库地址 https://leetcode.cn/problems/LwUNpT</description></item><item><title>面试题 08.05 递归乘法</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/recursive-mulitply-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/recursive-mulitply-lcci/</guid><description>面试题 08.05 递归乘法 递归乘法。 写一个递归函数，不使用 * 运算符， 实现两个正整数的相乘。可以使用加号、减号、位移，但要吝啬一些。
示例1:
输入：A = 1, B = 10 输出：10 示例2:
输入：A = 3, B = 4 输出：12 提示:
保证乘法范围不会溢出 func multiply(A int, B int) int { } LeetCode题库地址 https://leetcode.cn/problems/recursive-mulitply-lcci</description></item><item><title>剑指 Offer 46 把数字翻译成字符串</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/</guid><description>剑指 Offer 46 把数字翻译成字符串 给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 &amp;ldquo;a&amp;rdquo; ，1 翻译成 &amp;ldquo;b&amp;rdquo;，&amp;hellip;&amp;hellip;，11 翻译成 &amp;ldquo;l&amp;rdquo;，&amp;hellip;&amp;hellip;，25 翻译成 &amp;ldquo;z&amp;rdquo;。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。
&amp;nbsp;
示例 1:
输入: 12258 输出: 5 解释: 12258有5种不同的翻译，分别是&amp;quot;bccfi&amp;quot;, &amp;quot;bwfi&amp;quot;, &amp;quot;bczi&amp;quot;, &amp;quot;mcfi&amp;quot;和&amp;quot;mzi&amp;quot; &amp;nbsp;
提示：
0 &amp;lt;= num &amp;lt; 231 func translateNum(num int) int { } LeetCode题库地址 https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof</description></item><item><title>剑指 Offer II 046 二叉树的右侧视图</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/wnc0lk/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/wnc0lk/</guid><description>剑指 Offer II 046 二叉树的右侧视图 给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
&amp;nbsp;
示例 1:
输入:&amp;nbsp;[1,2,3,null,5,null,4] 输出:&amp;nbsp;[1,3,4] 示例 2:
输入:&amp;nbsp;[1,null,3] 输出:&amp;nbsp;[1,3] 示例 3:
输入:&amp;nbsp;[] 输出:&amp;nbsp;[] &amp;nbsp;
提示:
二叉树的节点个数的范围是 [0,100] -100&amp;nbsp;&amp;lt;= Node.val &amp;lt;= 100&amp;nbsp; &amp;nbsp;
注意：本题与主站 199&amp;nbsp;题相同：https://leetcode-cn.com/problems/binary-tree-right-side-view/
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func rightSideView(root *TreeNode) []int { } LeetCode题库地址 https://leetcode.cn/problems/WNC0Lk</description></item><item><title>面试题 08.06 汉诺塔问题</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/hanota-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/hanota-lcci/</guid><description>面试题 08.06 汉诺塔问题 在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:
(1) 每次只能移动一个盘子;
(2) 盘子只能从柱子顶端滑出移到下一根柱子;
(3) 盘子只能叠在比它大的盘子上。
请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。
你需要原地修改栈。
示例1:
输入：A = [2, 1, 0], B = [], C = [] 输出：C = [2, 1, 0] 示例2:
输入：A = [1, 0], B = [], C = [] 输出：C = [1, 0] 提示:
A中盘子的数目不大于14个。 func hanota(A []int, B []int, C []int) []int { } LeetCode题库地址 https://leetcode.cn/problems/hanota-lcci</description></item><item><title>剑指 Offer 47 礼物的最大价值</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/li-wu-de-zui-da-jie-zhi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/li-wu-de-zui-da-jie-zhi-lcof/</guid><description>剑指 Offer 47 礼物的最大价值 在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？
&amp;nbsp;
示例 1:
输入: [ &amp;nbsp; [1,3,1], &amp;nbsp; [1,5,1], &amp;nbsp; [4,2,1] ] 输出: 12 解释: 路径 1&amp;rarr;3&amp;rarr;5&amp;rarr;2&amp;rarr;1 可以拿到最多价值的礼物 &amp;nbsp;
提示：
0 &amp;lt; grid.length &amp;lt;= 200 0 &amp;lt; grid[0].length &amp;lt;= 200 func maxValue(grid [][]int) int { } LeetCode题库地址 https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof</description></item><item><title>剑指 Offer II 047 二叉树剪枝</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/pocwxh/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/pocwxh/</guid><description>剑指 Offer II 047 二叉树剪枝 给定一个二叉树 根节点&amp;nbsp;root&amp;nbsp;，树的每个节点的值要么是 0，要么是 1。请剪除该二叉树中所有节点的值为 0 的子树。
节点 node 的子树为&amp;nbsp;node 本身，以及所有 node&amp;nbsp;的后代。
&amp;nbsp;
示例 1:
输入: [1,null,0,0,1] 输出: [1,null,0,null,1] 解释: 只有红色节点满足条件&amp;ldquo;所有不包含 1 的子树&amp;rdquo;。 右图为返回的答案。 示例 2:
输入: [1,0,1,0,0,0,1] 输出: [1,null,1,null,1] 解释: 示例 3:
输入: [1,1,0,1,1,0,1,0] 输出: [1,1,0,1,1,null,1] 解释: &amp;nbsp;
提示:
二叉树的节点个数的范围是 [1,200] 二叉树节点的值只会是 0 或 1 &amp;nbsp;
注意：本题与主站 814&amp;nbsp;题相同：https://leetcode-cn.com/problems/binary-tree-pruning/
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func pruneTree(root *TreeNode) *TreeNode { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 08.07 无重复字符串的排列组合</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/permutation-i-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/permutation-i-lcci/</guid><description>面试题 08.07 无重复字符串的排列组合 无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。
示例1:
输入：S = "qwe" 输出：["qwe", "qew", "wqe", "weq", "ewq", "eqw"] 示例2:
输入：S = "ab" 输出：["ab", "ba"] 提示:
字符都是英文字母。 字符串长度在[1, 9]之间。 func permutation(S string) []string { } LeetCode题库地址 https://leetcode.cn/problems/permutation-i-lcci</description></item><item><title>剑指 Offer 48 最长不含重复字符的子字符串</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/</guid><description>剑指 Offer 48 最长不含重复字符的子字符串 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。
&amp;nbsp;
示例&amp;nbsp;1:
输入: &amp;quot;abcabcbb&amp;quot; 输出: 3 解释: 因为无重复字符的最长子串是 &amp;quot;abc&amp;quot;，所以其长度为 3。 示例 2:
输入: &amp;quot;bbbbb&amp;quot; 输出: 1 解释: 因为无重复字符的最长子串是 &amp;quot;b&amp;quot;，所以其长度为 1。 示例 3:
输入: &amp;quot;pwwkew&amp;quot; 输出: 3 解释: 因为无重复字符的最长子串是&amp;nbsp;&amp;quot;wke&amp;quot;，所以其长度为 3。 &amp;nbsp; 请注意，你的答案必须是 子串 的长度，&amp;quot;pwke&amp;quot;&amp;nbsp;是一个子序列，不是子串。 &amp;nbsp;
提示：
s.length &amp;lt;= 40000 注意：本题与主站 3 题相同：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/
func lengthOfLongestSubstring(s string) int { } LeetCode题库地址 https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof</description></item><item><title>剑指 Offer II 048 序列化与反序列化二叉树</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/h54ybf/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/h54ybf/</guid><description>剑指 Offer II 048 序列化与反序列化二叉树 序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。
请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。
&amp;nbsp;
示例 1：
输入：root = [1,2,3,null,null,4,5] 输出：[1,2,3,null,null,4,5] 示例 2：
输入：root = [] 输出：[] 示例 3：
输入：root = [1] 输出：[1] 示例 4：
输入：root = [1,2] 输出：[1,2] &amp;nbsp;
提示：
输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅&amp;nbsp;LeetCode 序列化二叉树的格式。你并非必须采取这种方式，也可以采用其他的方法解决这个问题。 树中结点数在范围 [0, 104] 内 -1000 &amp;lt;= Node.val &amp;lt;= 1000 &amp;nbsp;
注意：本题与主站 297&amp;nbsp;题相同：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/&amp;nbsp;
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ type Codec struct { } func Constructor() Codec { } // Serializes a tree to a single string.</description></item><item><title>面试题 08.08 有重复字符串的排列组合</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/permutation-ii-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/permutation-ii-lcci/</guid><description>面试题 08.08 有重复字符串的排列组合 有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。
示例1:
输入：S = &amp;quot;qqe&amp;quot; 输出：[&amp;quot;eqq&amp;quot;,&amp;quot;qeq&amp;quot;,&amp;quot;qqe&amp;quot;] 示例2:
输入：S = &amp;quot;ab&amp;quot; 输出：[&amp;quot;ab&amp;quot;, &amp;quot;ba&amp;quot;] 提示:
字符都是英文字母。 字符串长度在[1, 9]之间。 func permutation(S string) []string { } LeetCode题库地址 https://leetcode.cn/problems/permutation-ii-lcci</description></item><item><title>剑指 Offer 49 丑数</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/chou-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/chou-shu-lcof/</guid><description>剑指 Offer 49 丑数 我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。
&amp;nbsp;
示例:
输入: n = 10 输出: 12 解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 说明:&amp;nbsp;&amp;nbsp;
1&amp;nbsp;是丑数。 n&amp;nbsp;不超过1690。 注意：本题与主站 264 题相同：https://leetcode-cn.com/problems/ugly-number-ii/
func nthUglyNumber(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/chou-shu-lcof</description></item><item><title>剑指 Offer II 049 从根节点到叶节点的路径数字之和</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/3etpl5/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/3etpl5/</guid><description>剑指 Offer II 049 从根节点到叶节点的路径数字之和 给定一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
每条从根节点到叶节点的路径都代表一个数字：
例如，从根节点到叶节点的路径 1 -&amp;gt; 2 -&amp;gt; 3 表示数字 123 。 计算从根节点到叶节点生成的 所有数字之和 。
叶节点 是指没有子节点的节点。
&amp;nbsp;
示例 1：
输入：root = [1,2,3] 输出：25 解释： 从根到叶子节点路径 1-&amp;gt;2 代表数字 12 从根到叶子节点路径 1-&amp;gt;3 代表数字 13 因此，数字总和 = 12 + 13 = 25 示例 2：
输入：root = [4,9,0,5,1] 输出：1026 解释： 从根到叶子节点路径 4-&amp;gt;9-&amp;gt;5 代表数字 495 从根到叶子节点路径 4-&amp;gt;9-&amp;gt;1 代表数字 491 从根到叶子节点路径 4-&amp;gt;0 代表数字 40 因此，数字总和 = 495 + 491 + 40 = 1026 &amp;nbsp;</description></item><item><title>面试题 08.09 括号</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/bracket-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/bracket-lcci/</guid><description>面试题 08.09 括号 括号。设计一种算法，打印n对括号的所有合法的（例如，开闭一一对应）组合。
说明：解集不能包含重复的子集。
例如，给出 n = 3，生成结果为：
[ "((()))", "(()())", "(())()", "()(())", "()()()" ] func generateParenthesis(n int) []string { } LeetCode题库地址 https://leetcode.cn/problems/bracket-lcci</description></item><item><title>剑指 Offer 50 第一个只出现一次的字符</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/</guid><description>剑指 Offer 50 第一个只出现一次的字符 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。
示例 1:
输入：s = "abaccdeff" 输出：'b' 示例 2:
输入：s = "" 输出：' ' &amp;nbsp;
限制：
0 &amp;lt;= s 的长度 &amp;lt;= 50000
func firstUniqChar(s string) byte { } LeetCode题库地址 https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof</description></item><item><title>剑指 Offer II 050 向下的路径节点之和</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/6euywp/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/6euywp/</guid><description>剑指 Offer II 050 向下的路径节点之和 给定一个二叉树的根节点 root&amp;nbsp;，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。
路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
&amp;nbsp;
示例 1：
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8 输出：3 解释：和等于 8 的路径有 3 条，如图所示。 示例 2：
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 输出：3 &amp;nbsp;
提示:
二叉树的节点个数的范围是 [0,1000] -109&amp;nbsp;&amp;lt;= Node.val &amp;lt;= 109&amp;nbsp; -1000&amp;nbsp;&amp;lt;= targetSum&amp;nbsp;&amp;lt;= 1000&amp;nbsp; &amp;nbsp;
注意：本题与主站 437&amp;nbsp;题相同：https://leetcode-cn.com/problems/path-sum-iii/
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func pathSum(root *TreeNode, targetSum int) int { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 08.10 颜色填充</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/color-fill-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/color-fill-lcci/</guid><description>面试题 08.10 颜色填充 编写函数，实现许多图片编辑软件都支持的「颜色填充」功能。
待填充的图像用二维数组 image 表示，元素为初始颜色值。初始坐标点的行坐标为 sr 列坐标为 sc。需要填充的新颜色为 newColor 。
「周围区域」是指颜色相同且在上、下、左、右四个方向上存在相连情况的若干元素。
请用新颜色填充初始坐标点的周围区域，并返回填充后的图像。
示例：
输入： image = [[1,1,1],[1,1,0],[1,0,1]] sr = 1, sc = 1, newColor = 2 输出：[[2,2,2],[2,2,0],[2,0,1]] 解释: 初始坐标点位于图像的正中间，坐标 (sr,sc)=(1,1) 。 初始坐标点周围区域上所有符合条件的像素点的颜色都被更改成 2 。 注意，右下角的像素没有更改为 2 ，因为它不属于初始坐标点的周围区域。 提示：
image 和 image[0] 的长度均在范围 [1, 50] 内。 初始坐标点 (sr,sc) 满足 0 &lt;= sr &lt; image.length 和 0 &lt;= sc &lt; image[0].length 。 image[i][j] 和 newColor 表示的颜色值在范围 [0, 65535] 内。 func floodFill(image [][]int, sr int, sc int, newColor int) [][]int { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer 51 数组中的逆序对</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zu-zhong-de-ni-xu-dui-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zu-zhong-de-ni-xu-dui-lcof/</guid><description>剑指 Offer 51 数组中的逆序对 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。
&amp;nbsp;
示例 1:
输入: [7,5,6,4] 输出: 5 &amp;nbsp;
限制：
0 &amp;lt;= 数组长度 &amp;lt;= 50000
func reversePairs(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof</description></item><item><title>剑指 Offer II 051 节点之和最大的路径</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/jc7mid/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/jc7mid/</guid><description>剑指 Offer II 051 节点之和最大的路径 路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。
路径和 是路径中各节点值的总和。
给定一个二叉树的根节点 root ，返回其 最大路径和，即所有路径上节点值之和的最大值。
&amp;nbsp;
示例 1：
输入：root = [1,2,3] 输出：6 解释：最优路径是 2 -&amp;gt; 1 -&amp;gt; 3 ，路径和为 2 + 1 + 3 = 6 示例 2：
输入：root = [-10,9,20,null,null,15,7] 输出：42 解释：最优路径是 15 -&amp;gt; 20 -&amp;gt; 7 ，路径和为 15 + 20 + 7 = 42 &amp;nbsp;
提示：
树中节点数目范围是 [1, 3 * 104] -1000 &amp;lt;= Node.val &amp;lt;= 1000 &amp;nbsp;
注意：本题与主站 124&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/
/** * Definition for a binary tree node.</description></item><item><title>面试题 08.11 硬币</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/coin-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/coin-lcci/</guid><description>面试题 08.11 硬币 硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)
示例1:
输入: n = 5 输出：2 解释: 有两种方式可以凑成总金额: 5=5 5=1+1+1+1+1 示例2:
输入: n = 10 输出：4 解释: 有四种方式可以凑成总金额: 10=10 10=5+5 10=5+1+1+1+1+1 10=1+1+1+1+1+1+1+1+1+1 说明：
注意:
你可以假设：
0 &amp;lt;= n (总金额) &amp;lt;= 1000000 func waysToChange(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/coin-lcci</description></item><item><title>剑指 Offer 52 两个链表的第一个公共节点</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/</guid><description>剑指 Offer 52 两个链表的第一个公共节点 输入两个链表，找出它们的第一个公共节点。
如下面的两个链表：
在节点 c1 开始相交。
&amp;nbsp;
示例 1：
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 &amp;nbsp;
示例&amp;nbsp;2：
输入：intersectVal&amp;nbsp;= 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Reference of the node with value = 2 输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 &amp;nbsp;</description></item><item><title>剑指 Offer II 052 展平二叉搜索树</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/nybbnl/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/nybbnl/</guid><description>剑指 Offer II 052 展平二叉搜索树 给你一棵二叉搜索树，请&amp;nbsp;按中序遍历 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。
&amp;nbsp;
示例 1：
输入：root = [5,3,6,2,4,null,8,1,null,null,null,7,9] 输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] 示例 2：
输入：root = [5,1,7] 输出：[1,null,5,null,7] &amp;nbsp;
提示：
树中节点数的取值范围是 [1, 100] 0 &amp;lt;= Node.val &amp;lt;= 1000 &amp;nbsp;
注意：本题与主站 897&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/increasing-order-search-tree/
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func increasingBST(root *TreeNode) *TreeNode { } LeetCode题库地址 https://leetcode.cn/problems/NYBBNL</description></item><item><title>面试题 08.12 八皇后</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/eight-queens-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/eight-queens-lcci/</guid><description>面试题 08.12 八皇后 设计一种算法，打印 N 皇后在 N &amp;times; N 棋盘上的各种摆法，其中每个皇后都不同行、不同列，也不在对角线上。这里的&amp;ldquo;对角线&amp;rdquo;指的是所有的对角线，不只是平分整个棋盘的那两条对角线。
注意：本题相对原题做了扩展
示例:
输入：4 输出：[[&amp;quot;.Q..&amp;quot;,&amp;quot;...Q&amp;quot;,&amp;quot;Q...&amp;quot;,&amp;quot;..Q.&amp;quot;],[&amp;quot;..Q.&amp;quot;,&amp;quot;Q...&amp;quot;,&amp;quot;...Q&amp;quot;,&amp;quot;.Q..&amp;quot;]] 解释: 4 皇后问题存在如下两个不同的解法。 [ &amp;nbsp;[&amp;quot;.Q..&amp;quot;, &amp;nbsp;// 解法 1 &amp;nbsp; &amp;quot;...Q&amp;quot;, &amp;nbsp; &amp;quot;Q...&amp;quot;, &amp;nbsp; &amp;quot;..Q.&amp;quot;], &amp;nbsp;[&amp;quot;..Q.&amp;quot;, &amp;nbsp;// 解法 2 &amp;nbsp; &amp;quot;Q...&amp;quot;, &amp;nbsp; &amp;quot;...Q&amp;quot;, &amp;nbsp; &amp;quot;.Q..&amp;quot;] ] func solveNQueens(n int) [][]string { } LeetCode题库地址 https://leetcode.cn/problems/eight-queens-lcci</description></item><item><title>剑指 Offer 53 - I 在排序数组中查找数字 I</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/</guid><description>剑指 Offer 53 - I 在排序数组中查找数字 I 统计一个数字在排序数组中出现的次数。
示例 1:
输入: nums = [5,7,7,8,8,10], target = 8 输出: 2 示例 2:
输入: nums = [5,7,7,8,8,10], target = 6 输出: 0 提示：
0 &lt;= nums.length &lt;= 105 -109 &lt;= nums[i] &lt;= 109 nums 是一个非递减数组 -109 &lt;= target &lt;= 109 注意：本题与主站 34 题相同（仅返回值不同）：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/
func search(nums []int, target int) int { } LeetCode题库地址 https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof</description></item><item><title>剑指 Offer II 053 二叉搜索树中的中序后继</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/p5rct8/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/p5rct8/</guid><description>剑指 Offer II 053 二叉搜索树中的中序后继 给定一棵二叉搜索树和其中的一个节点 p ，找到该节点在树中的中序后继。如果节点没有中序后继，请返回 null 。
节点&amp;nbsp;p&amp;nbsp;的后继是值比&amp;nbsp;p.val&amp;nbsp;大的节点中键值最小的节点，即按中序遍历的顺序节点 p 的下一个节点。
&amp;nbsp;
示例 1：
输入：root = [2,1,3], p = 1 输出：2 解释：这里 1 的中序后继是 2。请注意 p 和返回值都应是 TreeNode 类型。 示例&amp;nbsp;2：
输入：root = [5,3,6,2,4,null,null,1], p = 6 输出：null 解释：因为给出的节点没有中序后继，所以答案就返回 null 了。 &amp;nbsp;
提示：
树中节点的数目在范围 [1, 104] 内。 -105 &amp;lt;= Node.val &amp;lt;= 105 树中各节点的值均保证唯一。 &amp;nbsp;
注意：本题与主站 285&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/inorder-successor-in-bst/
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func inorderSuccessor(root *TreeNode, p *TreeNode) *TreeNode { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 08.13 堆箱子</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/pile-box-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/pile-box-lcci/</guid><description>面试题 08.13 堆箱子 堆箱子。给你一堆n个箱子，箱子宽 wi、深 di、高 hi。箱子不能翻转，将箱子堆起来时，下面箱子的宽度、高度和深度必须大于上面的箱子。实现一种方法，搭出最高的一堆箱子。箱堆的高度为每个箱子高度的总和。
输入使用数组[wi, di, hi]表示每个箱子。
示例1:
输入：box = [[1, 1, 1], [2, 2, 2], [3, 3, 3]] 输出：6 示例2:
输入：box = [[1, 1, 1], [2, 3, 4], [2, 6, 7], [3, 4, 5]] 输出：10 提示:
箱子的数目不大于3000个。 func pileBox(box [][]int) int { } LeetCode题库地址 https://leetcode.cn/problems/pile-box-lcci</description></item><item><title>剑指 Offer 53 - II 0～n-1中缺失的数字</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/que-shi-de-shu-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/que-shi-de-shu-zi-lcof/</guid><description>剑指 Offer 53 - II 0～n-1中缺失的数字 一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。
&amp;nbsp;
示例 1:
输入: [0,1,3] 输出: 2 示例&amp;nbsp;2:
输入: [0,1,2,3,4,5,6,7,9] 输出: 8 &amp;nbsp;
限制：
1 &amp;lt;= 数组长度 &amp;lt;= 10000
func missingNumber(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/que-shi-de-shu-zi-lcof</description></item><item><title>剑指 Offer II 054 所有大于等于节点的值之和</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/w6cpku/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/w6cpku/</guid><description>剑指 Offer II 054 所有大于等于节点的值之和 给定一个二叉搜索树，请将它的每个节点的值替换成树中大于或者等于该节点值的所有节点值之和。
&amp;nbsp;
提醒一下，二叉搜索树满足下列约束条件：
节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。 &amp;nbsp;
示例 1：
输入：root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8] 输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] 示例 2：
输入：root = [0,null,1] 输出：[1,null,1] 示例 3：
输入：root = [1,0,2] 输出：[3,3,2] 示例 4：
输入：root = [3,2,4,1] 输出：[7,9,4,10] &amp;nbsp;
提示：
树中的节点数介于 0&amp;nbsp;和 104&amp;nbsp;之间。 每个节点的值介于 -104&amp;nbsp;和&amp;nbsp;104&amp;nbsp;之间。 树中的所有值 互不相同 。 给定的树为二叉搜索树。 &amp;nbsp;
注意：
本题与主站 538&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/convert-bst-to-greater-tree/ 本题与主站 1038&amp;nbsp;题相同：https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func convertBST(root *TreeNode) *TreeNode { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 08.14 布尔运算</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/boolean-evaluation-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/boolean-evaluation-lcci/</guid><description>面试题 08.14 布尔运算 给定一个布尔表达式和一个期望的布尔结果 result，布尔表达式由 0 (false)、1 (true)、&amp;amp; (AND)、 | (OR) 和 ^ (XOR) 符号组成。实现一个函数，算出有几种可使该表达式得出 result 值的括号方法。
示例 1:
输入: s = &amp;quot;1^0|0|1&amp;quot;, result = 0 输出: 2 解释:&amp;nbsp;两种可能的括号方法是 1^(0|(0|1)) 1^((0|0)|1) 示例 2:
输入: s = &amp;quot;0&amp;amp;0&amp;amp;0&amp;amp;1^1|0&amp;quot;, result = 1 输出: 10 提示：
运算符的数量不超过 19 个 func countEval(s string, result int) int { } LeetCode题库地址 https://leetcode.cn/problems/boolean-evaluation-lcci</description></item><item><title>剑指 Offer 54 二叉搜索树的第k大节点</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/</guid><description>剑指 Offer 54 二叉搜索树的第k大节点 给定一棵二叉搜索树，请找出其中第 k 大的节点的值。
&amp;nbsp;
示例 1:
输入: root = [3,1,4,null,2], k = 1 3 / \ 1 4 \ &amp;nbsp; 2 输出: 4 示例 2:
输入: root = [5,3,6,2,4,null,null,1], k = 3 5 / \ 3 6 / \ 2 4 / 1 输出: 4 &amp;nbsp;
限制：
1 ≤ k ≤ 二叉搜索树元素个数 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func kthLargest(root *TreeNode, k int) int { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer II 055 二叉搜索树迭代器</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/ktoapq/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/ktoapq/</guid><description>剑指 Offer II 055 二叉搜索树迭代器 实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：
BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。 boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。 int next()将指针向右移动，然后返回指针处的数字。 注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。
可以假设&amp;nbsp;next()&amp;nbsp;调用总是有效的，也就是说，当调用 next()&amp;nbsp;时，BST 的中序遍历中至少存在一个下一个数字。
&amp;nbsp;
示例：
输入 inputs = [&amp;quot;BSTIterator&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;hasNext&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;hasNext&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;hasNext&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;hasNext&amp;quot;] inputs = [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []] 输出 [null, 3, 7, true, 9, true, 15, true, 20, false] 解释 BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]); bSTIterator.</description></item><item><title>面试题 10.01 合并排序的数组</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sorted-merge-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sorted-merge-lcci/</guid><description>面试题 10.01 合并排序的数组 给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。
初始化&amp;nbsp;A 和 B 的元素数量分别为&amp;nbsp;m 和 n。
示例:
输入: A = [1,2,3,0,0,0], m = 3 B = [2,5,6], n = 3 输出:&amp;nbsp;[1,2,2,3,5,6] 说明:
A.length == n + m func merge(A []int, m int, B []int, n int) { } LeetCode题库地址 https://leetcode.cn/problems/sorted-merge-lcci</description></item><item><title>剑指 Offer 55 - I 二叉树的深度</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-shu-de-shen-du-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-shu-de-shen-du-lcof/</guid><description>剑指 Offer 55 - I 二叉树的深度 输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。
例如：
给定二叉树 [3,9,20,null,null,15,7]，
3 / \ 9 20 / \ 15 7 返回它的最大深度&amp;nbsp;3 。
&amp;nbsp;
提示：
节点总数 &amp;lt;= 10000 注意：本题与主站 104&amp;nbsp;题相同：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func maxDepth(root *TreeNode) int { } LeetCode题库地址 https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof</description></item><item><title>剑指 Offer II 056 二叉搜索树中两个节点之和</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/opldqz/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/opldqz/</guid><description>剑指 Offer II 056 二叉搜索树中两个节点之和 给定一个二叉搜索树的 根节点 root&amp;nbsp;和一个整数 k , 请判断该二叉搜索树中是否存在两个节点它们的值之和等于 k 。假设二叉搜索树中节点的值均唯一。
&amp;nbsp;
示例 1：
输入: root = [8,6,10,5,7,9,11], k = 12 输出: true 解释: 节点 5 和节点 7 之和等于 12 示例 2：
输入: root = [8,6,10,5,7,9,11], k = 22 输出: false 解释: 不存在两个节点值之和为 22 的节点 &amp;nbsp;
提示：
二叉树的节点个数的范围是&amp;nbsp;&amp;nbsp;[1, 104]. -104&amp;nbsp;&amp;lt;= Node.val &amp;lt;= 104 root&amp;nbsp;为二叉搜索树 -105&amp;nbsp;&amp;lt;= k &amp;lt;= 105 &amp;nbsp;
注意：本题与主站 653 题相同：&amp;nbsp;https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func findTarget(root *TreeNode, k int) bool { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 10.02 变位词组</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/group-anagrams-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/group-anagrams-lcci/</guid><description>面试题 10.02 变位词组 编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。
注意：本题相对原题稍作修改
示例:
输入: [&amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;tan&amp;quot;, &amp;quot;ate&amp;quot;, &amp;quot;nat&amp;quot;, &amp;quot;bat&amp;quot;], 输出: [ [&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;], [&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;], [&amp;quot;bat&amp;quot;] ] 说明：
所有输入均为小写字母。 不考虑答案输出的顺序。 func groupAnagrams(strs []string) [][]string { } LeetCode题库地址 https://leetcode.cn/problems/group-anagrams-lcci</description></item><item><title>剑指 Offer 55 - II 平衡二叉树</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ping-heng-er-cha-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ping-heng-er-cha-shu-lcof/</guid><description>剑指 Offer 55 - II 平衡二叉树 输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。
示例 1:
给定二叉树 [3,9,20,null,null,15,7]
3 / \ 9 20 / \ 15 7 返回 true 。
示例 2:
给定二叉树 [1,2,2,3,3,null,null,4,4]
1 / \ 2 2 / \ 3 3 / \ 4 4 返回 false 。
限制：
0 &lt;= 树的结点个数 &lt;= 10000 注意：本题与主站 110 题相同：https://leetcode-cn.com/problems/balanced-binary-tree/
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isBalanced(root *TreeNode) bool { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer II 057 值和下标之差都在给定的范围内</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/7wqedu/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/7wqedu/</guid><description>剑指 Offer II 057 值和下标之差都在给定的范围内 给你一个整数数组 nums 和两个整数&amp;nbsp;k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得&amp;nbsp;abs(nums[i] - nums[j]) &amp;lt;= t ，同时又满足 abs(i - j) &amp;lt;= k 。
如果存在则返回 true，不存在返回 false。
&amp;nbsp;
示例&amp;nbsp;1：
输入：nums = [1,2,3,1], k = 3, t = 0 输出：true 示例 2：
输入：nums = [1,0,1,1], k = 1, t = 2 输出：true 示例 3：
输入：nums = [1,5,9,1,5,9], k = 2, t = 3 输出：false &amp;nbsp;
提示：
0 &amp;lt;= nums.length &amp;lt;= 2 * 104 -231 &amp;lt;= nums[i] &amp;lt;= 231 - 1 0 &amp;lt;= k &amp;lt;= 104 0 &amp;lt;= t &amp;lt;= 231 - 1 &amp;nbsp;</description></item><item><title>面试题 10.03 搜索旋转数组</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/search-rotate-array-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/search-rotate-array-lcci/</guid><description>面试题 10.03 搜索旋转数组 搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。
示例1:
输入: arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 5 输出: 8（元素5在该数组中的索引） 示例2:
输入：arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 11 输出：-1 （没有找到） 提示:
arr 长度范围在[1, 1000000]之间 func search(arr []int, target int) int { } LeetCode题库地址 https://leetcode.cn/problems/search-rotate-array-lcci</description></item><item><title>剑指 Offer 56 - I 数组中数字出现的次数</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/</guid><description>剑指 Offer 56 - I 数组中数字出现的次数 一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。
&amp;nbsp;
示例 1：
输入：nums = [4,1,4,6] 输出：[1,6] 或 [6,1] 示例 2：
输入：nums = [1,2,10,4,1,4,3,3] 输出：[2,10] 或 [10,2] &amp;nbsp;
限制：
2 &amp;lt;= nums.length &amp;lt;= 10000 &amp;nbsp;
func singleNumbers(nums []int) []int { } LeetCode题库地址 https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof</description></item><item><title>剑指 Offer II 058 日程表</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/fi9suh/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/fi9suh/</guid><description>剑指 Offer II 058 日程表 请实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内没有其他安排，则可以存储这个新的日程安排。
MyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数&amp;nbsp;x 的范围为， &amp;nbsp;start &amp;lt;= x &amp;lt; end。
当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生重复预订。
每次调用 MyCalendar.book方法时，如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 true。否则，返回 false&amp;nbsp;并且不要将该日程安排添加到日历中。
请按照以下步骤调用 MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)
&amp;nbsp;
示例:
输入: [&amp;quot;MyCalendar&amp;quot;,&amp;quot;book&amp;quot;,&amp;quot;book&amp;quot;,&amp;quot;book&amp;quot;] [[],[10,20],[15,25],[20,30]] 输出: [null,true,false,true] 解释: MyCalendar myCalendar = new MyCalendar(); MyCalendar.book(10, 20); // returns true MyCalendar.book(15, 25); // returns false ，第二个日程安排不能添加到日历中，因为时间 15 已经被第一个日程安排预定了 MyCalendar.book(20, 30); // returns true ，第三个日程安排可以添加到日历中，因为第一个日程安排并不包含时间 20 &amp;nbsp;</description></item><item><title>面试题 10.05 稀疏数组搜索</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sparse-array-search-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sparse-array-search-lcci/</guid><description>面试题 10.05 稀疏数组搜索 稀疏数组搜索。有个排好序的字符串数组，其中散布着一些空字符串，编写一种方法，找出给定字符串的位置。
示例1:
输入: words = [&amp;quot;at&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;ball&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;car&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;,&amp;quot;dad&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;], s = &amp;quot;ta&amp;quot; 输出：-1 说明: 不存在返回-1。 示例2:
输入：words = [&amp;quot;at&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;ball&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;car&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;,&amp;quot;dad&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;], s = &amp;quot;ball&amp;quot; 输出：4 提示:
words的长度在[1, 1000000]之间 func findString(words []string, s string) int { } LeetCode题库地址 https://leetcode.cn/problems/sparse-array-search-lcci</description></item><item><title>剑指 Offer 56 - II 数组中数字出现的次数 II</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/</guid><description>剑指 Offer 56 - II 数组中数字出现的次数 II 在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。
&amp;nbsp;
示例 1：
输入：nums = [3,4,3,3] 输出：4 示例 2：
输入：nums = [9,1,7,9,7,9,7] 输出：1 &amp;nbsp;
限制：
1 &amp;lt;= nums.length &amp;lt;= 10000 1 &amp;lt;= nums[i] &amp;lt; 2^31 &amp;nbsp;
func singleNumber(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof</description></item><item><title>剑指 Offer II 059 数据流的第 K 大数值</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/jbjn9c/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/jbjn9c/</guid><description>剑指 Offer II 059 数据流的第 K 大数值 设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。
请实现 KthLargest&amp;nbsp;类：
KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。 int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。 &amp;nbsp;
示例：
输入： [&amp;quot;KthLargest&amp;quot;, &amp;quot;add&amp;quot;, &amp;quot;add&amp;quot;, &amp;quot;add&amp;quot;, &amp;quot;add&amp;quot;, &amp;quot;add&amp;quot;] [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]] 输出： [null, 4, 5, 5, 8, 8] 解释： KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]); kthLargest.add(3); // return 4 kthLargest.</description></item><item><title>面试题 10.09 排序矩阵查找</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sorted-matrix-search-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sorted-matrix-search-lcci/</guid><description>面试题 10.09 排序矩阵查找 给定M&amp;times;N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。
示例:
现有矩阵 matrix 如下：
[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target&amp;nbsp;=&amp;nbsp;5，返回&amp;nbsp;true。
给定&amp;nbsp;target&amp;nbsp;=&amp;nbsp;20，返回&amp;nbsp;false。
func searchMatrix(matrix [][]int, target int) bool { } LeetCode题库地址 https://leetcode.cn/problems/sorted-matrix-search-lcci</description></item><item><title>剑指 Offer 57 和为s的两个数字</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/he-wei-sde-liang-ge-shu-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/he-wei-sde-liang-ge-shu-zi-lcof/</guid><description>剑指 Offer 57 和为s的两个数字 输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。
&amp;nbsp;
示例 1：
输入：nums = [2,7,11,15], target = 9 输出：[2,7] 或者 [7,2] 示例 2：
输入：nums = [10,26,30,31,47,60], target = 40 输出：[10,30] 或者 [30,10] &amp;nbsp;
限制：
1 &amp;lt;= nums.length &amp;lt;= 10^5 1 &amp;lt;= nums[i]&amp;nbsp;&amp;lt;= 10^6 func twoSum(nums []int, target int) []int { } LeetCode题库地址 https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof</description></item><item><title>剑指 Offer II 060 出现频率最高的 k 个数字</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/g5c51o/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/g5c51o/</guid><description>剑指 Offer II 060 出现频率最高的 k 个数字 给定一个整数数组 nums 和一个整数 k&amp;nbsp;，请返回其中出现频率前 k 高的元素。可以按 任意顺序 返回答案。
&amp;nbsp;
示例 1:
输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2] 示例 2:
输入: nums = [1], k = 1 输出: [1] &amp;nbsp;
提示：
1 &amp;lt;= nums.length &amp;lt;= 105 k 的取值范围是 [1, 数组中不相同的元素的个数] 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的 &amp;nbsp;
进阶：所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n&amp;nbsp;是数组大小。
&amp;nbsp;
注意：本题与主站 347&amp;nbsp;题相同：https://leetcode-cn.com/problems/top-k-frequent-elements/
func topKFrequent(nums []int, k int) []int { } LeetCode题库地址 https://leetcode.cn/problems/g5c51o</description></item><item><title>面试题 10.10 数字流的秩</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/rank-from-stream-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/rank-from-stream-lcci/</guid><description>面试题 10.10 数字流的秩 假设你正在读取一串整数。每隔一段时间，你希望能找出数字 x 的秩(小于或等于 x 的值的个数)。请实现数据结构和算法来支持这些操作，也就是说：
实现 track(int x)&amp;nbsp;方法，每读入一个数字都会调用该方法；
实现 getRankOfNumber(int x) 方法，返回小于或等于 x 的值的个数。
注意：本题相对原题稍作改动
示例:
输入: [&amp;quot;StreamRank&amp;quot;, &amp;quot;getRankOfNumber&amp;quot;, &amp;quot;track&amp;quot;, &amp;quot;getRankOfNumber&amp;quot;] [[], [1], [0], [0]] 输出: [null,0,null,1] 提示：
x &amp;lt;= 50000 track&amp;nbsp;和&amp;nbsp;getRankOfNumber 方法的调用次数均不超过 2000 次 type StreamRank struct { } func Constructor() StreamRank { } func (this *StreamRank) Track(x int) { } func (this *StreamRank) GetRankOfNumber(x int) int { } /** * Your StreamRank object will be instantiated and called as such: * obj := Constructor(); * obj.</description></item><item><title>剑指 Offer 57 - II 和为s的连续正数序列</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/</guid><description>剑指 Offer 57 - II 和为s的连续正数序列 输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。
序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。
&amp;nbsp;
示例 1：
输入：target = 9 输出：[[2,3,4],[4,5]] 示例 2：
输入：target = 15 输出：[[1,2,3,4,5],[4,5,6],[7,8]] &amp;nbsp;
限制：
1 &amp;lt;= target &amp;lt;= 10^5 &amp;nbsp;
func findContinuousSequence(target int) [][]int { } LeetCode题库地址 https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof</description></item><item><title>剑指 Offer II 061 和最小的 k 个数对</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/qn8ggx/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/qn8ggx/</guid><description>剑指 Offer II 061 和最小的 k 个数对 给定两个以升序排列的整数数组 nums1 和 nums2&amp;nbsp;,&amp;nbsp;以及一个整数 k&amp;nbsp;。
定义一对值&amp;nbsp;(u,v)，其中第一个元素来自&amp;nbsp;nums1，第二个元素来自 nums2&amp;nbsp;。
请找到和最小的 k&amp;nbsp;个数对&amp;nbsp;(u1,v1), &amp;nbsp;(u2,v2) &amp;nbsp;... &amp;nbsp;(uk,vk)&amp;nbsp;。
&amp;nbsp;
示例 1:
输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3 输出: [1,2],[1,4],[1,6] 解释: 返回序列中的前 3 对数： [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] 示例 2:
输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2 输出: [1,1],[1,1] 解释: 返回序列中的前 2 对数： &amp;nbsp; [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3] 示例 3:
输入: nums1 = [1,2], nums2 = [3], k = 3 输出: [1,3],[2,3] 解释: 也可能序列中所有的数对都被返回:[1,3],[2,3] &amp;nbsp;</description></item><item><title>面试题 10.11 峰与谷</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/peaks-and-valleys-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/peaks-and-valleys-lcci/</guid><description>面试题 10.11 峰与谷 在一个整数数组中，&amp;ldquo;峰&amp;rdquo;是大于或等于相邻整数的元素，相应地，&amp;ldquo;谷&amp;rdquo;是小于或等于相邻整数的元素。例如，在数组{5, 8, 4, 2, 3, 4, 6}中，{8, 6}是峰， {5, 2}是谷。现在给定一个整数数组，将该数组按峰与谷的交替顺序排序。
示例:
输入: [5, 3, 1, 2, 3] 输出:&amp;nbsp;[5, 1, 3, 2, 3] 提示：
nums.length &amp;lt;= 10000 func wiggleSort(nums []int) { } LeetCode题库地址 https://leetcode.cn/problems/peaks-and-valleys-lcci</description></item><item><title>剑指 Offer 58 - I 翻转单词顺序</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/fan-zhuan-dan-ci-shun-xu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/fan-zhuan-dan-ci-shun-xu-lcof/</guid><description>剑指 Offer 58 - I 翻转单词顺序 输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串&amp;quot;I am a student. &amp;quot;，则输出&amp;quot;student. a am I&amp;quot;。
&amp;nbsp;
示例 1：
输入: &amp;quot;the sky is blue&amp;quot; 输出:&amp;nbsp;&amp;quot;blue is sky the&amp;quot; 示例 2：
输入: &amp;quot; &amp;nbsp;hello world! &amp;nbsp;&amp;quot; 输出:&amp;nbsp;&amp;quot;world! hello&amp;quot; 解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 示例 3：
输入: &amp;quot;a good &amp;nbsp; example&amp;quot; 输出:&amp;nbsp;&amp;quot;example good a&amp;quot; 解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 &amp;nbsp;
说明：
无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 注意：本题与主站 151 题相同：https://leetcode-cn.com/problems/reverse-words-in-a-string/
注意：此题对比原题有改动
func reverseWords(s string) string { } LeetCode题库地址 https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof</description></item><item><title>剑指 Offer II 062 实现前缀树</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/qc3q1f/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/qc3q1f/</guid><description>剑指 Offer II 062 实现前缀树 Trie（发音类似 &amp;quot;try&amp;quot;）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。
请你实现 Trie 类：
Trie() 初始化前缀树对象。 void insert(String word) 向前缀树中插入字符串 word 。 boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。 boolean startsWith(String prefix) 如果之前已经插入的字符串&amp;nbsp;word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。 &amp;nbsp;
示例：
输入 inputs = [&amp;quot;Trie&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;search&amp;quot;, &amp;quot;search&amp;quot;, &amp;quot;startsWith&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;search&amp;quot;] inputs = [[], [&amp;quot;apple&amp;quot;], [&amp;quot;apple&amp;quot;], [&amp;quot;app&amp;quot;], [&amp;quot;app&amp;quot;], [&amp;quot;app&amp;quot;], [&amp;quot;app&amp;quot;]] 输出 [null, null, true, false, true, null, true] 解释 Trie trie = new Trie(); trie.</description></item><item><title>面试题 16.01 交换数字</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/swap-numbers-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/swap-numbers-lcci/</guid><description>面试题 16.01 交换数字 编写一个函数，不用临时变量，直接交换numbers = [a, b]中a与b的值。
示例：
输入: numbers = [1,2] 输出: [2,1] 提示：
numbers.length == 2 -2147483647 &lt;= numbers[i] &lt;= 2147483647 func swapNumbers(numbers []int) []int { } LeetCode题库地址 https://leetcode.cn/problems/swap-numbers-lcci</description></item><item><title>剑指 Offer 58 - II 左旋转字符串</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zuo-xuan-zhuan-zi-fu-chuan-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zuo-xuan-zhuan-zi-fu-chuan-lcof/</guid><description>剑指 Offer 58 - II 左旋转字符串 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&amp;quot;abcdefg&amp;quot;和数字2，该函数将返回左旋转两位得到的结果&amp;quot;cdefgab&amp;quot;。
&amp;nbsp;
示例 1：
输入: s = &amp;quot;abcdefg&amp;quot;, k = 2 输出:&amp;nbsp;&amp;quot;cdefgab&amp;quot; 示例 2：
输入: s = &amp;quot;lrloseumgh&amp;quot;, k = 6 输出:&amp;nbsp;&amp;quot;umghlrlose&amp;quot; &amp;nbsp;
限制：
1 &amp;lt;= k &amp;lt; s.length &amp;lt;= 10000 func reverseLeftWords(s string, n int) string { } LeetCode题库地址 https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof</description></item><item><title>剑指 Offer II 063 替换单词</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/uhwrsj/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/uhwrsj/</guid><description>剑指 Offer II 063 替换单词 在英语中，有一个叫做&amp;nbsp;词根(root) 的概念，它可以跟着其他一些词组成另一个较长的单词&amp;mdash;&amp;mdash;我们称这个词为&amp;nbsp;继承词(successor)。例如，词根an，跟随着单词&amp;nbsp;other(其他)，可以形成新的单词&amp;nbsp;another(另一个)。
现在，给定一个由许多词根组成的词典和一个句子，需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。
需要输出替换之后的句子。
&amp;nbsp;
示例 1：
输入：dictionary = [&amp;quot;cat&amp;quot;,&amp;quot;bat&amp;quot;,&amp;quot;rat&amp;quot;], sentence = &amp;quot;the cattle was rattled by the battery&amp;quot; 输出：&amp;quot;the cat was rat by the bat&amp;quot; 示例 2：
输入：dictionary = [&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;], sentence = &amp;quot;aadsfasf absbs bbab cadsfafs&amp;quot; 输出：&amp;quot;a a b c&amp;quot; 示例 3：
输入：dictionary = [&amp;quot;a&amp;quot;, &amp;quot;aa&amp;quot;, &amp;quot;aaa&amp;quot;, &amp;quot;aaaa&amp;quot;], sentence = &amp;quot;a aa a aaaa aaa aaa aaa aaaaaa bbb baba ababa&amp;quot; 输出：&amp;quot;a a a a a a a a bbb baba a&amp;quot; 示例 4：</description></item><item><title>面试题 16.02 单词频率</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/words-frequency-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/words-frequency-lcci/</guid><description>面试题 16.02 单词频率 设计一个方法，找出任意指定单词在一本书中的出现频率。
你的实现应该支持如下操作：
WordsFrequency(book)构造函数，参数为字符串数组构成的一本书 get(word)查询指定单词在书中出现的频率 示例：
WordsFrequency wordsFrequency = new WordsFrequency({&amp;quot;i&amp;quot;, &amp;quot;have&amp;quot;, &amp;quot;an&amp;quot;, &amp;quot;apple&amp;quot;, &amp;quot;he&amp;quot;, &amp;quot;have&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;pen&amp;quot;}); wordsFrequency.get(&amp;quot;you&amp;quot;); //返回0，&amp;quot;you&amp;quot;没有出现过 wordsFrequency.get(&amp;quot;have&amp;quot;); //返回2，&amp;quot;have&amp;quot;出现2次 wordsFrequency.get(&amp;quot;an&amp;quot;); //返回1 wordsFrequency.get(&amp;quot;apple&amp;quot;); //返回1 wordsFrequency.get(&amp;quot;pen&amp;quot;); //返回1 提示：
book[i]中只包含小写字母 1 &amp;lt;= book.length &amp;lt;= 100000 1 &amp;lt;= book[i].length &amp;lt;= 10 get函数的调用次数不会超过100000 type WordsFrequency struct { } func Constructor(book []string) WordsFrequency { } func (this *WordsFrequency) Get(word string) int { } /** * Your WordsFrequency object will be instantiated and called as such: * obj := Constructor(book); * param_1 := obj.</description></item><item><title>剑指 Offer 59 - I 滑动窗口的最大值</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/hua-dong-chuang-kou-de-zui-da-zhi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/hua-dong-chuang-kou-de-zui-da-zhi-lcof/</guid><description>剑指 Offer 59 - I 滑动窗口的最大值 给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。
示例:
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 输出: [3,3,5,5,6,7] 解释: 滑动窗口的位置 最大值 --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 &amp;nbsp;</description></item><item><title>剑指 Offer II 064 神奇的字典</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/us1pgt/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/us1pgt/</guid><description>剑指 Offer II 064 神奇的字典 设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同 。 如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于已构建的神奇字典中。
实现 MagicDictionary 类：
MagicDictionary() 初始化对象 void buildDict(String[]&amp;nbsp;dictionary) 使用字符串数组&amp;nbsp;dictionary 设定该数据结构，dictionary 中的字符串互不相同 bool search(String searchWord) 给定一个字符串 searchWord ，判定能否只将字符串中 一个 字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 true ；否则，返回 false 。 &amp;nbsp;
示例：
输入 inputs = [&amp;quot;MagicDictionary&amp;quot;, &amp;quot;buildDict&amp;quot;, &amp;quot;search&amp;quot;, &amp;quot;search&amp;quot;, &amp;quot;search&amp;quot;, &amp;quot;search&amp;quot;] inputs = [[], [[&amp;quot;hello&amp;quot;, &amp;quot;leetcode&amp;quot;]], [&amp;quot;hello&amp;quot;], [&amp;quot;hhllo&amp;quot;], [&amp;quot;hell&amp;quot;], [&amp;quot;leetcoded&amp;quot;]] 输出 [null, null, false, true, false, false] 解释 MagicDictionary magicDictionary = new MagicDictionary(); magicDictionary.buildDict([&amp;quot;hello&amp;quot;, &amp;quot;leetcode&amp;quot;]); magicDictionary.search(&amp;quot;hello&amp;quot;); // 返回 False magicDictionary.search(&amp;quot;hhllo&amp;quot;); // 将第二个 &amp;#39;h&amp;#39; 替换为 &amp;#39;e&amp;#39; 可以匹配 &amp;quot;hello&amp;quot; ，所以返回 True magicDictionary.</description></item><item><title>面试题 16.03 交点</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/intersection-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/intersection-lcci/</guid><description>面试题 16.03 交点 给定两条线段（表示为起点start = {X1, Y1}和终点end = {X2, Y2}），如果它们有交点，请计算其交点，没有交点则返回空值。
要求浮点型误差不超过10^-6。若有多个交点（线段重叠）则返回 X 值最小的点，X 坐标相同则返回 Y 值最小的点。
&amp;nbsp;
示例 1：
输入： line1 = {0, 0}, {1, 0} line2 = {1, 1}, {0, -1} 输出： {0.5, 0} 示例 2：
输入： line1 = {0, 0}, {3, 3} line2 = {1, 1}, {2, 2} 输出： {1, 1} 示例 3：
输入： line1 = {0, 0}, {1, 1} line2 = {1, 0}, {2, 1} 输出： {}，两条线段没有交点 &amp;nbsp;
提示：
坐标绝对值不会超过 2^7 输入的坐标均是有效的二维坐标 func intersection(start1 []int, end1 []int, start2 []int, end2 []int) []float64 { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer 59 - II 队列的最大值</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/dui-lie-de-zui-da-zhi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/dui-lie-de-zui-da-zhi-lcof/</guid><description>剑指 Offer 59 - II 队列的最大值 请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。
若队列为空，pop_front 和 max_value&amp;nbsp;需要返回 -1
示例 1：
输入: [&amp;quot;MaxQueue&amp;quot;,&amp;quot;push_back&amp;quot;,&amp;quot;push_back&amp;quot;,&amp;quot;max_value&amp;quot;,&amp;quot;pop_front&amp;quot;,&amp;quot;max_value&amp;quot;] [[],[1],[2],[],[],[]] 输出:&amp;nbsp;[null,null,null,2,1,2] 示例 2：
输入: [&amp;quot;MaxQueue&amp;quot;,&amp;quot;pop_front&amp;quot;,&amp;quot;max_value&amp;quot;] [[],[],[]] 输出:&amp;nbsp;[null,-1,-1] &amp;nbsp;
限制：
1 &amp;lt;= push_back,pop_front,max_value的总操作数&amp;nbsp;&amp;lt;= 10000 1 &amp;lt;= value &amp;lt;= 10^5 type MaxQueue struct { } func Constructor() MaxQueue { } func (this *MaxQueue) Max_value() int { } func (this *MaxQueue) Push_back(value int) { } func (this *MaxQueue) Pop_front() int { } /** * Your MaxQueue object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.</description></item><item><title>剑指 Offer II 065 最短的单词编码</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/iswd2y/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/iswd2y/</guid><description>剑指 Offer II 065 最短的单词编码 单词数组&amp;nbsp;words 的 有效编码 由任意助记字符串 s 和下标数组 indices 组成，且满足：
words.length == indices.length 助记字符串 s 以 &amp;#39;#&amp;#39; 字符结尾 对于每个下标 indices[i] ，s 的一个从 indices[i] 开始、到下一个 &amp;#39;#&amp;#39; 字符结束（但不包括 &amp;#39;#&amp;#39;）的 子字符串 恰好与 words[i] 相等 给定一个单词数组&amp;nbsp;words ，返回成功对 words 进行编码的最小助记字符串 s 的长度 。
&amp;nbsp;
示例 1：
输入：words = [&amp;quot;time&amp;quot;, &amp;quot;me&amp;quot;, &amp;quot;bell&amp;quot;] 输出：10 解释：一组有效编码为 s = &amp;quot;time#bell#&amp;quot; 和 indices = [0, 2, 5] 。 words[0] = &amp;quot;time&amp;quot; ，s 开始于 indices[0] = 0 到下一个 &amp;#39;#&amp;#39; 结束的子字符串，如加粗部分所示 &amp;quot;time#bell#&amp;quot; words[1] = &amp;quot;me&amp;quot; ，s 开始于 indices[1] = 2 到下一个 &amp;#39;#&amp;#39; 结束的子字符串，如加粗部分所示 &amp;quot;time#bell#&amp;quot; words[2] = &amp;quot;bell&amp;quot; ，s 开始于 indices[2] = 5 到下一个 &amp;#39;#&amp;#39; 结束的子字符串，如加粗部分所示 &amp;quot;time#bell#&amp;quot; 示例 2：</description></item><item><title>面试题 16.04 井字游戏</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/tic-tac-toe-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/tic-tac-toe-lcci/</guid><description>面试题 16.04 井字游戏 设计一个算法，判断玩家是否赢了井字游戏。输入是一个 N x N 的数组棋盘，由字符&amp;quot; &amp;quot;，&amp;quot;X&amp;quot;和&amp;quot;O&amp;quot;组成，其中字符&amp;quot; &amp;quot;代表一个空位。
以下是井字游戏的规则：
玩家轮流将字符放入空位（&amp;quot; &amp;quot;）中。 第一个玩家总是放字符&amp;quot;O&amp;quot;，且第二个玩家总是放字符&amp;quot;X&amp;quot;。 &amp;quot;X&amp;quot;和&amp;quot;O&amp;quot;只允许放置在空位中，不允许对已放有字符的位置进行填充。 当有N个相同（且非空）的字符填充任何行、列或对角线时，游戏结束，对应该字符的玩家获胜。 当所有位置非空时，也算为游戏结束。 如果游戏结束，玩家不允许再放置字符。 如果游戏存在获胜者，就返回该游戏的获胜者使用的字符（&amp;quot;X&amp;quot;或&amp;quot;O&amp;quot;）；如果游戏以平局结束，则返回 &amp;quot;Draw&amp;quot;；如果仍会有行动（游戏未结束），则返回 &amp;quot;Pending&amp;quot;。
示例 1：
输入： board = [&amp;quot;O X&amp;quot;,&amp;quot; XO&amp;quot;,&amp;quot;X O&amp;quot;] 输出： &amp;quot;X&amp;quot; 示例 2：
输入： board = [&amp;quot;OOX&amp;quot;,&amp;quot;XXO&amp;quot;,&amp;quot;OXO&amp;quot;] 输出： &amp;quot;Draw&amp;quot; 解释： 没有玩家获胜且不存在空位 示例 3：
输入： board = [&amp;quot;OOX&amp;quot;,&amp;quot;XXO&amp;quot;,&amp;quot;OX &amp;quot;] 输出： &amp;quot;Pending&amp;quot; 解释： 没有玩家获胜且仍存在空位 提示：
1 &amp;lt;= board.length == board[i].length &amp;lt;= 100 输入一定遵循井字棋规则 func tictactoe(board []string) string { } LeetCode题库地址 https://leetcode.cn/problems/tic-tac-toe-lcci</description></item><item><title>面试题59 - II 队列的最大值</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/dui-lie-de-zui-da-zhi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/dui-lie-de-zui-da-zhi-lcof/</guid><description>面试题59 - II 队列的最大值 请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。
若队列为空，pop_front 和 max_value&amp;nbsp;需要返回 -1
示例 1：
输入: [&amp;quot;MaxQueue&amp;quot;,&amp;quot;push_back&amp;quot;,&amp;quot;push_back&amp;quot;,&amp;quot;max_value&amp;quot;,&amp;quot;pop_front&amp;quot;,&amp;quot;max_value&amp;quot;] [[],[1],[2],[],[],[]] 输出:&amp;nbsp;[null,null,null,2,1,2] 示例 2：
输入: [&amp;quot;MaxQueue&amp;quot;,&amp;quot;pop_front&amp;quot;,&amp;quot;max_value&amp;quot;] [[],[],[]] 输出:&amp;nbsp;[null,-1,-1] &amp;nbsp;
限制：
1 &amp;lt;= push_back,pop_front,max_value的总操作数&amp;nbsp;&amp;lt;= 10000 1 &amp;lt;= value &amp;lt;= 10^5 type MaxQueue struct { } func Constructor() MaxQueue { } func (this *MaxQueue) Max_value() int { } func (this *MaxQueue) Push_back(value int) { } func (this *MaxQueue) Pop_front() int { } /** * Your MaxQueue object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.</description></item><item><title>剑指 Offer 60 n个骰子的点数</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/nge-tou-zi-de-dian-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/nge-tou-zi-de-dian-shu-lcof/</guid><description>剑指 Offer 60 n个骰子的点数 把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。
&amp;nbsp;
你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。
&amp;nbsp;
示例 1:
输入: 1 输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667] 示例&amp;nbsp;2:
输入: 2 输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778] &amp;nbsp;
限制：
1 &amp;lt;= n &amp;lt;= 11
func dicesProbability(n int) []float64 { } LeetCode题库地址 https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof</description></item><item><title>剑指 Offer II 066 单词之和</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/z1r5dt/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/z1r5dt/</guid><description>剑指 Offer II 066 单词之和 实现一个 MapSum 类，支持两个方法，insert&amp;nbsp;和&amp;nbsp;sum：
MapSum() 初始化 MapSum 对象 void insert(String key, int val) 插入 key-val 键值对，字符串表示键 key ，整数表示值 val 。如果键 key 已经存在，那么原来的键值对将被替代成新的键值对。 int sum(string prefix) 返回所有以该前缀 prefix 开头的键 key 的值的总和。 &amp;nbsp;
示例：
输入： inputs = [&amp;quot;MapSum&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;sum&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;sum&amp;quot;] inputs = [[], [&amp;quot;apple&amp;quot;, 3], [&amp;quot;ap&amp;quot;], [&amp;quot;app&amp;quot;, 2], [&amp;quot;ap&amp;quot;]] 输出： [null, null, 3, null, 5] 解释： MapSum mapSum = new MapSum(); mapSum.insert(&amp;quot;apple&amp;quot;, 3); mapSum.sum(&amp;quot;ap&amp;quot;); // return 3 (apple = 3) mapSum.insert(&amp;quot;app&amp;quot;, 2); mapSum.</description></item><item><title>面试题 16.05 阶乘尾数</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/factorial-zeros-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/factorial-zeros-lcci/</guid><description>面试题 16.05 阶乘尾数 设计一个算法，算出 n 阶乘有多少个尾随零。
示例 1:
输入: 3 输出: 0 解释:&amp;nbsp;3! = 6, 尾数中没有零。 示例&amp;nbsp;2:
输入: 5 输出: 1 解释:&amp;nbsp;5! = 120, 尾数中有 1 个零. 说明: 你算法的时间复杂度应为&amp;nbsp;O(log&amp;nbsp;n)&amp;nbsp;。
func trailingZeroes(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/factorial-zeros-lcci</description></item><item><title>剑指 Offer 61 扑克牌中的顺子</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/bu-ke-pai-zhong-de-shun-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/bu-ke-pai-zhong-de-shun-zi-lcof/</guid><description>剑指 Offer 61 扑克牌中的顺子 从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。
&amp;nbsp;
示例&amp;nbsp;1:
输入: [1,2,3,4,5] 输出: True &amp;nbsp;
示例&amp;nbsp;2:
输入: [0,0,1,2,5] 输出: True &amp;nbsp;
限制：
数组长度为 5&amp;nbsp;
数组的数取值为 [0, 13] .
func isStraight(nums []int) bool { } LeetCode题库地址 https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof</description></item><item><title>剑指 Offer II 067 最大的异或</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/ms70ja/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/ms70ja/</guid><description>剑指 Offer II 067 最大的异或 给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j &amp;lt; n 。
&amp;nbsp;
示例 1：
输入：nums = [3,10,5,25,2,8] 输出：28 解释：最大运算结果是 5 XOR 25 = 28. 示例 2：
输入：nums = [14,70,53,83,49,91,36,80,92,51,66,70] 输出：127 &amp;nbsp;
提示：
1 &amp;lt;= nums.length &amp;lt;= 2 * 105 0 &amp;lt;= nums[i] &amp;lt;= 231 - 1 &amp;nbsp;
注意：本题与主站 421&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/
func findMaximumXOR(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/ms70jA</description></item><item><title>面试题 16.06 最小差</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/smallest-difference-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/smallest-difference-lcci/</guid><description>面试题 16.06 最小差 给定两个整数数组a和b，计算具有最小差绝对值的一对数值（每个数组中取一个值），并返回该对数值的差
示例：
输入：{1, 3, 15, 11, 2}, {23, 127, 235, 19, 8} 输出：3，即数值对(11, 8) 提示：
1 &lt;= a.length, b.length &lt;= 100000 -2147483648 &lt;= a[i], b[i] &lt;= 2147483647 正确结果在区间 [0, 2147483647] 内 func smallestDifference(a []int, b []int) int { } LeetCode题库地址 https://leetcode.cn/problems/smallest-difference-lcci</description></item><item><title>剑指 Offer 62 圆圈中最后剩下的数字</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</guid><description>剑指 Offer 62 圆圈中最后剩下的数字 0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。
例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。
示例 1：
输入: n = 5, m = 3 输出: 3 示例 2：
输入: n = 10, m = 17 输出: 2 限制：
1 &lt;= n &lt;= 10^5 1 &lt;= m &lt;= 10^6 func lastRemaining(n int, m int) int { } LeetCode题库地址 https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof</description></item><item><title>剑指 Offer II 068 查找插入位置</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/n6ydxv/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/n6ydxv/</guid><description>剑指 Offer II 068 查找插入位置 给定一个排序的整数数组 nums&amp;nbsp;和一个整数目标值 target ，请在数组中找到&amp;nbsp;target&amp;nbsp;，并返回其下标。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
请必须使用时间复杂度为 O(log n) 的算法。
&amp;nbsp;
示例 1:
输入: nums = [1,3,5,6], target = 5 输出: 2 示例&amp;nbsp;2:
输入: nums = [1,3,5,6], target = 2 输出: 1 示例 3:
输入: nums = [1,3,5,6], target = 7 输出: 4 示例 4:
输入: nums = [1,3,5,6], target = 0 输出: 0 示例 5:
输入: nums = [1], target = 0 输出: 0 &amp;nbsp;
提示:
1 &amp;lt;= nums.length &amp;lt;= 104 -104 &amp;lt;= nums[i] &amp;lt;= 104 nums 为无重复元素的升序排列数组 -104 &amp;lt;= target &amp;lt;= 104 &amp;nbsp;</description></item><item><title>面试题 16.07 最大数值</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/maximum-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/maximum-lcci/</guid><description>面试题 16.07 最大数值 编写一个方法，找出两个数字a和b中最大的那一个。不得使用if-else或其他比较运算符。
示例：
输入： a = 1, b = 2 输出： 2 func maximum(a int, b int) int { } LeetCode题库地址 https://leetcode.cn/problems/maximum-lcci</description></item><item><title>剑指 Offer 63 股票的最大利润</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/gu-piao-de-zui-da-li-run-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/gu-piao-de-zui-da-li-run-lcof/</guid><description>剑指 Offer 63 股票的最大利润 假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？
&amp;nbsp;
示例 1:
输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2:
输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 &amp;nbsp;
限制：
0 &amp;lt;= 数组长度 &amp;lt;= 10^5
&amp;nbsp;
注意：本题与主站 121 题相同：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/
func maxProfit(prices []int) int { } LeetCode题库地址 https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof</description></item><item><title>剑指 Offer II 069 山峰数组的顶部</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/b1iidl/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/b1iidl/</guid><description>剑指 Offer II 069 山峰数组的顶部 符合下列属性的数组 arr 称为 山峰数组（山脉数组） ：
arr.length &amp;gt;= 3 存在 i（0 &amp;lt; i&amp;nbsp;&amp;lt; arr.length - 1）使得： arr[0] &amp;lt; arr[1] &amp;lt; ... arr[i-1] &amp;lt; arr[i] arr[i] &amp;gt; arr[i+1] &amp;gt; ... &amp;gt; arr[arr.length - 1] 给定由整数组成的山峰数组 arr ，返回任何满足 arr[0] &amp;lt; arr[1] &amp;lt; ... arr[i - 1] &amp;lt; arr[i] &amp;gt; arr[i + 1] &amp;gt; ... &amp;gt; arr[arr.length - 1] 的下标 i&amp;nbsp;，即山峰顶部。
&amp;nbsp;
示例 1：
输入：arr = [0,1,0] 输出：1 示例 2：
输入：arr = [1,3,5,4,2] 输出：2 示例 3：</description></item><item><title>面试题 16.08 整数的英语表示</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/english-int-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/english-int-lcci/</guid><description>面试题 16.08 整数的英语表示 给定一个整数，打印该整数的英文描述。
示例 1:
输入: 123 输出: "One Hundred Twenty Three" 示例 2:
输入: 12345 输出: "Twelve Thousand Three Hundred Forty Five" 示例 3:
输入: 1234567 输出: "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven" 示例 4:
输入: 1234567891 输出: "One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One" 注意：本题与 273 题相同：https://leetcode-cn.com/problems/integer-to-english-words/
func numberToWords(num int) string { } LeetCode题库地址 https://leetcode.cn/problems/english-int-lcci</description></item><item><title>剑指 Offer 64 求1+2+…+n</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/qiu-12n-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/qiu-12n-lcof/</guid><description>剑指 Offer 64 求1+2+…+n 求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
&amp;nbsp;
示例 1：
输入: n = 3 输出:&amp;nbsp;6 示例 2：
输入: n = 9 输出:&amp;nbsp;45 &amp;nbsp;
限制：
1 &amp;lt;= n&amp;nbsp;&amp;lt;= 10000 func sumNums(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/qiu-12n-lcof</description></item><item><title>剑指 Offer II 070 排序数组中只出现一次的数字</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/skftm2/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/skftm2/</guid><description>剑指 Offer II 070 排序数组中只出现一次的数字 给定一个只包含整数的有序数组 nums&amp;nbsp;，每个元素都会出现两次，唯有一个数只会出现一次，请找出这个唯一的数字。
你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。
&amp;nbsp;
示例 1:
输入: nums = [1,1,2,3,3,4,4,8,8] 输出: 2 示例 2:
输入: nums = [3,3,7,7,10,11,11] 输出: 10 &amp;nbsp;
提示:
1 &amp;lt;= nums.length &amp;lt;= 105 0 &amp;lt;= nums[i]&amp;nbsp;&amp;lt;= 105 &amp;nbsp;
注意：本题与主站 540&amp;nbsp;题相同：https://leetcode-cn.com/problems/single-element-in-a-sorted-array/
func singleNonDuplicate(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/skFtm2</description></item><item><title>面试题 16.09 运算</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/operations-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/operations-lcci/</guid><description>面试题 16.09 运算 请实现整数数字的乘法、减法和除法运算，运算结果均为整数数字，程序中只允许使用加法运算符和逻辑运算符，允许程序中出现正负常数，不允许使用位运算。
你的实现应该支持如下操作：
Operations() 构造函数 minus(a, b) 减法，返回a - b multiply(a, b) 乘法，返回a * b divide(a, b) 除法，返回a / b 示例：
Operations operations = new Operations(); operations.minus(1, 2); //返回-1 operations.multiply(3, 4); //返回12 operations.divide(5, -2); //返回-2 提示：
你可以假设函数输入一定是有效的，例如不会出现除法分母为0的情况 单个用例的函数调用次数不会超过1000次 type Operations struct { } func Constructor() Operations { } func (this *Operations) Minus(a int, b int) int { } func (this *Operations) Multiply(a int, b int) int { } func (this *Operations) Divide(a int, b int) int { } /** * Your Operations object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.</description></item><item><title>剑指 Offer 65 不用加减乘除做加法</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/</guid><description>剑指 Offer 65 不用加减乘除做加法 写一个函数，求两个整数之和，要求在函数体内不得使用 &amp;ldquo;+&amp;rdquo;、&amp;ldquo;-&amp;rdquo;、&amp;ldquo;*&amp;rdquo;、&amp;ldquo;/&amp;rdquo; 四则运算符号。
&amp;nbsp;
示例:
输入: a = 1, b = 1 输出: 2 &amp;nbsp;
提示：
a,&amp;nbsp;b&amp;nbsp;均可能是负数或 0 结果不会溢出 32 位整数 func add(a int, b int) int { } LeetCode题库地址 https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof</description></item><item><title>剑指 Offer II 071 按权重生成随机数</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/cuyjef/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/cuyjef/</guid><description>剑指 Offer II 071 按权重生成随机数 给定一个正整数数组&amp;nbsp;w ，其中&amp;nbsp;w[i]&amp;nbsp;代表下标 i&amp;nbsp;的权重（下标从 0 开始），请写一个函数&amp;nbsp;pickIndex&amp;nbsp;，它可以随机地获取下标 i，选取下标 i&amp;nbsp;的概率与&amp;nbsp;w[i]&amp;nbsp;成正比。
例如，对于 w = [1, 3]，挑选下标 0 的概率为 1 / (1 + 3)&amp;nbsp;= 0.25 （即，25%），而选取下标 1 的概率为 3 / (1 + 3)&amp;nbsp;= 0.75（即，75%）。
也就是说，选取下标 i 的概率为 w[i] / sum(w) 。
&amp;nbsp;
示例 1：
输入： inputs = [&amp;quot;Solution&amp;quot;,&amp;quot;pickIndex&amp;quot;] inputs = [[[1]],[]] 输出： [null,0] 解释： Solution solution = new Solution([1]); solution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。 示例 2：
输入： inputs = [&amp;quot;Solution&amp;quot;,&amp;quot;pickIndex&amp;quot;,&amp;quot;pickIndex&amp;quot;,&amp;quot;pickIndex&amp;quot;,&amp;quot;pickIndex&amp;quot;,&amp;quot;pickIndex&amp;quot;] inputs = [[[1,3]],[],[],[],[],[]] 输出： [null,1,1,1,1,0] 解释： Solution solution = new Solution([1, 3]); solution.</description></item><item><title>面试题 16.10 生存人数</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/living-people-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/living-people-lcci/</guid><description>面试题 16.10 生存人数 给定 N 个人的出生年份和死亡年份，第 i 个人的出生年份为 birth[i]，死亡年份为 death[i]，实现一个方法以计算生存人数最多的年份。
你可以假设所有人都出生于 1900 年至 2000 年（含 1900 和 2000 ）之间。如果一个人在某一年的任意时期处于生存状态，那么他应该被纳入那一年的统计中。例如，生于 1908 年、死于 1909 年的人应当被列入 1908 年和 1909 年的计数。
如果有多个年份生存人数相同且均为最大值，输出其中最小的年份。
示例：
输入： birth = {1900, 1901, 1950} death = {1948, 1951, 2000} 输出： 1901 提示：
0 &lt; birth.length == death.length &lt;= 10000 birth[i] &lt;= death[i] func maxAliveYear(birth []int, death []int) int { } LeetCode题库地址 https://leetcode.cn/problems/living-people-lcci</description></item><item><title>剑指 Offer 66 构建乘积数组</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/gou-jian-cheng-ji-shu-zu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/gou-jian-cheng-ji-shu-zu-lcof/</guid><description>剑指 Offer 66 构建乘积数组 给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。
示例:
输入: [1,2,3,4,5] 输出: [120,60,40,30,24] 提示：
所有元素乘积之和不会溢出 32 位整数 a.length &lt;= 100000 func constructArr(a []int) []int { } LeetCode题库地址 https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof</description></item><item><title>剑指 Offer II 072 求平方根</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/jj0w9p/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/jj0w9p/</guid><description>剑指 Offer II 072 求平方根 给定一个非负整数 x ，计算并返回 x 的平方根，即实现&amp;nbsp;int sqrt(int x)&amp;nbsp;函数。
正数的平方根有两个，只输出其中的正数平方根。
如果平方根不是整数，输出只保留整数的部分，小数部分将被舍去。
&amp;nbsp;
示例 1:
输入: x = 4 输出: 2 示例 2:
输入: x = 8 输出: 2 解释: 8 的平方根是 2.82842...，由于小数部分将被舍去，所以返回 2 &amp;nbsp;
提示:
0 &amp;lt;= x &amp;lt;= 231&amp;nbsp;- 1 &amp;nbsp;
注意：本题与主站 69&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/sqrtx/
func mySqrt(x int) int { } LeetCode题库地址 https://leetcode.cn/problems/jJ0w9p</description></item><item><title>面试题 16.11 跳水板</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/diving-board-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/diving-board-lcci/</guid><description>面试题 16.11 跳水板 你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。
返回的长度需要从小到大排列。
示例 1
输入： shorter = 1 longer = 2 k = 3 输出： [3,4,5,6] 解释： 可以使用 3 次 shorter，得到结果 3；使用 2 次 shorter 和 1 次 longer，得到结果 4 。以此类推，得到最终结果。 提示：
0 &amp;lt; shorter &amp;lt;= longer 0 &amp;lt;= k &amp;lt;= 100000 func divingBoard(shorter int, longer int, k int) []int { } LeetCode题库地址 https://leetcode.cn/problems/diving-board-lcci</description></item><item><title>剑指 Offer 67 把字符串转换成整数</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/</guid><description>剑指 Offer 67 把字符串转换成整数 写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。
&amp;nbsp;
首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。
当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。
该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。
注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。
在任何情况下，若函数不能进行有效的转换时，请返回 0。
说明：
假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为&amp;nbsp;[&amp;minus;231,&amp;nbsp; 231&amp;nbsp;&amp;minus; 1]。如果数值超过这个范围，请返回 &amp;nbsp;INT_MAX (231&amp;nbsp;&amp;minus; 1) 或&amp;nbsp;INT_MIN (&amp;minus;231) 。
示例&amp;nbsp;1:
输入: &amp;quot;42&amp;quot; 输出: 42 示例&amp;nbsp;2:
输入: &amp;quot; -42&amp;quot; 输出: -42 解释: 第一个非空白字符为 &amp;#39;-&amp;#39;, 它是一个负号。 &amp;nbsp; 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例&amp;nbsp;3:
输入: &amp;quot;4193 with words&amp;quot; 输出: 4193 解释: 转换截止于数字 &amp;#39;3&amp;#39; ，因为它的下一个字符不为数字。 示例&amp;nbsp;4:
输入: &amp;quot;words and 987&amp;quot; 输出: 0 解释: 第一个非空字符是 &amp;#39;w&amp;#39;, 但它不是数字或正、负号。 因此无法执行有效的转换。 示例&amp;nbsp;5:
输入: &amp;quot;-91283472332&amp;quot; 输出: -2147483648 解释: 数字 &amp;quot;-91283472332&amp;quot; 超过 32 位有符号整数范围。 &amp;nbsp; 因此返回 INT_MIN (&amp;minus;231) 。 &amp;nbsp;</description></item><item><title>剑指 Offer II 073 狒狒吃香蕉</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/nzzqjq/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/nzzqjq/</guid><description>剑指 Offer II 073 狒狒吃香蕉 狒狒喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有&amp;nbsp;piles[i]&amp;nbsp;根香蕉。警卫已经离开了，将在 h 小时后回来。
狒狒可以决定她吃香蕉的速度 k （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉，下一个小时才会开始吃另一堆的香蕉。&amp;nbsp;&amp;nbsp;
狒狒喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。
返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。
&amp;nbsp;
示例 1：
输入：piles = [3,6,7,11], h = 8 输出：4 示例 2：
输入：piles = [30,11,23,4,20], h = 5 输出：30 示例 3：
输入：piles = [30,11,23,4,20], h = 6 输出：23 &amp;nbsp;
提示：
1 &amp;lt;= piles.length &amp;lt;= 104 piles.length &amp;lt;= h &amp;lt;= 109 1 &amp;lt;= piles[i] &amp;lt;= 109 &amp;nbsp;
注意：本题与主站 875&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/koko-eating-bananas/
func minEatingSpeed(piles []int, h int) int { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 16.13 平分正方形</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/bisect-squares-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/bisect-squares-lcci/</guid><description>面试题 16.13 平分正方形 给定两个正方形及一个二维平面。请找出将这两个正方形分割成两半的一条直线。假设正方形顶边和底边与 x 轴平行。
每个正方形的数据square包含3个数值，正方形的左下顶点坐标[X,Y] = [square[0],square[1]]，以及正方形的边长square[2]。所求直线穿过两个正方形会形成4个交点，请返回4个交点形成线段的两端点坐标（两个端点即为4个交点中距离最远的2个点，这2个点所连成的线段一定会穿过另外2个交点）。2个端点坐标[X1,Y1]和[X2,Y2]的返回格式为{X1,Y1,X2,Y2}，要求若X1 != X2，需保证X1 &amp;lt; X2，否则需保证Y1 &amp;lt;= Y2。
若同时有多条直线满足要求，则选择斜率最大的一条计算并返回（与Y轴平行的直线视为斜率无穷大）。
示例：
输入： square1 = {-1, -1, 2} square2 = {0, -1, 2} 输出： {-1,0,2,0} 解释： 直线 y = 0 能将两个正方形同时分为等面积的两部分，返回的两线段端点为[-1,0]和[2,0] 提示：
square.length == 3 square[2] &amp;gt; 0 func cutSquares(square1 []int, square2 []int) []float64 { } LeetCode题库地址 https://leetcode.cn/problems/bisect-squares-lcci</description></item><item><title>剑指 Offer 68 - I 二叉搜索树的最近公共祖先</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/</guid><description>剑指 Offer 68 - I 二叉搜索树的最近公共祖先 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：&amp;ldquo;对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。&amp;rdquo;
例如，给定如下二叉搜索树:&amp;nbsp; root =&amp;nbsp;[6,2,8,0,4,7,9,null,null,3,5]
&amp;nbsp;
示例 1:
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2:
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 输出: 2 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 &amp;nbsp;
说明:
所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。 注意：本题与主站 235 题相同：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/
LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer II 074 合并区间</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/ssgohc/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/ssgohc/</guid><description>剑指 Offer II 074 合并区间 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。
&amp;nbsp;
示例 1：
输入：intervals = [[1,3],[2,6],[8,10],[15,18]] 输出：[[1,6],[8,10],[15,18]] 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例&amp;nbsp;2：
输入：intervals = [[1,4],[4,5]] 输出：[[1,5]] 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。 &amp;nbsp;
提示：
1 &amp;lt;= intervals.length &amp;lt;= 104 intervals[i].length == 2 0 &amp;lt;= starti &amp;lt;= endi &amp;lt;= 104 &amp;nbsp;
注意：本题与主站 56&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/merge-intervals/
func merge(intervals [][]int) [][]int { } LeetCode题库地址 https://leetcode.cn/problems/SsGoHC</description></item><item><title>面试题 16.14 最佳直线</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/best-line-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/best-line-lcci/</guid><description>面试题 16.14 最佳直线 给定一个二维平面及平面上的 N 个点列表Points，其中第i个点的坐标为Points[i]=[Xi,Yi]。请找出一条直线，其通过的点的数目最多。
设穿过最多点的直线所穿过的全部点编号从小到大排序的列表为S，你仅需返回[S[0],S[1]]作为答案，若有多条直线穿过了相同数量的点，则选择S[0]值较小的直线返回，S[0]相同则选择S[1]值较小的直线返回。
示例：
输入： [[0,0],[1,1],[1,0],[2,0]] 输出： [0,2] 解释： 所求直线穿过的3个点的编号为[0,2,3] 提示：
2 &lt;= len(Points) &lt;= 300 len(Points[i]) = 2 func bestLine(points [][]int) []int { } LeetCode题库地址 https://leetcode.cn/problems/best-line-lcci</description></item><item><title>剑指 Offer 68 - II 二叉树的最近公共祖先</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/</guid><description>剑指 Offer 68 - II 二叉树的最近公共祖先 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：&amp;ldquo;对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。&amp;rdquo;
例如，给定如下二叉树:&amp;nbsp; root =&amp;nbsp;[3,5,1,6,2,0,8,null,null,7,4]
&amp;nbsp;
示例 1:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例&amp;nbsp;2:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 &amp;nbsp;
说明:
所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。 注意：本题与主站 236 题相同：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/
/** * Definition for a binary tree node.</description></item><item><title>剑指 Offer II 075 数组相对排序</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/0h97zc/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/0h97zc/</guid><description>剑指 Offer II 075 数组相对排序 给定两个数组，arr1 和&amp;nbsp;arr2，
arr2&amp;nbsp;中的元素各不相同 arr2 中的每个元素都出现在&amp;nbsp;arr1&amp;nbsp;中 对 arr1&amp;nbsp;中的元素进行排序，使 arr1 中项的相对顺序和&amp;nbsp;arr2&amp;nbsp;中的相对顺序相同。未在&amp;nbsp;arr2&amp;nbsp;中出现过的元素需要按照升序放在&amp;nbsp;arr1&amp;nbsp;的末尾。
&amp;nbsp;
示例：
输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6] 输出：[2,2,2,1,4,3,3,9,6,7,19] &amp;nbsp;
提示：
1 &amp;lt;= arr1.length, arr2.length &amp;lt;= 1000 0 &amp;lt;= arr1[i], arr2[i] &amp;lt;= 1000 arr2&amp;nbsp;中的元素&amp;nbsp;arr2[i]&amp;nbsp;各不相同 arr2 中的每个元素&amp;nbsp;arr2[i]&amp;nbsp;都出现在&amp;nbsp;arr1&amp;nbsp;中 &amp;nbsp;
注意：本题与主站 1122&amp;nbsp;题相同：https://leetcode-cn.com/problems/relative-sort-array/&amp;nbsp;
func relativeSortArray(arr1 []int, arr2 []int) []int { } LeetCode题库地址 https://leetcode.cn/problems/0H97ZC</description></item><item><title>面试题 16.15 珠玑妙算</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/master-mind-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/master-mind-lcci/</guid><description>面试题 16.15 珠玑妙算 珠玑妙算游戏（the game of master mind）的玩法如下。
计算机有4个槽，每个槽放一个球，颜色可能是红色（R）、黄色（Y）、绿色（G）或蓝色（B）。例如，计算机可能有RGGB 4种（槽1为红色，槽2、3为绿色，槽4为蓝色）。作为用户，你试图猜出颜色组合。打个比方，你可能会猜YRGB。要是猜对某个槽的颜色，则算一次“猜中”；要是只猜对颜色但槽位猜错了，则算一次“伪猜中”。注意，“猜中”不能算入“伪猜中”。
给定一种颜色组合solution和一个猜测guess，编写一个方法，返回猜中和伪猜中的次数answer，其中answer[0]为猜中的次数，answer[1]为伪猜中的次数。
示例：
输入： solution="RGBY",guess="GGRR" 输出： [1,1] 解释： 猜中1次，伪猜中1次。 提示：
len(solution) = len(guess) = 4 solution和guess仅包含"R","G","B","Y"这4种字符 func masterMind(solution string, guess string) []int { } LeetCode题库地址 https://leetcode.cn/problems/master-mind-lcci</description></item><item><title>剑指 Offer II 076 数组中的第 k 大的数字</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/xx4gt2/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/xx4gt2/</guid><description>剑指 Offer II 076 数组中的第 k 大的数字 给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。
请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
&amp;nbsp;
示例 1:
输入: [3,2,1,5,6,4] 和 k = 2 输出: 5 示例&amp;nbsp;2:
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4 输出: 4 &amp;nbsp;
提示： 1 &amp;lt;= k &amp;lt;= nums.length &amp;lt;= 104 -104&amp;nbsp;&amp;lt;= nums[i] &amp;lt;= 104 &amp;nbsp;
注意：本题与主站 215&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/kth-largest-element-in-an-array/
func findKthLargest(nums []int, k int) int { } LeetCode题库地址 https://leetcode.cn/problems/xx4gT2</description></item><item><title>面试题 16.16 部分排序</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sub-sort-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sub-sort-lcci/</guid><description>面试题 16.16 部分排序 给定一个整数数组，编写一个函数，找出索引m和n，只要将索引区间[m,n]的元素排好序，整个数组就是有序的。注意：n-m尽量最小，也就是说，找出符合条件的最短序列。函数返回值为[m,n]，若不存在这样的m和n（例如整个数组是有序的），请返回[-1,-1]。
示例：
输入： [1,2,4,7,10,11,7,12,6,7,16,18,19] 输出： [3,9] 提示：
0 &lt;= len(array) &lt;= 1000000 func subSort(array []int) []int { } LeetCode题库地址 https://leetcode.cn/problems/sub-sort-lcci</description></item><item><title>剑指 Offer II 077 链表排序</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/7whec2/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/7whec2/</guid><description>剑指 Offer II 077 链表排序 给定链表的头结点&amp;nbsp;head&amp;nbsp;，请将其按 升序 排列并返回 排序后的链表 。
&amp;nbsp;
示例 1：
输入：head = [4,2,1,3] 输出：[1,2,3,4] 示例 2：
输入：head = [-1,5,3,4,0] 输出：[-1,0,3,4,5] 示例 3：
输入：head = [] 输出：[] &amp;nbsp;
提示：
链表中节点的数目在范围&amp;nbsp;[0, 5 * 104]&amp;nbsp;内 -105&amp;nbsp;&amp;lt;= Node.val &amp;lt;= 105 &amp;nbsp;
进阶：你可以在&amp;nbsp;O(n&amp;nbsp;log&amp;nbsp;n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？
&amp;nbsp;
注意：本题与主站 148&amp;nbsp;题相同：https://leetcode-cn.com/problems/sort-list/
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func sortList(head *ListNode) *ListNode { } LeetCode题库地址 https://leetcode.cn/problems/7WHec2</description></item><item><title>面试题 16.17 连续数列</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/contiguous-sequence-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/contiguous-sequence-lcci/</guid><description>面试题 16.17 连续数列 给定一个整数数组，找出总和最大的连续数列，并返回总和。
示例：
输入： [-2,1,-3,4,-1,2,1,-5,4] 输出： 6 解释： 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶：
如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。
func maxSubArray(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/contiguous-sequence-lcci</description></item><item><title>剑指 Offer II 078 合并排序链表</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/vvxgsw/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/vvxgsw/</guid><description>剑指 Offer II 078 合并排序链表 给定一个链表数组，每个链表都已经按升序排列。
请将所有链表合并到一个升序链表中，返回合并后的链表。
&amp;nbsp;
示例 1：
输入：lists = [[1,4,5],[1,3,4],[2,6]] 输出：[1,1,2,3,4,4,5,6] 解释：链表数组如下： [ 1-&amp;gt;4-&amp;gt;5, 1-&amp;gt;3-&amp;gt;4, 2-&amp;gt;6 ] 将它们合并到一个有序链表中得到。 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6 示例 2：
输入：lists = [] 输出：[] 示例 3：
输入：lists = [[]] 输出：[] &amp;nbsp;
提示：
k == lists.length 0 &amp;lt;= k &amp;lt;= 10^4 0 &amp;lt;= lists[i].length &amp;lt;= 500 -10^4 &amp;lt;= lists[i][j] &amp;lt;= 10^4 lists[i] 按 升序 排列 lists[i].length 的总和不超过 10^4 &amp;nbsp;
注意：本题与主站 23&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/merge-k-sorted-lists/
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeKLists(lists []*ListNode) *ListNode { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 16.18 模式匹配</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/pattern-matching-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/pattern-matching-lcci/</guid><description>面试题 16.18 模式匹配 你有两个字符串，即pattern和value。 pattern字符串由字母&amp;quot;a&amp;quot;和&amp;quot;b&amp;quot;组成，用于描述字符串中的模式。例如，字符串&amp;quot;catcatgocatgo&amp;quot;匹配模式&amp;quot;aabab&amp;quot;（其中&amp;quot;cat&amp;quot;是&amp;quot;a&amp;quot;，&amp;quot;go&amp;quot;是&amp;quot;b&amp;quot;），该字符串也匹配像&amp;quot;a&amp;quot;、&amp;quot;ab&amp;quot;和&amp;quot;b&amp;quot;这样的模式。但需注意&amp;quot;a&amp;quot;和&amp;quot;b&amp;quot;不能同时表示相同的字符串。编写一个方法判断value字符串是否匹配pattern字符串。
示例 1：
输入： pattern = &amp;quot;abba&amp;quot;, value = &amp;quot;dogcatcatdog&amp;quot; 输出： true 示例 2：
输入： pattern = &amp;quot;abba&amp;quot;, value = &amp;quot;dogcatcatfish&amp;quot; 输出： false 示例 3：
输入： pattern = &amp;quot;aaaa&amp;quot;, value = &amp;quot;dogcatcatdog&amp;quot; 输出： false 示例 4：
输入： pattern = &amp;quot;abba&amp;quot;, value = &amp;quot;dogdogdogdog&amp;quot; 输出： true 解释： &amp;quot;a&amp;quot;=&amp;quot;dogdog&amp;quot;,b=&amp;quot;&amp;quot;，反之也符合规则 提示：
1 &amp;lt;= len(pattern) &amp;lt;= 1000 0 &amp;lt;= len(value) &amp;lt;= 1000 你可以假设pattern只包含字母&amp;quot;a&amp;quot;和&amp;quot;b&amp;quot;，value仅包含小写字母。 func patternMatching(pattern string, value string) bool { } LeetCode题库地址 https://leetcode.cn/problems/pattern-matching-lcci</description></item><item><title>剑指 Offer II 079 所有子集</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/tvdhkn/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/tvdhkn/</guid><description>剑指 Offer II 079 所有子集 给定一个整数数组&amp;nbsp;nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。
&amp;nbsp;
示例 1：
输入：nums = [1,2,3] 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] 示例 2：
输入：nums = [0] 输出：[[],[0]] &amp;nbsp;
提示：
1 &amp;lt;= nums.length &amp;lt;= 10 -10 &amp;lt;= nums[i] &amp;lt;= 10 nums 中的所有元素 互不相同 &amp;nbsp;
注意：本题与主站 78&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/subsets/
func subsets(nums []int) [][]int { } LeetCode题库地址 https://leetcode.cn/problems/TVdhkn</description></item><item><title>面试题 16.19 水域大小</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/pond-sizes-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/pond-sizes-lcci/</guid><description>面试题 16.19 水域大小 你有一个用于表示一片土地的整数矩阵land，该矩阵中每个点的值代表对应地点的海拔高度。若值为0则表示水域。由垂直、水平或对角连接的水域为池塘。池塘的大小是指相连接的水域的个数。编写一个方法来计算矩阵中所有池塘的大小，返回值需要从小到大排序。
示例：
输入： [ [0,2,1,0], [0,1,0,1], [1,1,0,1], [0,1,0,1] ] 输出： [1,2,4] 提示：
0 &lt; len(land) &lt;= 1000 0 &lt; len(land[i]) &lt;= 1000 func pondSizes(land [][]int) []int { } LeetCode题库地址 https://leetcode.cn/problems/pond-sizes-lcci</description></item><item><title>剑指 Offer II 080 含有 k 个元素的组合</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/uusw3b/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/uusw3b/</guid><description>剑指 Offer II 080 含有 k 个元素的组合 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。
&amp;nbsp;
示例 1:
输入:&amp;nbsp;n = 4, k = 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] 示例 2:
输入:&amp;nbsp;n = 1, k = 1 输出: [[1]] &amp;nbsp;
提示:
1 &amp;lt;= n &amp;lt;= 20 1 &amp;lt;= k &amp;lt;= n &amp;nbsp;
注意：本题与主站 77&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/combinations/
func combine(n int, k int) [][]int { } LeetCode题库地址 https://leetcode.cn/problems/uUsW3B</description></item><item><title>面试题 16.20 T9键盘</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/t9-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/t9-lcci/</guid><description>面试题 16.20 T9键盘 在老式手机上，用户通过数字键盘输入，手机将提供与这些数字相匹配的单词列表。每个数字映射到0至4个字母。给定一个数字序列，实现一个算法来返回匹配单词的列表。你会得到一张含有有效单词的列表。映射如下图所示：
示例 1:
输入: num = &amp;quot;8733&amp;quot;, words = [&amp;quot;tree&amp;quot;, &amp;quot;used&amp;quot;] 输出: [&amp;quot;tree&amp;quot;, &amp;quot;used&amp;quot;] 示例 2:
输入: num = &amp;quot;2&amp;quot;, words = [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;] 输出: [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;] 提示：
num.length &amp;lt;= 1000 words.length &amp;lt;= 500 words[i].length == num.length num中不会出现 0, 1 这两个数字 func getValidT9Words(num string, words []string) []string { } LeetCode题库地址 https://leetcode.cn/problems/t9-lcci</description></item><item><title>剑指 Offer II 081 允许重复选择元素的组合</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/ygoe9j/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/ygoe9j/</guid><description>剑指 Offer II 081 允许重复选择元素的组合 给定一个无重复元素的正整数数组&amp;nbsp;candidates&amp;nbsp;和一个正整数&amp;nbsp;target&amp;nbsp;，找出&amp;nbsp;candidates&amp;nbsp;中所有可以使数字和为目标数&amp;nbsp;target&amp;nbsp;的唯一组合。
candidates&amp;nbsp;中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是不同的。&amp;nbsp;
对于给定的输入，保证和为&amp;nbsp;target 的唯一组合数少于 150 个。
&amp;nbsp;
示例&amp;nbsp;1：
输入: candidates = [2,3,6,7], target = 7 输出: [[7],[2,2,3]] 示例&amp;nbsp;2：
输入: candidates = [2,3,5], target = 8 输出: [[2,2,2,2],[2,3,3],[3,5]] 示例 3：
输入: candidates = [2], target = 1 输出: [] 示例 4：
输入: candidates = [1], target = 1 输出: [[1]] 示例 5：
输入: candidates = [1], target = 2 输出: [[1,1]] &amp;nbsp;
提示：
1 &amp;lt;= candidates.length &amp;lt;= 30 1 &amp;lt;= candidates[i] &amp;lt;= 200 candidate 中的每个元素都是独一无二的。 1 &amp;lt;= target &amp;lt;= 500 &amp;nbsp;</description></item><item><title>面试题 16.21 交换和</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sum-swap-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sum-swap-lcci/</guid><description>面试题 16.21 交换和 给定两个整数数组，请交换一对数值（每个数组中取一个数值），使得两个数组所有元素的和相等。
返回一个数组，第一个元素是第一个数组中要交换的元素，第二个元素是第二个数组中要交换的元素。若有多个答案，返回任意一个均可。若无满足条件的数值，返回空数组。
示例:
输入: array1 = [4, 1, 2, 1, 1, 2], array2 = [3, 6, 3, 3] 输出: [1, 3] 示例:
输入: array1 = [1, 2, 3], array2 = [4, 5, 6] 输出: [] 提示：
1 &amp;lt;= array1.length, array2.length &amp;lt;= 100000 func findSwapValues(array1 []int, array2 []int) []int { } LeetCode题库地址 https://leetcode.cn/problems/sum-swap-lcci</description></item><item><title>剑指 Offer II 082 含有重复元素集合的组合</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/4sjjuc/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/4sjjuc/</guid><description>剑指 Offer II 082 含有重复元素集合的组合 给定一个可能有重复数字的整数数组&amp;nbsp;candidates&amp;nbsp;和一个目标数&amp;nbsp;target&amp;nbsp;，找出&amp;nbsp;candidates&amp;nbsp;中所有可以使数字和为&amp;nbsp;target&amp;nbsp;的组合。
candidates&amp;nbsp;中的每个数字在每个组合中只能使用一次，解集不能包含重复的组合。&amp;nbsp;
&amp;nbsp;
示例&amp;nbsp;1:
输入: candidates =&amp;nbsp;[10,1,2,7,6,1,5], target =&amp;nbsp;8, 输出: [ [1,1,6], [1,2,5], [1,7], [2,6] ] 示例&amp;nbsp;2:
输入: candidates =&amp;nbsp;[2,5,2,1,2], target =&amp;nbsp;5, 输出: [ [1,2,2], [5] ] &amp;nbsp;
提示:
1 &amp;lt;=&amp;nbsp;candidates.length &amp;lt;= 100 1 &amp;lt;=&amp;nbsp;candidates[i] &amp;lt;= 50 1 &amp;lt;= target &amp;lt;= 30 &amp;nbsp;
注意：本题与主站 40&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/combination-sum-ii/
func combinationSum2(candidates []int, target int) [][]int { } LeetCode题库地址 https://leetcode.cn/problems/4sjJUc</description></item><item><title>面试题 16.22 兰顿蚂蚁</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/langtons-ant-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/langtons-ant-lcci/</guid><description>面试题 16.22 兰顿蚂蚁 一只蚂蚁坐在由白色和黑色方格构成的无限网格上。开始时，网格全白，蚂蚁面向右侧。每行走一步，蚂蚁执行以下操作。
(1) 如果在白色方格上，则翻转方格的颜色，向右(顺时针)转 90 度，并向前移动一个单位。
(2) 如果在黑色方格上，则翻转方格的颜色，向左(逆时针方向)转 90 度，并向前移动一个单位。
编写程序来模拟蚂蚁执行的前 K 个动作，并返回最终的网格。
网格由数组表示，每个元素是一个字符串，代表网格中的一行，黑色方格由&amp;nbsp;&amp;#39;X&amp;#39;&amp;nbsp;表示，白色方格由&amp;nbsp;&amp;#39;_&amp;#39;&amp;nbsp;表示，蚂蚁所在的位置由&amp;nbsp;&amp;#39;L&amp;#39;, &amp;#39;U&amp;#39;, &amp;#39;R&amp;#39;, &amp;#39;D&amp;#39;&amp;nbsp;表示，分别表示蚂蚁&amp;nbsp;左、上、右、下 的朝向。只需要返回能够包含蚂蚁走过的所有方格的最小矩形。
示例 1:
输入: 0 输出: [&amp;quot;R&amp;quot;] 示例 2:
输入: 2 输出: [ &amp;nbsp; &amp;quot;_X&amp;quot;, &amp;nbsp; &amp;quot;LX&amp;quot; ] 示例 3:
输入: 5 输出: [ &amp;nbsp; &amp;quot;_U&amp;quot;, &amp;nbsp; &amp;quot;X_&amp;quot;, &amp;nbsp; &amp;quot;XX&amp;quot; ] 说明：
K &amp;lt;= 100000 func printKMoves(K int) []string { } LeetCode题库地址 https://leetcode.cn/problems/langtons-ant-lcci</description></item><item><title>剑指 Offer II 083 没有重复元素集合的全排列</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/vvjkup/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/vvjkup/</guid><description>剑指 Offer II 083 没有重复元素集合的全排列 给定一个不含重复数字的整数数组 nums ，返回其 所有可能的全排列 。可以 按任意顺序 返回答案。
&amp;nbsp;
示例 1：
输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 示例 2：
输入：nums = [0,1] 输出：[[0,1],[1,0]] 示例 3：
输入：nums = [1] 输出：[[1]] &amp;nbsp;
提示：
1 &amp;lt;= nums.length &amp;lt;= 6 -10 &amp;lt;= nums[i] &amp;lt;= 10 nums 中的所有整数 互不相同 &amp;nbsp;
注意：本题与主站 46&amp;nbsp;题相同：https://leetcode-cn.com/problems/permutations/&amp;nbsp;
func permute(nums []int) [][]int { } LeetCode题库地址 https://leetcode.cn/problems/VvJkup</description></item><item><title>面试题 16.24 数对和</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/pairs-with-sum-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/pairs-with-sum-lcci/</guid><description>面试题 16.24 数对和 设计一个算法，找出数组中两数之和为指定值的所有整数对。一个数只能属于一个数对。
示例 1:
输入: nums = [5,6,5], target = 11 输出: [[5,6]] 示例 2:
输入: nums = [5,6,5,6], target = 11 输出: [[5,6],[5,6]] 提示：
nums.length &amp;lt;= 100000 func pairSums(nums []int, target int) [][]int { } LeetCode题库地址 https://leetcode.cn/problems/pairs-with-sum-lcci</description></item><item><title>剑指 Offer II 084 含有重复元素集合的全排列</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/7p8l0z/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/7p8l0z/</guid><description>剑指 Offer II 084 含有重复元素集合的全排列 给定一个可包含重复数字的整数集合&amp;nbsp;nums ，按任意顺序 返回它所有不重复的全排列。
&amp;nbsp;
示例 1：
输入：nums = [1,1,2] 输出： [[1,1,2], [1,2,1], [2,1,1]] 示例 2：
输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] &amp;nbsp;
提示：
1 &amp;lt;= nums.length &amp;lt;= 8 -10 &amp;lt;= nums[i] &amp;lt;= 10 &amp;nbsp;
注意：本题与主站 47&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/permutations-ii/
func permuteUnique(nums []int) [][]int { } LeetCode题库地址 https://leetcode.cn/problems/7p8L0Z</description></item><item><title>面试题 16.25 LRU 缓存</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/lru-cache-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/lru-cache-lcci/</guid><description>面试题 16.25 LRU 缓存 设计和构建一个&amp;ldquo;最近最少使用&amp;rdquo;缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。
它应该支持以下操作： 获取数据 get 和 写入数据 put 。
获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。
写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。
示例:
LRUCache cache = new LRUCache( 2 /* 缓存容量 */ ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // 返回 1 cache.put(3, 3); // 该操作会使得密钥 2 作废 cache.get(2); // 返回 -1 (未找到) cache.put(4, 4); // 该操作会使得密钥 1 作废 cache.get(1); // 返回 -1 (未找到) cache.get(3); // 返回 3 cache.get(4); // 返回 4 type LRUCache struct { } func Constructor(capacity int) LRUCache { } func (this *LRUCache) Get(key int) int { } func (this *LRUCache) Put(key int, value int) { } /** * Your LRUCache object will be instantiated and called as such: * obj := Constructor(capacity); * param_1 := obj.</description></item><item><title>剑指 Offer II 085 生成匹配的括号</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/idbivt/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/idbivt/</guid><description>剑指 Offer II 085 生成匹配的括号 正整数&amp;nbsp;n&amp;nbsp;代表生成括号的对数，请设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
&amp;nbsp;
示例 1：
输入：n = 3 输出：[&amp;quot;((()))&amp;quot;,&amp;quot;(()())&amp;quot;,&amp;quot;(())()&amp;quot;,&amp;quot;()(())&amp;quot;,&amp;quot;()()()&amp;quot;] 示例 2：
输入：n = 1 输出：[&amp;quot;()&amp;quot;] &amp;nbsp;
提示：
1 &amp;lt;= n &amp;lt;= 8 &amp;nbsp;
注意：本题与主站 22&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/generate-parentheses/
func generateParenthesis(n int) []string { } LeetCode题库地址 https://leetcode.cn/problems/IDBivT</description></item><item><title>面试题 16.26 计算器</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/calculator-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/calculator-lcci/</guid><description>面试题 16.26 计算器 给定一个包含正整数、加(+)、减(-)、乘(*)、除(/)的算数表达式(括号除外)，计算其结果。
表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格&amp;nbsp;&amp;nbsp;。 整数除法仅保留整数部分。
示例&amp;nbsp;1:
输入: &amp;quot;3+2*2&amp;quot; 输出: 7 示例 2:
输入: &amp;quot; 3/2 &amp;quot; 输出: 1 示例 3:
输入: &amp;quot; 3+5 / 2 &amp;quot; 输出: 5 说明：
你可以假设所给定的表达式都是有效的。 请不要使用内置的库函数 eval。 func calculate(s string) int { } LeetCode题库地址 https://leetcode.cn/problems/calculator-lcci</description></item><item><title>剑指 Offer II 086 分割回文子字符串</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/m99oja/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/m99oja/</guid><description>剑指 Offer II 086 分割回文子字符串 给定一个字符串 s ，请将 s 分割成一些子串，使每个子串都是 回文串 ，返回 s 所有可能的分割方案。
回文串&amp;nbsp;是正着读和反着读都一样的字符串。
&amp;nbsp;
示例 1：
输入：s = &amp;quot;google&amp;quot; 输出：[[&amp;quot;g&amp;quot;,&amp;quot;o&amp;quot;,&amp;quot;o&amp;quot;,&amp;quot;g&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;e&amp;quot;],[&amp;quot;g&amp;quot;,&amp;quot;oo&amp;quot;,&amp;quot;g&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;e&amp;quot;],[&amp;quot;goog&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;e&amp;quot;]] 示例 2：
输入：s = &amp;quot;aab&amp;quot; 输出：[[&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;],[&amp;quot;aa&amp;quot;,&amp;quot;b&amp;quot;]] 示例 3：
输入：s = &amp;quot;a&amp;quot; 输出：[[&amp;quot;a&amp;quot;]] &amp;nbsp;
提示：
1 &amp;lt;= s.length &amp;lt;= 16 s 仅由小写英文字母组成 &amp;nbsp;
注意：本题与主站 131&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/palindrome-partitioning/
func partition(s string) [][]string { } LeetCode题库地址 https://leetcode.cn/problems/M99OJA</description></item><item><title>面试题 17.01 不用加号的加法</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/add-without-plus-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/add-without-plus-lcci/</guid><description>面试题 17.01 不用加号的加法 设计一个函数把两个数字相加。不得使用 + 或者其他算术运算符。
示例:
输入: a = 1, b = 1 输出: 2 &amp;nbsp;
提示：
a,&amp;nbsp;b&amp;nbsp;均可能是负数或 0 结果不会溢出 32 位整数 func add(a int, b int) int { } LeetCode题库地址 https://leetcode.cn/problems/add-without-plus-lcci</description></item><item><title>剑指 Offer II 087 复原 IP</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/0on3un/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/0on3un/</guid><description>剑指 Offer II 087 复原 IP 给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能从&amp;nbsp;s 获得的 有效 IP 地址 。你可以按任何顺序返回答案。
有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 &amp;#39;.&amp;#39; 分隔。
例如：&amp;quot;0.1.2.201&amp;quot; 和 &amp;quot;192.168.1.1&amp;quot; 是 有效 IP 地址，但是 &amp;quot;0.011.255.245&amp;quot;、&amp;quot;192.168.1.312&amp;quot; 和 &amp;quot;192.168@1.1&amp;quot; 是 无效 IP 地址。
&amp;nbsp;
示例 1：
输入：s = &amp;quot;25525511135&amp;quot; 输出：[&amp;quot;255.255.11.135&amp;quot;,&amp;quot;255.255.111.35&amp;quot;] 示例 2：
输入：s = &amp;quot;0000&amp;quot; 输出：[&amp;quot;0.0.0.0&amp;quot;] 示例 3：
输入：s = &amp;quot;1111&amp;quot; 输出：[&amp;quot;1.1.1.1&amp;quot;] 示例 4：
输入：s = &amp;quot;010010&amp;quot; 输出：[&amp;quot;0.10.0.10&amp;quot;,&amp;quot;0.100.1.0&amp;quot;] 示例 5：
输入：s = &amp;quot;10203040&amp;quot; 输出：[&amp;quot;10.20.30.40&amp;quot;,&amp;quot;102.0.30.40&amp;quot;,&amp;quot;10.203.0.40&amp;quot;] &amp;nbsp;
提示：
0 &amp;lt;= s.</description></item><item><title>面试题 17.04 消失的数字</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/missing-number-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/missing-number-lcci/</guid><description>面试题 17.04 消失的数字 数组nums包含从0到n的所有整数，但其中缺了一个。请编写代码找出那个缺失的整数。你有办法在O(n)时间内完成吗？
注意：本题相对书上原题稍作改动
示例 1：
输入：[3,0,1] 输出：2 &amp;nbsp;
示例 2：
输入：[9,6,4,2,3,5,7,0,1] 输出：8 func missingNumber(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/missing-number-lcci</description></item><item><title>剑指 Offer II 088 爬楼梯的最少成本</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/gzcjip/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/gzcjip/</guid><description>剑指 Offer II 088 爬楼梯的最少成本 数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值&amp;nbsp;cost[i]（下标从 0 开始）。
每当爬上一个阶梯都要花费对应的体力值，一旦支付了相应的体力值，就可以选择向上爬一个阶梯或者爬两个阶梯。
请找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。
&amp;nbsp;
示例&amp;nbsp;1：
输入：cost = [10, 15, 20] 输出：15 解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。 &amp;nbsp;示例 2：
输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 输出：6 解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。 &amp;nbsp;
提示：
2 &amp;lt;= cost.length &amp;lt;= 1000 0 &amp;lt;= cost[i] &amp;lt;= 999 &amp;nbsp;
注意：本题与主站 746&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/min-cost-climbing-stairs/
func minCostClimbingStairs(cost []int) int { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 17.05 字母与数字</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/find-longest-subarray-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/find-longest-subarray-lcci/</guid><description>面试题 17.05 字母与数字 给定一个放有字母和数字的数组，找到最长的子数组，且包含的字母和数字的个数相同。
返回该子数组，若存在多个最长子数组，返回左端点下标值最小的子数组。若不存在这样的数组，返回一个空数组。
示例 1:
输入: ["A","1","B","C","D","2","3","4","E","5","F","G","6","7","H","I","J","K","L","M"] 输出: ["A","1","B","C","D","2","3","4","E","5","F","G","6","7"] 示例 2:
输入: ["A","A"] 输出: [] 提示：
array.length &lt;= 100000 func findLongestSubarray(array []string) []string { } LeetCode题库地址 https://leetcode.cn/problems/find-longest-subarray-lcci</description></item><item><title>剑指 Offer II 089 房屋偷盗</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/gu0c2t/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/gu0c2t/</guid><description>剑指 Offer II 089 房屋偷盗 一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响小偷偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组 nums&amp;nbsp;，请计算&amp;nbsp;不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
&amp;nbsp;
示例 1：
输入：nums = [1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 &amp;nbsp; 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2：
输入：nums = [2,7,9,3,1] 输出：12 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 &amp;nbsp; 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 &amp;nbsp;
提示：
1 &amp;lt;= nums.</description></item><item><title>面试题 17.06 2出现的次数</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/number-of-2s-in-range-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/number-of-2s-in-range-lcci/</guid><description>面试题 17.06 2出现的次数 编写一个方法，计算从 0 到 n (含 n) 中数字 2 出现的次数。
示例:
输入: 25 输出: 9 解释: (2, 12, 20, 21, 22, 23, 24, 25)(注意 22 应该算作两次) 提示：
n &amp;lt;= 10^9 func numberOf2sInRange(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/number-of-2s-in-range-lcci</description></item><item><title>剑指 Offer II 090 环形房屋偷盗</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/pzwkhm/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/pzwkhm/</guid><description>剑指 Offer II 090 环形房屋偷盗 一个专业的小偷，计划偷窃一个环形街道上沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。
给定一个代表每个房屋存放金额的非负整数数组 nums ，请计算&amp;nbsp;在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。
&amp;nbsp;
示例&amp;nbsp;1：
输入：nums = [2,3,2] 输出：3 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2：
输入：nums = [1,2,3,1] 输出：4 解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 &amp;nbsp; 偷窃到的最高金额 = 1 + 3 = 4 。 示例 3：
输入：nums = [0] 输出：0 &amp;nbsp;
提示：
1 &amp;lt;= nums.length &amp;lt;= 100 0 &amp;lt;= nums[i] &amp;lt;= 1000 &amp;nbsp;
注意：本题与主站 213&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/house-robber-ii/
func rob(nums []int) int { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 17.07 婴儿名字</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/baby-names-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/baby-names-lcci/</guid><description>面试题 17.07 婴儿名字 每年，政府都会公布一万个最常见的婴儿名字和它们出现的频率，也就是同名婴儿的数量。有些名字有多种拼法，例如，John 和 Jon 本质上是相同的名字，但被当成了两个名字公布出来。给定两个列表，一个是名字及对应的频率，另一个是本质相同的名字对。设计一个算法打印出每个真实名字的实际频率。注意，如果 John 和 Jon 是相同的，并且 Jon 和 Johnny 相同，则 John 与 Johnny 也相同，即它们有传递和对称性。
在结果列表中，选择 字典序最小 的名字作为真实名字。
示例：
输入：names = ["John(15)","Jon(12)","Chris(13)","Kris(4)","Christopher(19)"], synonyms = ["(Jon,John)","(John,Johnny)","(Chris,Kris)","(Chris,Christopher)"] 输出：["John(27)","Chris(36)"] 提示：
names.length &lt;= 100000 func trulyMostPopular(names []string, synonyms []string) []string { } LeetCode题库地址 https://leetcode.cn/problems/baby-names-lcci</description></item><item><title>剑指 Offer II 091 粉刷房子</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/jej789/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/jej789/</guid><description>剑指 Offer II 091 粉刷房子 假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。
当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个&amp;nbsp;n x 3&amp;nbsp;的正整数矩阵 costs 来表示的。
例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2]&amp;nbsp;表示第 1 号房子粉刷成绿色的花费，以此类推。
请计算出粉刷完所有房子最少的花费成本。
&amp;nbsp;
示例 1：
输入: costs = [[17,2,17],[16,16,5],[14,3,19]] 输出: 10 解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。 &amp;nbsp; 最少花费: 2 + 5 + 3 = 10。 示例 2：
输入: costs = [[7,6,2]] 输出: 2 &amp;nbsp;
提示:
costs.length == n costs[i].length == 3 1 &amp;lt;= n &amp;lt;= 100 1 &amp;lt;= costs[i][j] &amp;lt;= 20 &amp;nbsp;
注意：本题与主站 256&amp;nbsp;题相同：https://leetcode-cn.com/problems/paint-house/
func minCost(costs [][]int) int { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 17.08 马戏团人塔</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/circus-tower-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/circus-tower-lcci/</guid><description>面试题 17.08 马戏团人塔 有个马戏团正在设计叠罗汉的表演节目，一个人要站在另一人的肩膀上。出于实际和美观的考虑，在上面的人要比下面的人矮一点且轻一点。已知马戏团每个人的身高和体重，请编写代码计算叠罗汉最多能叠几个人。
示例：
输入：height = [65,70,56,75,60,68] weight = [100,150,90,190,95,110] 输出：6 解释：从上往下数，叠罗汉最多能叠 6 层：(56,90), (60,95), (65,100), (68,110), (70,150), (75,190) 提示：
height.length == weight.length &lt;= 10000 func bestSeqAtIndex(height []int, weight []int) int { } LeetCode题库地址 https://leetcode.cn/problems/circus-tower-lcci</description></item><item><title>剑指 Offer II 092 翻转字符</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/cyjerh/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/cyjerh/</guid><description>剑指 Offer II 092 翻转字符 如果一个由&amp;nbsp;&amp;#39;0&amp;#39; 和 &amp;#39;1&amp;#39;&amp;nbsp;组成的字符串，是以一些 &amp;#39;0&amp;#39;（可能没有 &amp;#39;0&amp;#39;）后面跟着一些 &amp;#39;1&amp;#39;（也可能没有 &amp;#39;1&amp;#39;）的形式组成的，那么该字符串是&amp;nbsp;单调递增&amp;nbsp;的。
我们给出一个由字符 &amp;#39;0&amp;#39; 和 &amp;#39;1&amp;#39;&amp;nbsp;组成的字符串 s，我们可以将任何&amp;nbsp;&amp;#39;0&amp;#39; 翻转为&amp;nbsp;&amp;#39;1&amp;#39;&amp;nbsp;或者将&amp;nbsp;&amp;#39;1&amp;#39;&amp;nbsp;翻转为&amp;nbsp;&amp;#39;0&amp;#39;。
返回使 s&amp;nbsp;单调递增&amp;nbsp;的最小翻转次数。
&amp;nbsp;
示例 1：
输入：s = &amp;quot;00110&amp;quot; 输出：1 解释：我们翻转最后一位得到 00111. 示例 2：
输入：s = &amp;quot;010110&amp;quot; 输出：2 解释：我们翻转得到 011111，或者是 000111。 示例 3：
输入：s = &amp;quot;00011000&amp;quot; 输出：2 解释：我们翻转得到 00000000。 &amp;nbsp;
提示：
1 &amp;lt;= s.length &amp;lt;= 20000 s 中只包含字符&amp;nbsp;&amp;#39;0&amp;#39;&amp;nbsp;和&amp;nbsp;&amp;#39;1&amp;#39; &amp;nbsp;
注意：本题与主站 926&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/flip-string-to-monotone-increasing/
func minFlipsMonoIncr(s string) int { } LeetCode题库地址 https://leetcode.cn/problems/cyJERH</description></item><item><title>面试题 17.09 第 k 个数</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/get-kth-magic-number-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/get-kth-magic-number-lcci/</guid><description>面试题 17.09 第 k 个数 有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。
示例 1:
输入: k = 5 输出: 9 func getKthMagicNumber(k int) int { } LeetCode题库地址 https://leetcode.cn/problems/get-kth-magic-number-lcci</description></item><item><title>剑指 Offer II 093 最长斐波那契数列</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/q91fma/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/q91fma/</guid><description>剑指 Offer II 093 最长斐波那契数列 如果序列&amp;nbsp;X_1, X_2, ..., X_n&amp;nbsp;满足下列条件，就说它是&amp;nbsp;斐波那契式&amp;nbsp;的：
n &amp;gt;= 3 对于所有&amp;nbsp;i + 2 &amp;lt;= n，都有&amp;nbsp;X_i + X_{i+1} = X_{i+2} 给定一个严格递增的正整数数组形成序列 arr&amp;nbsp;，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回&amp;nbsp;&amp;nbsp;0 。
（回想一下，子序列是从原序列&amp;nbsp; arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如，&amp;nbsp;[3, 5, 8]&amp;nbsp;是&amp;nbsp;[3, 4, 5, 6, 7, 8]&amp;nbsp;的一个子序列）
&amp;nbsp;
示例 1：
输入: arr = [1,2,3,4,5,6,7,8] 输出: 5 解释: 最长的斐波那契式子序列为 [1,2,3,5,8] 。 示例&amp;nbsp;2：
输入: arr = [1,3,7,11,12,14,18] 输出: 3 解释: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。 &amp;nbsp;
提示：
3 &amp;lt;= arr.length &amp;lt;= 1000 1 &amp;lt;= arr[i] &amp;lt; arr[i + 1] &amp;lt;= 10^9</description></item><item><title>面试题 17.10 主要元素</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/find-majority-element-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/find-majority-element-lcci/</guid><description>面试题 17.10 主要元素 数组中占比超过一半的元素称之为主要元素。给你一个 整数 数组，找出其中的主要元素。若没有，返回 -1 。请设计时间复杂度为 O(N) 、空间复杂度为 O(1) 的解决方案。
示例 1：
输入：[1,2,5,9,5,9,5,5,5] 输出：5 示例 2：
输入：[3,2] 输出：-1 示例 3：
输入：[2,2,1,1,1,2,2] 输出：2 func majorityElement(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/find-majority-element-lcci</description></item><item><title>剑指 Offer II 094 最少回文分割</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/omkaoa/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/omkaoa/</guid><description>剑指 Offer II 094 最少回文分割 给定一个字符串 s，请将 s 分割成一些子串，使每个子串都是回文串。
返回符合要求的 最少分割次数 。
&amp;nbsp;
示例 1：
输入：s = &amp;quot;aab&amp;quot; 输出：1 解释：只需一次分割就可将&amp;nbsp;s 分割成 [&amp;quot;aa&amp;quot;,&amp;quot;b&amp;quot;] 这样两个回文子串。 示例 2：
输入：s = &amp;quot;a&amp;quot; 输出：0 示例 3：
输入：s = &amp;quot;ab&amp;quot; 输出：1 &amp;nbsp;
提示：
1 &amp;lt;= s.length &amp;lt;= 2000 s 仅由小写英文字母组成 &amp;nbsp;
注意：本题与主站 132&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/palindrome-partitioning-ii/
func minCut(s string) int { } LeetCode题库地址 https://leetcode.cn/problems/omKAoA</description></item><item><title>面试题 17.11 单词距离</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/find-closest-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/find-closest-lcci/</guid><description>面试题 17.11 单词距离 有个内含单词的超大文本文件，给定任意两个不同的单词，找出在这个文件中这两个单词的最短距离(相隔单词数)。如果寻找过程在这个文件中会重复多次，而每次寻找的单词不同，你能对此优化吗?
示例：
输入：words = ["I","am","a","student","from","a","university","in","a","city"], word1 = "a", word2 = "student" 输出：1 提示：
words.length &amp;lt;= 100000 func findClosest(words []string, word1 string, word2 string) int { } LeetCode题库地址 https://leetcode.cn/problems/find-closest-lcci</description></item><item><title>剑指 Offer II 095 最长公共子序列</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/qjnos7/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/qjnos7/</guid><description>剑指 Offer II 095 最长公共子序列 给定两个字符串&amp;nbsp;text1 和&amp;nbsp;text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。
一个字符串的&amp;nbsp;子序列&amp;nbsp;是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
例如，&amp;quot;ace&amp;quot; 是 &amp;quot;abcde&amp;quot; 的子序列，但 &amp;quot;aec&amp;quot; 不是 &amp;quot;abcde&amp;quot; 的子序列。 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。
&amp;nbsp;
示例 1：
输入：text1 = &amp;quot;abcde&amp;quot;, text2 = &amp;quot;ace&amp;quot; 输出：3 解释：最长公共子序列是 &amp;quot;ace&amp;quot; ，它的长度为 3 。 示例 2：
输入：text1 = &amp;quot;abc&amp;quot;, text2 = &amp;quot;abc&amp;quot; 输出：3 解释：最长公共子序列是 &amp;quot;abc&amp;quot; ，它的长度为 3 。 示例 3：
输入：text1 = &amp;quot;abc&amp;quot;, text2 = &amp;quot;def&amp;quot; 输出：0 解释：两个字符串没有公共子序列，返回 0 。 &amp;nbsp;
提示：
1 &amp;lt;= text1.length, text2.length &amp;lt;= 1000 text1 和&amp;nbsp;text2 仅由小写英文字符组成。 &amp;nbsp;</description></item><item><title>面试题 17.12 BiNode</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/binode-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/binode-lcci/</guid><description>面试题 17.12 BiNode 二叉树数据结构TreeNode可用来表示单向链表（其中left置空，right为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求依然符合二叉搜索树的性质，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。
返回转换后的单向链表的头节点。
注意：本题相对原题稍作改动
&amp;nbsp;
示例：
输入： [4,2,5,1,3,null,6,0] 输出： [0,null,1,null,2,null,3,null,4,null,5,null,6] 提示：
节点数量不会超过 100000。 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func convertBiNode(root *TreeNode) *TreeNode { } LeetCode题库地址 https://leetcode.cn/problems/binode-lcci</description></item><item><title>剑指 Offer II 096 字符串交织</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/iy6buf/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/iy6buf/</guid><description>剑指 Offer II 096 字符串交织 给定三个字符串&amp;nbsp;s1、s2、s3，请判断&amp;nbsp;s3&amp;nbsp;能不能由&amp;nbsp;s1&amp;nbsp;和&amp;nbsp;s2&amp;nbsp;交织（交错）&amp;nbsp;组成。
两个字符串 s 和 t 交织&amp;nbsp;的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：
s = s1 + s2 + ... + sn t = t1 + t2 + ... + tm |n - m| &amp;lt;= 1 交织 是 s1 + t1 + s2 + t2 + s3 + t3 + ... 或者 t1 + s1 + t2 + s2 + t3 + s3 + ... 提示：a + b 意味着字符串 a 和 b 连接。
&amp;nbsp;
示例 1：</description></item><item><title>面试题 17.13 恢复空格</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/re-space-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/re-space-lcci/</guid><description>面试题 17.13 恢复空格 哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子&amp;quot;I reset the computer. It still didn&amp;rsquo;t boot!&amp;quot;已经变成了&amp;quot;iresetthecomputeritstilldidntboot&amp;quot;。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。
注意：本题相对原题稍作改动，只需返回未识别的字符数
&amp;nbsp;
示例：
输入： dictionary = [&amp;quot;looked&amp;quot;,&amp;quot;just&amp;quot;,&amp;quot;like&amp;quot;,&amp;quot;her&amp;quot;,&amp;quot;brother&amp;quot;] sentence = &amp;quot;jesslookedjustliketimherbrother&amp;quot; 输出： 7 解释： 断句后为&amp;quot;jess looked just like tim her brother&amp;quot;，共7个未识别字符。 提示：
0 &amp;lt;= len(sentence) &amp;lt;= 1000 dictionary中总字符数不超过 150000。 你可以认为dictionary和sentence中只包含小写字母。 func respace(dictionary []string, sentence string) int { } LeetCode题库地址 https://leetcode.cn/problems/re-space-lcci</description></item><item><title>剑指 Offer II 097 子序列的数目</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/21dk04/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/21dk04/</guid><description>剑指 Offer II 097 子序列的数目 给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。
字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，&amp;quot;ACE&amp;quot;&amp;nbsp;是&amp;nbsp;&amp;quot;ABCDE&amp;quot;&amp;nbsp;的一个子序列，而&amp;nbsp;&amp;quot;AEC&amp;quot;&amp;nbsp;不是）
题目数据保证答案符合 32 位带符号整数范围。
&amp;nbsp;
示例&amp;nbsp;1：
输入：s = &amp;quot;rabbbit&amp;quot;, t = &amp;quot;rabbit&amp;quot; 输出：3 解释： 如下图所示, 有 3 种可以从 s 中得到 &amp;quot;rabbit&amp;quot; 的方案。 rabbbit rabbbit rabbbit 示例&amp;nbsp;2：
输入：s = &amp;quot;babgbag&amp;quot;, t = &amp;quot;bag&amp;quot; 输出：5 解释： 如下图所示, 有 5 种可以从 s 中得到 &amp;quot;bag&amp;quot; 的方案。 babgbag babgbag babgbag babgbag babgbag &amp;nbsp;
提示：
0 &amp;lt;= s.length, t.length &amp;lt;= 1000 s 和 t 由英文字母组成 &amp;nbsp;</description></item><item><title>面试题 17.14 最小K个数</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/smallest-k-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/smallest-k-lcci/</guid><description>面试题 17.14 最小K个数 设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。
示例：
输入： arr = [1,3,5,7,2,4,6,8], k = 4 输出： [1,2,3,4] 提示：
0 &amp;lt;= len(arr) &amp;lt;= 100000 0 &amp;lt;= k &amp;lt;= min(100000, len(arr)) func smallestK(arr []int, k int) []int { } LeetCode题库地址 https://leetcode.cn/problems/smallest-k-lcci</description></item><item><title>剑指 Offer II 098 路径的数目</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/2aoefn/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/2aoefn/</guid><description>剑指 Offer II 098 路径的数目 一个机器人位于一个 m x n&amp;nbsp;网格的左上角 （起始点在下图中标记为 &amp;ldquo;Start&amp;rdquo; ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 &amp;ldquo;Finish&amp;rdquo; ）。
问总共有多少条不同的路径？
&amp;nbsp;
示例 1：
输入：m = 3, n = 7 输出：28 示例 2：
输入：m = 3, n = 2 输出：3 解释： 从左上角开始，总共有 3 条路径可以到达右下角。 1. 向右 -&amp;gt; 向下 -&amp;gt; 向下 2. 向下 -&amp;gt; 向下 -&amp;gt; 向右 3. 向下 -&amp;gt; 向右 -&amp;gt; 向下 示例 3：
输入：m = 7, n = 3 输出：28 示例 4：
输入：m = 3, n = 3 输出：6 &amp;nbsp;</description></item><item><title>面试题 17.15 最长单词</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/longest-word-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/longest-word-lcci/</guid><description>面试题 17.15 最长单词 给定一组单词words，编写一个程序，找出其中的最长单词，且该单词由这组单词中的其他单词组合而成。若有多个长度相同的结果，返回其中字典序最小的一项，若没有符合要求的单词则返回空字符串。
示例：
输入： [&amp;quot;cat&amp;quot;,&amp;quot;banana&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;nana&amp;quot;,&amp;quot;walk&amp;quot;,&amp;quot;walker&amp;quot;,&amp;quot;dogwalker&amp;quot;] 输出： &amp;quot;dogwalker&amp;quot; 解释： &amp;quot;dogwalker&amp;quot;可由&amp;quot;dog&amp;quot;和&amp;quot;walker&amp;quot;组成。 提示：
0 &amp;lt;= len(words) &amp;lt;= 200 1 &amp;lt;= len(words[i]) &amp;lt;= 100 func longestWord(words []string) string { } LeetCode题库地址 https://leetcode.cn/problems/longest-word-lcci</description></item><item><title>剑指 Offer II 099 最小路径之和</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/0i0mdw/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/0i0mdw/</guid><description>剑指 Offer II 099 最小路径之和 给定一个包含非负整数的 m&amp;nbsp;x&amp;nbsp;n&amp;nbsp;网格&amp;nbsp;grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明：一个机器人每次只能向下或者向右移动一步。
&amp;nbsp;
示例 1：
输入：grid = [[1,3,1],[1,5,1],[4,2,1]] 输出：7 解释：因为路径 1&amp;rarr;3&amp;rarr;1&amp;rarr;1&amp;rarr;1 的总和最小。 示例 2：
输入：grid = [[1,2,3],[4,5,6]] 输出：12 &amp;nbsp;
提示：
m == grid.length n == grid[i].length 1 &amp;lt;= m, n &amp;lt;= 200 0 &amp;lt;= grid[i][j] &amp;lt;= 100 &amp;nbsp;
注意：本题与主站 64&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/minimum-path-sum/
func minPathSum(grid [][]int) int { } LeetCode题库地址 https://leetcode.cn/problems/0i0mDW</description></item><item><title>面试题 17.16 按摩师</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/the-masseuse-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/the-masseuse-lcci/</guid><description>面试题 17.16 按摩师 一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。
注意：本题相对原题稍作改动
&amp;nbsp;
示例 1：
输入： [1,2,3,1] 输出： 4 解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。 示例 2：
输入： [2,7,9,3,1] 输出： 12 解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。 示例 3：
输入： [2,1,4,5,3,1,1,3] 输出： 12 解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。 func massage(nums []int) int { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer II 100 三角形中最小路径之和</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/ilpe0q/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/ilpe0q/</guid><description>剑指 Offer II 100 三角形中最小路径之和 给定一个三角形 triangle ，找出自顶向下的最小路径和。
每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。
&amp;nbsp;
示例 1：
输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]] 输出：11 解释：如下面简图所示： 2 3 4 6 5 7 4 1 8 3 自顶向下的最小路径和为&amp;nbsp;11（即，2&amp;nbsp;+&amp;nbsp;3&amp;nbsp;+&amp;nbsp;5&amp;nbsp;+&amp;nbsp;1&amp;nbsp;= 11）。 示例 2：
输入：triangle = [[-10]] 输出：-10 &amp;nbsp;
提示：
1 &amp;lt;= triangle.length &amp;lt;= 200 triangle[0].length == 1 triangle[i].length == triangle[i - 1].length + 1 -104 &amp;lt;= triangle[i][j] &amp;lt;= 104 &amp;nbsp;</description></item><item><title>面试题 17.17 多次搜索</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/multi-search-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/multi-search-lcci/</guid><description>面试题 17.17 多次搜索 给定一个较长字符串big和一个包含较短字符串的数组smalls，设计一个方法，根据smalls中的每一个较短字符串，对big进行搜索。输出smalls中的字符串在big里出现的所有位置positions，其中positions[i]为smalls[i]出现的所有位置。
示例：
输入： big = &amp;quot;mississippi&amp;quot; smalls = [&amp;quot;is&amp;quot;,&amp;quot;ppi&amp;quot;,&amp;quot;hi&amp;quot;,&amp;quot;sis&amp;quot;,&amp;quot;i&amp;quot;,&amp;quot;ssippi&amp;quot;] 输出： [[1,4],[8],[],[3],[1,4,7,10],[5]] 提示：
0 &amp;lt;= len(big) &amp;lt;= 1000 0 &amp;lt;= len(smalls[i]) &amp;lt;= 1000 smalls的总字符数不会超过 100000。 你可以认为smalls中没有重复字符串。 所有出现的字符均为英文小写字母。 func multiSearch(big string, smalls []string) [][]int { } LeetCode题库地址 https://leetcode.cn/problems/multi-search-lcci</description></item><item><title>剑指 Offer II 101 分割等和子集</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/nupfpr/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/nupfpr/</guid><description>剑指 Offer II 101 分割等和子集 给定一个非空的正整数数组 nums ，请判断能否将这些数字分成元素和相等的两部分。
&amp;nbsp;
示例&amp;nbsp;1：
输入：nums = [1,5,11,5] 输出：true 解释：nums 可以分割成 [1, 5, 5] 和 [11] 。 示例&amp;nbsp;2：
输入：nums = [1,2,3,5] 输出：false 解释：nums 不可以分为和相等的两部分 &amp;nbsp;
提示：
1 &amp;lt;= nums.length &amp;lt;= 200 1 &amp;lt;= nums[i] &amp;lt;= 100 &amp;nbsp;
注意：本题与主站 416&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/partition-equal-subset-sum/
func canPartition(nums []int) bool { } LeetCode题库地址 https://leetcode.cn/problems/NUPfPr</description></item><item><title>面试题 17.18 最短超串</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/shortest-supersequence-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/shortest-supersequence-lcci/</guid><description>面试题 17.18 最短超串 假设你有两个数组，一个长一个短，短的元素均不相同。找到长数组中包含短数组所有的元素的最短子数组，其出现顺序无关紧要。
返回最短子数组的左端点和右端点，如有多个满足条件的子数组，返回左端点最小的一个。若不存在，返回空数组。
示例 1:
输入: big = [7,5,9,0,2,1,3,5,7,9,1,1,5,8,8,9,7] small = [1,5,9] 输出: [7,10] 示例 2:
输入: big = [1,2,3] small = [4] 输出: [] 提示：
big.length&amp;nbsp;&amp;lt;= 100000 1 &amp;lt;= small.length&amp;nbsp;&amp;lt;= 100000 func shortestSeq(big []int, small []int) []int { } LeetCode题库地址 https://leetcode.cn/problems/shortest-supersequence-lcci</description></item><item><title>剑指 Offer II 102 加减的目标值</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/yavdxd/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/yavdxd/</guid><description>剑指 Offer II 102 加减的目标值 给定一个正整数数组 nums 和一个整数 target 。
向数组中的每个整数前添加&amp;nbsp;&amp;#39;+&amp;#39; 或 &amp;#39;-&amp;#39; ，然后串联起所有整数，可以构造一个 表达式 ：
例如，nums = [2, 1] ，可以在 2 之前添加 &amp;#39;+&amp;#39; ，在 1 之前添加 &amp;#39;-&amp;#39; ，然后串联起来得到表达式 &amp;quot;+2-1&amp;quot; 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。
&amp;nbsp;
示例 1：
输入：nums = [1,1,1,1,1], target = 3 输出：5 解释：一共有 5 种方法让最终目标和为 3 。 -1 + 1 + 1 + 1 + 1 = 3 +1 - 1 + 1 + 1 + 1 = 3 +1 + 1 - 1 + 1 + 1 = 3 +1 + 1 + 1 - 1 + 1 = 3 +1 + 1 + 1 + 1 - 1 = 3 示例 2：</description></item><item><title>面试题 17.19 消失的两个数字</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/missing-two-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/missing-two-lcci/</guid><description>面试题 17.19 消失的两个数字 给定一个数组，包含从 1 到 N 所有的整数，但其中缺了两个数字。你能在 O(N) 时间内只用 O(1) 的空间找到它们吗？
以任意顺序返回这两个数字均可。
示例 1:
输入: [1] 输出: [2,3] 示例 2:
输入: [2,3] 输出: [1,4] 提示：
nums.length &amp;lt;=&amp;nbsp;30000 func missingTwo(nums []int) []int { } LeetCode题库地址 https://leetcode.cn/problems/missing-two-lcci</description></item><item><title>剑指 Offer II 103 最少的硬币数目</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/gam7ch/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/gam7ch/</guid><description>剑指 Offer II 103 最少的硬币数目 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回&amp;nbsp;-1。
你可以认为每种硬币的数量是无限的。
&amp;nbsp;
示例&amp;nbsp;1：
输入：coins = [1, 2, 5], amount = 11 输出：3 解释：11 = 5 + 5 + 1 示例 2：
输入：coins = [2], amount = 3 输出：-1 示例 3：
输入：coins = [1], amount = 0 输出：0 示例 4：
输入：coins = [1], amount = 1 输出：1 示例 5：
输入：coins = [1], amount = 2 输出：2 &amp;nbsp;
提示：
1 &amp;lt;= coins.length &amp;lt;= 12 1 &amp;lt;= coins[i] &amp;lt;= 231 - 1 0 &amp;lt;= amount &amp;lt;= 104 &amp;nbsp;</description></item><item><title>面试题 17.20 连续中值</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/continuous-median-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/continuous-median-lcci/</guid><description>面试题 17.20 连续中值 随机产生数字并传递给一个方法。你能否完成这个方法，在每次产生新值时，寻找当前所有值的中间值（中位数）并保存。
中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。
例如，
[2,3,4]&amp;nbsp;的中位数是 3
[2,3] 的中位数是 (2 + 3) / 2 = 2.5
设计一个支持以下两种操作的数据结构：
void addNum(int num) - 从数据流中添加一个整数到数据结构中。 double findMedian() - 返回目前所有元素的中位数。 示例：
addNum(1) addNum(2) findMedian() -&amp;gt; 1.5 addNum(3) findMedian() -&amp;gt; 2 type MedianFinder struct { } /** initialize your data structure here. */ func Constructor() MedianFinder { } func (this *MedianFinder) AddNum(num int) { } func (this *MedianFinder) FindMedian() float64 { } /** * Your MedianFinder object will be instantiated and called as such: * obj := Constructor(); * obj.</description></item><item><title>剑指 Offer II 104 排列的数目</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/d0f0sv/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/d0f0sv/</guid><description>剑指 Offer II 104 排列的数目 给定一个由 不同&amp;nbsp;正整数组成的数组 nums ，和一个目标整数 target 。请从 nums 中找出并返回总和为 target 的元素组合的个数。数组中的数字可以在一次排列中出现任意次，但是顺序不同的序列被视作不同的组合。
题目数据保证答案符合 32 位整数范围。
&amp;nbsp;
示例 1：
输入：nums = [1,2,3], target = 4 输出：7 解释： 所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) 请注意，顺序不同的序列被视作不同的组合。 示例 2：
输入：nums = [9], target = 3 输出：0 &amp;nbsp;
提示：
1 &amp;lt;= nums.length &amp;lt;= 200 1 &amp;lt;= nums[i] &amp;lt;= 1000 nums 中的所有元素 互不相同 1 &amp;lt;= target &amp;lt;= 1000 &amp;nbsp;</description></item><item><title>面试题 17.21 直方图的水量</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/volume-of-histogram-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/volume-of-histogram-lcci/</guid><description>面试题 17.21 直方图的水量 给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。
上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的直方图，在这种情况下，可以接 6 个单位的水（蓝色部分表示水）。&amp;nbsp;感谢 Marcos 贡献此图。
示例:
输入: [0,1,0,2,1,0,1,3,2,1,2,1] 输出: 6 func trap(height []int) int { } LeetCode题库地址 https://leetcode.cn/problems/volume-of-histogram-lcci</description></item><item><title>剑指 Offer II 105 岛屿的最大面积</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/zl6zan/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/zl6zan/</guid><description>剑指 Offer II 105 岛屿的最大面积 给定一个由&amp;nbsp;0 和 1 组成的非空二维数组&amp;nbsp;grid&amp;nbsp;，用来表示海洋岛屿地图。
一个&amp;nbsp;岛屿&amp;nbsp;是由一些相邻的&amp;nbsp;1&amp;nbsp;(代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设&amp;nbsp;grid 的四个边缘都被 0（代表水）包围着。
找到给定的二维数组中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。
&amp;nbsp;
示例 1:
输入: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]] 输出: 6 解释: 对于上面这个给定矩阵应返回&amp;nbsp;6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。 示例 2:
输入: grid = [[0,0,0,0,0,0,0,0]] 输出: 0 &amp;nbsp;
提示：
m == grid.length n == grid[i].length 1 &amp;lt;= m, n &amp;lt;= 50 grid[i][j] is either 0 or 1 &amp;nbsp;
注意：本题与主站 695&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/max-area-of-island/
func maxAreaOfIsland(grid [][]int) int { } LeetCode题库地址 https://leetcode.cn/problems/ZL6zAn</description></item><item><title>面试题 17.22 单词转换</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/word-transformer-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/word-transformer-lcci/</guid><description>面试题 17.22 单词转换 给定字典中的两个词，长度相等。写一个方法，把一个词转换成另一个词， 但是一次只能改变一个字符。每一步得到的新词都必须能在字典中找到。
编写一个程序，返回一个可能的转换序列。如有多个可能的转换序列，你可以返回任何一个。
示例 1:
输入: beginWord = &amp;quot;hit&amp;quot;, endWord = &amp;quot;cog&amp;quot;, wordList = [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;,&amp;quot;cog&amp;quot;] 输出: [&amp;quot;hit&amp;quot;,&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;,&amp;quot;cog&amp;quot;] 示例 2:
输入: beginWord = &amp;quot;hit&amp;quot; endWord = &amp;quot;cog&amp;quot; wordList = [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;] 输出: [] 解释:&amp;nbsp;endWord &amp;quot;cog&amp;quot; 不在字典中，所以不存在符合要求的转换序列。 func findLadders(beginWord string, endWord string, wordList []string) []string { } LeetCode题库地址 https://leetcode.cn/problems/word-transformer-lcci</description></item><item><title>剑指 Offer II 106 二分图</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/veab3k/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/veab3k/</guid><description>剑指 Offer II 106 二分图 存在一个 无向图 ，图中有 n 个节点。其中每个节点都有一个介于 0 到 n - 1 之间的唯一编号。
给定一个二维数组 graph&amp;nbsp;，表示图，其中 graph[u] 是一个节点数组，由节点 u 的邻接节点组成。形式上，对于&amp;nbsp;graph[u] 中的每个 v ，都存在一条位于节点 u 和节点 v 之间的无向边。该无向图同时具有以下属性：
不存在自环（graph[u] 不包含 u）。 不存在平行边（graph[u] 不包含重复值）。 如果 v 在 graph[u] 内，那么 u 也应该在 graph[v] 内（该图是无向图） 这个图可能不是连通图，也就是说两个节点 u 和 v 之间可能不存在一条连通彼此的路径。 二分图 定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为 二分图 。
如果图是二分图，返回 true ；否则，返回 false 。
&amp;nbsp;
示例 1：
输入：graph = [[1,2,3],[0,2],[0,1,3],[0,2]] 输出：false 解释：不能将节点分割成两个独立的子集，以使每条边都连通一个子集中的一个节点与另一个子集中的一个节点。 示例 2：</description></item><item><title>面试题 17.23 最大黑方阵</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/max-black-square-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/max-black-square-lcci/</guid><description>面试题 17.23 最大黑方阵 给定一个方阵，其中每个单元(像素)非黑即白。设计一个算法，找出 4 条边皆为黑色像素的最大子方阵。
返回一个数组 [r, c, size] ，其中&amp;nbsp;r,&amp;nbsp;c&amp;nbsp;分别代表子方阵左上角的行号和列号，size 是子方阵的边长。若有多个满足条件的子方阵，返回 r 最小的，若 r 相同，返回 c 最小的子方阵。若无满足条件的子方阵，返回空数组。
示例 1:
输入: [ &amp;nbsp; [1,0,1], &amp;nbsp; [0,0,1], &amp;nbsp; [0,0,1] ] 输出: [1,0,2] 解释: 输入中 0 代表黑色，1 代表白色，标粗的元素即为满足条件的最大子方阵 示例 2:
输入: [ &amp;nbsp; [0,1,1], &amp;nbsp; [1,0,1], &amp;nbsp; [1,1,0] ] 输出: [0,0,1] 提示：
matrix.length == matrix[0].length &amp;lt;= 200 func findSquare(matrix [][]int) []int { } LeetCode题库地址 https://leetcode.cn/problems/max-black-square-lcci</description></item><item><title>剑指 Offer II 107 矩阵中的距离</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/2bcmpm/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/2bcmpm/</guid><description>剑指 Offer II 107 矩阵中的距离 给定一个由 0 和 1 组成的矩阵 mat&amp;nbsp;，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。
两个相邻元素间的距离为 1 。
&amp;nbsp;
示例 1：
输入：mat = [[0,0,0],[0,1,0],[0,0,0]] 输出：[[0,0,0],[0,1,0],[0,0,0]] 示例 2：
输入：mat = [[0,0,0],[0,1,0],[1,1,1]] 输出：[[0,0,0],[0,1,0],[1,2,1]] &amp;nbsp;
提示：
m == mat.length n == mat[i].length 1 &amp;lt;= m, n &amp;lt;= 104 1 &amp;lt;= m * n &amp;lt;= 104 mat[i][j] is either 0 or 1. mat 中至少有一个 0&amp;nbsp; &amp;nbsp;
注意：本题与主站 542&amp;nbsp;题相同：https://leetcode-cn.com/problems/01-matrix/
func updateMatrix(mat [][]int) [][]int { } LeetCode题库地址 https://leetcode.cn/problems/2bCMpM</description></item><item><title>面试题 17.24 最大子矩阵</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/max-submatrix-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/max-submatrix-lcci/</guid><description>面试题 17.24 最大子矩阵 给定一个正整数、负整数和 0 组成的 N &amp;times; M&amp;nbsp;矩阵，编写代码找出元素总和最大的子矩阵。
返回一个数组 [r1, c1, r2, c2]，其中 r1, c1 分别代表子矩阵左上角的行号和列号，r2, c2 分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。
注意：本题相对书上原题稍作改动
示例：
输入： [ &amp;nbsp; [-1,0], &amp;nbsp; [0,-1] ] 输出：[0,1,0,1] 解释：输入中标粗的元素即为输出所表示的矩阵 &amp;nbsp;
说明：
1 &amp;lt;= matrix.length, matrix[0].length &amp;lt;= 200 func getMaxMatrix(matrix [][]int) []int { } LeetCode题库地址 https://leetcode.cn/problems/max-submatrix-lcci</description></item><item><title>剑指 Offer II 108 单词演变</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/om3rec/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/om3rec/</guid><description>剑指 Offer II 108 单词演变 在字典（单词列表）&amp;nbsp;wordList 中，从单词 beginWord&amp;nbsp;和 endWord 的 转换序列 是一个按下述规格形成的序列：
序列中第一个单词是 beginWord 。 序列中最后一个单词是 endWord 。 每次转换只能改变一个字母。 转换过程中的中间单词必须是字典&amp;nbsp;wordList 中的单词。 给定两个长度相同但内容不同的单词 beginWord&amp;nbsp;和 endWord 和一个字典 wordList ，找到从&amp;nbsp;beginWord 到&amp;nbsp;endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。
&amp;nbsp;
示例 1：
输入：beginWord = &amp;quot;hit&amp;quot;, endWord = &amp;quot;cog&amp;quot;, wordList = [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;,&amp;quot;cog&amp;quot;] 输出：5 解释：一个最短转换序列是 &amp;quot;hit&amp;quot; -&amp;gt; &amp;quot;hot&amp;quot; -&amp;gt; &amp;quot;dot&amp;quot; -&amp;gt; &amp;quot;dog&amp;quot; -&amp;gt; &amp;quot;cog&amp;quot;, 返回它的长度 5。 示例 2：
输入：beginWord = &amp;quot;hit&amp;quot;, endWord = &amp;quot;cog&amp;quot;, wordList = [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;] 输出：0 解释：endWord &amp;quot;cog&amp;quot; 不在字典中，所以无法进行转换。 &amp;nbsp;</description></item><item><title>面试题 17.25 单词矩阵</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/word-rectangle-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/word-rectangle-lcci/</guid><description>面试题 17.25 单词矩阵 给定一份单词的清单，设计一个算法，创建由字母组成的面积最大的矩形，其中每一行组成一个单词(自左向右)，每一列也组成一个单词(自上而下)。不要求这些单词在清单里连续出现，但要求所有行等长，所有列等高。
如果有多个面积最大的矩形，输出任意一个均可。一个单词可以重复使用。
示例 1:
输入: [&amp;quot;this&amp;quot;, &amp;quot;real&amp;quot;, &amp;quot;hard&amp;quot;, &amp;quot;trh&amp;quot;, &amp;quot;hea&amp;quot;, &amp;quot;iar&amp;quot;, &amp;quot;sld&amp;quot;] 输出: [ &amp;nbsp; &amp;quot;this&amp;quot;, &amp;nbsp; &amp;quot;real&amp;quot;, &amp;nbsp; &amp;quot;hard&amp;quot; ] 示例 2:
输入: [&amp;quot;aa&amp;quot;] 输出: [&amp;quot;aa&amp;quot;,&amp;quot;aa&amp;quot;] 说明：
words.length &amp;lt;= 1000 words[i].length &amp;lt;= 100 数据保证单词足够随机 func maxRectangle(words []string) []string { } LeetCode题库地址 https://leetcode.cn/problems/word-rectangle-lcci</description></item><item><title>剑指 Offer II 109 开密码锁</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/zldjc7/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/zldjc7/</guid><description>剑指 Offer II 109 开密码锁 一个密码锁由 4&amp;nbsp;个环形拨轮组成，每个拨轮都有 10 个数字： &amp;#39;0&amp;#39;, &amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;4&amp;#39;, &amp;#39;5&amp;#39;, &amp;#39;6&amp;#39;, &amp;#39;7&amp;#39;, &amp;#39;8&amp;#39;, &amp;#39;9&amp;#39; 。每个拨轮可以自由旋转：例如把 &amp;#39;9&amp;#39; 变为&amp;nbsp;&amp;#39;0&amp;#39;，&amp;#39;0&amp;#39; 变为 &amp;#39;9&amp;#39; 。每次旋转都只能旋转一个拨轮的一位数字。
锁的初始数字为 &amp;#39;0000&amp;#39; ，一个代表四个拨轮的数字的字符串。
列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。
字符串 target 代表可以解锁的数字，请给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。
&amp;nbsp;
示例 1:
输入：deadends = [&amp;quot;0201&amp;quot;,&amp;quot;0101&amp;quot;,&amp;quot;0102&amp;quot;,&amp;quot;1212&amp;quot;,&amp;quot;2002&amp;quot;], target = &amp;quot;0202&amp;quot; 输出：6 解释： 可能的移动序列为 &amp;quot;0000&amp;quot; -&amp;gt; &amp;quot;1000&amp;quot; -&amp;gt; &amp;quot;1100&amp;quot; -&amp;gt; &amp;quot;1200&amp;quot; -&amp;gt; &amp;quot;1201&amp;quot; -&amp;gt; &amp;quot;1202&amp;quot; -&amp;gt; &amp;quot;0202&amp;quot;。 注意 &amp;quot;0000&amp;quot; -&amp;gt; &amp;quot;0001&amp;quot; -&amp;gt; &amp;quot;0002&amp;quot; -&amp;gt; &amp;quot;0102&amp;quot; -&amp;gt; &amp;quot;0202&amp;quot; 这样的序列是不能解锁的，因为当拨动到 &amp;quot;0102&amp;quot; 时这个锁就会被锁定。 示例 2:</description></item><item><title>面试题 17.26 稀疏相似度</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sparse-similarity-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sparse-similarity-lcci/</guid><description>面试题 17.26 稀疏相似度 两个(具有不同单词的)文档的交集(intersection)中元素的个数除以并集(union)中元素的个数，就是这两个文档的相似度。例如，{1, 5, 3} 和 {1, 7, 2, 3} 的相似度是 0.4，其中，交集的元素有 2 个，并集的元素有 5 个。给定一系列的长篇文档，每个文档元素各不相同，并与一个 ID 相关联。它们的相似度非常&amp;ldquo;稀疏&amp;rdquo;，也就是说任选 2 个文档，相似度都很接近 0。请设计一个算法返回每对文档的 ID 及其相似度。只需输出相似度大于 0 的组合。请忽略空文档。为简单起见，可以假定每个文档由一个含有不同整数的数组表示。
输入为一个二维数组 docs，docs[i]&amp;nbsp;表示&amp;nbsp;id 为 i 的文档。返回一个数组，其中每个元素是一个字符串，代表每对相似度大于 0 的文档，其格式为 {id1},{id2}: {similarity}，其中 id1 为两个文档中较小的 id，similarity 为相似度，精确到小数点后 4 位。以任意顺序返回数组均可。
示例:
输入: [ &amp;nbsp; [14, 15, 100, 9, 3], &amp;nbsp; [32, 1, 9, 3, 5], &amp;nbsp; [15, 29, 2, 6, 8, 7], &amp;nbsp; [7, 10] ] 输出: [ &amp;nbsp; &amp;quot;0,1: 0.2500&amp;quot;, &amp;nbsp; &amp;quot;0,2: 0.1000&amp;quot;, &amp;nbsp; &amp;quot;2,3: 0.</description></item><item><title>剑指 Offer II 110 所有路径</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/bp4bmd/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/bp4bmd/</guid><description>剑指 Offer II 110 所有路径 给定一个有&amp;nbsp;n&amp;nbsp;个节点的有向无环图，用二维数组&amp;nbsp;graph&amp;nbsp;表示，请找到所有从&amp;nbsp;0&amp;nbsp;到&amp;nbsp;n-1&amp;nbsp;的路径并输出（不要求按顺序）。
graph&amp;nbsp;的第 i 个数组中的单元都表示有向图中 i&amp;nbsp;号节点所能到达的下一些结点（译者注：有向图是有方向的，即规定了 a&amp;rarr;b 你就不能从 b&amp;rarr;a ），若为空，就是没有下一个节点了。
&amp;nbsp;
示例 1：
输入：graph = [[1,2],[3],[3],[]] 输出：[[0,1,3],[0,2,3]] 解释：有两条路径 0 -&amp;gt; 1 -&amp;gt; 3 和 0 -&amp;gt; 2 -&amp;gt; 3 示例 2：
输入：graph = [[4,3,1],[3,2,4],[3],[4],[]] 输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]] 示例 3：
输入：graph = [[1],[]] 输出：[[0,1]] 示例 4：
输入：graph = [[1,2,3],[2],[3],[]] 输出：[[0,1,2,3],[0,2,3],[0,3]] 示例 5：
输入：graph = [[1,3],[2],[3],[]] 输出：[[0,1,2,3],[0,3]] &amp;nbsp;
提示：
n == graph.length 2 &amp;lt;= n &amp;lt;= 15 0 &amp;lt;= graph[i][j] &amp;lt; n graph[i][j] != i&amp;nbsp; 保证输入为有向无环图 (GAD) &amp;nbsp;</description></item><item><title>剑指 Offer II 111 计算除法</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/vlzxql/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/vlzxql/</guid><description>剑指 Offer II 111 计算除法 给定一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。
另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。
返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。
注意：输入总是有效的。可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。
&amp;nbsp;
示例 1：
输入：equations = [[&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;],[&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;]], values = [2.0,3.0], queries = [[&amp;quot;a&amp;quot;,&amp;quot;c&amp;quot;],[&amp;quot;b&amp;quot;,&amp;quot;a&amp;quot;],[&amp;quot;a&amp;quot;,&amp;quot;e&amp;quot;],[&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;],[&amp;quot;x&amp;quot;,&amp;quot;x&amp;quot;]] 输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000] 解释： 条件：a / b = 2.0, b / c = 3.</description></item><item><title>剑指 Offer II 112 最长递增路径</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/fptfwp/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/fptfwp/</guid><description>剑指 Offer II 112 最长递增路径 给定一个&amp;nbsp;m x n 整数矩阵&amp;nbsp;matrix ，找出其中 最长递增路径 的长度。
对于每个单元格，你可以往上，下，左，右四个方向移动。 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。
&amp;nbsp;
示例 1：
输入：matrix = [[9,9,4],[6,6,8],[2,1,1]] 输出：4 解释：最长递增路径为&amp;nbsp;[1, 2, 6, 9]。 示例 2：
输入：matrix = [[3,4,5],[3,2,6],[2,2,1]] 输出：4 解释：最长递增路径是&amp;nbsp;[3, 4, 5, 6]。注意不允许在对角线方向上移动。 示例 3：
输入：matrix = [[1]] 输出：1 &amp;nbsp;
提示：
m == matrix.length n == matrix[i].length 1 &amp;lt;= m, n &amp;lt;= 200 0 &amp;lt;= matrix[i][j] &amp;lt;= 231 - 1 &amp;nbsp;
注意：本题与主站 329&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/
func longestIncreasingPath(matrix [][]int) int { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer II 113 课程顺序</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/qa2igt/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/qa2igt/</guid><description>剑指 Offer II 113 课程顺序 现在总共有 numCourses&amp;nbsp;门课需要选，记为&amp;nbsp;0&amp;nbsp;到&amp;nbsp;numCourses-1。
给定一个数组&amp;nbsp;prerequisites ，它的每一个元素&amp;nbsp;prerequisites[i]&amp;nbsp;表示两门课程之间的先修顺序。&amp;nbsp;例如&amp;nbsp;prerequisites[i] = [ai, bi]&amp;nbsp;表示想要学习课程 ai&amp;nbsp;，需要先完成课程 bi&amp;nbsp;。
请根据给出的总课程数 &amp;nbsp;numCourses 和表示先修顺序的&amp;nbsp;prerequisites&amp;nbsp;得出一个可行的修课序列。
可能会有多个正确的顺序，只要任意返回一种就可以了。如果不可能完成所有课程，返回一个空数组。
&amp;nbsp;
示例&amp;nbsp;1:
输入: numCourses = 2, prerequisites = [[1,0]] 输出: [0,1] 解释:&amp;nbsp;总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。 示例&amp;nbsp;2:
输入: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]] 输出: [0,1,2,3] or [0,2,1,3] 解释:&amp;nbsp;总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。 &amp;nbsp;因此，一个正确的课程顺序是&amp;nbsp;[0,1,2,3] 。另一个正确的排序是&amp;nbsp;[0,2,1,3] 。 示例 3:
输入: numCourses = 1, prerequisites = [] 输出: [0] 解释:&amp;nbsp;总共 1 门课，直接修第一门课就可。 &amp;nbsp;</description></item><item><title>剑指 Offer II 114 外星文字典</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/jf1jut/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/jf1jut/</guid><description>剑指 Offer II 114 外星文字典 现有一种使用英语字母的外星文语言，这门语言的字母顺序与英语顺序不同。
给定一个字符串列表 words ，作为这门语言的词典，words 中的字符串已经 按这门新语言的字母顺序进行了排序 。
请你根据该词典还原出此语言中已知的字母顺序，并 按字母递增顺序 排列。若不存在合法字母顺序，返回 &amp;quot;&amp;quot; 。若存在多种可能的合法字母顺序，返回其中 任意一种 顺序即可。
字符串 s 字典顺序小于 字符串 t 有两种情况：
在第一个不同字母处，如果 s 中的字母在这门外星语言的字母顺序中位于 t 中字母之前，那么&amp;nbsp;s 的字典顺序小于 t 。 如果前面 min(s.length, t.length) 字母都相同，那么 s.length &amp;lt; t.length 时，s 的字典顺序也小于 t 。 &amp;nbsp;
示例 1：
输入：words = [&amp;quot;wrt&amp;quot;,&amp;quot;wrf&amp;quot;,&amp;quot;er&amp;quot;,&amp;quot;ett&amp;quot;,&amp;quot;rftt&amp;quot;] 输出：&amp;quot;wertf&amp;quot; 示例 2：
输入：words = [&amp;quot;z&amp;quot;,&amp;quot;x&amp;quot;] 输出：&amp;quot;zx&amp;quot; 示例 3：
输入：words = [&amp;quot;z&amp;quot;,&amp;quot;x&amp;quot;,&amp;quot;z&amp;quot;] 输出：&amp;quot;&amp;quot; 解释：不存在合法字母顺序，因此返回 &amp;quot;&amp;quot; 。 &amp;nbsp;
提示：
1 &amp;lt;= words.length &amp;lt;= 100 1 &amp;lt;= words[i].</description></item><item><title>剑指 Offer II 115 重建序列</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/ur2n8p/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/ur2n8p/</guid><description>剑指 Offer II 115 重建序列 给定一个长度为 n 的整数数组 nums ，其中 nums 是范围为 [1，n] 的整数的排列。还提供了一个 2D 整数数组&amp;nbsp;sequences&amp;nbsp;，其中&amp;nbsp;sequences[i]&amp;nbsp;是&amp;nbsp;nums&amp;nbsp;的子序列。
检查 nums 是否是唯一的最短&amp;nbsp;超序列 。最短 超序列 是 长度最短 的序列，并且所有序列&amp;nbsp;sequences[i]&amp;nbsp;都是它的子序列。对于给定的数组&amp;nbsp;sequences&amp;nbsp;，可能存在多个有效的 超序列 。
例如，对于&amp;nbsp;sequences = [[1,2],[1,3]]&amp;nbsp;，有两个最短的 超序列 ，[1,2,3] 和 [1,3,2] 。 而对于&amp;nbsp;sequences = [[1,2],[1,3],[1,2,3]]&amp;nbsp;，唯一可能的最短 超序列 是 [1,2,3] 。[1,2,3,4] 是可能的超序列，但不是最短的。 如果 nums 是序列的唯一最短 超序列 ，则返回 true ，否则返回 false 。
子序列 是一个可以通过从另一个序列中删除一些元素或不删除任何元素，而不改变其余元素的顺序的序列。
&amp;nbsp;
示例 1：
输入：nums = [1,2,3], sequences = [[1,2],[1,3]] 输出：false 解释：有两种可能的超序列：[1,2,3]和[1,3,2]。 序列 [1,2] 是[1,2,3]和[1,3,2]的子序列。 序列 [1,3] 是[1,2,3]和[1,3,2]的子序列。 因为 nums 不是唯一最短的超序列，所以返回false。 示例 2：</description></item><item><title>剑指 Offer II 116 省份数量</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/blyhh0/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/blyhh0/</guid><description>剑指 Offer II 116 省份数量 有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。
省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。
给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。
返回矩阵中 省份 的数量。
&amp;nbsp;
示例 1：
输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]] 输出：2 示例 2：
输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]] 输出：3 &amp;nbsp;
提示：
1 &amp;lt;= n &amp;lt;= 200 n == isConnected.length n == isConnected[i].length isConnected[i][j] 为 1 或 0 isConnected[i][i] == 1 isConnected[i][j] == isConnected[j][i] &amp;nbsp;</description></item><item><title>剑指 Offer II 117 相似的字符串</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/h6lpxb/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/h6lpxb/</guid><description>剑指 Offer II 117 相似的字符串 如果交换字符串&amp;nbsp;X 中的两个不同位置的字母，使得它和字符串&amp;nbsp;Y 相等，那么称 X 和 Y 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。
例如，&amp;quot;tars&amp;quot; 和 &amp;quot;rats&amp;quot; 是相似的 (交换 0 与 2 的位置)；&amp;nbsp;&amp;quot;rats&amp;quot; 和 &amp;quot;arts&amp;quot; 也是相似的，但是 &amp;quot;star&amp;quot; 不与 &amp;quot;tars&amp;quot;，&amp;quot;rats&amp;quot;，或 &amp;quot;arts&amp;quot; 相似。
总之，它们通过相似性形成了两个关联组：{&amp;quot;tars&amp;quot;, &amp;quot;rats&amp;quot;, &amp;quot;arts&amp;quot;} 和 {&amp;quot;star&amp;quot;}。注意，&amp;quot;tars&amp;quot; 和 &amp;quot;arts&amp;quot; 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。
给定一个字符串列表 strs。列表中的每个字符串都是 strs 中其它所有字符串的一个&amp;nbsp;字母异位词&amp;nbsp;。请问 strs 中有多少个相似字符串组？
字母异位词（anagram），一种把某个字符串的字母的位置（顺序）加以改换所形成的新词。
&amp;nbsp;
示例 1：
输入：strs = [&amp;quot;tars&amp;quot;,&amp;quot;rats&amp;quot;,&amp;quot;arts&amp;quot;,&amp;quot;star&amp;quot;] 输出：2 示例 2：
输入：strs = [&amp;quot;omv&amp;quot;,&amp;quot;ovm&amp;quot;] 输出：1 &amp;nbsp;
提示：
1 &amp;lt;= strs.length &amp;lt;= 300 1 &amp;lt;= strs[i].length &amp;lt;= 300 strs[i] 只包含小写字母。 strs 中的所有单词都具有相同的长度，且是彼此的字母异位词。 &amp;nbsp; &amp;nbsp;</description></item><item><title>剑指 Offer II 118 多余的边</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/7lpjuw/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/7lpjuw/</guid><description>剑指 Offer II 118 多余的边 树可以看成是一个连通且 无环&amp;nbsp;的&amp;nbsp;无向&amp;nbsp;图。
给定往一棵&amp;nbsp;n 个节点 (节点值&amp;nbsp;1～n) 的树中添加一条边后的图。添加的边的两个顶点包含在 1 到 n&amp;nbsp;中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 n 的二维数组 edges&amp;nbsp;，edges[i] = [ai, bi]&amp;nbsp;表示图中在 ai 和 bi 之间存在一条边。
请找出一条可以删去的边，删除后可使得剩余部分是一个有着 n 个节点的树。如果有多个答案，则返回数组&amp;nbsp;edges&amp;nbsp;中最后出现的边。
&amp;nbsp;
示例 1：
输入: edges = [[1,2],[1,3],[2,3]] 输出: [2,3] 示例 2：
输入: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]] 输出: [1,4] &amp;nbsp;
提示:
n == edges.length 3 &amp;lt;= n &amp;lt;= 1000 edges[i].length == 2 1 &amp;lt;= ai&amp;nbsp;&amp;lt; bi&amp;nbsp;&amp;lt;= edges.length ai != bi edges 中无重复元素 给定的图是连通的&amp;nbsp; &amp;nbsp;
注意：本题与主站 684&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/redundant-connection/
func findRedundantConnection(edges [][]int) []int { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer II 119 最长连续序列</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/whswhi/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/whswhi/</guid><description>剑指 Offer II 119 最长连续序列 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
&amp;nbsp;
示例 1：
输入：nums = [100,4,200,1,3,2] 输出：4 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。 示例 2：
输入：nums = [0,3,7,2,5,8,4,6,0,1] 输出：9 &amp;nbsp;
提示：
0 &amp;lt;= nums.length &amp;lt;= 104 -109 &amp;lt;= nums[i] &amp;lt;= 109 &amp;nbsp;
进阶：可以设计并实现时间复杂度为&amp;nbsp;O(n) 的解决方案吗？
&amp;nbsp;
注意：本题与主站 128&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/longest-consecutive-sequence/
func longestConsecutive(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/WhsWhI</description></item><item><title>【2023-01-19每日一题】2299. 强密码检验器 II[Easy]</title><link>/study/leetcode/strong-password-checker-ii/</link><pubDate>Thu, 19 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/strong-password-checker-ii/</guid><description>2023-01-19每日一题：2299. 强密码检验器 II 难度：Easy
标签：字符串
如果一个密码满足以下所有条件，我们称它是一个 强&amp;nbsp;密码：
它有至少 8&amp;nbsp;个字符。 至少包含 一个小写英文&amp;nbsp;字母。 至少包含 一个大写英文&amp;nbsp;字母。 至少包含 一个数字&amp;nbsp;。 至少包含 一个特殊字符&amp;nbsp;。特殊字符为："!@#$%^&amp;amp;*()-+"&amp;nbsp;中的一个。 它 不&amp;nbsp;包含&amp;nbsp;2&amp;nbsp;个连续相同的字符（比方说&amp;nbsp;"aab"&amp;nbsp;不符合该条件，但是&amp;nbsp;"aba"&amp;nbsp;符合该条件）。 给你一个字符串&amp;nbsp;password&amp;nbsp;，如果它是一个&amp;nbsp;强&amp;nbsp;密码，返回&amp;nbsp;true，否则返回&amp;nbsp;false&amp;nbsp;。
&amp;nbsp;
示例 1：
输入：password = "IloveLe3tcode!" 输出：true 解释：密码满足所有的要求，所以我们返回 true 。 示例 2：
输入：password = "Me+You--IsMyDream" 输出：false 解释：密码不包含数字，且包含 2 个连续相同的字符。所以我们返回 false 。 示例 3：
输入：password = "1aB!" 输出：false 解释：密码不符合长度要求。所以我们返回 false 。 &amp;nbsp;
提示：
1 &amp;lt;= password.length &amp;lt;= 100 password&amp;nbsp;包含字母，数字和&amp;nbsp;"!@#$%^&amp;amp;*()-+"&amp;nbsp;这些特殊字符。 方法一： 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
func strongPasswordCheckerII(password string) bool { } 复杂度分析 LeetCode题库地址 https://leetcode.cn/problems/strong-password-checker-ii</description></item><item><title>【2023-01-18每日一题】1825. 求出 MK 平均值[Hard]</title><link>/study/leetcode/finding-mk-average/</link><pubDate>Wed, 18 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/finding-mk-average/</guid><description>2023-01-18每日一题：1825. 求出 MK 平均值 难度：Hard
标签：设计 、 队列 、 数据流 、 有序集合 、 堆（优先队列）
给你两个整数&amp;nbsp;m&amp;nbsp;和&amp;nbsp;k&amp;nbsp;，以及数据流形式的若干整数。你需要实现一个数据结构，计算这个数据流的 MK 平均值&amp;nbsp;。
MK 平均值&amp;nbsp;按照如下步骤计算：
如果数据流中的整数少于 m&amp;nbsp;个，MK 平均值&amp;nbsp;为 -1&amp;nbsp;，否则将数据流中最后 m&amp;nbsp;个元素拷贝到一个独立的容器中。 从这个容器中删除最小的 k&amp;nbsp;个数和最大的 k&amp;nbsp;个数。 计算剩余元素的平均值，并 向下取整到最近的整数&amp;nbsp;。 请你实现&amp;nbsp;MKAverage&amp;nbsp;类：
MKAverage(int m, int k)&amp;nbsp;用一个空的数据流和两个整数 m&amp;nbsp;和 k&amp;nbsp;初始化&amp;nbsp;MKAverage&amp;nbsp;对象。 void addElement(int num)&amp;nbsp;往数据流中插入一个新的元素&amp;nbsp;num&amp;nbsp;。 int calculateMKAverage()&amp;nbsp;对当前的数据流计算并返回 MK 平均数&amp;nbsp;，结果需 向下取整到最近的整数 。 &amp;nbsp;
示例 1：
输入： ["MKAverage", "addElement", "addElement", "calculateMKAverage", "addElement", "calculateMKAverage", "addElement", "addElement", "addElement", "calculateMKAverage"] [[3, 1], [3], [1], [], [10], [], [5], [5], [5], []] 输出： [null, null, null, -1, null, 3, null, null, null, 5] 解释： MKAverage obj = new MKAverage(3, 1); obj.</description></item><item><title>【2023-01-17每日一题】1814. 统计一个数组中好对子的数目[Medium]</title><link>/study/leetcode/count-nice-pairs-in-an-array/</link><pubDate>Tue, 17 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/count-nice-pairs-in-an-array/</guid><description>2023-01-17每日一题：1814. 统计一个数组中好对子的数目 难度：Medium
标签：数组 、 哈希表 、 数学 、 计数
给你一个数组 nums ，数组中只包含非负整数。定义 rev(x) 的值为将整数 x 各个数字位反转得到的结果。比方说 rev(123) = 321 ， rev(120) = 21 。我们称满足下面条件的下标对 (i, j) 是 好的 ：
0 &amp;lt;= i &amp;lt; j &amp;lt; nums.length nums[i] + rev(nums[j]) == nums[j] + rev(nums[i]) 请你返回好下标对的数目。由于结果可能会很大，请将结果对 109 + 7 取余 后返回。
示例 1：
输入：nums = [42,11,1,97] 输出：2 解释：两个坐标对为： - (0,3)：42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121 。 - (1,2)：11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12 。 示例 2：</description></item><item><title>【2023-01-16每日一题】1813. 句子相似性 III[Medium]</title><link>/study/leetcode/sentence-similarity-iii/</link><pubDate>Mon, 16 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/sentence-similarity-iii/</guid><description>2023-01-16每日一题：1813. 句子相似性 III 难度：Medium
标签：数组 、 双指针 、 字符串
一个句子是由一些单词与它们之间的单个空格组成，且句子的开头和结尾没有多余空格。比方说，"Hello World" ，"HELLO" ，"hello world hello world" 都是句子。每个单词都 只 包含大写和小写英文字母。
如果两个句子 sentence1 和 sentence2 ，可以通过往其中一个句子插入一个任意的句子（可以是空句子）而得到另一个句子，那么我们称这两个句子是 相似的 。比方说，sentence1 = "Hello my name is Jane" 且 sentence2 = "Hello Jane" ，我们可以往 sentence2 中 "Hello" 和 "Jane" 之间插入 "my name is" 得到 sentence1 。
给你两个句子 sentence1 和 sentence2 ，如果 sentence1 和 sentence2 是相似的，请你返回 true ，否则返回 false 。
示例 1：
输入：sentence1 = "My name is Haley", sentence2 = "My Haley" 输出：true 解释：可以往 sentence2 中 "</description></item><item><title>【2023-01-15每日一题】2293. 极大极小游戏[Easy]</title><link>/study/leetcode/min-max-game/</link><pubDate>Sun, 15 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/min-max-game/</guid><description>2023-01-15每日一题：2293. 极大极小游戏 难度：Easy
标签：数组 、 模拟
给你一个下标从 0 开始的整数数组 nums ，其长度是 2 的幂。
对 nums 执行下述算法：
设 n 等于 nums 的长度，如果 n == 1 ，终止 算法过程。否则，创建 一个新的整数数组&amp;nbsp;newNums ，新数组长度为 n / 2 ，下标从 0 开始。 对于满足&amp;nbsp;0 &amp;lt;= i &amp;lt; n / 2 的每个 偶数 下标 i ，将 newNums[i] 赋值 为 min(nums[2 * i], nums[2 * i + 1]) 。 对于满足&amp;nbsp;0 &amp;lt;= i &amp;lt; n / 2 的每个 奇数 下标 i ，将 newNums[i] 赋值 为 max(nums[2 * i], nums[2 * i + 1]) 。 用 newNums 替换 nums 。 从步骤 1 开始 重复 整个过程。 执行算法后，返回 nums 中剩下的那个数字。</description></item><item><title>【2023-01-14每日一题】1819. 序列中不同最大公约数的数目[Hard]</title><link>/study/leetcode/number-of-different-subsequences-gcds/</link><pubDate>Sat, 14 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/number-of-different-subsequences-gcds/</guid><description>2023-01-14每日一题：1819. 序列中不同最大公约数的数目 难度：Hard
标签：数组 、 数学 、 计数 、 数论
给你一个由正整数组成的数组 nums 。
数字序列的 最大公约数 定义为序列中所有整数的共有约数中的最大整数。
例如，序列 [4,6,16] 的最大公约数是 2 。 数组的一个 子序列 本质是一个序列，可以通过删除数组中的某些元素（或者不删除）得到。
例如，[2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。 计算并返回 nums 的所有 非空 子序列中 不同 最大公约数的 数目 。
示例 1：
输入：nums = [6,10,3] 输出：5 解释：上图显示了所有的非空子序列与各自的最大公约数。 不同的最大公约数为 6 、10 、3 、2 和 1 。 示例 2：
输入：nums = [5,15,40,5,6] 输出：7 提示：
1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 2 * 105 方法一： 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
func countDifferentSubsequenceGCDs(nums []int) int { } 复杂度分析 LeetCode题库地址 https://leetcode.</description></item><item><title>【2023-01-13每日一题】2287. 重排字符形成目标字符串[Easy]</title><link>/study/leetcode/rearrange-characters-to-make-target-string/</link><pubDate>Fri, 13 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/rearrange-characters-to-make-target-string/</guid><description>2023-01-13每日一题：2287. 重排字符形成目标字符串 难度：Easy
标签：哈希表 、 字符串 、 计数
给你两个下标从 0 开始的字符串 s 和 target 。你可以从 s 取出一些字符并将其重排，得到若干新的字符串。
从 s 中取出字符并重新排列，返回可以形成 target 的 最大 副本数。
&amp;nbsp;
示例 1：
输入：s = "ilovecodingonleetcode", target = "code" 输出：2 解释： 对于 "code" 的第 1 个副本，选取下标为 4 、5 、6 和 7 的字符。 对于 "code" 的第 2 个副本，选取下标为 17 、18 、19 和 20 的字符。 形成的字符串分别是 "ecod" 和 "code" ，都可以重排为 "code" 。 可以形成最多 2 个 "code" 的副本，所以返回 2 。 示例 2：
输入：s = "</description></item><item><title>【2023-01-12每日一题】1807. 替换字符串中的括号内容[Medium]</title><link>/study/leetcode/evaluate-the-bracket-pairs-of-a-string/</link><pubDate>Thu, 12 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/evaluate-the-bracket-pairs-of-a-string/</guid><description>2023-01-12每日一题：1807. 替换字符串中的括号内容 难度：Medium
标签：数组 、 哈希表 、 字符串
给你一个字符串&amp;nbsp;s&amp;nbsp;，它包含一些括号对，每个括号中包含一个 非空&amp;nbsp;的键。
比方说，字符串&amp;nbsp;"(name)is(age)yearsold"&amp;nbsp;中，有&amp;nbsp;两个&amp;nbsp;括号对，分别包含键&amp;nbsp;"name" 和&amp;nbsp;"age"&amp;nbsp;。 你知道许多键对应的值，这些关系由二维字符串数组&amp;nbsp;knowledge&amp;nbsp;表示，其中&amp;nbsp;knowledge[i] = [keyi, valuei]&amp;nbsp;，表示键&amp;nbsp;keyi&amp;nbsp;对应的值为&amp;nbsp;valuei&amp;nbsp;。
你需要替换 所有&amp;nbsp;的括号对。当你替换一个括号对，且它包含的键为&amp;nbsp;keyi&amp;nbsp;时，你需要：
将&amp;nbsp;keyi&amp;nbsp;和括号用对应的值&amp;nbsp;valuei&amp;nbsp;替换。 如果从 knowledge&amp;nbsp;中无法得知某个键对应的值，你需要将&amp;nbsp;keyi&amp;nbsp;和括号用问号&amp;nbsp;"?"&amp;nbsp;替换（不需要引号）。 knowledge&amp;nbsp;中每个键最多只会出现一次。s&amp;nbsp;中不会有嵌套的括号。
请你返回替换 所有&amp;nbsp;括号对后的结果字符串。
&amp;nbsp;
示例 1：
输入：s = "(name)is(age)yearsold", knowledge = [["name","bob"],["age","two"]] 输出："bobistwoyearsold" 解释： 键 "name" 对应的值为 "bob" ，所以将 "(name)" 替换为 "bob" 。 键 "age" 对应的值为 "two" ，所以将 "(age)" 替换为 "two" 。 示例 2：
输入：s = "hi(name)", knowledge = [["a","b"]] 输出："hi?" 解释：由于不知道键 "name" 对应的值，所以用 "?" 替换 "(name)" 。 示例 3：
输入：s = "(a)(a)(a)aaa", knowledge = [["</description></item><item><title>【2023-01-11每日一题】2283. 判断一个数的数字计数是否等于数位的值[Easy]</title><link>/study/leetcode/check-if-number-has-equal-digit-count-and-digit-value/</link><pubDate>Wed, 11 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/check-if-number-has-equal-digit-count-and-digit-value/</guid><description>2023-01-11每日一题：2283. 判断一个数的数字计数是否等于数位的值 难度：Easy
标签：哈希表 、 字符串 、 计数
给你一个下标从 0&amp;nbsp;开始长度为 n&amp;nbsp;的字符串&amp;nbsp;num&amp;nbsp;，它只包含数字。
如果对于 每个&amp;nbsp;0 &amp;lt;= i &amp;lt; n&amp;nbsp;的下标&amp;nbsp;i&amp;nbsp;，都满足数位&amp;nbsp;i&amp;nbsp;在 num&amp;nbsp;中出现了&amp;nbsp;num[i]次，那么请你返回&amp;nbsp;true&amp;nbsp;，否则返回&amp;nbsp;false&amp;nbsp;。
&amp;nbsp;
示例 1：
输入：num = "1210" 输出：true 解释： num[0] = '1' 。数字 0 在 num 中出现了一次。 num[1] = '2' 。数字 1 在 num 中出现了两次。 num[2] = '1' 。数字 2 在 num 中出现了一次。 num[3] = '0' 。数字 3 在 num 中出现了零次。 "1210" 满足题目要求条件，所以返回 true 。 示例 2：
输入：num = "030" 输出：false 解释： num[0] = '0' 。数字 0 应该出现 0 次，但是在 num 中出现了一次。 num[1] = '3' 。数字 1 应该出现 3 次，但是在 num 中出现了零次。 num[2] = '0' 。数字 2 在 num 中出现了 0 次。 下标 0 和 1 都违反了题目要求，所以返回 false 。 &amp;nbsp;</description></item><item><title>【2023-01-10每日一题】753. 破解保险箱[Hard]</title><link>/study/leetcode/cracking-the-safe/</link><pubDate>Tue, 10 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/cracking-the-safe/</guid><description>2023-01-10每日一题：753. 破解保险箱 难度：Hard
标签：深度优先搜索 、 图 、 欧拉回路
有一个需要密码才能打开的保险箱。密码是&amp;nbsp;n 位数, 密码的每一位是&amp;nbsp;k&amp;nbsp;位序列&amp;nbsp;0, 1, ..., k-1&amp;nbsp;中的一个 。
你可以随意输入密码，保险箱会自动记住最后&amp;nbsp;n&amp;nbsp;位输入，如果匹配，则能够打开保险箱。
举个例子，假设密码是&amp;nbsp;&amp;quot;345&amp;quot;，你可以输入&amp;nbsp;&amp;quot;012345&amp;quot;&amp;nbsp;来打开它，只是你输入了 6&amp;nbsp;个字符.
请返回一个能打开保险箱的最短字符串。
&amp;nbsp;
示例1:
输入: n = 1, k = 2 输出: &amp;quot;01&amp;quot; 说明: &amp;quot;10&amp;quot;也可以打开保险箱。 &amp;nbsp;
示例2:
输入: n = 2, k = 2 输出: &amp;quot;00110&amp;quot; 说明: &amp;quot;01100&amp;quot;, &amp;quot;10011&amp;quot;, &amp;quot;11001&amp;quot; 也能打开保险箱。 &amp;nbsp;
提示：
n 的范围是&amp;nbsp;[1, 4]。 k 的范围是&amp;nbsp;[1, 10]。 k^n 最大可能为&amp;nbsp;4096。 &amp;nbsp;
方法一： 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
func crackSafe(n int, k int) string { } 复杂度分析 LeetCode题库地址 https://leetcode.cn/problems/cracking-the-safe</description></item><item><title>【2023-01-09每日一题】1806. 还原排列的最少操作步数[Medium]</title><link>/study/leetcode/minimum-number-of-operations-to-reinitialize-a-permutation/</link><pubDate>Mon, 09 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/minimum-number-of-operations-to-reinitialize-a-permutation/</guid><description>2023-01-09每日一题：1806. 还原排列的最少操作步数 难度：Medium
标签：数组 、 数学 、 模拟
给你一个偶数 n​​​​​​ ，已知存在一个长度为 n 的排列 perm ，其中 perm[i] == i​（下标 从 0 开始 计数）。
一步操作中，你将创建一个新数组 arr ，对于每个 i ：
如果 i % 2 == 0 ，那么 arr[i] = perm[i / 2] 如果 i % 2 == 1 ，那么 arr[i] = perm[n / 2 + (i - 1) / 2] 然后将 arr​​ 赋值​​给 perm 。
要想使 perm 回到排列初始值，至少需要执行多少步操作？返回最小的 非零 操作步数。
示例 1：
输入：n = 2 输出：1 解释：最初，perm = [0,1] 第 1 步操作后，perm = [0,1] 所以，仅需执行 1 步操作 示例 2：</description></item><item><title>【2023-01-08每日一题】2185. 统计包含给定前缀的字符串[Easy]</title><link>/study/leetcode/counting-words-with-a-given-prefix/</link><pubDate>Sun, 08 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/counting-words-with-a-given-prefix/</guid><description>2023-01-08每日一题：2185. 统计包含给定前缀的字符串 难度：Easy
标签：数组 、 字符串
给你一个字符串数组 words 和一个字符串 pref 。
返回 words 中以 pref 作为 前缀 的字符串的数目。
字符串 s 的 前缀 就是&amp;nbsp; s 的任一前导连续字符串。
&amp;nbsp;
示例 1：
输入：words = ["pay","attention","practice","attend"], pref = "at" 输出：2 解释：以 "at" 作为前缀的字符串有两个，分别是："attention" 和 "attend" 。 示例 2：
输入：words = ["leetcode","win","loops","success"], pref = "code" 输出：0 解释：不存在以 "code" 作为前缀的字符串。 &amp;nbsp;
提示：
1 &amp;lt;= words.length &amp;lt;= 100 1 &amp;lt;= words[i].length, pref.length &amp;lt;= 100 words[i] 和 pref 由小写英文字母组成 方法一： 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
func prefixCount(words []string, pref string) int { } 复杂度分析 LeetCode题库地址 https://leetcode.</description></item><item><title>【2023-01-07每日一题】1658. 将 x 减到 0 的最小操作数[Medium]</title><link>/study/leetcode/minimum-operations-to-reduce-x-to-zero/</link><pubDate>Sat, 07 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/minimum-operations-to-reduce-x-to-zero/</guid><description>2023-01-07每日一题：1658. 将 x 减到 0 的最小操作数 难度：Medium
标签：数组 、 哈希表 、 二分查找 、 前缀和 、 滑动窗口
给你一个整数数组 nums 和一个整数 x 。每一次操作时，你应当移除数组 nums 最左边或最右边的元素，然后从 x 中减去该元素的值。请注意，需要 修改 数组以供接下来的操作使用。
如果可以将 x 恰好 减到 0 ，返回 最小操作数 ；否则，返回 -1 。
示例 1：
输入：nums = [1,1,4,2,3], x = 5 输出：2 解释：最佳解决方案是移除后两个元素，将 x 减到 0 。 示例 2：
输入：nums = [5,6,7,8,9], x = 4 输出：-1 示例 3：
输入：nums = [3,2,20,1,1,3], x = 10 输出：5 解释：最佳解决方案是移除后三个元素和前两个元素（总共 5 次操作），将 x 减到 0 。 提示：</description></item><item><title>【2023-01-06每日一题】2180. 统计各位数字之和为偶数的整数个数[Easy]</title><link>/study/leetcode/count-integers-with-even-digit-sum/</link><pubDate>Fri, 06 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/count-integers-with-even-digit-sum/</guid><description>2023-01-06每日一题：2180. 统计各位数字之和为偶数的整数个数 难度：Easy
标签：数学 、 模拟
给你一个正整数 num ，请你统计并返回 小于或等于 num 且各位数字之和为 偶数 的正整数的数目。
正整数的 各位数字之和 是其所有位上的对应数字相加的结果。
&amp;nbsp;
示例 1：
输入：num = 4 输出：2 解释： 只有 2 和 4 满足小于等于 4 且各位数字之和为偶数。 示例 2：
输入：num = 30 输出：14 解释： 只有 14 个整数满足小于等于 30 且各位数字之和为偶数，分别是： 2、4、6、8、11、13、15、17、19、20、22、24、26 和 28 。 &amp;nbsp;
提示：
1 &amp;lt;= num &amp;lt;= 1000 方法一： 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
func countEven(num int) int { } 复杂度分析 LeetCode题库地址 https://leetcode.cn/problems/count-integers-with-even-digit-sum</description></item><item><title>【2023-01-05每日一题】1803. 统计异或值在范围内的数对有多少[Hard]</title><link>/study/leetcode/count-pairs-with-xor-in-a-range/</link><pubDate>Thu, 05 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/count-pairs-with-xor-in-a-range/</guid><description>2023-01-05每日一题：1803. 统计异或值在范围内的数对有多少 难度：Hard
标签：位运算 、 字典树 、 数组
给你一个整数数组 nums （下标 从 0 开始 计数）以及两个整数：low 和 high ，请返回 漂亮数对 的数目。
漂亮数对 是一个形如 (i, j) 的数对，其中 0 &amp;lt;= i &amp;lt; j &amp;lt; nums.length 且 low &amp;lt;= (nums[i] XOR nums[j]) &amp;lt;= high 。
示例 1：
输入：nums = [1,4,2,7], low = 2, high = 6 输出：6 解释：所有漂亮数对 (i, j) 列出如下： - (0, 1): nums[0] XOR nums[1] = 5 - (0, 2): nums[0] XOR nums[2] = 3 - (0, 3): nums[0] XOR nums[3] = 6 - (1, 2): nums[1] XOR nums[2] = 6 - (1, 3): nums[1] XOR nums[3] = 3 - (2, 3): nums[2] XOR nums[3] = 5 示例 2：</description></item><item><title>【2023-01-04每日一题】1802. 有界数组中指定下标处的最大值[Medium]</title><link>/study/leetcode/maximum-value-at-a-given-index-in-a-bounded-array/</link><pubDate>Wed, 04 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximum-value-at-a-given-index-in-a-bounded-array/</guid><description>2023-01-04每日一题：1802. 有界数组中指定下标处的最大值 难度：Medium
标签：贪心 、 二分查找
给你三个正整数 n、index 和 maxSum 。你需要构造一个同时满足下述所有条件的数组 nums（下标 从 0 开始 计数）：
nums.length == n nums[i] 是 正整数 ，其中 0 &amp;lt;= i &amp;lt; n abs(nums[i] - nums[i+1]) &amp;lt;= 1 ，其中 0 &amp;lt;= i &amp;lt; n-1 nums 中所有元素之和不超过 maxSum nums[index] 的值被 最大化 返回你所构造的数组中的 nums[index] 。
注意：abs(x) 等于 x 的前提是 x &amp;gt;= 0 ；否则，abs(x) 等于 -x 。
示例 1：
输入：n = 4, index = 2, maxSum = 6 输出：2 解释：数组 [1,1,2,1] 和 [1,2,2,1] 满足所有条件。不存在其他在指定下标处具有更大值的有效数组。 示例 2：</description></item><item><title>【2023-01-03每日一题】2042. 检查句子中的数字是否递增[Easy]</title><link>/study/leetcode/check-if-numbers-are-ascending-in-a-sentence/</link><pubDate>Tue, 03 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/check-if-numbers-are-ascending-in-a-sentence/</guid><description>2023-01-03每日一题：2042. 检查句子中的数字是否递增 难度：Easy
标签：字符串
句子是由若干 token 组成的一个列表，token 间用 单个 空格分隔，句子没有前导或尾随空格。每个 token 要么是一个由数字 0-9 组成的不含前导零的 正整数&amp;nbsp;，要么是一个由小写英文字母组成的 单词 。
示例，"a puppy has 2 eyes 4 legs" 是一个由 7 个 token 组成的句子："2" 和 "4" 是数字，其他像&amp;nbsp;"puppy" 这样的 tokens 属于单词。 给你一个表示句子的字符串 s ，你需要检查 s 中的 全部 数字是否从左到右严格递增（即，除了最后一个数字，s 中的 每个 数字都严格小于它 右侧 的数字）。
如果满足题目要求，返回 true&amp;nbsp;，否则，返回 false 。
&amp;nbsp;
示例 1：
输入：s = "1 box has 3 blue 4 red 6 green and 12 yellow marbles" 输出：true 解释：句子中的数字是：1, 3, 4, 6, 12 。 这些数字是按从左到右严格递增的 1 &amp;lt; 3 &amp;lt; 4 &amp;lt; 6 &amp;lt; 12 。 示例 2：</description></item><item><title>【2023-01-02每日一题】1801. 积压订单中的订单总数[Medium]</title><link>/study/leetcode/number-of-orders-in-the-backlog/</link><pubDate>Mon, 02 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/number-of-orders-in-the-backlog/</guid><description>2023-01-02每日一题：1801. 积压订单中的订单总数 难度：Medium
标签：数组 、 模拟 、 堆（优先队列）
给你一个二维整数数组 orders ，其中每个 orders[i] = [pricei, amounti, orderTypei] 表示有 amounti 笔类型为 orderTypei 、价格为 pricei 的订单。
订单类型 orderTypei 可以分为两种：
0 表示这是一批采购订单 buy 1 表示这是一批销售订单 sell 注意，orders[i] 表示一批共计 amounti 笔的独立订单，这些订单的价格和类型相同。对于所有有效的 i ，由 orders[i] 表示的所有订单提交时间均早于 orders[i+1] 表示的所有订单。
存在由未执行订单组成的 积压订单 。积压订单最初是空的。提交订单时，会发生以下情况：
如果该订单是一笔采购订单 buy ，则可以查看积压订单中价格 最低 的销售订单 sell 。如果该销售订单 sell 的价格 低于或等于 当前采购订单 buy 的价格，则匹配并执行这两笔订单，并将销售订单 sell 从积压订单中删除。否则，采购订单 buy 将会添加到积压订单中。 反之亦然，如果该订单是一笔销售订单 sell ，则可以查看积压订单中价格 最高 的采购订单 buy 。如果该采购订单 buy 的价格 高于或等于 当前销售订单 sell 的价格，则匹配并执行这两笔订单，并将采购订单 buy 从积压订单中删除。否则，销售订单 sell 将会添加到积压订单中。 输入所有订单后，返回积压订单中的 订单总数 。由于数字可能很大，所以需要返回对 109 + 7 取余的结果。</description></item><item><title>【2023-01-01每日一题】2351. 第一个出现两次的字母[Easy]</title><link>/study/leetcode/first-letter-to-appear-twice/</link><pubDate>Sun, 01 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/first-letter-to-appear-twice/</guid><description>2023-01-01每日一题：2351. 第一个出现两次的字母 难度：Easy
标签：哈希表 、 字符串 、 计数
给你一个由小写英文字母组成的字符串 s ，请你找出并返回第一个出现 两次 的字母。
注意：
如果 a 的 第二次 出现比 b 的 第二次 出现在字符串中的位置更靠前，则认为字母 a 在字母 b 之前出现两次。 s 包含至少一个出现两次的字母。 &amp;nbsp;
示例 1：
输入：s = "abccbaacz" 输出："c" 解释： 字母 'a' 在下标 0 、5 和 6 处出现。 字母 'b' 在下标 1 和 4 处出现。 字母 'c' 在下标 2 、3 和 7 处出现。 字母 'z' 在下标 8 处出现。 字母 'c' 是第一个出现两次的字母，因为在所有字母中，'c' 第二次出现的下标是最小的。 示例 2：
输入：s = "abcdd" 输出："d" 解释： 只有字母 'd' 出现两次，所以返回 'd' 。 &amp;nbsp;</description></item><item><title>【2022-12-31每日一题】2037. 使每位学生都有座位的最少移动次数[Easy]</title><link>/study/leetcode/minimum-number-of-moves-to-seat-everyone/</link><pubDate>Sat, 31 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/minimum-number-of-moves-to-seat-everyone/</guid><description>2022-12-31每日一题：2037. 使每位学生都有座位的最少移动次数 难度：Easy
标签：数组 、 排序
一个房间里有 n&amp;nbsp;个座位和 n&amp;nbsp;名学生，房间用一个数轴表示。给你一个长度为 n&amp;nbsp;的数组&amp;nbsp;seats&amp;nbsp;，其中&amp;nbsp;seats[i] 是第 i&amp;nbsp;个座位的位置。同时给你一个长度为 n&amp;nbsp;的数组&amp;nbsp;students&amp;nbsp;，其中&amp;nbsp;students[j]&amp;nbsp;是第 j&amp;nbsp;位学生的位置。
你可以执行以下操作任意次：
增加或者减少第&amp;nbsp;i&amp;nbsp;位学生的位置，每次变化量为 1&amp;nbsp;（也就是将第 i&amp;nbsp;位学生从位置 x&amp;nbsp;移动到 x + 1&amp;nbsp;或者 x - 1） 请你返回使所有学生都有座位坐的 最少移动次数&amp;nbsp;，并确保没有两位学生的座位相同。
请注意，初始时有可能有多个座位或者多位学生在 同一&amp;nbsp;位置。
&amp;nbsp;
示例 1：
输入：seats = [3,1,5], students = [2,7,4] 输出：4 解释：学生移动方式如下： - 第一位学生从位置 2 移动到位置 1 ，移动 1 次。 - 第二位学生从位置 7 移动到位置 5 ，移动 2 次。 - 第三位学生从位置 4 移动到位置 3 ，移动 1 次。 总共 1 + 2 + 1 = 4 次移动。 示例 2：</description></item><item><title>【2022-12-30每日一题】855. 考场就座[Medium]</title><link>/study/leetcode/exam-room/</link><pubDate>Fri, 30 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/exam-room/</guid><description>2022-12-30每日一题：855. 考场就座 难度：Medium
标签：设计 、 有序集合 、 堆（优先队列）
在考场里，一排有&amp;nbsp;N&amp;nbsp;个座位，分别编号为&amp;nbsp;0, 1, 2, ..., N-1&amp;nbsp;。
当学生进入考场后，他必须坐在能够使他与离他最近的人之间的距离达到最大化的座位上。如果有多个这样的座位，他会坐在编号最小的座位上。(另外，如果考场里没有人，那么学生就坐在 0 号座位上。)
返回&amp;nbsp;ExamRoom(int N)&amp;nbsp;类，它有两个公开的函数：其中，函数&amp;nbsp;ExamRoom.seat()&amp;nbsp;会返回一个&amp;nbsp;int&amp;nbsp;（整型数据），代表学生坐的位置；函数&amp;nbsp;ExamRoom.leave(int p)&amp;nbsp;代表坐在座位 p 上的学生现在离开了考场。每次调用&amp;nbsp;ExamRoom.leave(p)&amp;nbsp;时都保证有学生坐在座位&amp;nbsp;p&amp;nbsp;上。
&amp;nbsp;
示例：
输入：[&amp;quot;ExamRoom&amp;quot;,&amp;quot;seat&amp;quot;,&amp;quot;seat&amp;quot;,&amp;quot;seat&amp;quot;,&amp;quot;seat&amp;quot;,&amp;quot;leave&amp;quot;,&amp;quot;seat&amp;quot;], [[10],[],[],[],[],[4],[]] 输出：[null,0,9,4,2,null,5] 解释： ExamRoom(10) -&amp;gt; null seat() -&amp;gt; 0，没有人在考场里，那么学生坐在 0 号座位上。 seat() -&amp;gt; 9，学生最后坐在 9 号座位上。 seat() -&amp;gt; 4，学生最后坐在 4 号座位上。 seat() -&amp;gt; 2，学生最后坐在 2 号座位上。 leave(4) -&amp;gt; null seat() -&amp;gt; 5，学生最后坐在 5 号座位上。 &amp;nbsp;
提示：
1 &amp;lt;= N &amp;lt;= 10^9 在所有的测试样例中&amp;nbsp;ExamRoom.seat()&amp;nbsp;和&amp;nbsp;ExamRoom.leave()&amp;nbsp;最多被调用&amp;nbsp;10^4&amp;nbsp;次。 保证在调用&amp;nbsp;ExamRoom.leave(p)&amp;nbsp;时有学生正坐在座位 p 上。 方法一： 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
type ExamRoom struct { } func Constructor(n int) ExamRoom { } func (this *ExamRoom) Seat() int { } func (this *ExamRoom) Leave(p int) { } /** * Your ExamRoom object will be instantiated and called as such: * obj := Constructor(n); * param_1 := obj.</description></item><item><title>【2022-12-29每日一题】2032. 至少在两个数组中出现的值[Easy]</title><link>/study/leetcode/two-out-of-three/</link><pubDate>Thu, 29 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/two-out-of-three/</guid><description>2022-12-29每日一题：2032. 至少在两个数组中出现的值 难度：Easy
标签：数组 、 哈希表
给你三个整数数组 nums1、nums2 和 nums3 ，请你构造并返回一个 元素各不相同的 数组，且由 至少 在 两个 数组中出现的所有值组成。数组中的元素可以按 任意 顺序排列。
&amp;nbsp;
示例 1：
输入：nums1 = [1,1,3,2], nums2 = [2,3], nums3 = [3] 输出：[3,2] 解释：至少在两个数组中出现的所有值为： - 3 ，在全部三个数组中都出现过。 - 2 ，在数组 nums1 和 nums2 中出现过。 示例 2：
输入：nums1 = [3,1], nums2 = [2,3], nums3 = [1,2] 输出：[2,3,1] 解释：至少在两个数组中出现的所有值为： - 2 ，在数组 nums2 和 nums3 中出现过。 - 3 ，在数组 nums1 和 nums2 中出现过。 - 1 ，在数组 nums1 和 nums3 中出现过。 示例 3：</description></item><item><title>【2022-12-28每日一题】1750. 删除字符串两端相同字符后的最短长度[Medium]</title><link>/study/leetcode/minimum-length-of-string-after-deleting-similar-ends/</link><pubDate>Wed, 28 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/minimum-length-of-string-after-deleting-similar-ends/</guid><description>2022-12-28每日一题：1750. 删除字符串两端相同字符后的最短长度 难度：Medium
标签：双指针 、 字符串
给你一个只包含字符 'a'，'b' 和 'c' 的字符串 s ，你可以执行下面这个操作（5 个步骤）任意次：
选择字符串 s 一个 非空 的前缀，这个前缀的所有字符都相同。 选择字符串 s 一个 非空 的后缀，这个后缀的所有字符都相同。 前缀和后缀在字符串中任意位置都不能有交集。 前缀和后缀包含的所有字符都要相同。 同时删除前缀和后缀。 请你返回对字符串 s 执行上面操作任意次以后（可能 0 次），能得到的 最短长度 。
示例 1：
输入：s = "ca" 输出：2 解释：你没法删除任何一个字符，所以字符串长度仍然保持不变。 示例 2：
输入：s = "cabaabac" 输出：0 解释：最优操作序列为： - 选择前缀 "c" 和后缀 "c" 并删除它们，得到 s = "abaaba" 。 - 选择前缀 "a" 和后缀 "a" 并删除它们，得到 s = "baab" 。 - 选择前缀 "b" 和后缀 "b" 并删除它们，得到 s = "</description></item><item><title>【2022-12-27每日一题】2027. 转换字符串的最少操作次数[Easy]</title><link>/study/leetcode/minimum-moves-to-convert-string/</link><pubDate>Tue, 27 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/minimum-moves-to-convert-string/</guid><description>2022-12-27每日一题：2027. 转换字符串的最少操作次数 难度：Easy
标签：贪心 、 字符串
给你一个字符串 s ，由 n 个字符组成，每个字符不是 'X' 就是 'O' 。
一次 操作 定义为从 s 中选出 三个连续字符 并将选中的每个字符都转换为 'O' 。注意，如果字符已经是 'O' ，只需要保持 不变 。
返回将 s 中所有字符均转换为 'O' 需要执行的&amp;nbsp;最少&amp;nbsp;操作次数。
&amp;nbsp;
示例 1：
输入：s = "XXX" 输出：1 解释：XXX -&amp;gt; OOO 一次操作，选中全部 3 个字符，并将它们转换为 'O' 。 示例 2：
输入：s = "XXOX" 输出：2 解释：XXOX -&amp;gt; OOOX -&amp;gt; OOOO 第一次操作，选择前 3 个字符，并将这些字符转换为 'O' 。 然后，选中后 3 个字符，并执行转换。最终得到的字符串全由字符 'O' 组成。 示例 3：
输入：s = "OOOO" 输出：0 解释：s 中不存在需要转换的 'X' 。 &amp;nbsp;</description></item><item><title>【2022-12-26每日一题】1759. 统计同构子字符串的数目[Medium]</title><link>/study/leetcode/count-number-of-homogenous-substrings/</link><pubDate>Mon, 26 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/count-number-of-homogenous-substrings/</guid><description>2022-12-26每日一题：1759. 统计同构子字符串的数目 难度：Medium
标签：数学 、 字符串
给你一个字符串 s ，返回 s 中 同构子字符串 的数目。由于答案可能很大，只需返回对 109 + 7 取余 后的结果。
同构字符串 的定义为：如果一个字符串中的所有字符都相同，那么该字符串就是同构字符串。
子字符串 是字符串中的一个连续字符序列。
示例 1：
输入：s = "abbcccaa" 输出：13 解释：同构子字符串如下所列： "a" 出现 3 次。 "aa" 出现 1 次。 "b" 出现 2 次。 "bb" 出现 1 次。 "c" 出现 3 次。 "cc" 出现 2 次。 "ccc" 出现 1 次。 3 + 1 + 2 + 1 + 3 + 2 + 1 = 13 示例 2：
输入：s = "</description></item><item><title>【2022-12-25每日一题】1739. 放置盒子[Hard]</title><link>/study/leetcode/building-boxes/</link><pubDate>Sun, 25 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/building-boxes/</guid><description>2022-12-25每日一题：1739. 放置盒子 难度：Hard
标签：贪心 、 数学 、 二分查找
有一个立方体房间，其长度、宽度和高度都等于 n 个单位。请你在房间里放置 n 个盒子，每个盒子都是一个单位边长的立方体。放置规则如下：
你可以把盒子放在地板上的任何地方。 如果盒子 x 需要放置在盒子 y 的顶部，那么盒子 y 竖直的四个侧面都 必须 与另一个盒子或墙相邻。 给你一个整数 n ，返回接触地面的盒子的 最少 可能数量。
示例 1：
输入：n = 3 输出：3 解释：上图是 3 个盒子的摆放位置。 这些盒子放在房间的一角，对应左侧位置。 示例 2：
输入：n = 4 输出：3 解释：上图是 3 个盒子的摆放位置。 这些盒子放在房间的一角，对应左侧位置。 示例 3：
输入：n = 10 输出：6 解释：上图是 10 个盒子的摆放位置。 这些盒子放在房间的一角，对应后方位置。 提示：
1 &lt;= n &lt;= 109 方法一：ylb https://leetcode.cn/problems/building-boxes/solutions/2031828/by-lcbin-nbq1/ func minimumBoxes(n int) int { s, k := 0, 1 for s+k*(k+1)/2 &amp;lt;= n { s += k*(k+1)/2 k++ } k-- ans := k*(k+1)/2 for s &amp;lt; n { ans++ s += k k++ } return ans } 复杂度分析 时间复杂度: $O(\sqrt{n})$，空间复杂度 $O(1)$。其中 n 为题目给定的盒子数量。 方法二：灵茶山艾府 https://leetcode.</description></item><item><title>【2022-12-24每日一题】1754. 构造字典序最大的合并字符串[Medium]</title><link>/study/leetcode/largest-merge-of-two-strings/</link><pubDate>Sat, 24 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/largest-merge-of-two-strings/</guid><description>2022-12-24每日一题：1754. 构造字典序最大的合并字符串 难度：Medium
标签：贪心 、 双指针 、 字符串
给你两个字符串 word1 和 word2 。你需要按下述方式构造一个新字符串 merge ：如果 word1 或 word2 非空，选择 下面选项之一 继续操作：
如果 word1 非空，将 word1 中的第一个字符附加到 merge 的末尾，并将其从 word1 中移除。 &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;例如，&amp;lt;code&amp;gt;word1 = &amp;quot;abc&amp;quot; &amp;lt;/code&amp;gt;且 &amp;lt;code&amp;gt;merge = &amp;quot;dv&amp;quot;&amp;lt;/code&amp;gt; ，在执行此选项操作之后，&amp;lt;code&amp;gt;word1 = &amp;quot;bc&amp;quot;&amp;lt;/code&amp;gt; ，同时 &amp;lt;code&amp;gt;merge = &amp;quot;dva&amp;quot;&amp;lt;/code&amp;gt; 。&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;如果 &amp;lt;code&amp;gt;word2&amp;lt;/code&amp;gt; 非空，将 &amp;lt;code&amp;gt;word2&amp;lt;/code&amp;gt; 中的第一个字符附加到 &amp;lt;code&amp;gt;merge&amp;lt;/code&amp;gt; 的末尾，并将其从 &amp;lt;code&amp;gt;word2&amp;lt;/code&amp;gt; 中移除。 &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;例如，&amp;lt;code&amp;gt;word2 = &amp;quot;abc&amp;quot; &amp;lt;/code&amp;gt;且 &amp;lt;code&amp;gt;merge = &amp;quot;&amp;quot;&amp;lt;/code&amp;gt; ，在执行此选项操作之后，&amp;lt;code&amp;gt;word2 = &amp;quot;bc&amp;quot;&amp;lt;/code&amp;gt; ，同时 &amp;lt;code&amp;gt;merge = &amp;quot;a&amp;quot;&amp;lt;/code&amp;gt; 。&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/li&amp;gt; 返回你可以构造的字典序 最大 的合并字符串 merge 。</description></item><item><title>【2022-12-23每日一题】2011. 执行操作后的变量值[Easy]</title><link>/study/leetcode/final-value-of-variable-after-performing-operations/</link><pubDate>Fri, 23 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/final-value-of-variable-after-performing-operations/</guid><description>2022-12-23每日一题：2011. 执行操作后的变量值 难度：Easy
标签：数组 、 字符串 、 模拟
存在一种仅支持 4 种操作和 1 个变量 X 的编程语言：
++X 和 X++ 使变量 X 的值 加 1 --X 和 X-- 使变量 X 的值 减 1 最初，X 的值是 0
给你一个字符串数组 operations ，这是由操作组成的一个列表，返回执行所有操作后， X 的 最终值 。
&amp;nbsp;
示例 1：
输入：operations = ["--X","X++","X++"] 输出：1 解释：操作按下述步骤执行： 最初，X = 0 --X：X 减 1 ，X = 0 - 1 = -1 X++：X 加 1 ，X = -1 + 1 = 0 X++：X 加 1 ，X = 0 + 1 = 1 示例 2：</description></item><item><title>【2022-12-22每日一题】1799. N 次操作后的最大分数和[Hard]</title><link>/study/leetcode/maximize-score-after-n-operations/</link><pubDate>Thu, 22 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximize-score-after-n-operations/</guid><description>2022-12-22每日一题：1799. N 次操作后的最大分数和 难度：Hard
标签：位运算 、 数组 、 数学 、 动态规划 、 回溯 、 状态压缩 、 数论
给你 nums ，它是一个大小为 2 * n 的正整数数组。你必须对这个数组执行 n 次操作。
在第 i 次操作时（操作编号从 1 开始），你需要：
选择两个元素 x 和 y 。 获得分数 i * gcd(x, y) 。 将 x 和 y 从 nums 中删除。 请你返回 n 次操作后你能获得的分数和最大为多少。
函数 gcd(x, y) 是 x 和 y 的最大公约数。
示例 1：
输入：nums = [1,2] 输出：1 解释：最优操作是： (1 * gcd(1, 2)) = 1 示例 2：</description></item><item><title>【2022-12-21每日一题】1753. 移除石子的最大得分[Medium]</title><link>/study/leetcode/maximum-score-from-removing-stones/</link><pubDate>Wed, 21 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximum-score-from-removing-stones/</guid><description>2022-12-21每日一题：1753. 移除石子的最大得分 难度：Medium
标签：贪心 、 数学 、 堆（优先队列）
你正在玩一个单人游戏，面前放置着大小分别为 a​​​​​​、b 和 c​​​​​​ 的 三堆 石子。
每回合你都要从两个 不同的非空堆 中取出一颗石子，并在得分上加 1 分。当存在 两个或更多 的空堆时，游戏停止。
给你三个整数 a 、b 和 c ，返回可以得到的 最大分数 。
示例 1：
输入：a = 2, b = 4, c = 6 输出：6 解释：石子起始状态是 (2, 4, 6) ，最优的一组操作是： - 从第一和第三堆取，石子状态现在是 (1, 4, 5) - 从第一和第三堆取，石子状态现在是 (0, 4, 4) - 从第二和第三堆取，石子状态现在是 (0, 3, 3) - 从第二和第三堆取，石子状态现在是 (0, 2, 2) - 从第二和第三堆取，石子状态现在是 (0, 1, 1) - 从第二和第三堆取，石子状态现在是 (0, 0, 0) 总分：6 分 。 示例 2：</description></item><item><title>【2022-12-20每日一题】1760. 袋子里最少数目的球[Medium]</title><link>/study/leetcode/minimum-limit-of-balls-in-a-bag/</link><pubDate>Tue, 20 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/minimum-limit-of-balls-in-a-bag/</guid><description>2022-12-20每日一题：1760. 袋子里最少数目的球 难度：Medium
标签：数组 、 二分查找
给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。
你可以进行如下操作至多 maxOperations 次：
选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 正整数 个球。 &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;比方说，一个袋子里有 &amp;lt;code&amp;gt;5&amp;lt;/code&amp;gt; 个球，你可以把它们分到两个新袋子里，分别有 &amp;lt;code&amp;gt;1&amp;lt;/code&amp;gt; 个和 &amp;lt;code&amp;gt;4&amp;lt;/code&amp;gt; 个球，或者分别有 &amp;lt;code&amp;gt;2&amp;lt;/code&amp;gt; 个和 &amp;lt;code&amp;gt;3&amp;lt;/code&amp;gt; 个球。&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/li&amp;gt; 你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。
请你返回进行上述操作后的最小开销。
示例 1：
输入：nums = [9], maxOperations = 2 输出：3 解释： - 将装有 9 个球的袋子分成装有 6 个和 3 个球的袋子。[9] -> [6,3] 。 - 将装有 6 个球的袋子分成装有 3 个和 3 个球的袋子。[6,3] -> [3,3,3] 。 装有最多球的袋子里装有 3 个球，所以开销为 3 并返回 3 。 示例 2：</description></item><item><title>【2022-12-19每日一题】1971. 寻找图中是否存在路径[Easy]</title><link>/study/leetcode/find-if-path-exists-in-graph/</link><pubDate>Mon, 19 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/find-if-path-exists-in-graph/</guid><description>2022-12-19每日一题：1971. 寻找图中是否存在路径 难度：Easy
标签：深度优先搜索 、 广度优先搜索 、 并查集 、 图
有一个具有 n 个顶点的 双向 图，其中每个顶点标记从 0 到 n - 1（包含 0 和 n - 1）。图中的边用一个二维整数数组 edges 表示，其中 edges[i] = [ui, vi] 表示顶点 ui 和顶点 vi 之间的双向边。 每个顶点对由 最多一条 边连接，并且没有顶点存在与自身相连的边。
请你确定是否存在从顶点 source 开始，到顶点 destination 结束的 有效路径 。
给你数组 edges 和整数 n、source 和 destination，如果从 source 到 destination 存在 有效路径 ，则返回 true，否则返回 false 。
&amp;nbsp;
示例 1：
输入：n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2 输出：true 解释：存在由顶点 0 到顶点 2 的路径: - 0 → 1 → 2 - 0 → 2 示例 2：</description></item><item><title>【2022-12-18每日一题】1703. 得到连续 K 个 1 的最少相邻交换次数[Hard]</title><link>/study/leetcode/minimum-adjacent-swaps-for-k-consecutive-ones/</link><pubDate>Sun, 18 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/minimum-adjacent-swaps-for-k-consecutive-ones/</guid><description>2022-12-18每日一题：1703. 得到连续 K 个 1 的最少相邻交换次数 难度：Hard
标签：贪心 、 数组 、 前缀和 、 滑动窗口
给你一个整数数组 nums 和一个整数 k 。 nums 仅包含 0 和 1 。每一次移动，你可以选择 相邻 两个数字并将它们交换。
请你返回使 nums 中包含 k 个 连续 1 的 最少 交换次数。
示例 1：
输入：nums = [1,0,0,1,0,1], k = 2 输出：1 解释：在第一次操作时，nums 可以变成 [1,0,0,0,1,1] 得到连续两个 1 。 示例 2：
输入：nums = [1,0,0,0,0,0,1,1], k = 3 输出：5 解释：通过 5 次操作，最左边的 1 可以移到右边直到 nums 变为 [0,0,0,0,0,1,1,1] 。 示例 3：
输入：nums = [1,1,0,1], k = 2 输出：0 解释：nums 已经有连续 2 个 1 了。 提示：</description></item><item><title>【2022-12-17每日一题】1764. 通过连接另一个数组的子数组得到一个数组[Medium]</title><link>/study/leetcode/form-array-by-concatenating-subarrays-of-another-array/</link><pubDate>Sat, 17 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/form-array-by-concatenating-subarrays-of-another-array/</guid><description>2022-12-17每日一题：1764. 通过连接另一个数组的子数组得到一个数组 难度：Medium
标签：贪心 、 数组 、 字符串匹配
给你一个长度为 n 的二维整数数组 groups ，同时给你一个整数数组 nums 。
你是否可以从 nums 中选出 n 个 不相交 的子数组，使得第 i 个子数组与 groups[i] （下标从 0 开始）完全相同，且如果 i > 0 ，那么第 (i-1) 个子数组在 nums 中出现的位置在第 i 个子数组前面。（也就是说，这些子数组在 nums 中出现的顺序需要与 groups 顺序相同）
如果你可以找出这样的 n 个子数组，请你返回 true ，否则返回 false 。
如果不存在下标为 k 的元素 nums[k] 属于不止一个子数组，就称这些子数组是 不相交 的。子数组指的是原数组中连续元素组成的一个序列。
示例 1：
输入：groups = [[1,-1,-1],[3,-2,0]], nums = [1,-1,0,1,-1,-1,3,-2,0] 输出：true 解释：你可以分别在 nums 中选出第 0 个子数组 [1,-1,0,1,-1,-1,3,-2,0] 和第 1 个子数组 [1,-1,0,1,-1,-1,3,-2,0] 。 这两个子数组是不相交的，因为它们没有任何共同的元素。 示例 2：</description></item><item><title>【2022-12-16每日一题】1785. 构成特定和需要添加的最少元素[Medium]</title><link>/study/leetcode/minimum-elements-to-add-to-form-a-given-sum/</link><pubDate>Fri, 16 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/minimum-elements-to-add-to-form-a-given-sum/</guid><description>2022-12-16每日一题：1785. 构成特定和需要添加的最少元素 难度：Medium
标签：贪心 、 数组
给你一个整数数组 nums ，和两个整数 limit 与 goal 。数组 nums 有一条重要属性：abs(nums[i]) &lt;= limit 。
返回使数组元素总和等于 goal 所需要向数组中添加的 最少元素数量 ，添加元素 不应改变 数组中 abs(nums[i]) &lt;= limit 这一属性。
注意，如果 x >= 0 ，那么 abs(x) 等于 x ；否则，等于 -x 。
示例 1：
输入：nums = [1,-1,1], limit = 3, goal = -4 输出：2 解释：可以将 -2 和 -3 添加到数组中，数组的元素总和变为 1 - 1 + 1 - 2 - 3 = -4 。 示例 2：
输入：nums = [1,-10,9,1], limit = 100, goal = 0 输出：1 提示：</description></item><item><title>【2022-12-15每日一题】1945. 字符串转化后的各位数字之和[Easy]</title><link>/study/leetcode/sum-of-digits-of-string-after-convert/</link><pubDate>Thu, 15 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/sum-of-digits-of-string-after-convert/</guid><description>2022-12-15每日一题：1945. 字符串转化后的各位数字之和 难度：Easy
标签：字符串 、 模拟
给你一个由小写字母组成的字符串 s ，以及一个整数 k 。
首先，用字母在字母表中的位置替换该字母，将 s 转化 为一个整数（也就是，'a' 用 1 替换，'b' 用 2 替换，... 'z' 用 26 替换）。接着，将整数 转换 为其 各位数字之和 。共重复 转换 操作 k 次 。
例如，如果 s = "zbax" 且 k = 2 ，那么执行下述步骤后得到的结果是整数 8 ：
转化："zbax" ➝ "(26)(2)(1)(24)" ➝ "262124" ➝ 262124 转换 #1：262124&amp;nbsp;➝ 2 + 6 + 2 + 1 + 2 + 4&amp;nbsp;➝ 17 转换 #2：17 ➝ 1 + 7 ➝ 8 返回执行上述操作后得到的结果整数。</description></item><item><title>【2022-12-14每日一题】1697. 检查边长度限制的路径是否存在[Hard]</title><link>/study/leetcode/checking-existence-of-edge-length-limited-paths/</link><pubDate>Wed, 14 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/checking-existence-of-edge-length-limited-paths/</guid><description>2022-12-14每日一题：1697. 检查边长度限制的路径是否存在 难度：Hard
标签：并查集 、 图 、 数组 、 排序
给你一个 n 个点组成的无向图边集 edgeList ，其中 edgeList[i] = [ui, vi, disi] 表示点 ui 和点 vi 之间有一条长度为 disi 的边。请注意，两个点之间可能有 超过一条边 。
给你一个查询数组queries ，其中 queries[j] = [pj, qj, limitj] ，你的任务是对于每个查询 queries[j] ，判断是否存在从 pj 到 qj 的路径，且这条路径上的每一条边都 严格小于 limitj 。
请你返回一个 布尔数组 answer ，其中 answer.length == queries.length ，当 queries[j] 的查询结果为 true 时， answer 第 j 个值为 true ，否则为 false 。
示例 1：
输入：n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]] 输出：[false,true] 解释：上图为给定的输入数据。注意到 0 和 1 之间有两条重边，分别为 2 和 16 。 对于第一个查询，0 和 1 之间没有小于 2 的边，所以我们返回 false 。 对于第二个查询，有一条路径（0 -> 1 -> 2）两条边都小于 5 ，所以这个查询我们返回 true 。 示例 2：</description></item><item><title>【2022-12-13每日一题】1832. 判断句子是否为全字母句[Easy]</title><link>/study/leetcode/check-if-the-sentence-is-pangram/</link><pubDate>Tue, 13 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/check-if-the-sentence-is-pangram/</guid><description>2022-12-13每日一题：1832. 判断句子是否为全字母句 难度：Easy
标签：哈希表 、 字符串
全字母句 指包含英语字母表中每个字母至少一次的句子。
给你一个仅由小写英文字母组成的字符串 sentence ，请你判断 sentence 是否为 全字母句 。
如果是，返回 true ；否则，返回 false 。
示例 1：
输入：sentence = "thequickbrownfoxjumpsoverthelazydog" 输出：true 解释：sentence 包含英语字母表中每个字母至少一次。 示例 2：
输入：sentence = "leetcode" 输出：false 提示：
1 &lt;= sentence.length &lt;= 1000 sentence 由小写英语字母组成 方法一：哈希表 func checkIfPangram(sentence string) bool { if len(sentence) &amp;lt; 26 { return false } exist := [26]bool{} for _, c := range sentence { exist[c-'a'] = true } for _, v := range exist { if !</description></item><item><title>【2022-12-12每日一题】1781. 所有子字符串美丽值之和[Medium]</title><link>/study/leetcode/sum-of-beauty-of-all-substrings/</link><pubDate>Mon, 12 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/sum-of-beauty-of-all-substrings/</guid><description>2022-12-12每日一题：1781. 所有子字符串美丽值之和 难度：Medium
标签：哈希表 、 字符串 、 计数
一个字符串的 美丽值 定义为：出现频率最高字符与出现频率最低字符的出现次数之差。
比方说，"abaacc" 的美丽值为 3 - 1 = 2 。 给你一个字符串 s ，请你返回它所有子字符串的 美丽值 之和。
示例 1：
输入：s = "aabcb" 输出：5 解释：美丽值不为零的字符串包括 ["aab","aabc","aabcb","abcb","bcb"] ，每一个字符串的美丽值都为 1 。 示例 2：
输入：s = "aabcbaa" 输出：17 提示：
1 &lt;= s.length &lt;= 500 s 只包含小写英文字母。 方法一：暴力枚举+计数 func beautySum(s string) (ans int) { for i := 0; i &amp;lt; len(s); i++ { cnt, mx := [26]int{}, 0 for j := i; j &amp;lt; len(s); j++ { cnt[s[j]-'a']++ mx = max(mx, cnt[s[j]-'a']) mi := len(s) for _, c := range cnt { if c &amp;gt; 0 { mi = min(mi, c) } } ans += mx-mi } } return ans } func min(a, b int) int { if a &amp;lt; b { return a } return b } func max(a, b int) int { if a &amp;gt; b { return a } return b } 复杂度分析 时间复杂度：$O(C×n^2)$，其中 C 是 s 的元素种类，n 是 s 的长度。</description></item><item><title>【2022-12-11每日一题】1827. 最少操作使数组递增[Easy]</title><link>/study/leetcode/minimum-operations-to-make-the-array-increasing/</link><pubDate>Sun, 11 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/minimum-operations-to-make-the-array-increasing/</guid><description>2022-12-11每日一题：1827. 最少操作使数组递增 难度：Easy
标签：贪心 、 数组
给你一个整数数组 nums （下标从 0 开始）。每一次操作中，你可以选择数组中一个元素，并将它增加 1 。
比方说，如果 nums = [1,2,3] ，你可以选择增加 nums[1] 得到 nums = [1,3,3] 。 请你返回使 nums 严格递增 的 最少 操作次数。
我们称数组 nums 是 严格递增的 ，当它满足对于所有的 0 &amp;lt;= i &amp;lt; nums.length - 1 都有 nums[i] &amp;lt; nums[i+1] 。一个长度为 1 的数组是严格递增的一种特殊情况。
示例 1：
输入：nums = [1,1,1] 输出：3 解释：你可以进行如下操作： 1) 增加 nums[2] ，数组变为 [1,1,2] 。 2) 增加 nums[1] ，数组变为 [1,2,2] 。 3) 增加 nums[2] ，数组变为 [1,2,3] 。 示例 2：</description></item><item><title>【2022-12-10每日一题】1691. 堆叠长方体的最大高度[Hard]</title><link>/study/leetcode/maximum-height-by-stacking-cuboids/</link><pubDate>Sat, 10 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximum-height-by-stacking-cuboids/</guid><description>2022-12-10每日一题：1691. 堆叠长方体的最大高度 难度：Hard
标签：数组 、 动态规划 、 排序
给你 n 个长方体 cuboids ，其中第 i 个长方体的长宽高表示为 cuboids[i] = [widthi, lengthi, heighti]（下标从 0 开始）。请你从 cuboids 选出一个 子集 ，并将它们堆叠起来。
如果 widthi &lt;= widthj 且 lengthi &lt;= lengthj 且 heighti &lt;= heightj ，你就可以将长方体 i 堆叠在长方体 j 上。你可以通过旋转把长方体的长宽高重新排列，以将它放在另一个长方体上。
返回 堆叠长方体 cuboids 可以得到的 最大高度 。
示例 1：
输入：cuboids = [[50,45,20],[95,37,53],[45,23,12]] 输出：190 解释： 第 1 个长方体放在底部，53x37 的一面朝下，高度为 95 。 第 0 个长方体放在中间，45x20 的一面朝下，高度为 50 。 第 2 个长方体放在上面，23x12 的一面朝下，高度为 45 。 总高度是 95 + 50 + 45 = 190 。 示例 2：</description></item><item><title>【2022-12-09每日一题】1780. 判断一个数字是否可以表示成三的幂的和[Medium]</title><link>/study/leetcode/check-if-number-is-a-sum-of-powers-of-three/</link><pubDate>Fri, 09 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/check-if-number-is-a-sum-of-powers-of-three/</guid><description>2022-12-09每日一题：1780. 判断一个数字是否可以表示成三的幂的和 难度：Medium
标签：数学
给你一个整数 n ，如果你可以将 n 表示成若干个不同的三的幂之和，请你返回 true ，否则请返回 false 。
对于一个整数 y ，如果存在整数 x 满足 y == 3x ，我们称这个整数 y 是三的幂。
示例 1：
输入：n = 12 输出：true 解释：12 = 31 + 32 示例 2：
输入：n = 91 输出：true 解释：91 = 30 + 32 + 34 示例 3：
输入：n = 21 输出：false 提示：
1 &amp;lt;= n &amp;lt;= 107 方法一：三进制 思路与算法 我们可以将 n 转换成 3 进制。如果 n 的 3 进制表示中每一位均不为 2，那么答案为 True，否则为 False。
例如当 n=12 时，12=(110)3，满足要求；当 n=21 时，21=(210)3，不满足要求。</description></item><item><title>【2022-12-08每日一题】1812. 判断国际象棋棋盘中一个格子的颜色[Easy]</title><link>/study/leetcode/determine-color-of-a-chessboard-square/</link><pubDate>Thu, 08 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/determine-color-of-a-chessboard-square/</guid><description>2022-12-08每日一题：1812. 判断国际象棋棋盘中一个格子的颜色 难度：Easy
标签：数学 、 字符串
给你一个坐标 coordinates ，它是一个字符串，表示国际象棋棋盘中一个格子的坐标。下图是国际象棋棋盘示意图。
如果所给格子的颜色是白色，请你返回 true，如果是黑色，请返回 false 。
给定坐标一定代表国际象棋棋盘上一个存在的格子。坐标第一个字符是字母，第二个字符是数字。
示例 1：
输入：coordinates = "a1" 输出：false 解释：如上图棋盘所示，"a1" 坐标的格子是黑色的，所以返回 false 。 示例 2：
输入：coordinates = "h3" 输出：true 解释：如上图棋盘所示，"h3" 坐标的格子是白色的，所以返回 true 。 示例 3：
输入：coordinates = "c7" 输出：false 提示：
coordinates.length == 2 'a' &lt;= coordinates[0] &lt;= 'h' '1' &lt;= coordinates[1] &lt;= '8' 方法一：找规律 可以换算成2x2格子，行列相同为黑色返回false，不同为白色返回true
func squareIsWhite(coordinates string) bool { r := int(coordinates[1]-'1') % 2 c := int(coordinates[0]-'a') % 2 if r == c { return false } return true } 复杂度分析 时间复杂度：O(1)。仅使用常数时间。 空间复杂度：O(1)。仅使用常数空间。 方法二：数学 思路 经过观察可以发现，从左下角开始，棋盘的行数和列数（均从 1 开始计数）之和如果为奇数，则为白色格子，如果和为偶数，则为黑色格子。可以根据这个结论判断格子颜色。</description></item><item><title>【2022-12-07每日一题】1775. 通过最少操作次数使数组的和相等[Medium]</title><link>/study/leetcode/equal-sum-arrays-with-minimum-number-of-operations/</link><pubDate>Wed, 07 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/equal-sum-arrays-with-minimum-number-of-operations/</guid><description>2022-12-07每日一题：1775. 通过最少操作次数使数组的和相等 难度：Medium
标签：贪心 、 数组 、 哈希表 、 计数
给你两个长度可能不等的整数数组 nums1 和 nums2 。两个数组中的所有值都在 1 到 6 之间（包含 1 和 6）。
每次操作中，你可以选择 任意 数组中的任意一个整数，将它变成 1 到 6 之间 任意 的值（包含 1 和 6）。
请你返回使 nums1 中所有数的和与 nums2 中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回 -1 。
示例 1：
输入：nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2] 输出：3 解释：你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。 - 将 nums2[0] 变为 6 。 nums1 = [1,2,3,4,5,6], nums2 = [6,1,2,2,2,2] 。 - 将 nums1[5] 变为 1 。 nums1 = [1,2,3,4,5,1], nums2 = [6,1,2,2,2,2] 。 - 将 nums1[2] 变为 2 。 nums1 = [1,2,2,4,5,1], nums2 = [6,1,2,2,2,2] 。 示例 2：</description></item><item><title>【2022-12-06每日一题】1805. 字符串中不同整数的数目[Easy]</title><link>/study/leetcode/number-of-different-integers-in-a-string/</link><pubDate>Tue, 06 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/number-of-different-integers-in-a-string/</guid><description>2022-12-06每日一题：1805. 字符串中不同整数的数目 难度：Easy
标签：哈希表 、 字符串
给你一个字符串 word ，该字符串由数字和小写英文字母组成。
请你用空格替换每个不是数字的字符。例如，"a123bc34d8ef34" 将会变成 " 123 34 8 34" 。注意，剩下的这些整数为（相邻彼此至少有一个空格隔开）："123"、"34"、"8" 和 "34" 。
返回对 word 完成替换后形成的 不同 整数的数目。
只有当两个整数的 不含前导零 的十进制表示不同， 才认为这两个整数也不同。
示例 1：
输入：word = "a123bc34d8ef34" 输出：3 解释：不同的整数有 "123"、"34" 和 "8" 。注意，"34" 只计数一次。 示例 2：
输入：word = "leet1234code234" 输出：2 示例 3：
输入：word = "a1b01c001" 输出：1 解释："1"、"01" 和 "001" 视为同一个整数的十进制表示，因为在比较十进制值时会忽略前导零的存在。 提示：
1 &lt;= word.length &lt;= 1000 word 由数字和小写英文字母组成 方法一：哈希表（自己） 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
func numDifferentIntegers(word string) int { nums := make(map[int]bool) num, valid := 0, false for _, c := range word { if c &amp;gt;= '0' &amp;amp;&amp;amp; c &amp;lt;= '9' { num += num*10+int(c-'0') valid = true } else if valid { nums[num] = true num, valid = 0, false } } if valid { nums[num] = true } return len(nums) } 复杂度分析 时间复杂度: O(n)。 空间复杂度: O(n)。 方法二：双指针+模拟 写法一 func numDifferentIntegers(word string) int { s, n := map[string]struct{}{}, len(word) for i := 0; i &amp;lt; n; i++ { if word[i] &amp;gt;= '0' &amp;amp;&amp;amp; word[i] &amp;lt;= '9' { // 跳过前缀0 for i &amp;lt; n &amp;amp;&amp;amp; word[i] == '0' { i++ } // 查找数字结束位置 j := i for j &amp;lt; n &amp;amp;&amp;amp; word[j] &amp;gt;= '0' &amp;amp;&amp;amp; word[j] &amp;lt;= '9' { j++ } s[word[i:j]] = struct{}{} // a000，此时word[i:j]为空字符串 i = j } } return len(s) } 写法二 func numDifferentIntegers(word string) int { s, n := map[string]bool{}, len(word) p1 := 0 for { // 查找开始位置 for p1 &amp;lt; n &amp;amp;&amp;amp; !</description></item><item><title>【2022-12-05每日一题】1687. 从仓库到码头运输箱子[Hard]</title><link>/study/leetcode/delivering-boxes-from-storage-to-ports/</link><pubDate>Mon, 05 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/delivering-boxes-from-storage-to-ports/</guid><description>2022-12-05每日一题：1687. 从仓库到码头运输箱子 难度：Hard
标签：线段树 、 队列 、 数组 、 动态规划 、 单调队列 、 堆（优先队列）
你有一辆货运卡车，你需要用这一辆车把一些箱子从仓库运送到码头。这辆卡车每次运输有 箱子数目的限制 和 总重量的限制 。
给你一个箱子数组 boxes 和三个整数 portsCount, maxBoxes 和 maxWeight ，其中 boxes[i] = [ports​​i​, weighti] 。
ports​​i 表示第 i 个箱子需要送达的码头， weightsi 是第 i 个箱子的重量。 portsCount 是码头的数目。 maxBoxes 和 maxWeight 分别是卡车每趟运输箱子数目和重量的限制。 箱子需要按照 数组顺序 运输，同时每次运输需要遵循以下步骤：
卡车从 boxes 队列中按顺序取出若干个箱子，但不能违反 maxBoxes 和 maxWeight 限制。 对于在卡车上的箱子，我们需要 按顺序 处理它们，卡车会通过 一趟行程 将最前面的箱子送到目的地码头并卸货。如果卡车已经在对应的码头，那么不需要 额外行程 ，箱子也会立马被卸货。 卡车上所有箱子都被卸货后，卡车需要 一趟行程 回到仓库，从箱子队列里再取出一些箱子。 卡车在将所有箱子运输并卸货后，最后必须回到仓库。
请你返回将所有箱子送到相应码头的 最少行程 次数。
示例 1：
输入：boxes = [[1,1],[2,1],[1,1]], portsCount = 2, maxBoxes = 3, maxWeight = 3 输出：4 解释：最优策略如下： - 卡车将所有箱子装上车，到达码头 1 ，然后去码头 2 ，然后再回到码头 1 ，最后回到仓库，总共需要 4 趟行程。 所以总行程数为 4 。 注意到第一个和第三个箱子不能同时被卸货，因为箱子需要按顺序处理（也就是第二个箱子需要先被送到码头 2 ，然后才能处理第三个箱子）。 示例 2：</description></item><item><title>【2022-12-04每日一题】1774. 最接近目标价格的甜点成本[Medium]</title><link>/study/leetcode/closest-dessert-cost/</link><pubDate>Sun, 04 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/closest-dessert-cost/</guid><description>2022-12-04每日一题：1774. 最接近目标价格的甜点成本 难度：Medium
标签：数组 、 动态规划 、 回溯
你打算做甜点，现在需要购买配料。目前共有 n 种冰激凌基料和 m 种配料可供选购。而制作甜点需要遵循以下几条规则：
必须选择 一种 冰激凌基料。 可以添加 一种或多种 配料，也可以不添加任何配料。 每种类型的配料 最多两份 。 给你以下三个输入：
baseCosts ，一个长度为 n 的整数数组，其中每个 baseCosts[i] 表示第 i 种冰激凌基料的价格。 toppingCosts，一个长度为 m 的整数数组，其中每个 toppingCosts[i] 表示 一份 第 i 种冰激凌配料的价格。 target ，一个整数，表示你制作甜点的目标价格。 你希望自己做的甜点总成本尽可能接近目标价格 target 。
返回最接近 target 的甜点成本。如果有多种方案，返回 成本相对较低 的一种。
示例 1：
输入：baseCosts = [1,7], toppingCosts = [3,4], target = 10 输出：10 解释：考虑下面的方案组合（所有下标均从 0 开始）： - 选择 1 号基料：成本 7 - 选择 1 份 0 号配料：成本 1 x 3 = 3 - 选择 0 份 1 号配料：成本 0 x 4 = 0 总成本：7 + 3 + 0 = 10 。 示例 2：</description></item><item><title>【2022-12-03每日一题】1796. 字符串中第二大的数字[Easy]</title><link>/study/leetcode/second-largest-digit-in-a-string/</link><pubDate>Sat, 03 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/second-largest-digit-in-a-string/</guid><description>2022-12-03每日一题：1796. 字符串中第二大的数字 难度：Easy
标签：哈希表 、 字符串
给你一个混合字符串 s ，请你返回 s 中 第二大 的数字，如果不存在第二大的数字，请你返回 -1 。
混合字符串 由小写英文字母和数字组成。
示例 1：
输入：s = "dfa12321afd" 输出：2 解释：出现在 s 中的数字包括 [1, 2, 3] 。第二大的数字是 2 。 示例 2：
输入：s = "abc1111" 输出：-1 解释：出现在 s 中的数字只包含 [1] 。没有第二大的数字。 提示：
1 &lt;= s.length &lt;= 500 s 只包含小写英文字母和（或）数字。 方法一：直接遍历+双指针 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
func secondHighest(s string) int { first, second := -1, -1 for _, c := range s { if unicode.IsDigit(c) { num := int(c - '0') if num &amp;gt; first { first, second = num, first } else if second &amp;lt; num &amp;amp;&amp;amp; num &amp;lt; first { // num &amp;lt; first 防止second 与 first 重复 second = num } } } return second } 复杂度分析 时间复杂度：O(n)，其中 n 表示字符串的长度。我们只需遍历一遍字符串即可。</description></item><item><title>【2022-12-02每日一题】1769. 移动所有球到每个盒子所需的最小操作数[Medium]</title><link>/study/leetcode/minimum-number-of-operations-to-move-all-balls-to-each-box/</link><pubDate>Fri, 02 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/minimum-number-of-operations-to-move-all-balls-to-each-box/</guid><description>2022-12-02每日一题：1769. 移动所有球到每个盒子所需的最小操作数 难度：Medium
标签：数组 、 字符串
有 n 个盒子。给你一个长度为 n 的二进制字符串 boxes ，其中 boxes[i] 的值为 '0' 表示第 i 个盒子是 空 的，而 boxes[i] 的值为 '1' 表示盒子里有 一个 小球。
在一步操作中，你可以将 一个 小球从某个盒子移动到一个与之相邻的盒子中。第 i 个盒子和第 j 个盒子相邻需满足 abs(i - j) == 1 。注意，操作执行后，某些盒子中可能会存在不止一个小球。
返回一个长度为 n 的数组 answer ，其中 answer[i] 是将所有小球移动到第 i 个盒子所需的 最小 操作数。
每个 answer[i] 都需要根据盒子的 初始状态 进行计算。
示例 1：
输入：boxes = "110" 输出：[1,1,3] 解释：每个盒子对应的最小操作数如下： 1) 第 1 个盒子：将一个小球从第 2 个盒子移动到第 1 个盒子，需要 1 步操作。 2) 第 2 个盒子：将一个小球从第 1 个盒子移动到第 2 个盒子，需要 1 步操作。 3) 第 3 个盒子：将一个小球从第 1 个盒子移动到第 3 个盒子，需要 2 步操作。将一个小球从第 2 个盒子移动到第 3 个盒子，需要 1 步操作。共计 3 步操作。 示例 2：</description></item><item><title>【2022-12-01每日一题】1779. 找到最近的有相同 X 或 Y 坐标的点[Easy]</title><link>/study/leetcode/find-nearest-point-that-has-the-same-x-or-y-coordinate/</link><pubDate>Thu, 01 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/find-nearest-point-that-has-the-same-x-or-y-coordinate/</guid><description>2022-12-01每日一题：1779. 找到最近的有相同 X 或 Y 坐标的点 难度：Easy
标签：数组
给你两个整数&amp;nbsp;x 和&amp;nbsp;y&amp;nbsp;，表示你在一个笛卡尔坐标系下的&amp;nbsp;(x, y)&amp;nbsp;处。同时，在同一个坐标系下给你一个数组&amp;nbsp;points&amp;nbsp;，其中&amp;nbsp;points[i] = [ai, bi]&amp;nbsp;表示在&amp;nbsp;(ai, bi)&amp;nbsp;处有一个点。当一个点与你所在的位置有相同的 x 坐标或者相同的 y 坐标时，我们称这个点是 有效的&amp;nbsp;。
请返回距离你当前位置&amp;nbsp;曼哈顿距离&amp;nbsp;最近的&amp;nbsp;有效&amp;nbsp;点的下标（下标从 0 开始）。如果有多个最近的有效点，请返回下标&amp;nbsp;最小&amp;nbsp;的一个。如果没有有效点，请返回&amp;nbsp;-1&amp;nbsp;。
两个点 (x1, y1)&amp;nbsp;和 (x2, y2)&amp;nbsp;之间的 曼哈顿距离&amp;nbsp;为&amp;nbsp;abs(x1 - x2) + abs(y1 - y2)&amp;nbsp;。
&amp;nbsp;
示例 1：
输入：x = 3, y = 4, points = [[1,2],[3,1],[2,4],[2,3],[4,4]] 输出：2 解释：所有点中，[3,1]，[2,4] 和 [4,4] 是有效点。有效点中，[2,4] 和 [4,4] 距离你当前位置的曼哈顿距离最小，都为 1 。[2,4] 的下标最小，所以返回 2 。 示例 2：
输入：x = 3, y = 4, points = [[3,4]] 输出：0 提示：答案可以与你当前所在位置坐标相同。 示例 3：</description></item><item><title>【2022-11-30每日一题】895. 最大频率栈[Hard]</title><link>/study/leetcode/maximum-frequency-stack/</link><pubDate>Wed, 30 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximum-frequency-stack/</guid><description>2022-11-30每日一题：895. 最大频率栈 难度：Hard
标签：栈 、 设计 、 哈希表 、 有序集合
设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出出现频率最高的元素。
实现 FreqStack&amp;nbsp;类:
FreqStack()&amp;nbsp;构造一个空的堆栈。 void push(int val)&amp;nbsp;将一个整数&amp;nbsp;val&amp;nbsp;压入栈顶。 int pop()&amp;nbsp;删除并返回堆栈中出现频率最高的元素。 如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。 &amp;nbsp;
示例 1：
输入： ["FreqStack","push","push","push","push","push","push","pop","pop","pop","pop"], [[],[5],[7],[5],[7],[4],[5],[],[],[],[]] 输出：[null,null,null,null,null,null,null,5,7,5,4] 解释： FreqStack = new FreqStack(); freqStack.push (5);//堆栈为 [5] freqStack.push (7);//堆栈是 [5,7] freqStack.push (5);//堆栈是 [5,7,5] freqStack.push (7);//堆栈是 [5,7,5,7] freqStack.push (4);//堆栈是 [5,7,5,7,4] freqStack.push (5);//堆栈是 [5,7,5,7,4,5] freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,5,7,4]。 freqStack.pop ();//返回 7 ，因为 5 和 7 出现频率最高，但7最接近顶部。堆栈变成 [5,7,5,4]。 freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,4]。 freqStack.pop ();//返回 4 ，因为 4, 5 和 7 出现频率最高，但 4 是最接近顶部的。堆栈变成 [5,7]。 &amp;nbsp;</description></item><item><title>【2022-11-29每日一题】1758. 生成交替二进制字符串的最少操作数[Easy]</title><link>/study/leetcode/minimum-changes-to-make-alternating-binary-string/</link><pubDate>Tue, 29 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/minimum-changes-to-make-alternating-binary-string/</guid><description>2022-11-29每日一题：1758. 生成交替二进制字符串的最少操作数 难度：Easy
标签：字符串
给你一个仅由字符 '0' 和 '1' 组成的字符串 s 。一步操作中，你可以将任一 '0' 变成 '1' ，或者将 '1' 变成 '0' 。
交替字符串 定义为：如果字符串中不存在相邻两个字符相等的情况，那么该字符串就是交替字符串。例如，字符串 "010" 是交替字符串，而字符串 "0100" 不是。
返回使 s 变成 交替字符串 所需的 最少 操作数。
示例 1：
输入：s = "0100" 输出：1 解释：如果将最后一个字符变为 '1' ，s 就变成 "0101" ，即符合交替字符串定义。 示例 2：
输入：s = "10" 输出：0 解释：s 已经是交替字符串。 示例 3：
输入：s = "1111" 输出：2 解释：需要 2 步操作得到 "0101" 或 "1010" 。 提示：
1 &amp;lt;= s.length &amp;lt;= 104 s[i] 是 '0' 或 '1' 方法一：模拟 思路 根据题意，经过多次操作，sss 可能会变成两种不同的交替二进制字符串，即：</description></item><item><title>【2022-11-28每日一题】813. 最大平均值和的分组[Medium]</title><link>/study/leetcode/largest-sum-of-averages/</link><pubDate>Mon, 28 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/largest-sum-of-averages/</guid><description>2022-11-28每日一题：813. 最大平均值和的分组 难度：Medium
标签：数组 、 动态规划 、 前缀和
给定数组&amp;nbsp;nums&amp;nbsp;和一个整数&amp;nbsp;k&amp;nbsp;。我们将给定的数组&amp;nbsp;nums&amp;nbsp;分成 最多&amp;nbsp;k&amp;nbsp;个相邻的非空子数组 。&amp;nbsp;分数 由每个子数组内的平均值的总和构成。
注意我们必须使用 nums 数组中的每一个数进行分组，并且分数不一定需要是整数。
返回我们所能得到的最大 分数 是多少。答案误差在&amp;nbsp;10-6&amp;nbsp;内被视为是正确的。
&amp;nbsp;
示例 1:
输入: nums = [9,1,2,3,9], k = 3 输出: 20.00000 解释: nums 的最优分组是[9], [1, 2, 3], [9]. 得到的分数是 9 + (1 + 2 + 3) / 3 + 9 = 20. 我们也可以把 nums 分成[9, 1], [2], [3, 9]. 这样的分组得到的分数为 5 + 2 + 6 = 13, 但不是最大值. 示例 2:
输入: nums = [1,2,3,4,5,6,7], k = 4 输出: 20.</description></item><item><title>【2022-11-27每日一题】1752. 检查数组是否经排序和轮转得到[Easy]</title><link>/study/leetcode/check-if-array-is-sorted-and-rotated/</link><pubDate>Sun, 27 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/check-if-array-is-sorted-and-rotated/</guid><description>2022-11-27每日一题：1752. 检查数组是否经排序和轮转得到 难度：Easy
标签：数组
给你一个数组 nums 。nums 的源数组中，所有元素与 nums 相同，但按非递减顺序排列。
如果&amp;nbsp;nums 能够由源数组轮转若干位置（包括 0 个位置）得到，则返回 true ；否则，返回 false 。
源数组中可能存在 重复项 。
注意：我们称数组 A 在轮转 x 个位置后得到长度相同的数组 B ，当它们满足 A[i] == B[(i+x) % A.length] ，其中 % 为取余运算。
&amp;nbsp;
示例 1：
输入：nums = [3,4,5,1,2] 输出：true 解释：[1,2,3,4,5] 为有序的源数组。 可以轮转 x = 3 个位置，使新数组从值为 3 的元素开始：[3,4,5,1,2] 。 示例 2：
输入：nums = [2,1,3,4] 输出：false 解释：源数组无法经轮转得到 nums 。 示例 3：
输入：nums = [1,2,3] 输出：true 解释：[1,2,3] 为有序的源数组。 可以轮转 x = 0 个位置（即不轮转）得到 nums 。 &amp;nbsp;</description></item><item><title>【2022-11-26每日一题】882. 细分图中的可到达节点[Hard]</title><link>/study/leetcode/reachable-nodes-in-subdivided-graph/</link><pubDate>Sat, 26 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/reachable-nodes-in-subdivided-graph/</guid><description>2022-11-26每日一题：882. 细分图中的可到达节点 难度：Hard
标签：图 、 最短路 、 堆（优先队列）
给你一个无向图（原始图），图中有 n 个节点，编号从 0 到 n - 1 。你决定将图中的每条边 细分 为一条节点链，每条边之间的新节点数各不相同。
图用由边组成的二维数组 edges 表示，其中&amp;nbsp;edges[i] = [ui, vi, cnti] 表示原始图中节点&amp;nbsp;ui 和&amp;nbsp;vi 之间存在一条边，cnti 是将边 细分 后的新节点总数。注意，cnti == 0 表示边不可细分。
要 细分 边 [ui, vi] ，需要将其替换为 (cnti + 1) 条新边，和&amp;nbsp;cnti 个新节点。新节点为 x1, x2, ..., xcnti ，新边为 [ui, x1], [x1, x2], [x2, x3], ..., [xcnti+1, xcnti], [xcnti, vi] 。
现在得到一个&amp;nbsp;新的细分图 ，请你计算从节点 0 出发，可以到达多少个节点？如果节点间距离是 maxMoves 或更少，则视为 可以到达 。
给你原始图和 maxMoves ，返回 新的细分图中从节点 0 出发 可到达的节点数&amp;nbsp;。</description></item><item><title>【2022-11-25每日一题】809. 情感丰富的文字[Medium]</title><link>/study/leetcode/expressive-words/</link><pubDate>Fri, 25 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/expressive-words/</guid><description>2022-11-25每日一题：809. 情感丰富的文字 难度：Medium
标签：数组 、 双指针 、 字符串
有时候人们会用重复写一些字母来表示额外的感受，比如 "hello" -&amp;gt; "heeellooo", "hi" -&amp;gt; "hiii"。我们将相邻字母都相同的一串字符定义为相同字母组，例如："h", "eee", "ll", "ooo"。
对于一个给定的字符串 S ，如果另一个单词能够通过将一些字母组扩张从而使其和 S 相同，我们将这个单词定义为可扩张的（stretchy）。扩张操作定义如下：选择一个字母组（包含字母&amp;nbsp;c&amp;nbsp;），然后往其中添加相同的字母&amp;nbsp;c&amp;nbsp;使其长度达到 3 或以上。
例如，以&amp;nbsp;"hello" 为例，我们可以对字母组&amp;nbsp;"o" 扩张得到 "hellooo"，但是无法以同样的方法得到 "helloo" 因为字母组 "oo" 长度小于&amp;nbsp;3。此外，我们可以进行另一种扩张 "ll" -&amp;gt; "lllll" 以获得&amp;nbsp;"helllllooo"。如果&amp;nbsp;s = "helllllooo"，那么查询词&amp;nbsp;"hello" 是可扩张的，因为可以对它执行这两种扩张操作使得&amp;nbsp;query = "hello" -&amp;gt; "hellooo" -&amp;gt;&amp;nbsp;"helllllooo" = s。
输入一组查询单词，输出其中可扩张的单词数量。
&amp;nbsp;
示例：
输入： s = "heeellooo" words = ["hello", "hi", "helo"] 输出：1 解释： 我们能通过扩张 "hello" 的 "e" 和 "o" 来得到 "heeellooo"。 我们不能通过扩张 "helo" 来得到 "heeellooo" 因为 "ll" 的长度小于 3 。 &amp;nbsp;</description></item><item><title>【2022-11-24每日一题】795. 区间子数组个数[Medium]</title><link>/study/leetcode/number-of-subarrays-with-bounded-maximum/</link><pubDate>Thu, 24 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/number-of-subarrays-with-bounded-maximum/</guid><description>2022-11-24每日一题：795. 区间子数组个数 难度：Medium
标签：数组 、 双指针
给你一个整数数组 nums 和两个整数：left 及 right 。找出 nums 中连续、非空且其中最大元素在范围&amp;nbsp;[left, right] 内的子数组，并返回满足条件的子数组的个数。
生成的测试用例保证结果符合 32-bit 整数范围。
&amp;nbsp;
示例 1：
输入：nums = [2,1,4,3], left = 2, right = 3 输出：3 解释：满足条件的三个子数组：[2], [2, 1], [3] 示例 2：
输入：nums = [2,9,2,5,6], left = 2, right = 8 输出：7 &amp;nbsp;
提示：
1 &amp;lt;= nums.length &amp;lt;= 105 0 &amp;lt;= nums[i] &amp;lt;= 109 0 &amp;lt;= left &amp;lt;= right &amp;lt;= 109 方法一：一次遍历 推荐解释1-官方 推荐测试2-灵茶山艾府 // 写法一 func numSubarrayBoundedMax(nums []int, left int, right int) (cnt int) { last1, last2 := -1, -1 for i, x := range nums { if left &amp;lt;= x &amp;amp;&amp;amp; x &amp;lt;= right { last1 = i } else x &amp;gt; right { last1, last2 = -1, i } if last1 !</description></item><item><title>【2022-11-23每日一题】1742. 盒子中小球的最大数量[Easy]</title><link>/study/leetcode/maximum-number-of-balls-in-a-box/</link><pubDate>Wed, 23 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximum-number-of-balls-in-a-box/</guid><description>2022-11-23每日一题：1742. 盒子中小球的最大数量 难度：Easy
标签：哈希表 、 数学 、 计数
你在一家生产小球的玩具厂工作，有 n 个小球，编号从 lowLimit 开始，到 highLimit 结束（包括 lowLimit 和 highLimit ，即 n == highLimit - lowLimit + 1）。另有无限数量的盒子，编号从 1 到 infinity 。
你的工作是将每个小球放入盒子中，其中盒子的编号应当等于小球编号上每位数字的和。例如，编号 321 的小球应当放入编号 3 + 2 + 1 = 6 的盒子，而编号 10 的小球应当放入编号 1 + 0 = 1 的盒子。
给你两个整数 lowLimit 和 highLimit ，返回放有最多小球的盒子中的小球数量。如果有多个盒子都满足放有最多小球，只需返回其中任一盒子的小球数量。
示例 1：
输入：lowLimit = 1, highLimit = 10 输出：2 解释： 盒子编号：1 2 3 4 5 6 7 8 9 10 11 .</description></item><item><title>【2022-11-22每日一题】878. 第 N 个神奇数字[Hard]</title><link>/study/leetcode/nth-magical-number/</link><pubDate>Tue, 22 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/nth-magical-number/</guid><description>2022-11-22每日一题：878. 第 N 个神奇数字 难度：Hard
标签：数学 、 二分查找
一个正整数如果能被 a 或 b 整除，那么它是神奇的。
给定三个整数 n ,&amp;nbsp;a , b ，返回第 n 个神奇的数字。因为答案可能很大，所以返回答案&amp;nbsp;对&amp;nbsp;109&amp;nbsp;+ 7 取模&amp;nbsp;后的值。
&amp;nbsp;
示例 1：
输入：n = 1, a = 2, b = 3 输出：2 示例&amp;nbsp;2：
输入：n = 4, a = 2, b = 3 输出：6 &amp;nbsp;
提示：
1 &amp;lt;= n &amp;lt;= 109 2 &amp;lt;= a, b &amp;lt;= 4 * 104 &amp;nbsp;
方法一：数学+二分查找 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
const mod int = 1e9+7 // 系统库二分查找 func nthMagicalNumber(n int, a int, b int) int { c := a * b / gcd(a, b) // a,b最少公倍数 r := (a + b) * n return sort.</description></item><item><title>【2022-11-21每日一题】808. 分汤[Medium]</title><link>/study/leetcode/soup-servings/</link><pubDate>Mon, 21 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/soup-servings/</guid><description>2022-11-21每日一题：808. 分汤 难度：Medium
标签：数学 、 动态规划 、 概率与统计
有&amp;nbsp;A&amp;nbsp;和&amp;nbsp;B 两种类型&amp;nbsp;的汤。一开始每种类型的汤有&amp;nbsp;n&amp;nbsp;毫升。有四种分配操作：
提供 100ml 的 汤A 和 0ml 的 汤B 。 提供 75ml 的 汤A 和 25ml 的 汤B 。 提供 50ml 的 汤A 和 50ml 的 汤B 。 提供 25ml 的 汤A 和 75ml 的 汤B 。 当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为 0.25 的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。
注意&amp;nbsp;不存在先分配 100 ml 汤B 的操作。
需要返回的值：&amp;nbsp;汤A&amp;nbsp;先分配完的概率 +&amp;nbsp;&amp;nbsp;汤A和汤B&amp;nbsp;同时分配完的概率 / 2。返回值在正确答案&amp;nbsp;10-5&amp;nbsp;的范围内将被认为是正确的。
&amp;nbsp;
示例 1:
输入: n = 50 输出: 0.62500 解释:如果我们选择前两个操作，A 首先将变为空。 对于第三个操作，A 和 B 会同时变为空。 对于第四个操作，B 首先将变为空。 所以 A 变为空的总概率加上 A 和 B 同时变为空的概率的一半是 0.</description></item><item><title>【2022-11-20每日一题】799. 香槟塔[Medium]</title><link>/study/leetcode/champagne-tower/</link><pubDate>Sun, 20 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/champagne-tower/</guid><description>2022-11-20每日一题：799. 香槟塔 难度：Medium
标签：动态规划
我们把玻璃杯摆成金字塔的形状，其中&amp;nbsp;第一层&amp;nbsp;有 1 个玻璃杯， 第二层&amp;nbsp;有 2 个，依次类推到第 100 层，每个玻璃杯 (250ml) 将盛有香槟。
从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）
例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，如下图所示。
现在当倾倒了非负整数杯香槟后，返回第 i 行 j&amp;nbsp;个玻璃杯所盛放的香槟占玻璃杯容积的比例（ i 和 j&amp;nbsp;都从0开始）。
&amp;nbsp;
示例 1: 输入: poured(倾倒香槟总杯数) = 1, query_glass(杯子的位置数) = 1, query_row(行数) = 1 输出: 0.00000 解释: 我们在顶层（下标是（0，0））倒了一杯香槟后，没有溢出，因此所有在顶层以下的玻璃杯都是空的。 示例 2: 输入: poured(倾倒香槟总杯数) = 2, query_glass(杯子的位置数) = 1, query_row(行数) = 1 输出: 0.50000 解释: 我们在顶层（下标是（0，0）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（1，0）的玻璃杯和（1，1）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。 示例 3:
输入: poured = 100000009, query_row = 33, query_glass = 17 输出: 1.00000 &amp;nbsp;
提示:
0 &amp;lt;=&amp;nbsp;poured &amp;lt;= 109 0 &amp;lt;= query_glass &amp;lt;= query_row&amp;nbsp;&amp;lt; 100 方法一：模拟或动态规划 代码 func champagneTower(poured int, query_row int, query_glass int) float64 { row := []float64{float64(poured)} for i := 1; i &amp;lt;= query_row; i++ { newRow := make([]float64, i + 1) for j, volume := range row { if volume &amp;gt; 1 { volume -= 1 newRow[j] += volume/2 newRow[j+1] += volume/2 } } row = newRow } return math.</description></item><item><title>【2022-11-19每日一题】1732. 找到最高海拔[Easy]</title><link>/study/leetcode/find-the-highest-altitude/</link><pubDate>Sat, 19 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/find-the-highest-altitude/</guid><description>2022-11-19每日一题：1732. 找到最高海拔 难度：Easy
标签：数组 、 前缀和
有一个自行车手打算进行一场公路骑行，这条路线总共由 n + 1 个不同海拔的点组成。自行车手从海拔为 0 的点 0 开始骑行。
给你一个长度为 n 的整数数组 gain ，其中 gain[i] 是点 i 和点 i + 1 的 净海拔高度差（0 &lt;= i &lt; n）。请你返回 最高点的海拔 。
示例 1：
输入：gain = [-5,1,5,0,-7] 输出：1 解释：海拔高度依次为 [0,-5,-4,1,1,-6] 。最高海拔为 1 。 示例 2：
输入：gain = [-4,-3,-2,-1,4,3,2] 输出：0 解释：海拔高度依次为 [0,-4,-7,-9,-10,-6,-3,-1] 。最高海拔为 0 。 提示：
n == gain.length 1 &lt;= n &lt;= 100 -100 &lt;= gain[i] &lt;= 100 方法一：一次遍历，前缀和（差分数组） golang func largestAltitude(gain []int) int { ans, sum := 0, 0 for _, v := range gain { sum += v // 前缀和 ans = max(ans, sum) // 维护最大值 } return ans } func max(a, b int) int { if a &amp;gt; b { return a } return b } // 省略max函数写法 func largestAltitude(gain []int) int { ans, sum := 0, 0 for _, v := range gain { sum += v // 前缀和 // 维护最大值 if ans &amp;lt; sum { ans = sum } } return ans } php class Solution { /** * @param Integer[] $gain * @return Integer */ function largestAltitude($gain) { $ans = $total = 0; foreach($gain as $g) { $total += $g; $ans = max($ans, $total); } return $ans; } } 复杂度分析 时间复杂度：O(n)。 空间复杂度：O(1)。 LeetCode题库地址 https://leetcode.</description></item><item><title>【2022-11-18每日一题】891. 子序列宽度之和[Hard]</title><link>/study/leetcode/sum-of-subsequence-widths/</link><pubDate>Fri, 18 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/sum-of-subsequence-widths/</guid><description>2022-11-18每日一题：891. 子序列宽度之和 难度：Hard
标签：数组 、 数学 、 排序
一个序列的 宽度 定义为该序列中最大元素和最小元素的差值。
给你一个整数数组 nums ，返回 nums 的所有非空 子序列 的 宽度之和 。由于答案可能非常大，请返回对 109 + 7 取余 后的结果。
子序列 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，[3,6,2,7] 就是数组 [0,3,1,6,2,2,7] 的一个子序列。
&amp;nbsp;
示例 1：
输入：nums = [2,1,3] 输出：6 解释：子序列为 [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3] 。 相应的宽度是 0, 0, 0, 1, 1, 2, 2 。 宽度之和是 6 。 示例 2：
输入：nums = [2] 输出：0 &amp;nbsp;
提示：
1 &amp;lt;= nums.length &amp;lt;= 105 1 &amp;lt;= nums[i] &amp;lt;= 105 方法一：数学（排序 + 枚举元素计算贡献） 推荐题解一 推荐题解二 const mod int = 1e9+7 // 写法一： func sumSubseqWidths(nums []int) (ans int) { sort.</description></item><item><title>【2022-11-17每日一题】792. 匹配子序列的单词数[Medium]</title><link>/study/leetcode/number-of-matching-subsequences/</link><pubDate>Thu, 17 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/number-of-matching-subsequences/</guid><description>2022-11-17每日一题：792. 匹配子序列的单词数 难度：Medium
标签：字典树 、 哈希表 、 字符串 、 排序
给定字符串 s&amp;nbsp;和字符串数组&amp;nbsp;words, 返回&amp;nbsp;&amp;nbsp;words[i]&amp;nbsp;中是s的子序列的单词个数&amp;nbsp;。
字符串的 子序列 是从原始字符串中生成的新字符串，可以从中删去一些字符(可以是none)，而不改变其余字符的相对顺序。
例如， “ace” 是 “abcde” 的子序列。 &amp;nbsp;
示例 1:
输入: s = "abcde", words = ["a","bb","acd","ace"] 输出: 3 解释: 有三个是&amp;nbsp;s 的子序列的单词: "a", "acd", "ace"。 Example 2:
输入: s = "dsahjpjauf", words = ["ahjpjau","ja","ahbwzgqnuk","tnmlanowax"] 输出: 2 &amp;nbsp;
提示:
1 &amp;lt;= s.length &amp;lt;= 5 * 104 1 &amp;lt;= words.length &amp;lt;= 5000 1 &amp;lt;= words[i].length &amp;lt;= 50 words[i]和 s&amp;nbsp;都只由小写字母组成。 ​​​​ 方法一：分桶 详细解释 func numMatchingSubseq(s string, words []string) (ans int) { d := [26][]string{} for _, w := range words { d[w[0]-'a'] = append(d[w[0]-'a'], w) // 按首字母分桶 } for _, c := range s { q := d[c-'a'] d[c-'a'] = nil for _, t := range q { if len(t) == 1 { // 长度加一 ans++ } else { d[t[1]-'a'] = append(d[t[1]-'a'], t[1:]) // 按第二个字母继续分桶 } } } return ans } 复杂度分析 方法二：分桶优化（多指针） // 写法一： func numMatchingSubseq(s string, words []string) (ans int) { type pair struct { i, j int } d := [26][]pair{} for i, w := range words { d[w[0]-'a'] = append(d[w[0]-'a'], pair{i, 0}) } for _, c := range s { q := d[c-'a'] d[c-'a'] = []pair{} for _, p := range q { i, j := p.</description></item><item><title>【2022-11-16每日一题】775. 全局倒置与局部倒置[Medium]</title><link>/study/leetcode/global-and-local-inversions/</link><pubDate>Wed, 16 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/global-and-local-inversions/</guid><description>2022-11-16每日一题：775. 全局倒置与局部倒置 难度：Medium
标签：数组 、 数学
给你一个长度为 n 的整数数组 nums ，表示由范围 [0, n - 1] 内所有整数组成的一个排列。
全局倒置 的数目等于满足下述条件不同下标对 (i, j) 的数目：
0 &lt;= i &lt; j &lt; n nums[i] > nums[j] 局部倒置 的数目等于满足下述条件的下标 i 的数目：
0 &lt;= i &lt; n - 1 nums[i] > nums[i + 1] 当数组 nums 中 全局倒置 的数量等于 局部倒置 的数量时，返回 true ；否则，返回 false 。
示例 1：
输入：nums = [1,0,2] 输出：true 解释：有 1 个全局倒置，和 1 个局部倒置。 示例 2：
输入：nums = [1,2,0] 输出：false 解释：有 2 个全局倒置，和 1 个局部倒置。 提示：</description></item><item><title>【2022-11-15每日一题】1710. 卡车上的最大单元数[Easy]</title><link>/study/leetcode/maximum-units-on-a-truck/</link><pubDate>Tue, 15 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximum-units-on-a-truck/</guid><description>2022-11-15每日一题：1710. 卡车上的最大单元数 难度：Easy
标签：贪心 、 数组 、 排序
请你将一些箱子装在 一辆卡车 上。给你一个二维数组 boxTypes ，其中 boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi] ：
numberOfBoxesi 是类型 i 的箱子的数量。 numberOfUnitsPerBoxi 是类型 i 每个箱子可以装载的单元数量。 整数 truckSize 表示卡车上可以装载 箱子 的 最大数量 。只要箱子数量不超过 truckSize ，你就可以选择任意箱子装到卡车上。
返回卡车可以装载 单元 的 最大 总数。
示例 1：
输入：boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4 输出：8 解释：箱子的情况如下： - 1 个第一类的箱子，里面含 3 个单元。 - 2 个第二类的箱子，每个里面含 2 个单元。 - 3 个第三类的箱子，每个里面含 1 个单元。 可以选择第一类和第二类的所有箱子，以及第三类的一个箱子。 单元总数 = (1 * 3) + (2 * 2) + (1 * 1) = 8 示例 2：</description></item><item><title>【2022-11-14每日一题】805. 数组的均值分割[Hard]</title><link>/study/leetcode/split-array-with-same-average/</link><pubDate>Mon, 14 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/split-array-with-same-average/</guid><description>2022-11-14每日一题：805. 数组的均值分割 难度：Hard
标签：位运算 、 数组 、 数学 、 动态规划 、 状态压缩
给定你一个整数数组&amp;nbsp;nums
我们要将&amp;nbsp;nums&amp;nbsp;数组中的每个元素移动到&amp;nbsp;A&amp;nbsp;数组 或者&amp;nbsp;B&amp;nbsp;数组中，使得&amp;nbsp;A&amp;nbsp;数组和&amp;nbsp;B&amp;nbsp;数组不为空，并且&amp;nbsp;average(A) == average(B)&amp;nbsp;。
如果可以完成则返回true&amp;nbsp;， 否则返回 false&amp;nbsp;&amp;nbsp;。
注意：对于数组&amp;nbsp;arr&amp;nbsp;, &amp;nbsp;average(arr)&amp;nbsp;是&amp;nbsp;arr&amp;nbsp;的所有元素除以&amp;nbsp;arr&amp;nbsp;长度的和。
&amp;nbsp;
示例 1:
输入: nums = [1,2,3,4,5,6,7,8] 输出: true 解释: 我们可以将数组分割为 [1,4,5,8] 和 [2,3,6,7], 他们的平均值都是4.5。 示例 2:
输入: nums = [3,1] 输出: false &amp;nbsp;
提示:
1 &amp;lt;= nums.length &amp;lt;= 30 0 &amp;lt;= nums[i] &amp;lt;= 104 方法一：折半查找 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
题解一 题解二 func splitArraySameAverage(nums []int) bool { n := len(nums) if n == 1 { // 不符合A, B都有元素 return false } // 求和 sum := 0 for _, v := range nums { sum += v } // 预处理数组 for i, v := range nums { nums[i] = v * n - sum } m := n &amp;gt;&amp;gt; 1 // 相当于 n/2 left := map[int]bool{} // 左侧处理 for i := 1; i &amp;lt; 1&amp;lt;&amp;lt;m; i++ { total := 0 for j, v := range nums { if i&amp;gt;&amp;gt;j&amp;amp;1 &amp;gt; 0 { total += v } } if total == 0 { return true } left[total] = true } // 右半部分处理 rsum := 0 for _, v := range nums[m:] { rsum += v } for i := 1; i &amp;lt; 1&amp;lt;&amp;lt;(n-m); i++ { total := 0 for j, v := range nums[m:] { if i&amp;gt;&amp;gt;j&amp;amp;1 &amp;gt; 0 { total += v } } // rsum !</description></item><item><title>【2022-11-13每日一题】791. 自定义字符串排序[Medium]</title><link>/study/leetcode/custom-sort-string/</link><pubDate>Sun, 13 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/custom-sort-string/</guid><description>2022-11-13每日一题：791. 自定义字符串排序 难度：Medium
标签：哈希表 、 字符串 、 排序
给定两个字符串 order 和 s 。order 的所有单词都是 唯一 的，并且以前按照一些自定义的顺序排序。
对 s 的字符进行置换，使其与排序的&amp;nbsp;order&amp;nbsp;相匹配。更具体地说，如果在&amp;nbsp;order&amp;nbsp;中的字符 x 出现字符 y 之前，那么在排列后的字符串中， x&amp;nbsp;也应该出现在 y 之前。
返回 满足这个性质的 s 的任意排列&amp;nbsp;。
&amp;nbsp;
示例 1:
输入: order = "cba", s = "abcd" 输出: "cbad" 解释: “a”、“b”、“c”是按顺序出现的，所以“a”、“b”、“c”的顺序应该是“c”、“b”、“a”。 因为“d”不是按顺序出现的，所以它可以在返回的字符串中的任何位置。“dcba”、“cdba”、“cbda”也是有效的输出。 示例 2:
输入: order = "cbafg", s = "abcd" 输出: "cbad" &amp;nbsp;
提示:
1 &amp;lt;= order.length &amp;lt;= 26 1 &amp;lt;= s.length &amp;lt;= 200 order&amp;nbsp;和&amp;nbsp;s&amp;nbsp;由小写英文字母组成 order&amp;nbsp;中的所有字符都 不同 方法一：哈希表 + 按字母索引排序 // 写法一 func customSortString(order string, s string) string { n := len(order) ht := make(map[byte]int, n) // 此处可以用 [26]int{} 代替 for i := 0; i &amp;lt; n; i++ { ht[order[i]] = i } ss := []byte(s) sort.</description></item><item><title>【2022-11-12每日一题】790. 多米诺和托米诺平铺[Medium]</title><link>/study/leetcode/domino-and-tromino-tiling/</link><pubDate>Sat, 12 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/domino-and-tromino-tiling/</guid><description>2022-11-12每日一题：790. 多米诺和托米诺平铺 难度：Medium
标签：动态规划
有两种形状的瓷砖：一种是&amp;nbsp;2 x 1 的多米诺形，另一种是形如&amp;nbsp;"L" 的托米诺形。两种形状都可以旋转。
给定整数 n ，返回可以平铺&amp;nbsp;2 x n 的面板的方法的数量。返回对&amp;nbsp;109&amp;nbsp;+ 7&amp;nbsp;取模&amp;nbsp;的值。
平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。
&amp;nbsp;
示例 1:
输入: n = 3 输出: 5 解释: 五种不同的方法如上所示。 示例 2:
输入: n = 1 输出: 1 &amp;nbsp;
提示：
1 &amp;lt;= n &amp;lt;= 1000 方法一：动态规划 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
代码 func numTilings(n int) int { const mod int = 1e9+7 dp := make([][4]int, n+1) dp[0][3] = 1 for i := 1; i &amp;lt;= n; i++ { dp[i][0] = dp[i-1][3] // 一个正方形都没有被覆盖，记为状态 0 dp[i][1] = (dp[i-1][0] + dp[i-1][2])%mod// 只有上方的正方形被覆盖，记为状态 1 dp[i][2] = (dp[i-1][0] + dp[i-1][1])%mod// 只有下方的正方形被覆盖，记为状态 2 // 上下两个正方形都被覆盖，记为状态 3 dp[i][3] = (((dp[i-1][0] + dp[i-1][1])%mod + dp[i-1][2])%mod + dp[i-1][3])%mod } return dp[n][3] } 复杂度分析 时间复杂度：O(n)，其中 n 是总列数。</description></item><item><title>【2022-11-11每日一题】1704. 判断字符串的两半是否相似[Easy]</title><link>/study/leetcode/determine-if-string-halves-are-alike/</link><pubDate>Fri, 11 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/determine-if-string-halves-are-alike/</guid><description>2022-11-11每日一题：1704. 判断字符串的两半是否相似 难度：Easy
标签：字符串 、 计数
给你一个偶数长度的字符串 s 。将其拆分成长度相同的两半，前一半为 a ，后一半为 b 。
两个字符串 相似 的前提是它们都含有相同数目的元音（'a'，'e'，'i'，'o'，'u'，'A'，'E'，'I'，'O'，'U'）。注意，s 可能同时含有大写和小写字母。
如果 a 和 b 相似，返回 true ；否则，返回 false 。
&amp;nbsp;
示例 1：
输入：s = "book" 输出：true 解释：a = "bo" 且 b = "ok" 。a 中有 1 个元音，b 也有 1 个元音。所以，a 和 b 相似。 示例 2：
输入：s = "textbook" 输出：false 解释：a = "text" 且 b = "book" 。a 中有 1 个元音，b 中有 2 个元音。因此，a 和 b 不相似。 注意，元音 o 在 b 中出现两次，记为 2 个。 &amp;nbsp;</description></item><item><title>【2022-11-10每日一题】864. 获取所有钥匙的最短路径[Hard]</title><link>/study/leetcode/shortest-path-to-get-all-keys/</link><pubDate>Thu, 10 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/shortest-path-to-get-all-keys/</guid><description>2022-11-10每日一题：864. 获取所有钥匙的最短路径 难度：Hard
标签：位运算 、 广度优先搜索 、 数组 、 矩阵
给定一个二维网格&amp;nbsp;grid&amp;nbsp;，其中：
'.' 代表一个空房间 '#' 代表一堵 '@'&amp;nbsp;是起点 小写字母代表钥匙 大写字母代表锁 我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。
假设 k&amp;nbsp;为 钥匙/锁 的个数，且满足&amp;nbsp;1 &amp;lt;= k&amp;nbsp;&amp;lt;= 6，字母表中的前 k&amp;nbsp;个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。
返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回&amp;nbsp;-1&amp;nbsp;。
&amp;nbsp;
示例 1：
输入：grid = ["@.a.#","###.#","b.A.B"] 输出：8 解释：目标是获得所有钥匙，而不是打开所有锁。 示例 2：
输入：grid = ["@..aA","..B#.","....b"] 输出：6 示例 3:
输入: grid = ["@Aa"] 输出: -1 &amp;nbsp;
提示：
m == grid.length n == grid[i].length 1 &amp;lt;= m, n &amp;lt;= 30 grid[i][j]&amp;nbsp;只含有&amp;nbsp;'.',&amp;nbsp;'#',&amp;nbsp;'@',&amp;nbsp;'a'-'f'&amp;nbsp;以及&amp;nbsp;'A'-'F' 钥匙的数目范围是&amp;nbsp;[1, 6]&amp;nbsp; 每个钥匙都对应一个 不同 的字母 每个钥匙正好打开一个对应的锁 方法一：状态压缩+广度优先搜索 写法一 func shortestPathAllKeys(grid []string) int { // 获取钥匙个数和起点坐标 var k, si, sj int for i, row := range grid { for j, c := range row { if c == '@' { si, sj = i, j // 起点 } else if c &amp;gt;= 'a' &amp;amp;&amp;amp; c &amp;lt;= 'z' { k++ // 累加钥匙个数 } } } m, n := len(grid), len(grid[0]) type tuple struct { i, j, state int } q := []tuple{{si, sj, 0}} // 初始化队列 visited := map[tuple]bool{{si, sj, 0}: true} // 判重初始化 dirs := []int{-1, 0, 1, 0, -1} // 上右下左 四个方向 ans := 0 // 结果 // 广度优先搜索 for len(q) &amp;gt; 0 { for t := len(q); t &amp;gt; 0; t-- { p := q[0] q = q[1:] i, j, state := p.</description></item><item><title>【2022-11-09每日一题】764. 最大加号标志[Medium]</title><link>/study/leetcode/largest-plus-sign/</link><pubDate>Wed, 09 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/largest-plus-sign/</guid><description>2022-11-09每日一题：764. 最大加号标志 难度：Medium
标签：数组 、 动态规划
在一个 n x n 的矩阵&amp;nbsp;grid&amp;nbsp;中，除了在数组&amp;nbsp;mines&amp;nbsp;中给出的元素为&amp;nbsp;0，其他每个元素都为&amp;nbsp;1。mines[i] = [xi, yi]表示&amp;nbsp;grid[xi][yi] == 0
返回 &amp;nbsp;grid 中包含&amp;nbsp;1&amp;nbsp;的最大的 轴对齐 加号标志的阶数 。如果未找到加号标志，则返回 0 。
一个&amp;nbsp;k&amp;nbsp;阶由&amp;nbsp;1&amp;nbsp;组成的 “轴对称”加号标志 具有中心网格&amp;nbsp;grid[r][c] == 1&amp;nbsp;，以及4个从中心向上、向下、向左、向右延伸，长度为&amp;nbsp;k-1，由&amp;nbsp;1&amp;nbsp;组成的臂。注意，只有加号标志的所有网格要求为 1 ，别的网格可能为 0 也可能为 1 。
&amp;nbsp;
示例 1：
输入: n = 5, mines = [[4, 2]] 输出: 2 解释: 在上面的网格中，最大加号标志的阶只能是2。一个标志已在图中标出。 示例 2：
输入: n = 1, mines = [[0, 0]] 输出: 0 解释: 没有加号标志，返回 0 。 &amp;nbsp;
提示：
1 &amp;lt;= n &amp;lt;= 500 1 &amp;lt;= mines.</description></item><item><title>【2022-11-08每日一题】1684. 统计一致字符串的数目[Easy]</title><link>/study/leetcode/count-the-number-of-consistent-strings/</link><pubDate>Tue, 08 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/count-the-number-of-consistent-strings/</guid><description>2022-11-08每日一题：1684. 统计一致字符串的数目 难度：Easy
标签：位运算 、 数组 、 哈希表 、 字符串
给你一个由不同字符组成的字符串 allowed 和一个字符串数组 words 。如果一个字符串的每一个字符都在 allowed 中，就称这个字符串是 一致字符串 。
请你返回 words 数组中 一致字符串 的数目。
示例 1：
输入：allowed = "ab", words = ["ad","bd","aaab","baa","badab"] 输出：2 解释：字符串 "aaab" 和 "baa" 都是一致字符串，因为它们只包含字符 'a' 和 'b' 。 示例 2：
输入：allowed = "abc", words = ["a","b","c","ab","ac","bc","abc"] 输出：7 解释：所有字符串都是一致的。 示例 3：
输入：allowed = "cad", words = ["cc","acd","b","ba","bac","bad","ac","d"] 输出：4 解释：字符串 "cc"，"acd"，"ac" 和 "d" 是一致字符串。 提示：
1 &lt;= words.length &lt;= 104 1 &lt;= allowed.length &lt;= 26 1 &lt;= words[i].</description></item><item><title>【2022-11-07每日一题】816. 模糊坐标[Medium]</title><link>/study/leetcode/ambiguous-coordinates/</link><pubDate>Mon, 07 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/ambiguous-coordinates/</guid><description>2022-11-07每日一题：816. 模糊坐标 难度：Medium
标签：字符串 、 回溯
我们有一些二维坐标，如&amp;nbsp;&amp;quot;(1, 3)&amp;quot;&amp;nbsp;或&amp;nbsp;&amp;quot;(2, 0.5)&amp;quot;，然后我们移除所有逗号，小数点和空格，得到一个字符串S。返回所有可能的原始字符串到一个列表中。
原始的坐标表示法不会存在多余的零，所以不会出现类似于&amp;quot;00&amp;quot;, &amp;quot;0.0&amp;quot;, &amp;quot;0.00&amp;quot;, &amp;quot;1.0&amp;quot;, &amp;quot;001&amp;quot;, &amp;quot;00.01&amp;quot;或一些其他更小的数来表示坐标。此外，一个小数点前至少存在一个数，所以也不会出现&amp;ldquo;.1&amp;rdquo;形式的数字。
最后返回的列表可以是任意顺序的。而且注意返回的两个数字中间（逗号之后）都有一个空格。
&amp;nbsp;
示例 1: 输入: &amp;quot;(123)&amp;quot; 输出: [&amp;quot;(1, 23)&amp;quot;, &amp;quot;(12, 3)&amp;quot;, &amp;quot;(1.2, 3)&amp;quot;, &amp;quot;(1, 2.3)&amp;quot;] 示例 2: 输入: &amp;quot;(00011)&amp;quot; 输出: &amp;nbsp;[&amp;quot;(0.001, 1)&amp;quot;, &amp;quot;(0, 0.011)&amp;quot;] 解释: 0.0, 00, 0001 或 00.01 是不被允许的。 示例 3: 输入: &amp;quot;(0123)&amp;quot; 输出: [&amp;quot;(0, 123)&amp;quot;, &amp;quot;(0, 12.3)&amp;quot;, &amp;quot;(0, 1.23)&amp;quot;, &amp;quot;(0.1, 23)&amp;quot;, &amp;quot;(0.1, 2.3)&amp;quot;, &amp;quot;(0.12, 3)&amp;quot;] 示例 4: 输入: &amp;quot;(100)&amp;quot; 输出: [(10, 0)] 解释: 1.0 是不被允许的。 &amp;nbsp;
提示: 4 &amp;lt;= S.</description></item><item><title>【2022-11-06 加练约瑟夫环】剑指 Offer 62. 圆圈中最后剩下的数字[Easy]</title><link>/study/leetcode/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</link><pubDate>Sun, 06 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</guid><description>加练：剑指 Offer 62. 圆圈中最后剩下的数字 难度：Easy
标签：递归 、 数学
0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。
例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。
示例 1：
输入: n = 5, m = 3 输出: 3 示例 2：
输入: n = 10, m = 17 输出: 2 限制：
1 &lt;= n &lt;= 10^5 1 &lt;= m &lt;= 10^6 方法一：递归 详细题解 核心思想：f(10,3)的结果就可以转化为f(9,3)的表达,后面也是同理：
f(10,3)=(f(9,3)+3)%10 f(9,3)=(f(8,3)+3)%9 …… f(2,3)=(f(1,3)+3)%2 f(1,3)=0 代码 func lastRemaining(n int, m int) int { if n == 1 { return 0 } return (lastRemaining(n-1, m) + m) % n } 复杂度分析 时间复杂度：O(n)。 空间复杂度：O(n)。 方法二：迭代 func lastRemaining(n int, m int) int { ans := 0 for i := 1; i &amp;lt;= n; i++ { ans = (ans + m) % i } return ans } 复杂度分析 时间复杂度：O(n)。 空间复杂度：O(1)。 LeetCode题库地址 https://leetcode.</description></item><item><title>【2022-11-06每日一题】1678. 设计 Goal 解析器[Easy]</title><link>/study/leetcode/goal-parser-interpretation/</link><pubDate>Sun, 06 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/goal-parser-interpretation/</guid><description>2022-11-06每日一题：1678. 设计 Goal 解析器 难度：Easy
标签：字符串
请你设计一个可以解释字符串 command 的 Goal 解析器 。command 由 "G"、"()" 和/或 "(al)" 按某种顺序组成。Goal 解析器会将 "G" 解释为字符串 "G"、"()" 解释为字符串 "o" ，"(al)" 解释为字符串 "al" 。然后，按原顺序将经解释得到的字符串连接成一个字符串。
给你字符串 command ，返回 Goal 解析器 对 command 的解释结果。
示例 1：
输入：command = "G()(al)" 输出："Goal" 解释：Goal 解析器解释命令的步骤如下所示： G -&amp;gt; G () -&amp;gt; o (al) -&amp;gt; al 最后连接得到的结果是 "Goal" 示例 2：
输入：command = "G()()()()(al)" 输出："Gooooal" 示例 3：
输入：command = "(al)G(al)()()G" 输出："alGalooG" 提示：
1 &amp;lt;= command.length &amp;lt;= 100 command 由 "G"、"()" 和/或 "</description></item><item><title>【2022-11-05每日一题】1106. 解析布尔表达式[Hard]</title><link>/study/leetcode/parsing-a-boolean-expression/</link><pubDate>Sat, 05 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/parsing-a-boolean-expression/</guid><description>2022-11-05每日一题：1106. 解析布尔表达式 难度：Hard
标签：栈 、 递归 、 字符串
给你一个以字符串形式表述的&amp;nbsp;布尔表达式（boolean） expression，返回该式的运算结果。
有效的表达式需遵循以下约定：
&amp;quot;t&amp;quot;，运算结果为 True &amp;quot;f&amp;quot;，运算结果为 False &amp;quot;!(expr)&amp;quot;，运算过程为对内部表达式 expr 进行逻辑 非的运算（NOT） &amp;quot;&amp;amp;(expr1,expr2,...)&amp;quot;，运算过程为对 2 个或以上内部表达式 expr1, expr2, ... 进行逻辑 与的运算（AND） &amp;quot;|(expr1,expr2,...)&amp;quot;，运算过程为对 2 个或以上内部表达式 expr1, expr2, ... 进行逻辑 或的运算（OR） &amp;nbsp;
示例 1：
输入：expression = &amp;quot;!(f)&amp;quot; 输出：true 示例 2：
输入：expression = &amp;quot;|(f,t)&amp;quot; 输出：true 示例 3：
输入：expression = &amp;quot;&amp;amp;(t,f)&amp;quot; 输出：false 示例 4：
输入：expression = &amp;quot;|(&amp;amp;(t,f,t),!(t))&amp;quot; 输出：false &amp;nbsp;
提示：
1 &amp;lt;= expression.length &amp;lt;= 20000 expression[i] 由 {&amp;#39;(&amp;#39;, &amp;#39;)&amp;#39;, &amp;#39;&amp;amp;&amp;#39;, &amp;#39;|&amp;#39;, &amp;#39;!&amp;#39;, &amp;#39;t&amp;#39;, &amp;#39;f&amp;#39;, &amp;#39;,&amp;#39;} 中的字符组成。 expression 是以上述形式给出的有效表达式，表示一个布尔值。 方法一： 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读</description></item><item><title>【2022-11-04每日一题】754. 到达终点数字[Medium]</title><link>/study/leetcode/reach-a-number/</link><pubDate>Fri, 04 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/reach-a-number/</guid><description>2022-11-04每日一题：754. 到达终点数字 难度：Medium
标签：数学 、 二分查找
在一根无限长的数轴上，你站在0的位置。终点在target的位置。
你可以做一些数量的移动 numMoves :
每次你可以选择向左或向右移动。 第 i&amp;nbsp;次移动（从 &amp;nbsp;i == 1&amp;nbsp;开始，到&amp;nbsp;i == numMoves ），在选择的方向上走 i&amp;nbsp;步。 给定整数&amp;nbsp;target ，返回 到达目标所需的 最小&amp;nbsp;移动次数(即最小 numMoves )&amp;nbsp;。
&amp;nbsp;
示例 1:
输入: target = 2 输出: 3 解释: 第一次移动，从 0 到 1 。 第二次移动，从 1 到 -1 。 第三次移动，从 -1 到 2 。 示例 2:
输入: target = 3 输出: 2 解释: 第一次移动，从 0 到 1 。 第二次移动，从 1 到 3 。 &amp;nbsp;
提示:
-109&amp;nbsp;&amp;lt;= target &amp;lt;= 109 target !</description></item><item><title>【2022-11-03每日一题】1668. 最大重复子字符串[Easy]</title><link>/study/leetcode/maximum-repeating-substring/</link><pubDate>Thu, 03 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximum-repeating-substring/</guid><description>2022-11-03每日一题：1668. 最大重复子字符串 难度：Easy
标签：字符串 、 字符串匹配
给你一个字符串 sequence ，如果字符串 word 连续重复 k 次形成的字符串是 sequence 的一个子字符串，那么单词 word 的 重复值为 k 。单词 word 的 最大重复值 是单词 word 在 sequence 中最大的重复值。如果 word 不是 sequence 的子串，那么重复值 k 为 0 。
给你一个字符串 sequence 和 word ，请你返回 最大重复值 k 。
示例 1：
输入：sequence = "ababc", word = "ab" 输出：2 解释："abab" 是 "ababc" 的子字符串。 示例 2：
输入：sequence = "ababc", word = "ba" 输出：1 解释："ba" 是 "ababc" 的子字符串，但 "baba" 不是 "ababc" 的子字符串。 示例 3：</description></item><item><title>【2022-11-02每日一题】1620. 网络信号最好的坐标[Medium]</title><link>/study/leetcode/coordinate-with-maximum-network-quality/</link><pubDate>Wed, 02 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/coordinate-with-maximum-network-quality/</guid><description>2022-11-02每日一题：1620. 网络信号最好的坐标 难度：Medium
标签：数组 、 枚举
给你一个数组 towers&amp;nbsp;和一个整数 radius 。
数组&amp;nbsp; towers&amp;nbsp; 中包含一些网络信号塔，其中&amp;nbsp;towers[i] = [xi, yi, qi]&amp;nbsp;表示第&amp;nbsp;i&amp;nbsp;个网络信号塔的坐标是&amp;nbsp;(xi, yi)&amp;nbsp;且信号强度参数为&amp;nbsp;qi&amp;nbsp;。所有坐标都是在&amp;nbsp; X-Y 坐标系内的&amp;nbsp;整数&amp;nbsp;坐标。两个坐标之间的距离用 欧几里得距离&amp;nbsp;计算。
整数&amp;nbsp;radius&amp;nbsp;表示一个塔 能到达&amp;nbsp;的 最远距离&amp;nbsp;。如果一个坐标跟塔的距离在 radius&amp;nbsp;以内，那么该塔的信号可以到达该坐标。在这个范围以外信号会很微弱，所以 radius&amp;nbsp;以外的距离该塔是 不能到达的&amp;nbsp;。
如果第 i&amp;nbsp;个塔能到达 (x, y)&amp;nbsp;，那么该塔在此处的信号为&amp;nbsp;⌊qi / (1 + d)⌋&amp;nbsp;，其中&amp;nbsp;d&amp;nbsp;是塔跟此坐标的距离。一个坐标的 信号强度 是所有 能到达&amp;nbsp;该坐标的塔的信号强度之和。
请你返回数组 [cx, cy] ，表示 信号强度 最大的 整数 坐标点&amp;nbsp;(cx, cy) 。如果有多个坐标网络信号一样大，请你返回字典序最小的 非负 坐标。
注意：
坐标&amp;nbsp;(x1, y1)&amp;nbsp;字典序比另一个坐标&amp;nbsp;(x2, y2) 小，需满足以下条件之一： &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;要么&amp;amp;nbsp;&amp;lt;code&amp;gt;x1 &amp;amp;lt; x2&amp;lt;/code&amp;gt;&amp;amp;nbsp;，&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;要么&amp;amp;nbsp;&amp;lt;code&amp;gt;x1 == x2&amp;lt;/code&amp;gt; 且&amp;amp;nbsp;&amp;lt;code&amp;gt;y1 &amp;amp;lt; y2&amp;lt;/code&amp;gt;&amp;amp;nbsp;。&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;code&amp;gt;⌊val⌋&amp;lt;/code&amp;gt;&amp;amp;nbsp;表示小于等于&amp;amp;nbsp;&amp;lt;code&amp;gt;val&amp;lt;/code&amp;gt;&amp;amp;nbsp;的最大整数（向下取整函数）。&amp;lt;/li&amp;gt; &amp;nbsp;
示例 1：
输入：towers = [[1,2,5],[2,1,7],[3,1,9]], radius = 2 输出：[2,1] 解释： 坐标 (2, 1) 信号强度之和为 13 - 塔 (2, 1) 强度参数为 7 ，在该点强度为 ⌊7 / (1 + sqrt(0)⌋ = ⌊7⌋ = 7 - 塔 (1, 2) 强度参数为 5 ，在该点强度为 ⌊5 / (1 + sqrt(2)⌋ = ⌊2.</description></item><item><title>【2022-11-01每日一题】1662. 检查两个字符串数组是否相等[Easy]</title><link>/study/leetcode/check-if-two-string-arrays-are-equivalent/</link><pubDate>Tue, 01 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/check-if-two-string-arrays-are-equivalent/</guid><description>2022-11-01每日一题：1662. 检查两个字符串数组是否相等 难度：Easy
标签：数组 、 字符串
给你两个字符串数组 word1 和 word2 。如果两个数组表示的字符串相同，返回 true ；否则，返回 false 。
数组表示的字符串 是由数组中的所有元素 按顺序 连接形成的字符串。
示例 1：
输入：word1 = ["ab", "c"], word2 = ["a", "bc"] 输出：true 解释： word1 表示的字符串为 "ab" + "c" -> "abc" word2 表示的字符串为 "a" + "bc" -> "abc" 两个字符串相同，返回 true 示例 2：
输入：word1 = ["a", "cb"], word2 = ["ab", "c"] 输出：false 示例 3：
输入：word1 = ["abc", "d", "defg"], word2 = ["abcddefg"] 输出：true 提示：
1 &lt;= word1.length, word2.length &lt;= 103 1 &lt;= word1[i].</description></item><item><title>【2022-10-31每日一题】481. 神奇字符串[Medium]</title><link>/study/leetcode/magical-string/</link><pubDate>Mon, 31 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/magical-string/</guid><description>2022-10-31每日一题：481. 神奇字符串 难度：Medium
标签：双指针 、 字符串
神奇字符串 s 仅由 '1' 和 '2' 组成，并需要遵守下面的规则：
神奇字符串 s 的神奇之处在于，串联字符串中 '1' 和 '2' 的连续出现次数可以生成该字符串。 s 的前几个元素是 s = "1221121221221121122……" 。如果将 s 中连续的若干 1 和 2 进行分组，可以得到 "1 22 11 2 1 22 1 22 11 2 11 22 ......" 。每组中 1 或者 2 的出现次数分别是 "1 2 2 1 1 2 1 2 2 1 2 2 ......" 。上面的出现次数正是 s 自身。
给你一个整数 n ，返回在神奇字符串 s 的前 n 个数字中 1 的数目。</description></item><item><title>【2022-10-30每日一题】784. 字母大小写全排列[Medium]</title><link>/study/leetcode/letter-case-permutation/</link><pubDate>Sun, 30 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/letter-case-permutation/</guid><description>2022-10-30每日一题：784. 字母大小写全排列 难度：Medium
标签：位运算 、 字符串 、 回溯
给定一个字符串&amp;nbsp;s&amp;nbsp;，通过将字符串&amp;nbsp;s&amp;nbsp;中的每个字母转变大小写，我们可以获得一个新的字符串。
返回 所有可能得到的字符串集合 。以 任意顺序 返回输出。
&amp;nbsp;
示例 1：
输入：s = "a1b2" 输出：["a1b2", "a1B2", "A1b2", "A1B2"] 示例 2:
输入: s = "3z4" 输出: ["3z4","3Z4"] &amp;nbsp;
提示:
1 &amp;lt;= s.length &amp;lt;= 12 s&amp;nbsp;由小写英文字母、大写英文字母和数字组成 方法一：回溯 个人写法 func letterCasePermutation(s string) (ans []string) { n := len(s) sb := []byte(s) var dfs func (i int) dfs = func(i int) { if i == n { ans = append(ans, string(sb)) return } dfs(i+1) if sb[i] &amp;lt; '0' || sb[i] &amp;gt; '9' { sb[i] ^= 32 dfs(i+1) sb[i] ^= 32 } } dfs(0) return ans } 官方优化 func letterCasePermutation(s string) (ans []string) { n, sb := len(s), []byte(s) var dfs func (i int) dfs = func(i int) { // 跳过数字 for i &amp;lt; n &amp;amp;&amp;amp; unicode.</description></item><item><title>【2022-10-29每日一题】1773. 统计匹配检索规则的物品数量[Easy]</title><link>/study/leetcode/count-items-matching-a-rule/</link><pubDate>Sat, 29 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/count-items-matching-a-rule/</guid><description>2022-10-29每日一题：1773. 统计匹配检索规则的物品数量 难度：Easy
标签：数组 、 字符串
给你一个数组 items ，其中 items[i] = [typei, colori, namei] ，描述第 i 件物品的类型、颜色以及名称。
另给你一条由两个字符串 ruleKey 和 ruleValue 表示的检索规则。
如果第 i 件物品能满足下述条件之一，则认为该物品与给定的检索规则 匹配 ：
ruleKey == "type" 且 ruleValue == typei 。 ruleKey == "color" 且 ruleValue == colori 。 ruleKey == "name" 且 ruleValue == namei 。 统计并返回 匹配检索规则的物品数量 。
示例 1：
输入：items = [["phone","blue","pixel"],["computer","silver","lenovo"],["phone","gold","iphone"]], ruleKey = "color", ruleValue = "silver" 输出：1 解释：只有一件物品匹配检索规则，这件物品是 ["computer","silver","lenovo"] 。 示例 2：
输入：items = [["phone","blue","pixel"],["computer","silver","phone"],["phone","gold","iphone"]], ruleKey = "</description></item><item><title>【2022-10-28每日一题】907. 子数组的最小值之和[Medium]</title><link>/study/leetcode/sum-of-subarray-minimums/</link><pubDate>Fri, 28 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/sum-of-subarray-minimums/</guid><description>2022-10-28每日一题：907. 子数组的最小值之和 难度：Medium
标签：栈 、 数组 、 动态规划 、 单调栈
给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。
由于答案可能很大，因此 返回答案模 10^9 + 7 。
示例 1：
输入：arr = [3,1,2,4] 输出：17 解释： 子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。 示例 2：
输入：arr = [11,81,94,43,3] 输出：444 提示：
1 &lt;= arr.length &lt;= 3 * 104 1 &lt;= arr[i] &lt;= 3 * 104 方法一：单调栈 官方优化版 const mod int = 1e9+7 func sumSubarrayMins(arr []int) int { n := len(arr) left, right := make([]int, n), make([]int, n) stack := []int{-1} // -1 为哨兵 for i := 0; i &amp;lt; n; i++ { for len(stack) &amp;gt; 1 &amp;amp;&amp;amp; arr[stack[len(stack)-1]] &amp;gt;= arr[i] { stack = stack[:len(stack)-1] } left[i] = i - stack[len(stack)-1] stack = append(stack, i) } stack = []int{n} for i := n - 1; i &amp;gt;= 0; i-- { for len(stack) &amp;gt; 1 &amp;amp;&amp;amp; arr[stack[len(stack)-1]] &amp;gt; arr[i] { stack = stack[:len(stack)-1] } right[i] = stack[len(stack)-1] - i stack = append(stack, i) } ans := 0 for i, x := range arr { ans = (ans + x * left[i] * right[i]) % mod } return ans } 延迟计算宽度 const mod int = 1e9+7 func sumSubarrayMins(arr []int) int { n := len(arr) left, right := make([]int, n), make([]int, n) stack := []int{-1} // -1 为哨兵 for i := 0; i &amp;lt; n; i++ { for len(stack) &amp;gt; 1 &amp;amp;&amp;amp; arr[stack[len(stack)-1]] &amp;gt;= arr[i] { stack = stack[:len(stack)-1] } left[i] = stack[len(stack)-1] stack = append(stack, i) } stack = []int{n} for i := n - 1; i &amp;gt;= 0; i-- { for len(stack) &amp;gt; 1 &amp;amp;&amp;amp; arr[stack[len(stack)-1]] &amp;gt; arr[i] { stack = stack[:len(stack)-1] } right[i] = stack[len(stack)-1] stack = append(stack, i) } ans := 0 for i, x := range arr { ans = (ans + x * (i - left[i]) * (right[i]-i)) % mod } return ans } 二次遍历变形 func sumSubarrayMins(arr []int) (ans int) { n := len(arr) left := make([]int, n) right := make([]int, n) for i := range right { right[i] = n } st := []int{-1} // -1 为哨兵，方便计算赋值 for i, x := range arr { for len(st) &amp;gt; 1 &amp;amp;&amp;amp; arr[st[len(st)-1]] &amp;gt;= x { right[st[len(st)-1]] = i // i 恰好是栈顶的右边界 st = st[:len(st)-1] } left[i] = st[len(st)-1] // 可以直接计算 i - st[len(st)-1] st = append(st, i) } for i, x := range arr { ans += x * (i - left[i]) * (right[i] - i) // 累加贡献 } return ans % (1e9 + 7) } 优化版本：一次遍历 func sumSubarrayMins(arr []int) (ans int) { arr = append(arr, -1) st := []int{-1} // 哨兵 for r, x := range arr { for len(st) &amp;gt; 1 &amp;amp;&amp;amp; arr[st[len(st)-1]] &amp;gt;= x { i := st[len(st)-1] st = st[:len(st)-1] ans += arr[i] * (i - st[len(st)-1]) * (r - i) // 累加贡献 } st = append(st, r) } return ans % (1e9 + 7) } 复杂度分析 时间复杂度：O(n)。 空间复杂度：O(n)。 方法二：动态规划 const mod int = 1e9 + 7 func sumSubarrayMins(arr []int) (ans int) { n := len(arr) dp := make([]int, n) stack := []int{} // 栈中保持数组索引 for i, x := range arr { // 移除栈顶比当前数大的所有数 for len(stack) &amp;gt; 0 &amp;amp;&amp;amp; arr[stack[len(stack)-1]] &amp;gt; x { stack = stack[:len(stack)-1] } k := i + 1 // 栈为空的k值 if len(stack) &amp;gt; 0 { k = i - stack[len(stack)-1] } dp[i] = k * x if len(stack) &amp;gt; 0 { dp[i] += dp[i-k] } ans = (ans+dp[i]) % mod stack = append(stack, i) } return ans } 复杂度分析 时间复杂度：O(n)。 空间复杂度：O(n)。 LeetCode题库地址 https://leetcode.</description></item><item><title>【2022-10-27每日一题】1822. 数组元素积的符号[Easy]</title><link>/study/leetcode/sign-of-the-product-of-an-array/</link><pubDate>Thu, 27 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/sign-of-the-product-of-an-array/</guid><description>2022-10-27每日一题：1822. 数组元素积的符号 难度：Easy
标签：数组 、 数学
已知函数 signFunc(x) 将会根据 x 的正负返回特定值：
如果 x 是正数，返回 1 。 如果 x 是负数，返回 -1 。 如果 x 是等于 0 ，返回 0 。 给你一个整数数组 nums 。令 product 为数组 nums 中所有元素值的乘积。
返回 signFunc(product) 。
示例 1：
输入：nums = [-1,-2,-3,-4,3,2,1] 输出：1 解释：数组中所有值的乘积是 144 ，且 signFunc(144) = 1 示例 2：
输入：nums = [1,5,0,2,-3] 输出：0 解释：数组中所有值的乘积是 0 ，且 signFunc(0) = 0 示例 3：
输入：nums = [-1,1,-1,1,-1] 输出：-1 解释：数组中所有值的乘积是 -1 ，且 signFunc(-1) = -1 提示：</description></item><item><title>【2022-10-26每日一题】862. 和至少为 K 的最短子数组[Hard]</title><link>/study/leetcode/shortest-subarray-with-sum-at-least-k/</link><pubDate>Wed, 26 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/shortest-subarray-with-sum-at-least-k/</guid><description>2022-10-26每日一题：862. 和至少为 K 的最短子数组 难度：Hard
标签：队列 、 数组 、 二分查找 、 前缀和 、 滑动窗口 、 单调队列 、 堆（优先队列）
给你一个整数数组 nums 和一个整数 k ，找出 nums 中和至少为 k 的 最短非空子数组 ，并返回该子数组的长度。如果不存在这样的 子数组 ，返回 -1 。
子数组 是数组中 连续 的一部分。
&amp;nbsp;
示例 1：
输入：nums = [1], k = 1 输出：1 示例 2：
输入：nums = [1,2], k = 4 输出：-1 示例 3：
输入：nums = [2,-1,2], k = 3 输出：3 &amp;nbsp;
提示：
1 &amp;lt;= nums.length &amp;lt;= 105 -105 &amp;lt;= nums[i] &amp;lt;= 105 1 &amp;lt;= k &amp;lt;= 109 方法一：前缀和 + 单调双端队列 推荐题解 func shortestSubarray(nums []int, k int) int { n := len(nums) preSum := make([]int, n+1) for i, num := range nums { preSum[i+1] = preSum[i] + num // 计算前缀和 } ans := n + 1 q := []int{} for i, curSum := range preSum { for len(q) &amp;gt; 0 &amp;amp;&amp;amp; curSum - preSum[q[0]] &amp;gt;= k { ans = min(ans, i-q[0]) q = q[1:] // 上面计算后 q[0] 没有用了，直接移除 } for len(q) &amp;gt;0 &amp;amp;&amp;amp; preSum[q[len(q)-1]] &amp;gt;= curSum { q = q[:len(q)-1] // 移除队列中大约等于当前数的元素 } q = append(q, i) } if ans &amp;lt; n + 1 { return ans } return -1 } func min(a, b int) int { if a &amp;lt; b { return a } return b } 复杂度分析 LeetCode题库地址 https://leetcode.</description></item><item><title>【2022-10-25每日一题】934. 最短的桥[Medium]</title><link>/study/leetcode/shortest-bridge/</link><pubDate>Tue, 25 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/shortest-bridge/</guid><description>2022-10-25每日一题：934. 最短的桥 难度：Medium
标签：深度优先搜索 、 广度优先搜索 、 数组 、 矩阵
给你一个大小为 n x n 的二元矩阵 grid ，其中 1 表示陆地，0 表示水域。
岛 是由四面相连的 1 形成的一个最大组，即不会与非组内的任何其他 1 相连。grid 中 恰好存在两座岛 。
你可以将任意数量的 0 变为 1 ，以使两座岛连接起来，变成 一座岛 。
返回必须翻转的 0 的最小数目。
&amp;nbsp;
示例 1：
输入：grid = [[0,1],[1,0]] 输出：1 示例 2：
输入：grid = [[0,1,0],[0,0,0],[0,0,1]] 输出：2 示例 3：
输入：grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]] 输出：1 &amp;nbsp;
提示：
n == grid.length == grid[i].length 2 &amp;lt;= n &amp;lt;= 100 grid[i][j] 为 0 或 1 grid 中恰有两个岛 方法一：深度优先搜索 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读</description></item><item><title>【2022-10-24每日一题】915. 分割数组[Medium]</title><link>/study/leetcode/partition-array-into-disjoint-intervals/</link><pubDate>Mon, 24 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/partition-array-into-disjoint-intervals/</guid><description>2022-10-24每日一题：915. 分割数组 难度：Medium
标签：数组
给定一个数组&amp;nbsp;nums&amp;nbsp;，将其划分为两个连续子数组&amp;nbsp;left&amp;nbsp;和&amp;nbsp;right，&amp;nbsp;使得：
left&amp;nbsp;中的每个元素都小于或等于&amp;nbsp;right&amp;nbsp;中的每个元素。 left 和&amp;nbsp;right&amp;nbsp;都是非空的。 left 的长度要尽可能小。 在完成这样的分组后返回&amp;nbsp;left&amp;nbsp;的&amp;nbsp;长度&amp;nbsp;。
用例可以保证存在这样的划分方法。
&amp;nbsp;
示例 1：
输入：nums = [5,0,3,8,6] 输出：3 解释：left = [5,0,3]，right = [8,6] 示例 2：
输入：nums = [1,1,1,0,6,12] 输出：4 解释：left = [1,1,1,0]，right = [6,12] &amp;nbsp;
提示：
2 &amp;lt;= nums.length &amp;lt;= 105 0 &amp;lt;= nums[i] &amp;lt;= 106 可以保证至少有一种方法能够按题目所描述的那样对 nums 进行划分。 方法一：两次遍历 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
func partitionDisjoint(nums []int) int { n := len(nums) // 处理后缀最小值 minRight := make([]int, n) minRight[n-1] = nums[n-1] for i := n-2; i &amp;gt; 0; i-- { minRight[i] = min(minRight[i+1], nums[i]) } maxLeft := nums[0] for i := 1; ; i++ { // 题目保证有解，所以i到n-1之前一定可以找到答案 if maxLeft &amp;lt;= minRight[i] { return i } maxLeft = max(maxLeft, nums[i]) } } func min(a, b int) int { if a &amp;lt; b { return a } return b } func max(a, b int) int { if a &amp;gt; b { return a } return b } 复杂度分析 时间复杂度：O(n)，其中 n 是 nums 的长度。求解 minRight 的时间复杂度是 O(n)，从前到后遍历 i 的时间复杂度也为 O(n)。</description></item><item><title>【2022-10-23每日一题】1768. 交替合并字符串[Easy]</title><link>/study/leetcode/merge-strings-alternately/</link><pubDate>Sun, 23 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/merge-strings-alternately/</guid><description>2022-10-23每日一题：1768. 交替合并字符串 难度：Easy
标签：双指针 、 字符串
给你两个字符串 word1 和 word2 。请你从 word1 开始，通过交替添加字母来合并字符串。如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。
返回 合并后的字符串 。
示例 1：
输入：word1 = "abc", word2 = "pqr" 输出："apbqcr" 解释：字符串合并情况如下所示： word1： a b c word2： p q r 合并后： a p b q c r 示例 2：
输入：word1 = "ab", word2 = "pqrs" 输出："apbqrs" 解释：注意，word2 比 word1 长，"rs" 需要追加到合并后字符串的末尾。 word1： a b word2： p q r s 合并后： a p b q r s 示例 3：
输入：word1 = "abcd", word2 = "</description></item><item><title>【2022-10-22每日一题】1235. 规划兼职工作[Hard]</title><link>/study/leetcode/maximum-profit-in-job-scheduling/</link><pubDate>Sat, 22 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximum-profit-in-job-scheduling/</guid><description>2022-10-22每日一题：1235. 规划兼职工作 难度：Hard
标签：数组 、 二分查找 、 动态规划 、 排序
你打算利用空闲时间来做兼职工作赚些零花钱。
这里有&amp;nbsp;n&amp;nbsp;份兼职工作，每份工作预计从&amp;nbsp;startTime[i]&amp;nbsp;开始到&amp;nbsp;endTime[i]&amp;nbsp;结束，报酬为&amp;nbsp;profit[i]。
给你一份兼职工作表，包含开始时间&amp;nbsp;startTime，结束时间&amp;nbsp;endTime&amp;nbsp;和预计报酬&amp;nbsp;profit&amp;nbsp;三个数组，请你计算并返回可以获得的最大报酬。
注意，时间上出现重叠的 2 份工作不能同时进行。
如果你选择的工作在时间&amp;nbsp;X&amp;nbsp;结束，那么你可以立刻进行在时间&amp;nbsp;X&amp;nbsp;开始的下一份工作。
&amp;nbsp;
示例 1：
输入：startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70] 输出：120 解释： 我们选出第 1 份和第 4 份工作， 时间范围是 [1-3]+[3-6]，共获得报酬 120 = 50 + 70。 示例 2：
输入：startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60] 输出：150 解释： 我们选择第 1，4，5 份工作。 共获得报酬 150 = 20 + 70 + 60。 示例 3：
输入：startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4] 输出：6 &amp;nbsp;</description></item><item><title>【2022-10-21每日一题】901. 股票价格跨度[Medium]</title><link>/study/leetcode/online-stock-span/</link><pubDate>Fri, 21 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/online-stock-span/</guid><description>2022-10-21每日一题：901. 股票价格跨度 难度：Medium
标签：栈 、 设计 、 数据流 、 单调栈
编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。
今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。
例如，如果未来7天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。
&amp;nbsp;
示例：
输入：[&amp;quot;StockSpanner&amp;quot;,&amp;quot;next&amp;quot;,&amp;quot;next&amp;quot;,&amp;quot;next&amp;quot;,&amp;quot;next&amp;quot;,&amp;quot;next&amp;quot;,&amp;quot;next&amp;quot;,&amp;quot;next&amp;quot;], [[],[100],[80],[60],[70],[60],[75],[85]] 输出：[null,1,1,1,2,1,4,6] 解释： 首先，初始化 S = StockSpanner()，然后： S.next(100) 被调用并返回 1， S.next(80) 被调用并返回 1， S.next(60) 被调用并返回 1， S.next(70) 被调用并返回 2， S.next(60) 被调用并返回 1， S.next(75) 被调用并返回 4， S.next(85) 被调用并返回 6。 注意 (例如) S.next(75) 返回 4，因为截至今天的最后 4 个价格 (包括今天的价格 75) 小于或等于今天的价格。 &amp;nbsp;
提示：
调用&amp;nbsp;StockSpanner.next(int price)&amp;nbsp;时，将有&amp;nbsp;1 &amp;lt;= price &amp;lt;= 10^5。 每个测试用例最多可以调用&amp;nbsp; 10000 次 StockSpanner.</description></item><item><title>【2022-10-20每日一题】779. 第K个语法符号[Medium]</title><link>/study/leetcode/k-th-symbol-in-grammar/</link><pubDate>Thu, 20 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/k-th-symbol-in-grammar/</guid><description>2022-10-20每日一题：779. 第K个语法符号 难度：Medium
标签：位运算 、 递归 、 数学
我们构建了一个包含 n 行(&amp;nbsp;索引从 1&amp;nbsp; 开始&amp;nbsp;)的表。首先在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。
例如，对于 n = 3 ，第 1 行是 0 ，第 2 行是 01 ，第3行是 0110 。 给定行数&amp;nbsp;n&amp;nbsp;和序数 k，返回第 n 行中第 k&amp;nbsp;个字符。（&amp;nbsp;k&amp;nbsp;从索引 1 开始）
示例 1:
输入: n = 1, k = 1 输出: 0 解释: 第一行：0 示例 2:
输入: n = 2, k = 1 输出: 0 解释: 第一行: 0 第二行: 01 示例 3:
输入: n = 2, k = 2 输出: 1 解释: 第一行: 0 第二行: 01 &amp;nbsp;</description></item><item><title>【2022-10-19每日一题】1700. 无法吃午餐的学生数量[Easy]</title><link>/study/leetcode/number-of-students-unable-to-eat-lunch/</link><pubDate>Wed, 19 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/number-of-students-unable-to-eat-lunch/</guid><description>2022-10-19每日一题：1700. 无法吃午餐的学生数量 难度：Easy
标签：栈 、 队列 、 数组 、 模拟
学校的自助午餐提供圆形和方形的三明治，分别用数字 0 和 1 表示。所有学生站在一个队列里，每个学生要么喜欢圆形的要么喜欢方形的。
餐厅里三明治的数量与学生的数量相同。所有三明治都放在一个 栈 里，每一轮：
如果队列最前面的学生 喜欢 栈顶的三明治，那么会 拿走它 并离开队列。 否则，这名学生会 放弃这个三明治 并回到队列的尾部。 这个过程会一直持续到队列里所有学生都不喜欢栈顶的三明治为止。
给你两个整数数组 students 和 sandwiches ，其中 sandwiches[i] 是栈里面第 i​​​​​​ 个三明治的类型（i = 0 是栈的顶部）， students[j] 是初始队列里第 j​​​​​​ 名学生对三明治的喜好（j = 0 是队列的最开始位置）。请你返回无法吃午餐的学生数量。
示例 1：
输入：students = [1,1,0,0], sandwiches = [0,1,0,1] 输出：0 解释： - 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [1,0,0,1]。 - 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [0,0,1,1]。 - 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [0,1,1]，三明治栈为 sandwiches = [1,0,1]。 - 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [1,1,0]。 - 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [1,0]，三明治栈为 sandwiches = [0,1]。 - 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [0,1]。 - 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [1]，三明治栈为 sandwiches = [1]。 - 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = []，三明治栈为 sandwiches = []。 所以所有学生都有三明治吃。 示例 2：</description></item><item><title>【2022-10-18每日一题】902. 最大为 N 的数字组合[Hard]</title><link>/study/leetcode/numbers-at-most-n-given-digit-set/</link><pubDate>Tue, 18 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/numbers-at-most-n-given-digit-set/</guid><description>2022-10-18每日一题：902. 最大为 N 的数字组合 难度：Hard
标签：数组 、 数学 、 字符串 、 二分查找 、 动态规划
给定一个按&amp;nbsp;非递减顺序&amp;nbsp;排列的数字数组&amp;nbsp;digits&amp;nbsp;。你可以用任意次数&amp;nbsp;digits[i]&amp;nbsp;来写的数字。例如，如果&amp;nbsp;digits = ['1','3','5']，我们可以写数字，如&amp;nbsp;'13',&amp;nbsp;'551', 和&amp;nbsp;'1351315'。
返回 可以生成的小于或等于给定整数 n 的正整数的个数&amp;nbsp;。
&amp;nbsp;
示例 1：
输入：digits = ["1","3","5","7"], n = 100 输出：20 解释： 可写出的 20 个数字是： 1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77. 示例 2：
输入：digits = ["1","4","9"], n = 1000000000 输出：29523 解释： 我们可以写 3 个一位数字，9 个两位数字，27 个三位数字， 81 个四位数字，243 个五位数字，729 个六位数字， 2187 个七位数字，6561 个八位数字和 19683 个九位数字。 总共，可以使用D中的数字写出 29523 个整数。 示例 3:</description></item><item><title>【2022-10-17每日一题】904. 水果成篮[Medium]</title><link>/study/leetcode/fruit-into-baskets/</link><pubDate>Mon, 17 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/fruit-into-baskets/</guid><description>2022-10-17每日一题：904. 水果成篮 难度：Medium
标签：数组 、 哈希表 、 滑动窗口
你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。
你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：
你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。 你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。 给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。
&amp;nbsp;
示例 1：
输入：fruits = [1,2,1] 输出：3 解释：可以采摘全部 3 棵树。 示例 2：
输入：fruits = [0,1,2,2] 输出：3 解释：可以采摘 [1,2,2] 这三棵树。 如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。 示例 3：
输入：fruits = [1,2,3,2,2] 输出：4 解释：可以采摘 [2,3,2,2] 这四棵树。 如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。 示例 4：
输入：fruits = [3,3,3,1,2,1,1,2,3,3,4] 输出：5 解释：可以采摘 [1,2,1,1,2] 这五棵树。 &amp;nbsp;</description></item><item><title>【2022-10-16每日一题】886. 可能的二分法[Medium]</title><link>/study/leetcode/possible-bipartition/</link><pubDate>Sun, 16 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/possible-bipartition/</guid><description>2022-10-16每日一题：886. 可能的二分法 难度：Medium
标签：深度优先搜索 、 广度优先搜索 、 并查集 、 图
给定一组&amp;nbsp;n&amp;nbsp;人（编号为&amp;nbsp;1, 2, ..., n），&amp;nbsp;我们想把每个人分进任意大小的两组。每个人都可能不喜欢其他人，那么他们不应该属于同一组。
给定整数 n&amp;nbsp;和数组 dislikes&amp;nbsp;，其中&amp;nbsp;dislikes[i] = [ai, bi]&amp;nbsp;，表示不允许将编号为 ai&amp;nbsp;和&amp;nbsp;&amp;nbsp;bi的人归入同一组。当可以用这种方法将所有人分进两组时，返回 true；否则返回 false。
&amp;nbsp;
示例 1：
输入：n = 4, dislikes = [[1,2],[1,3],[2,4]] 输出：true 解释：group1 [1,4], group2 [2,3] 示例 2：
输入：n = 3, dislikes = [[1,2],[1,3],[2,3]] 输出：false 示例 3：
输入：n = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]] 输出：false &amp;nbsp;
提示：
1 &amp;lt;= n &amp;lt;= 2000 0 &amp;lt;= dislikes.length &amp;lt;= 104 dislikes[i].length == 2 1 &amp;lt;= dislikes[i][j] &amp;lt;= n ai&amp;nbsp;&amp;lt; bi dislikes&amp;nbsp;中每一组都 不同 &amp;nbsp;</description></item><item><title>【2022-10-15每日一题】1441. 用栈操作构建数组[Medium]</title><link>/study/leetcode/build-an-array-with-stack-operations/</link><pubDate>Sat, 15 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/build-an-array-with-stack-operations/</guid><description>2022-10-15每日一题：1441. 用栈操作构建数组 难度：Medium
标签：栈 、 数组 、 模拟
给你一个数组 target 和一个整数 n。每次迭代，需要从&amp;nbsp; list = { 1 , 2 , 3 ..., n } 中依次读取一个数字。
请使用下述操作来构建目标数组 target ：
"Push"：从 list 中读取一个新元素， 并将其推入数组中。 "Pop"：删除数组中的最后一个元素。 如果目标数组构建完成，就停止读取更多元素。 题目数据保证目标数组严格递增，并且只包含 1 到 n 之间的数字。
请返回构建目标数组所用的操作序列。如果存在多个可行方案，返回任一即可。
&amp;nbsp;
示例 1：
输入：target = [1,3], n = 3 输出：["Push","Push","Pop","Push"] 解释： 读取 1 并自动推入数组 -&amp;gt; [1] 读取 2 并自动推入数组，然后删除它 -&amp;gt; [1] 读取 3 并自动推入数组 -&amp;gt; [1,3] 示例 2：
输入：target = [1,2,3], n = 3 输出：["Push","Push","Push"] 示例 3：</description></item><item><title>【2022-10-14每日一题】940. 不同的子序列 II[Hard]</title><link>/study/leetcode/distinct-subsequences-ii/</link><pubDate>Fri, 14 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/distinct-subsequences-ii/</guid><description>2022-10-14每日一题：940. 不同的子序列 II 难度：Hard
标签：字符串 、 动态规划
给定一个字符串 s，计算 s 的 不同非空子序列 的个数。因为结果可能很大，所以返回答案需要对 10^9 + 7 取余 。
字符串的 子序列 是经由原字符串删除一些（也可能不删除）字符但不改变剩余字符相对位置的一个新字符串。
例如，"ace" 是 "abcde" 的一个子序列，但 "aec" 不是。 &amp;nbsp;
示例 1：
输入：s = "abc" 输出：7 解释：7 个不同的子序列分别是 "a", "b", "c", "ab", "ac", "bc", 以及 "abc"。 示例 2：
输入：s = "aba" 输出：6 解释：6 个不同的子序列分别是 "a", "b", "ab", "ba", "aa" 以及 "aba"。 示例 3：
输入：s = "aaa" 输出：3 解释：3 个不同的子序列分别是 "a", "aa" 以及 "aaa"。 &amp;nbsp;
提示：
1 &amp;lt;= s.</description></item><item><title>【2022-10-13每日一题】769. 最多能完成排序的块[Medium]</title><link>/study/leetcode/max-chunks-to-make-sorted/</link><pubDate>Thu, 13 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/max-chunks-to-make-sorted/</guid><description>2022-10-13每日一题：769. 最多能完成排序的块 难度：Medium
标签：栈 、 贪心 、 数组 、 排序 、 单调栈
给定一个长度为 n 的整数数组 arr ，它表示在 [0, n - 1] 范围内的整数的排列。
我们将 arr 分割成若干 块 (即分区)，并对每个块单独排序。将它们连接起来后，使得连接的结果和按升序排序后的原数组相同。
返回数组能分成的最多块数量。
&amp;nbsp;
示例 1:
输入: arr = [4,3,2,1,0] 输出: 1 解释: 将数组分成2块或者更多块，都无法得到所需的结果。 例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。 示例 2:
输入: arr = [1,0,2,3,4] 输出: 4 解释: 我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。 然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。 &amp;nbsp;
提示:</description></item><item><title>【2022-10-12每日一题】817. 链表组件[Medium]</title><link>/study/leetcode/linked-list-components/</link><pubDate>Wed, 12 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/linked-list-components/</guid><description>2022-10-12每日一题：817. 链表组件 难度：Medium
标签：数组 、 哈希表 、 链表
给定链表头结点&amp;nbsp;head，该链表上的每个结点都有一个 唯一的整型值 。同时给定列表&amp;nbsp;nums，该列表是上述链表中整型值的一个子集。
返回列表&amp;nbsp;nums&amp;nbsp;中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表&amp;nbsp;nums&amp;nbsp;中）构成的集合。
&amp;nbsp;
示例&amp;nbsp;1：
输入: head = [0,1,2,3], nums = [0,1,3] 输出: 2 解释: 链表中,0 和 1 是相连接的，且 nums 中不包含 2，所以 [0, 1] 是 nums 的一个组件，同理 [3] 也是一个组件，故返回 2。 示例 2：
&amp;nbsp;
输入: head = [0,1,2,3,4], nums = [0,3,1,4] 输出: 2 解释: 链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 [0, 1] 和 [3, 4] 是两个组件，故返回 2。 &amp;nbsp;
提示：
链表中节点数为n 1 &amp;lt;= n &amp;lt;= 104 0 &amp;lt;= Node.</description></item><item><title>【2022-10-11每日一题】1790. 仅执行一次字符串交换能否使两个字符串相等[Easy]</title><link>/study/leetcode/check-if-one-string-swap-can-make-strings-equal/</link><pubDate>Tue, 11 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/check-if-one-string-swap-can-make-strings-equal/</guid><description>2022-10-11每日一题：1790. 仅执行一次字符串交换能否使两个字符串相等 难度：Easy
标签：哈希表 、 字符串 、 计数
给你长度相等的两个字符串 s1 和 s2 。一次 字符串交换 操作的步骤如下：选出某个字符串中的两个下标（不必不同），并交换这两个下标所对应的字符。
如果对 其中一个字符串 执行 最多一次字符串交换 就可以使两个字符串相等，返回 true ；否则，返回 false 。
示例 1：
输入：s1 = "bank", s2 = "kanb" 输出：true 解释：例如，交换 s2 中的第一个和最后一个字符可以得到 "bank" 示例 2：
输入：s1 = "attack", s2 = "defend" 输出：false 解释：一次字符串交换无法使两个字符串相等 示例 3：
输入：s1 = "kelb", s2 = "kelb" 输出：true 解释：两个字符串已经相等，所以不需要进行字符串交换 示例 4：
输入：s1 = "abcd", s2 = "dcba" 输出：false 提示：
1 &amp;lt;= s1.length, s2.length &amp;lt;= 100 s1.length == s2.</description></item><item><title>【2022-10-10每日一题】801. 使序列递增的最小交换次数[Hard]</title><link>/study/leetcode/minimum-swaps-to-make-sequences-increasing/</link><pubDate>Mon, 10 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/minimum-swaps-to-make-sequences-increasing/</guid><description>2022-10-10每日一题：801. 使序列递增的最小交换次数 难度：Hard
标签：数组 、 动态规划
我们有两个长度相等且不为空的整型数组&amp;nbsp;nums1&amp;nbsp;和&amp;nbsp;nums2&amp;nbsp;。在一次操作中，我们可以交换&amp;nbsp;nums1[i]&amp;nbsp;和&amp;nbsp;nums2[i]的元素。
例如，如果 nums1 = [1,2,3,8] ， nums2 =[5,6,7,4] ，你可以交换 i = 3 处的元素，得到 nums1 =[1,2,3,4] 和 nums2 =[5,6,7,8] 。 返回 使 nums1 和 nums2 严格递增&amp;nbsp;所需操作的最小次数 。
数组&amp;nbsp;arr&amp;nbsp;严格递增 且&amp;nbsp;&amp;nbsp;arr[0] &amp;lt; arr[1] &amp;lt; arr[2] &amp;lt; ... &amp;lt; arr[arr.length - 1]&amp;nbsp;。
注意：
用例保证可以实现操作。 &amp;nbsp;
示例 1:
输入: nums1 = [1,3,5,4], nums2 = [1,2,3,7] 输出: 1 解释: 交换 A[3] 和 B[3] 后，两个数组如下: A = [1, 3, 5, 7] ， B = [1, 2, 3, 4] 两个数组均为严格递增的。 示例 2:</description></item><item><title>【2022-10-09每日一题】856. 括号的分数[Medium]</title><link>/study/leetcode/score-of-parentheses/</link><pubDate>Sun, 09 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/score-of-parentheses/</guid><description>2022-10-09每日一题：856. 括号的分数 难度：Medium
标签：栈 、 字符串
给定一个平衡括号字符串&amp;nbsp;S，按下述规则计算该字符串的分数：
() 得 1 分。 AB 得&amp;nbsp;A + B&amp;nbsp;分，其中 A 和 B 是平衡括号字符串。 (A) 得&amp;nbsp;2 * A&amp;nbsp;分，其中 A 是平衡括号字符串。 &amp;nbsp;
示例 1：
输入： &amp;quot;()&amp;quot; 输出： 1 示例 2：
输入： &amp;quot;(())&amp;quot; 输出： 2 示例&amp;nbsp;3：
输入： &amp;quot;()()&amp;quot; 输出： 2 示例&amp;nbsp;4：
输入： &amp;quot;(()(()))&amp;quot; 输出： 6 &amp;nbsp;
提示：
S&amp;nbsp;是平衡括号字符串，且只含有&amp;nbsp;(&amp;nbsp;和&amp;nbsp;)&amp;nbsp;。 2 &amp;lt;= S.length &amp;lt;= 50 方法一：栈 核心思想 把平衡字符串 s 看作是一个空字符串加上 s 本身，并且定义空字符串的分数为 0。使用栈 st 记录平衡字符串的分数，在开始之前要压入分数 0，表示空字符串的分数。
在遍历字符串 s 的过程中：
遇到左括号，那么我们需要计算该左括号内部的子平衡括号字符串A 的分数，我们也要先压入分数 0，表示 A 前面的空字符串的分数。</description></item><item><title>【2022-10-08每日一题】870. 优势洗牌[Medium]</title><link>/study/leetcode/advantage-shuffle/</link><pubDate>Sat, 08 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/advantage-shuffle/</guid><description>2022-10-08每日一题：870. 优势洗牌 难度：Medium
标签：贪心 、 数组 、 双指针 、 排序
给定两个大小相等的数组&amp;nbsp;nums1&amp;nbsp;和&amp;nbsp;nums2，nums1&amp;nbsp;相对于 nums&amp;nbsp;的优势可以用满足&amp;nbsp;nums1[i] &amp;gt; nums2[i]&amp;nbsp;的索引 i&amp;nbsp;的数目来描述。
返回 nums1&amp;nbsp;的任意排列，使其相对于 nums2&amp;nbsp;的优势最大化。
&amp;nbsp;
示例 1：
输入：nums1 = [2,7,11,15], nums2 = [1,10,4,11] 输出：[2,11,7,15] 示例 2：
输入：nums1 = [12,24,8,32], nums2 = [13,25,32,11] 输出：[24,32,8,12] &amp;nbsp;
提示：
1 &amp;lt;= nums1.length &amp;lt;= 105 nums2.length == nums1.length 0 &amp;lt;= nums1[i], nums2[i] &amp;lt;= 109 方法一：排序+贪心算法 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
func advantageCount(nums1 []int, nums2 []int) []int { // 构造索引数组 n := len(nums1) idx1 := make([]int, n) idx2 := make([]int, n) for i := 1; i &amp;lt; n; i++ { idx1[i] = i idx2[i] = i } // 对索引数组升序排序，比较巧妙 sort.</description></item><item><title>【2022-10-07每日一题】1800. 最大升序子数组和[Easy]</title><link>/study/leetcode/maximum-ascending-subarray-sum/</link><pubDate>Fri, 07 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximum-ascending-subarray-sum/</guid><description>2022-10-07每日一题：1800. 最大升序子数组和 难度：Easy
标签：数组
给你一个正整数组成的数组 nums ，返回 nums 中一个 升序 子数组的最大可能元素和。
子数组是数组中的一个连续数字序列。
已知子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，若对所有 i（l &lt;= i &lt; r），numsi &lt; numsi+1 都成立，则称这一子数组为 升序 子数组。注意，大小为 1 的子数组也视作 升序 子数组。
示例 1：
输入：nums = [10,20,30,5,10,50] 输出：65 解释：[5,10,50] 是元素和最大的升序子数组，最大元素和为 65 。 示例 2：
输入：nums = [10,20,30,40,50] 输出：150 解释：[10,20,30,40,50] 是元素和最大的升序子数组，最大元素和为 150 。 示例 3：
输入：nums = [12,17,15,13,10,11,12] 输出：33 解释：[10,11,12] 是元素和最大的升序子数组，最大元素和为 33 。 示例 4：
输入：nums = [100,10,1] 输出：100 提示：
1 &lt;= nums.length &lt;= 100 1 &lt;= nums[i] &lt;= 100 方法一： 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读</description></item><item><title>【2022-10-06每日一题】927. 三等分[Hard]</title><link>/study/leetcode/three-equal-parts/</link><pubDate>Thu, 06 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/three-equal-parts/</guid><description>2022-10-06每日一题：927. 三等分 难度：Hard
标签：数组 、 数学
给定一个由 0 和 1 组成的数组&amp;nbsp;arr&amp;nbsp;，将数组分成 &amp;nbsp;3&amp;nbsp;个非空的部分 ，使得所有这些部分表示相同的二进制值。
如果可以做到，请返回任何&amp;nbsp;[i, j]，其中 i+1 &amp;lt; j，这样一来：
arr[0], arr[1], ..., arr[i]&amp;nbsp;为第一部分； arr[i + 1], arr[i + 2], ..., arr[j - 1]&amp;nbsp;为第二部分； arr[j], arr[j + 1], ..., arr[arr.length - 1]&amp;nbsp;为第三部分。 这三个部分所表示的二进制值相等。 如果无法做到，就返回&amp;nbsp;[-1, -1]。
注意，在考虑每个部分所表示的二进制时，应当将其看作一个整体。例如，[1,1,0]&amp;nbsp;表示十进制中的&amp;nbsp;6，而不会是&amp;nbsp;3。此外，前导零也是被允许的，所以&amp;nbsp;[0,1,1] 和&amp;nbsp;[1,1]&amp;nbsp;表示相同的值。
&amp;nbsp;
示例 1：
输入：arr = [1,0,1,0,1] 输出：[0,3] 示例 2：
输入：arr = [1,1,0,1,1] 输出：[-1,-1] 示例 3:
输入：arr = [1,1,0,0,1] 输出：[0,2] &amp;nbsp;
提示：
3 &amp;lt;= arr.length &amp;lt;= 3 * 104 arr[i]&amp;nbsp;是&amp;nbsp;0&amp;nbsp;或&amp;nbsp;1 方法一： 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读</description></item><item><title>【2022-10-05每日一题】811. 子域名访问计数[Medium]</title><link>/study/leetcode/subdomain-visit-count/</link><pubDate>Wed, 05 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/subdomain-visit-count/</guid><description>2022-10-05每日一题：811. 子域名访问计数 难度：Medium
标签：数组 、 哈希表 、 字符串 、 计数
网站域名 "discuss.leetcode.com" 由多个子域名组成。顶级域名为 "com" ，二级域名为 "leetcode.com" ，最低一级为 "discuss.leetcode.com" 。当访问域名 "discuss.leetcode.com" 时，同时也会隐式访问其父域名 "leetcode.com" 以及 "com" 。
计数配对域名 是遵循 "rep d1.d2.d3" 或 "rep d1.d2" 格式的一个域名表示，其中 rep 表示访问域名的次数，d1.d2.d3 为域名本身。
例如，"9001 discuss.leetcode.com" 就是一个 计数配对域名 ，表示 discuss.leetcode.com 被访问了 9001 次。 给你一个 计数配对域名 组成的数组 cpdomains ，解析得到输入中每个子域名对应的&amp;nbsp;计数配对域名 ，并以数组形式返回。可以按 任意顺序 返回答案。
&amp;nbsp;
示例 1：
输入：cpdomains = ["9001 discuss.leetcode.com"] 输出：["9001 leetcode.com","9001 discuss.leetcode.com","9001 com"] 解释：例子中仅包含一个网站域名："discuss.leetcode.com"。 按照前文描述，子域名 "leetcode.com" 和 "com" 都会被访问，所以它们都被访问了 9001 次。 示例 2：
输入：cpdomains = ["</description></item><item><title>【2022-10-04每日一题】921. 使括号有效的最少添加[Medium]</title><link>/study/leetcode/minimum-add-to-make-parentheses-valid/</link><pubDate>Tue, 04 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/minimum-add-to-make-parentheses-valid/</guid><description>2022-10-04每日一题：921. 使括号有效的最少添加 难度：Medium
标签：栈 、 贪心 、 字符串
只有满足下面几点之一，括号字符串才是有效的：
它是一个空字符串，或者 它可以被写成&amp;nbsp;AB&amp;nbsp;（A&amp;nbsp;与&amp;nbsp;B&amp;nbsp;连接）, 其中&amp;nbsp;A 和&amp;nbsp;B&amp;nbsp;都是有效字符串，或者 它可以被写作&amp;nbsp;(A)，其中&amp;nbsp;A&amp;nbsp;是有效字符串。 给定一个括号字符串 s ，移动N次，你就可以在字符串的任何位置插入一个括号。
例如，如果 s = "()))" ，你可以插入一个开始括号为 "(()))" 或结束括号为 "())))" 。 返回 为使结果字符串 s 有效而必须添加的最少括号数。
&amp;nbsp;
示例 1：
输入：s = "())" 输出：1 示例 2：
输入：s = "(((" 输出：3 &amp;nbsp;
提示：
1 &amp;lt;= s.length &amp;lt;= 1000 s 只包含&amp;nbsp;'(' 和&amp;nbsp;')'&amp;nbsp;字符。 方法一： 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
从左到右遍历字符串，在遍历过程中维护左括号的个数以及添加次数。
如果遇到左括号，则将左括号的个数加 1。
如果遇到右括号，则需要和前面的左括号进行匹配，具体做法如下：
如果左括号的个数大于 0，则前面有左括号可以匹配，因此将左括号的个数减 1，表示有一个左括号和当前右括号匹配；
如果左括号的个数等于 0，则前面没有左括号可以匹配，需要添加一个左括号才能匹配，因此将添加次数加 1。
遍历结束后，需要检查左括号的个数是否为 0
func minAddToMakeValid(s string) int { left, ans := 0, 0 for _, ch := range s { if ch == '(' { left++ } else if left &amp;gt; 0 { left-- } else { ans++ } } return left + ans } 复杂度分析 时间复杂度：O(n)，其中 n 是字符串的长度。遍历字符串一次。 空间复杂度：O(1)。只需要维护常量的额外空间。 LeetCode题库地址 https://leetcode.</description></item><item><title>【2022-10-03每日一题】1784. 检查二进制字符串字段[Easy]</title><link>/study/leetcode/check-if-binary-string-has-at-most-one-segment-of-ones/</link><pubDate>Mon, 03 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/check-if-binary-string-has-at-most-one-segment-of-ones/</guid><description>2022-10-03每日一题：1784. 检查二进制字符串字段 难度：Easy
标签：字符串
给你一个二进制字符串 s ，该字符串 不含前导零 。
如果 s 包含 零个或一个由连续的 '1' 组成的字段 ，返回 true​​​ 。否则，返回 false 。
如果 s&amp;nbsp;中&amp;nbsp;由连续若干个&amp;nbsp;'1' 组成的字段&amp;nbsp;数量不超过 1，返回 true​​​ 。否则，返回 false 。
&amp;nbsp;
示例 1：
输入：s = "1001" 输出：false 解释：由连续若干个&amp;nbsp;'1' 组成的字段数量为 2，返回 false 示例 2：
输入：s = "110" 输出：true &amp;nbsp;
提示：
1 &amp;lt;= s.length &amp;lt;= 100 s[i]​​​​ 为 '0' 或 '1' s[0] 为 '1' 方法一： 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
思路与算法 题目给定一个长度为 n 的二进制字符串 s，并满足该字符串不含前导零。现在我们需要判断字符串中是否只包含零个或一个由连续 1 组成的字段。首先我们依次分析这两种情况：
字符串 s 中包含零个由连续 1 组成的字段，那么整个串的表示为 00⋯00。 字符串 s 中只包含一个由连续 1 组成的字段，因为已知字符串 s 不包含前导零，所以整个串的表示为 1⋯100⋯00。 那么可以看到两种情况中都不包含 01 串。且不包含的 01 串的一个二进制字符串也有且仅有上面两种情况。所以我们可以通过原字符串中是否有 01 串来判断字符串中是否只包含零个或一个由连续 1 组成的字段。如果有 01 串则说明该情况不满足，否则即满足该情况条件。</description></item><item><title>【2022-10-02每日一题】777. 在LR字符串中交换相邻字符[Medium]</title><link>/study/leetcode/swap-adjacent-in-lr-string/</link><pubDate>Sun, 02 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/swap-adjacent-in-lr-string/</guid><description>2022-10-02每日一题：777. 在LR字符串中交换相邻字符 难度：Medium
标签：双指针 、 字符串
在一个由 &amp;#39;L&amp;#39; , &amp;#39;R&amp;#39; 和 &amp;#39;X&amp;#39; 三个字符组成的字符串（例如&amp;quot;RXXLRXRXL&amp;quot;）中进行移动操作。一次移动操作指用一个&amp;quot;LX&amp;quot;替换一个&amp;quot;XL&amp;quot;，或者用一个&amp;quot;XR&amp;quot;替换一个&amp;quot;RX&amp;quot;。现给定起始字符串start和结束字符串end，请编写代码，当且仅当存在一系列移动操作使得start可以转换成end时， 返回True。
&amp;nbsp;
示例 :
输入: start = &amp;quot;RXXLRXRXL&amp;quot;, end = &amp;quot;XRLXXRRLX&amp;quot; 输出: True 解释: 我们可以通过以下几步将start转换成end: RXXLRXRXL -&amp;gt; XRXLRXRXL -&amp;gt; XRLXRXRXL -&amp;gt; XRLXXRRXL -&amp;gt; XRLXXRRLX &amp;nbsp;
提示：
1 &amp;lt;= len(start) = len(end) &amp;lt;= 10000。 start和end中的字符串仅限于&amp;#39;L&amp;#39;, &amp;#39;R&amp;#39;和&amp;#39;X&amp;#39;。 方法一： 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
每次移动操作将 “XL&amp;quot; 替换成 “LX&amp;quot;，或将 “RX&amp;quot; 替换成“XR&amp;quot;，等价于如下操作：
如果一个字符 ‘L’ 左侧的相邻字符是 ‘X’，则将字符 ‘L’ 向左移动一位，将其左侧的 ‘X’ 向右移动一位；
如果一个字符 ‘R’ 右侧的相邻字符是 ‘X’，则将字符 ‘R’ 向右移动一位，将其右侧的 ‘X’ 向左移动一位。
// 写法一 func canTransform(start, end string) bool { i, j, n := 0, 0, len(start) for i &amp;lt; n &amp;amp;&amp;amp; j &amp;lt; n { for i &amp;lt; n &amp;amp;&amp;amp; start[i] == 'X' { i++ } for j &amp;lt; n &amp;amp;&amp;amp; end[j] == 'X' { j++ } if i &amp;lt; n &amp;amp;&amp;amp; j &amp;lt; n { if start[i] !</description></item><item><title>【2022-10-01每日一题】1694. 重新格式化电话号码[Easy]</title><link>/study/leetcode/reformat-phone-number/</link><pubDate>Sat, 01 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/reformat-phone-number/</guid><description>2022-10-01每日一题：1694. 重新格式化电话号码 难度：Easy
标签：字符串
给你一个字符串形式的电话号码 number 。number 由数字、空格 ' '、和破折号 '-' 组成。
请你按下述方式重新格式化电话号码。
首先，删除 所有的空格和破折号。 其次，将数组从左到右 每 3 个一组 分块，直到 剩下 4 个或更少数字。剩下的数字将按下述规定再分块： 2 个数字：单个含 2 个数字的块。 3 个数字：单个含 3 个数字的块。 4 个数字：两个分别含 2 个数字的块。 最后用破折号将这些块连接起来。注意，重新格式化过程中 不应该 生成仅含 1 个数字的块，并且 最多 生成两个含 2 个数字的块。
返回格式化后的电话号码。
示例 1：
输入：number = "1-23-45 6" 输出："123-456" 解释：数字是 "123456" 步骤 1：共有超过 4 个数字，所以先取 3 个数字分为一组。第 1 个块是 "123" 。 步骤 2：剩下 3 个数字，将它们放入单个含 3 个数字的块。第 2 个块是 "456" 。 连接这些块后得到 "</description></item><item><title>【2022-09-30每日一题】面试题 01.08. 零矩阵[Medium]</title><link>/study/leetcode/zero-matrix-lcci/</link><pubDate>Fri, 30 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/zero-matrix-lcci/</guid><description>2022-09-30每日一题：面试题 01.08. 零矩阵 难度：Medium
标签：数组 、 哈希表 、 矩阵
编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。
&amp;nbsp;
示例 1：
输入： [ [1,1,1], [1,0,1], [1,1,1] ] 输出： [ [1,0,1], [0,0,0], [1,0,1] ] 示例 2：
输入： [ [0,1,2,0], [3,4,5,2], [1,3,1,5] ] 输出： [ [0,0,0,0], [0,4,5,0], [0,3,1,0] ] 方法一：自己思路 func setZeroes(matrix [][]int) { queue := [][]int{} // 找到所有为0的坐标 for i, row := range matrix { for j, x := range row { if x == 0 { queue = append(queue, []int{i, j}) } } } // 遍历所有为0的坐标，分别处理对应的行和列，这里可能重复处理同一行和同一列，没有去重 for _, q := range queue { i, j := q[0], q[1] for k := range matrix[i] { matrix[i][k] = 0 } for k := range matrix { matrix[k][j] = 0 } } } 复杂度分析 时间复杂度：O(mn) 空间复杂度：O(mn) 方法二：使用两个标记数组 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读</description></item><item><title>【2022-09-29每日一题】面试题 01.09. 字符串轮转[Easy]</title><link>/study/leetcode/string-rotation-lcci/</link><pubDate>Thu, 29 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/string-rotation-lcci/</guid><description>2022-09-29每日一题：面试题 01.09. 字符串轮转 难度：Easy
标签：字符串 、 字符串匹配
字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。
示例1:
输入：s1 = &amp;quot;waterbottle&amp;quot;, s2 = &amp;quot;erbottlewat&amp;quot; 输出：True 示例2:
输入：s1 = &amp;quot;aa&amp;quot;, s2 = &amp;quot;aba&amp;quot; 输出：False 提示：
字符串长度在[0, 100000]范围内。 说明:
你能只调用一次检查子串的方法吗？ 方法一：模拟 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
func isFlipedString(s1 string, s2 string) bool { n := len(s1) if n != len(s2) { return false } if n == 0 { return true } next: for i := 0; i &amp;lt; n; i++ { for j := 0; j &amp;lt; n; j++ { if s1[(i+j)%n] !</description></item><item><title>【2022-09-28每日一题】面试题 17.09. 第 k 个数[Medium]</title><link>/study/leetcode/get-kth-magic-number-lcci/</link><pubDate>Wed, 28 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/get-kth-magic-number-lcci/</guid><description>2022-09-28每日一题：面试题 17.09. 第 k 个数 难度：Medium
标签：哈希表 、 数学 、 动态规划 、 堆（优先队列）
有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。
示例 1:
输入: k = 5 输出: 9 方法一：堆（优先队列） // 小顶堆 type hp struct { sort.IntSlice } func (h hp) Less(i, j int) bool { return h.IntSlice[i] &amp;lt; h.IntSlice[j] } func (h *hp) Push(v interface{}) {h.IntSlice = append(h.IntSlice, v.(int))} func (h *hp) Pop() (v interface{}) { v, h.IntSlice = h.IntSlice[h.Len()-1], h.IntSlice[:h.Len()-1]; return v} var factors = []int{3, 5, 7} func getKthMagicNumber(k int) int { h := hp{sort.</description></item><item><title>【2022-09-27每日一题】面试题 01.02. 判定是否互为字符重排[Easy]</title><link>/study/leetcode/check-permutation-lcci/</link><pubDate>Tue, 27 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/check-permutation-lcci/</guid><description>2022-09-27每日一题：面试题 01.02. 判定是否互为字符重排 难度：Easy
标签：哈希表 、 字符串 、 排序
给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。
示例 1：
输入: s1 = &amp;quot;abc&amp;quot;, s2 = &amp;quot;bca&amp;quot; 输出: true 示例 2：
输入: s1 = &amp;quot;abc&amp;quot;, s2 = &amp;quot;bad&amp;quot; 输出: false 说明：
0 &amp;lt;= len(s1) &amp;lt;= 100 0 &amp;lt;= len(s2) &amp;lt;= 100 方法一：排序 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
func CheckPermutation(s1 string, s2 string) bool { b1, b2 := []byte(s1), []byte(s2) sort.Slice(b1, func(i, j int) bool {return b1[i] &amp;lt; b1[j]}) sort.Slice(b2, func(i, j int) bool {return b2[i] &amp;lt; b2[j]}) // return reflect.</description></item><item><title>【2022-09-26每日一题】面试题 17.19. 消失的两个数字[Hard]</title><link>/study/leetcode/missing-two-lcci/</link><pubDate>Mon, 26 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/missing-two-lcci/</guid><description>2022-09-26每日一题：面试题 17.19. 消失的两个数字 难度：Hard
标签：位运算 、 数组 、 哈希表
给定一个数组，包含从 1 到 N 所有的整数，但其中缺了两个数字。你能在 O(N) 时间内只用 O(1) 的空间找到它们吗？
以任意顺序返回这两个数字均可。
示例 1:
输入: [1] 输出: [2,3] 示例 2:
输入: [2,3] 输出: [1,4] 提示：
nums.length &amp;lt;=&amp;nbsp;30000 方法一：位运算 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
func missingTwo(nums []int) []int { xorNum, n := 0, len(nums) + 2 for _, num := range nums { xorNum ^= num } for i := 1; i &amp;lt;= n; i++ { xorNum ^= i } lsb := xorNum &amp;amp; -xorNum type1, type2 := 0, 0 for _, num := range nums { if lsb &amp;amp; num &amp;gt; 0 { type1 ^= num } else { type2 ^= num } } for i := 1; i &amp;lt;= n; i++ { if lsb &amp;amp; i &amp;gt; 0 { type1 ^= i } else { type2 ^= i } } return []int{type1, type2} } 复杂度分析 时间复杂度：O(n)，其中 n 是最大的整数。需要遍历的数字有 2n−2 个，共遍历两次。 空间复杂度：O(1)。 方法二：数学 数学家小高斯巧解一加到一百的故事 思路1 思路2 func missingTwo(nums []int) []int { n := len(nums) + 2 cur := n * (n + 1) / 2 // 计算n个数的和 for _, num := range nums { cur -= num // 最终得到两个缺失数的和 } // 根据补全后数值各不相同可知，两者必不可能同时位于t的同一侧 sum, t := cur, cur/2 cur = t * (t + 1) / 2 // 计算1.</description></item><item><title>【2022-09-25每日一题】788. 旋转数字[Medium]</title><link>/study/leetcode/rotated-digits/</link><pubDate>Sun, 25 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/rotated-digits/</guid><description>2022-09-25每日一题：788. 旋转数字 难度：Medium
标签：数学 、 动态规划
我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。
如果一个数的每位数字被旋转以后仍然还是一个数字，&amp;nbsp;则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方（在这种情况下，它们以不同的方向旋转，换句话说，2 和 5 互为镜像）；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。
现在我们有一个正整数&amp;nbsp;N, 计算从&amp;nbsp;1 到&amp;nbsp;N 中有多少个数&amp;nbsp;X 是好数？
&amp;nbsp;
示例：
输入: 10 输出: 4 解释: 在[1, 10]中有四个好数： 2, 5, 6, 9。 注意 1 和 10 不是好数, 因为他们在旋转之后不变。 &amp;nbsp;
提示：
N&amp;nbsp;的取值范围是&amp;nbsp;[1, 10000]。 方法一：枚举 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
官方check数组法 // 写法一： // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 var check = []int{0, 0, 1,-1,-1, 1, 1,-1, 0, 1} // 反转后0代码原样, 1有对应数字，-1 无效 func rotatedDigits(n int) (ans int) { for i := 1; i &amp;lt;= n; i++ { s := strconv.</description></item><item><title>【2022-09-24每日一题】1652. 拆炸弹[Easy]</title><link>/study/leetcode/defuse-the-bomb/</link><pubDate>Sat, 24 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/defuse-the-bomb/</guid><description>2022-09-24每日一题：1652. 拆炸弹 难度：Easy
标签：数组
你有一个炸弹需要拆除，时间紧迫！你的情报员会给你一个长度为 n 的 循环 数组 code 以及一个密钥 k 。
为了获得正确的密码，你需要替换掉每一个数字。所有数字会 同时 被替换。
如果 k > 0 ，将第 i 个数字用 接下来 k 个数字之和替换。 如果 k &lt; 0 ，将第 i 个数字用 之前 k 个数字之和替换。 如果 k == 0 ，将第 i 个数字用 0 替换。 由于 code 是循环的， code[n-1] 下一个元素是 code[0] ，且 code[0] 前一个元素是 code[n-1] 。
给你 循环 数组 code 和整数密钥 k ，请你返回解密后的结果来拆除炸弹！
示例 1：
输入：code = [5,7,1,4], k = 3 输出：[12,10,16,13] 解释：每个数字都被接下来 3 个数字之和替换。解密后的密码为 [7+1+4, 1+4+5, 4+5+7, 5+7+1]。注意到数组是循环连接的。 示例 2：</description></item><item><title>【2022-09-23每日一题】707. 设计链表[Medium]</title><link>/study/leetcode/design-linked-list/</link><pubDate>Fri, 23 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/design-linked-list/</guid><description>2022-09-23每日一题：707. 设计链表 难度：Medium
标签：设计 、 链表
设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val&amp;nbsp;和&amp;nbsp;next。val&amp;nbsp;是当前节点的值，next&amp;nbsp;是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性&amp;nbsp;prev&amp;nbsp;以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。
在链表类中实现这些功能：
get(index)：获取链表中第&amp;nbsp;index&amp;nbsp;个节点的值。如果索引无效，则返回-1。 addAtHead(val)：在链表的第一个元素之前添加一个值为&amp;nbsp;val&amp;nbsp;的节点。插入后，新节点将成为链表的第一个节点。 addAtTail(val)：将值为&amp;nbsp;val 的节点追加到链表的最后一个元素。 addAtIndex(index,val)：在链表中的第&amp;nbsp;index&amp;nbsp;个节点之前添加值为&amp;nbsp;val&amp;nbsp; 的节点。如果&amp;nbsp;index&amp;nbsp;等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。 deleteAtIndex(index)：如果索引&amp;nbsp;index 有效，则删除链表中的第&amp;nbsp;index 个节点。 &amp;nbsp;
示例：
MyLinkedList linkedList = new MyLinkedList(); linkedList.addAtHead(1); linkedList.addAtTail(3); linkedList.addAtIndex(1,2); //链表变为1-&amp;gt; 2-&amp;gt; 3 linkedList.get(1); //返回2 linkedList.deleteAtIndex(1); //现在链表是1-&amp;gt; 3 linkedList.get(1); //返回3 &amp;nbsp;
提示：
所有val值都在&amp;nbsp;[1, 1000]&amp;nbsp;之内。 操作次数将在&amp;nbsp;&amp;nbsp;[1, 1000]&amp;nbsp;之内。 请不要使用内置的 LinkedList 库。 方法一：单向链表 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
type MyLinkedList struct { head *ListNode count int } func Constructor() MyLinkedList { return MyLinkedList{&amp;amp;ListNode{}, 0} } func (this *MyLinkedList) Get(index int) int { // 获取链表中第 index 个节点的值。如果索引无效，则返回-1。 if index &amp;lt; 0 || index &amp;gt;= this.</description></item><item><title>【2022-09-22每日一题】1640. 能否连接形成数组[Easy]</title><link>/study/leetcode/check-array-formation-through-concatenation/</link><pubDate>Thu, 22 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/check-array-formation-through-concatenation/</guid><description>2022-09-22每日一题：1640. 能否连接形成数组 难度：Easy
标签：数组 、 哈希表
给你一个整数数组 arr ，数组中的每个整数 互不相同 。另有一个由整数数组构成的数组 pieces，其中的整数也 互不相同 。请你以 任意顺序 连接 pieces 中的数组以形成 arr 。但是，不允许 对每个数组 pieces[i] 中的整数重新排序。
如果可以连接 pieces 中的数组形成 arr ，返回 true ；否则，返回 false 。
&amp;nbsp;
示例 1：
输入：arr = [15,88], pieces = [[88],[15]] 输出：true 解释：依次连接 [15] 和 [88] 示例 2：
输入：arr = [49,18,16], pieces = [[16,18,49]] 输出：false 解释：即便数字相符，也不能重新排列 pieces[0] 示例 3：
输入：arr = [91,4,64,78], pieces = [[78],[4,64],[91]] 输出：true 解释：依次连接 [91]、[4,64] 和 [78] &amp;nbsp;
提示：
1 &amp;lt;= pieces.length &amp;lt;= arr.</description></item><item><title>【2022-09-21每日一题】854. 相似度为 K 的字符串[Hard]</title><link>/study/leetcode/k-similar-strings/</link><pubDate>Wed, 21 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/k-similar-strings/</guid><description>2022-09-21每日一题：854. 相似度为 K 的字符串 难度：Hard
标签：广度优先搜索 、 字符串
对于某些非负整数 k ，如果交换 s1 中两个字母的位置恰好 k 次，能够使结果字符串等于 s2 ，则认为字符串 s1 和 s2 的 相似度为 k 。
给你两个字母异位词 s1 和 s2 ，返回 s1 和 s2 的相似度 k 的最小值。
&amp;nbsp;
示例 1：
输入：s1 = "ab", s2 = "ba" 输出：1 示例 2：
输入：s1 = "abc", s2 = "bca" 输出：2 &amp;nbsp;
提示：
1 &amp;lt;= s1.length &amp;lt;= 20 s2.length == s1.length s1&amp;nbsp;和&amp;nbsp;s2&amp;nbsp;&amp;nbsp;只包含集合&amp;nbsp;{'a', 'b', 'c', 'd', 'e', 'f'}&amp;nbsp;中的小写字母 s2 是 s1 的一个字母异位词 方法一：广度优先搜索 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读</description></item><item><title>【2022-09-20每日一题】698. 划分为k个相等的子集</title><link>/study/leetcode/partition-to-k-equal-sum-subsets/</link><pubDate>Tue, 20 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/partition-to-k-equal-sum-subsets/</guid><description>2022-09-20每日一题：698. 划分为k个相等的子集 难度：Medium
标签：位运算 、 记忆化搜索 、 数组 、 动态规划 、 回溯 、 状态压缩
给定一个整数数组&amp;nbsp;&amp;nbsp;nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。
&amp;nbsp;
示例 1：
输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4 输出： True 说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。 示例 2:
输入: nums = [1,2,3,4], k = 3 输出: false &amp;nbsp;
提示：
1 &amp;lt;= k &amp;lt;= len(nums) &amp;lt;= 16 0 &amp;lt; nums[i] &amp;lt; 10000 每个元素的频率在 [1,4] 范围内 方法一：状态压缩 + 记忆化搜索 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
思路与算法 func canPartitionKSubsets(nums []int, k int) bool { all := 0 for _, num := range nums { all += num } // 不能整除 if all%k &amp;gt; 0 { return false } sort.</description></item><item><title>【2022-09-19每日一题】1636. 按照频率将数组升序排序</title><link>/study/leetcode/sort-array-by-increasing-frequency/</link><pubDate>Mon, 19 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/sort-array-by-increasing-frequency/</guid><description>2022-09-19每日一题：1636. 按照频率将数组升序排序 难度：Easy
标签：数组 、 哈希表 、 排序
给你一个整数数组 nums ，请你将数组按照每个值的频率 升序 排序。如果有多个值的频率相同，请你按照数值本身将它们 降序 排序。 请你返回排序后的数组。
示例 1：
输入：nums = [1,1,2,2,2,3] 输出：[3,1,1,2,2,2] 解释：'3' 频率为 1，'1' 频率为 2，'2' 频率为 3 。 示例 2：
输入：nums = [2,3,1,3,2] 输出：[1,3,3,2,2] 解释：'2' 和 '3' 频率都为 2 ，所以它们之间按照数值本身降序排序。 示例 3：
输入：nums = [-1,1,-6,4,5,-6,1,4,1] 输出：[5,-1,4,4,-6,-6,1,1,1] 提示：
1 &amp;lt;= nums.length &amp;lt;= 100 -100 &amp;lt;= nums[i] &amp;lt;= 100 方法一：模拟 func frequencySort(nums []int) []int { mp := make(map[int]int) for _, num := range nums { mp[num]++ } slice := make([][2]int, 0, len(mp)) for num, count := range mp { slice = append(slice, [2]int{count, num}) } sort.</description></item><item><title>【2022-09-18每日一题】827. 最大人工岛</title><link>/study/leetcode/making-a-large-island/</link><pubDate>Sun, 18 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/making-a-large-island/</guid><description>2022-09-18每日一题：827. 最大人工岛 难度：Hard
标签：深度优先搜索 、 广度优先搜索 、 并查集 、 数组 、 矩阵
给你一个大小为 n x n 二进制矩阵 grid 。最多 只能将一格 0 变成 1 。
返回执行此操作后，grid 中最大的岛屿面积是多少？
岛屿 由一组上、下、左、右四个方向相连的 1 形成。
示例 1:
输入: grid = [[1, 0], [0, 1]] 输出: 3 解释: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。 示例 2:
输入: grid = [[1, 1], [1, 0]] 输出: 4 解释: 将一格0变成1，岛屿的面积扩大为 4。 示例 3:
输入: grid = [[1, 1], [1, 1]] 输出: 4 解释: 没有0可以让我们变成1，面积依然为 4。 提示：
n == grid.</description></item><item><title>【2022-09-17每日一题】1624. 两个相同字符之间的最长子字符串</title><link>/study/leetcode/largest-substring-between-two-equal-characters/</link><pubDate>Sat, 17 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/largest-substring-between-two-equal-characters/</guid><description>2022-09-17每日一题：1624. 两个相同字符之间的最长子字符串 难度：Easy 标签：哈希表 、 字符串 给你一个字符串 s，请你返回 两个相同字符之间的最长子字符串的长度 ，计算长度时不含这两个字符。如果不存在这样的子字符串，返回 -1 。
子字符串 是字符串中的一个连续字符序列。
示例 1：
输入：s = "aa" 输出：0 解释：最优的子字符串是两个 'a' 之间的空子字符串。 示例 2：
输入：s = "abca" 输出：2 解释：最优的子字符串是 "bc" 。 示例 3：
输入：s = "cbzxy" 输出：-1 解释：s 中不存在出现出现两次的字符，所以返回 -1 。 示例 4：
输入：s = "cabbac" 输出：4 解释：最优的子字符串是 "abba" ，其他的非最优解包括 "bb" 和 "" 。 提示：
1 &amp;lt;= s.length &amp;lt;= 300 s 只含小写英文字母 方法一：哈希表 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
直接使用map func maxLengthBetweenEqualCharacters(s string) int { mp, ans := make(map[rune]int), -1 for i, c := range s { if j, ok := mp[c]; ok { ans = max(ans, i - j -1) } else { mp[c] = i } } return ans } func max(a, b int) int { if a &amp;gt; b { return a } return b } 复杂度分析 时间复杂度：O(n)，其中 n 表示字符串的长度。我们只需遍历一遍字符串即可。</description></item><item><title>【2022-09-16每日一题】850. 矩形面积 II</title><link>/study/leetcode/rectangle-area-ii/</link><pubDate>Fri, 16 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/rectangle-area-ii/</guid><description>2022-09-16每日一题：850. 矩形面积 II 难度：Hard 标签：线段树 、 数组 、 有序集合 、 扫描线 我们给出了一个（轴对齐的）二维矩形列表&amp;nbsp;rectangles&amp;nbsp;。 对于&amp;nbsp;rectangle[i] = [x1, y1, x2, y2]，其中（x1，y1）是矩形&amp;nbsp;i&amp;nbsp;左下角的坐标，&amp;nbsp;(xi1, yi1)&amp;nbsp;是该矩形 左下角 的坐标，&amp;nbsp;(xi2, yi2)&amp;nbsp;是该矩形&amp;nbsp;右上角 的坐标。
计算平面中所有&amp;nbsp;rectangles&amp;nbsp;所覆盖的 总面积 。任何被两个或多个矩形覆盖的区域应只计算 一次 。
返回 总面积 。因为答案可能太大，返回&amp;nbsp;109&amp;nbsp;+ 7 的&amp;nbsp;模&amp;nbsp;。
&amp;nbsp;
示例 1：
输入：rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]] 输出：6 解释：如图所示，三个矩形覆盖了总面积为6的区域。 从(1,1)到(2,2)，绿色矩形和红色矩形重叠。 从(1,0)到(2,3)，三个矩形都重叠。 示例 2：
输入：rectangles = [[0,0,1000000000,1000000000]] 输出：49 解释：答案是 1018 对 (109 + 7) 取模的结果， 即 49 。 &amp;nbsp;
提示：
1 &amp;lt;= rectangles.length &amp;lt;= 200 rectanges[i].length = 4 0 &amp;lt;= xi1, yi1, xi2, yi2&amp;nbsp;&amp;lt;= 109 矩形叠加覆盖后的总面积不会超越&amp;nbsp;2^63 - 1&amp;nbsp;，这意味着可以用一个&amp;nbsp;64 位有符号整数来保存面积结果。 方法一： 详细思路过程见宫水三叶题解，这里只做个人刷题记录，方便后续查询阅读</description></item><item><title>【2022-09-15每日一题】672. 灯泡开关 Ⅱ</title><link>/study/leetcode/bulb-switcher-ii/</link><pubDate>Thu, 15 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/bulb-switcher-ii/</guid><description>2022-09-15每日一题：672. 灯泡开关 Ⅱ 难度：Medium 标签：位运算 、 深度优先搜索 、 广度优先搜索 、 数学 房间中有 n&amp;nbsp;只已经打开的灯泡，编号从 1 到 n 。墙上挂着 4 个开关 。
这 4 个开关各自都具有不同的功能，其中：
开关 1 ：反转当前所有灯的状态（即开变为关，关变为开） 开关 2 ：反转编号为偶数的灯的状态（即 2, 4, ...） 开关 3 ：反转编号为奇数的灯的状态（即 1, 3, ...） 开关 4 ：反转编号为 j = 3k + 1 的灯的状态，其中 k = 0, 1, 2, ...（即 1, 4, 7, 10, ...） 你必须 恰好 按压开关 presses 次。每次按压，你都需要从 4 个开关中选出一个来执行按压操作。
给你两个整数 n 和 presses ，执行完所有按压之后，返回 不同可能状态 的数量。
示例 1：
输入：n = 1, presses = 1 输出：2 解释：状态可以是： - 按压开关 1 ，[关] - 按压开关 2 ，[开] 示例 2：</description></item><item><title>【2022-09-14每日一题】1619. 删除某些元素后的数组均值</title><link>/study/leetcode/mean-of-array-after-removing-some-elements/</link><pubDate>Wed, 14 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/mean-of-array-after-removing-some-elements/</guid><description>2022-09-14每日一题：1619. 删除某些元素后的数组均值 难度：Easy 标签：数组 、 排序 给你一个整数数组 arr ，请你删除最小 5% 的数字和最大 5% 的数字后，剩余数字的平均值。
与 标准答案 误差在 10-5 的结果都被视为正确结果。
示例 1：
输入：arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3] 输出：2.00000 解释：删除数组中最大和最小的元素后，所有元素都等于 2，所以平均值为 2 。 示例 2：
输入：arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0] 输出：4.00000 示例 3：
输入：arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4] 输出：4.77778 示例 4：
输入：arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3] 输出：5.27778 示例 5：
输入：arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1] 输出：5.29167 提示：
20 &lt;= arr.length &lt;= 1000 arr.length 是 20 的 倍数 0 &lt;= arr[i] &lt;= 105 ### 方法一：排序 func trimMean(arr []int) float64 { sort.</description></item><item><title>【2022-09-13每日一题】670. 最大交换</title><link>/study/leetcode/maximum-swap/</link><pubDate>Tue, 13 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximum-swap/</guid><description>2022-09-13每日一题：670. 最大交换 难度：Medium 标签：贪心 、 数学 给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。
示例 1 :
输入: 2736 输出: 7236 解释: 交换数字2和数字7。 示例 2 :
输入: 9973 输出: 9973 解释: 不需要交换。 注意:
给定数字的范围是&amp;nbsp;[0, 108] ### 方法一：暴力枚举 func maximumSwap(num int) int { ans := num s := []byte(strconv.Itoa(num)) for i := range s { for j := range s[:i] { s[i], s[j] = s[j], s[i] v, _ := strconv.Atoi(string(s)) ans = max(ans, v) s[i], s[j] = s[j], s[i] // 还原 } } return ans } func max(a, b int) int { if a &amp;gt; b { return a } return b } 复杂度分析 时间复杂度：O(log^3*num) 空间复杂度：O(lognum) 方法二：贪心 解题思路 func maximumSwap(num int) int { nums := []byte(strconv.</description></item><item><title>【2022-09-12每日一题】1608. 特殊数组的特征值</title><link>/study/leetcode/special-array-with-x-elements-greater-than-or-equal-x/</link><pubDate>Mon, 12 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/special-array-with-x-elements-greater-than-or-equal-x/</guid><description>2022-09-12每日一题：1608. 特殊数组的特征值 难度：Easy 标签：数组 、 二分查找 、 排序 给你一个非负整数数组 nums 。如果存在一个数 x ，使得 nums 中恰好有 x 个元素 大于或者等于 x ，那么就称 nums 是一个 特殊数组 ，而 x 是该数组的 特征值 。
注意： x 不必 是 nums 的中的元素。
如果数组 nums 是一个 特殊数组 ，请返回它的特征值 x 。否则，返回 -1 。可以证明的是，如果 nums 是特殊数组，那么其特征值 x 是 唯一的 。
&amp;nbsp;
示例 1：
输入：nums = [3,5] 输出：2 解释：有 2 个元素（3 和 5）大于或等于 2 。 示例 2：
输入：nums = [0,0] 输出：-1 解释：没有满足题目要求的特殊数组，故而也不存在特征值 x 。 如果 x = 0，应该有 0 个元素 &amp;gt;= x，但实际有 2 个。 如果 x = 1，应该有 1 个元素 &amp;gt;= x，但实际有 0 个。 如果 x = 2，应该有 2 个元素 &amp;gt;= x，但实际有 0 个。 x 不能取更大的值，因为 nums 中只有两个元素。 示例 3：</description></item><item><title>【2022-09-11每日一题】：857. 雇佣 K 名工人的最低成本</title><link>/study/leetcode/minimum-cost-to-hire-k-workers/</link><pubDate>Sun, 11 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/minimum-cost-to-hire-k-workers/</guid><description>2022-09-11每日一题：857. 雇佣 K 名工人的最低成本 难度：Hard 标签：贪心 、 数组 、 排序 、 堆（优先队列） 有 n&amp;nbsp;名工人。&amp;nbsp;给定两个数组&amp;nbsp;quality&amp;nbsp;和&amp;nbsp;wage&amp;nbsp;，其中，quality[i]&amp;nbsp;表示第&amp;nbsp;i&amp;nbsp;名工人的工作质量，其最低期望工资为&amp;nbsp;wage[i]&amp;nbsp;。
现在我们想雇佣&amp;nbsp;k&amp;nbsp;名工人组成一个工资组。在雇佣&amp;nbsp;一组 k&amp;nbsp;名工人时，我们必须按照下述规则向他们支付工资：
对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资。 工资组中的每名工人至少应当得到他们的最低期望工资。 给定整数 k ，返回 组成满足上述条件的付费群体所需的最小金额&amp;nbsp;。在实际答案的&amp;nbsp;10-5&amp;nbsp;以内的答案将被接受。。
&amp;nbsp;
示例 1：
输入： quality = [10,20,5], wage = [70,50,30], k = 2 输出： 105.00000 解释： 我们向 0 号工人支付 70，向 2 号工人支付 35。 示例 2：
输入： quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3 输出： 30.66667 解释： 我们向 0 号工人支付 4，向 2 号和 3 号分别支付 13.33333。 &amp;nbsp;
提示：
n == quality.length == wage.</description></item><item><title>【2022-09-10每日一题】669. 修剪二叉搜索树</title><link>/study/leetcode/trim-a-binary-search-tree/</link><pubDate>Sat, 10 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/trim-a-binary-search-tree/</guid><description>2022-09-10每日一题：669. 修剪二叉搜索树 难度：Medium 标签：树 、 深度优先搜索 、 二叉搜索树 、 二叉树 给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该&amp;nbsp;改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在&amp;nbsp;唯一的答案&amp;nbsp;。
所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。
&amp;nbsp;
示例 1：
输入：root = [1,0,2], low = 1, high = 2 输出：[1,null,2] 示例 2：
输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3 输出：[3,2,null,1] &amp;nbsp;
提示：
树中节点数在范围 [1, 104] 内 0 &amp;lt;= Node.val &amp;lt;= 104 树中每个节点的值都是 唯一 的 题目数据保证输入是一棵有效的二叉搜索树 0 &amp;lt;= low &amp;lt;= high &amp;lt;= 104 ### 方法一：递归 /** * Definition for a binary tree node.</description></item><item><title>【2022-09-09每日一题】1598. 文件夹操作日志搜集器</title><link>/study/leetcode/crawler-log-folder/</link><pubDate>Fri, 09 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/crawler-log-folder/</guid><description>2022-09-09每日一题：1598. 文件夹操作日志搜集器 难度：Easy 标签：栈 、 数组 、 字符串 每当用户执行变更文件夹操作时，LeetCode 文件系统都会保存一条日志记录。
下面给出对变更操作的说明：
&amp;quot;../&amp;quot; ：移动到当前文件夹的父文件夹。如果已经在主文件夹下，则 继续停留在当前文件夹 。 &amp;quot;./&amp;quot; ：继续停留在当前文件夹。 &amp;quot;x/&amp;quot; ：移动到名为 x 的子文件夹中。题目数据 保证总是存在文件夹 x 。 给你一个字符串列表 logs ，其中 logs[i] 是用户在 ith 步执行的操作。
文件系统启动时位于主文件夹，然后执行 logs 中的操作。
执行完所有变更文件夹操作后，请你找出 返回主文件夹所需的最小步数 。
&amp;nbsp;
示例 1：
输入：logs = [&amp;quot;d1/&amp;quot;,&amp;quot;d2/&amp;quot;,&amp;quot;../&amp;quot;,&amp;quot;d21/&amp;quot;,&amp;quot;./&amp;quot;] 输出：2 解释：执行 &amp;quot;../&amp;quot; 操作变更文件夹 2 次，即可回到主文件夹 示例 2：
输入：logs = [&amp;quot;d1/&amp;quot;,&amp;quot;d2/&amp;quot;,&amp;quot;./&amp;quot;,&amp;quot;d3/&amp;quot;,&amp;quot;../&amp;quot;,&amp;quot;d31/&amp;quot;] 输出：3 示例 3：
输入：logs = [&amp;quot;d1/&amp;quot;,&amp;quot;../&amp;quot;,&amp;quot;../&amp;quot;,&amp;quot;../&amp;quot;] 输出：0 &amp;nbsp;
提示：
1 &amp;lt;= logs.length &amp;lt;= 103 2 &amp;lt;= logs[i].length &amp;lt;= 10 logs[i] 包含小写英文字母，数字，&amp;#39;.&amp;#39; 和 &amp;#39;/&amp;#39; logs[i] 符合语句中描述的格式 文件夹名称由小写英文字母和数字组成 ### 方法一：用栈模拟过程 func minOperations(logs []string) int { stack := []string{} for _, log := range logs { if log == &amp;quot;.</description></item><item><title>【2022-09-08每日一题】667. 优美的排列 II</title><link>/study/leetcode/beautiful-arrangement-ii/</link><pubDate>Thu, 08 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/beautiful-arrangement-ii/</guid><description>2022-09-08每日一题：667. 优美的排列 II 难度：Medium 标签：数组 、 数学 给你两个整数 n 和 k ，请你构造一个答案列表 answer ，该列表应当包含从 1 到 n 的 n 个不同正整数，并同时满足下述条件：
假设该列表是 answer = [a1, a2, a3, ... , an] ，那么列表 [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] 中应该有且仅有 k 个不同整数。 返回列表 answer 。如果存在多种答案，只需返回其中 任意一种 。
示例 1：
输入：n = 3, k = 1 输出：[1, 2, 3] 解释：[1, 2, 3] 包含 3 个范围在 1-3 的不同整数，并且 [1, 1] 中有且仅有 1 个不同整数：1 示例 2：</description></item><item><title>【2022-09-07每日一题】1592. 重新排列单词间的空格</title><link>/study/leetcode/rearrange-spaces-between-words/</link><pubDate>Wed, 07 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/rearrange-spaces-between-words/</guid><description>2022-09-07每日一题：1592. 重新排列单词间的空格 难度：Easy 标签：字符串 给你一个字符串 text ，该字符串由若干被空格包围的单词组成。每个单词由一个或者多个小写英文字母组成，并且两个单词之间至少存在一个空格。题目测试用例保证 text 至少包含一个单词 。
请你重新排列空格，使每对相邻单词之间的空格数目都 相等 ，并尽可能 最大化 该数目。如果不能重新平均分配所有空格，请 将多余的空格放置在字符串末尾 ，这也意味着返回的字符串应当与原 text 字符串的长度相等。
返回 重新排列空格后的字符串 。
&amp;nbsp;
示例 1：
输入：text = &amp;quot; this is a sentence &amp;quot; 输出：&amp;quot;this is a sentence&amp;quot; 解释：总共有 9 个空格和 4 个单词。可以将 9 个空格平均分配到相邻单词之间，相邻单词间空格数为：9 / (4-1) = 3 个。 示例 2：
输入：text = &amp;quot; practice makes perfect&amp;quot; 输出：&amp;quot;practice makes perfect &amp;quot; 解释：总共有 7 个空格和 3 个单词。7 / (3-1) = 3 个空格加上 1 个多余的空格。多余的空格需要放在字符串的末尾。 示例 3：</description></item><item><title>【2022-09-06每日一题】828. 统计子串中的唯一字符</title><link>/study/leetcode/count-unique-characters-of-all-substrings-of-a-given-string/</link><pubDate>Tue, 06 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/count-unique-characters-of-all-substrings-of-a-given-string/</guid><description>2022-09-06每日一题：828. 统计子串中的唯一字符 难度：Hard 标签：哈希表 、 字符串 、 动态规划 我们定义了一个函数 countUniqueChars(s) 来统计字符串 s 中的唯一字符，并返回唯一字符的个数。
例如：s = "LEETCODE" ，则其中 "L", "T","C","O","D" 都是唯一字符，因为它们只出现一次，所以 countUniqueChars(s) = 5 。
本题将会给你一个字符串 s ，我们需要返回 countUniqueChars(t) 的总和，其中 t 是 s 的子字符串。输入用例保证返回值为&amp;nbsp;32 位整数。
注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 s 的所有子字符串中的唯一字符）。
&amp;nbsp;
示例 1：
输入: s = "ABC" 输出: 10 解释: 所有可能的子串为："A","B","C","AB","BC" 和 "ABC"。 其中，每一个子串都由独特字符构成。 所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10 示例 2：
输入: s = "ABA" 输出: 8 解释: 除了 countUniqueChars("ABA") = 1 之外，其余与示例 1 相同。 示例 3：</description></item><item><title>【2022-09-05每日一题】652. 寻找重复的子树</title><link>/study/leetcode/find-duplicate-subtrees/</link><pubDate>Mon, 05 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/find-duplicate-subtrees/</guid><description>2022-09-05每日一题：652. 寻找重复的子树 难度：Medium 标签：树 、 深度优先搜索 、 哈希表 、 二叉树 给定一棵二叉树 root，返回所有重复的子树。
对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。
如果两棵树具有相同的结构和相同的结点值，则它们是重复的。
&amp;nbsp;
示例 1：
输入：root = [1,2,3,4,null,2,4,null,null,4] 输出：[[2,4],[4]] 示例 2：
输入：root = [2,1,1] 输出：[[1]] 示例 3：
输入：root = [2,2,2,3,null,3,null] 输出：[[2,3],[3]] &amp;nbsp;
提示：
树中的结点数在[1,10^4]范围内。 -200 &amp;lt;= Node.val &amp;lt;= 200 ### 方法一：使用序列化进行唯一表示 个人刷题记录，方便后续复习，具体解析思路请查看官方题解
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func findDuplicateSubtrees(root *TreeNode) []*TreeNode { repeat := map[*TreeNode]struct{}{} seen := map[string]*TreeNode{} var dfs func (*TreeNode) string dfs = func (node *TreeNode) string { if node == nil { return &amp;quot;&amp;quot; } // 序列化构造唯一key serial := fmt.</description></item><item><title>【2022-09-04每日一题】1582. 二进制矩阵中的特殊位置</title><link>/study/leetcode/special-positions-in-a-binary-matrix/</link><pubDate>Sun, 04 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/special-positions-in-a-binary-matrix/</guid><description>2022-09-04每日一题：1582. 二进制矩阵中的特殊位置 难度：Easy 标签：数组 、 矩阵 给你一个大小为 rows x cols 的矩阵 mat，其中 mat[i][j] 是 0 或 1，请返回 矩阵&amp;nbsp;mat 中特殊位置的数目 。
特殊位置 定义：如果 mat[i][j] == 1 并且第 i 行和第 j 列中的所有其他元素均为 0（行和列的下标均 从 0 开始 ），则位置 (i, j) 被称为特殊位置。
&amp;nbsp;
示例 1：
输入：mat = [[1,0,0], &amp;nbsp; [0,0,1], &amp;nbsp; [1,0,0]] 输出：1 解释：(1,2) 是一个特殊位置，因为 mat[1][2] == 1 且所处的行和列上所有其他元素都是 0 示例 2：
输入：mat = [[1,0,0], &amp;nbsp; [0,1,0], &amp;nbsp; [0,0,1]] 输出：3 解释：(0,0), (1,1) 和 (2,2) 都是特殊位置 示例 3：
输入：mat = [[0,0,0,1], &amp;nbsp; [1,0,0,0], &amp;nbsp; [0,1,1,0], &amp;nbsp; [0,0,0,0]] 输出：2 示例 4：</description></item><item><title>【2022-09-03每日一题】646. 最长数对链</title><link>/study/leetcode/maximum-length-of-pair-chain/</link><pubDate>Sat, 03 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximum-length-of-pair-chain/</guid><description>2022-09-03每日一题：646. 最长数对链 难度：Medium 标签：贪心 、 数组 、 动态规划 、 排序 给出 n 个数对。 在每一个数对中，第一个数字总是比第二个数字小。
现在，我们定义一种跟随关系，当且仅当 b &lt; c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。
给定一个数对集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。
示例：
输入：[[1,2], [2,3], [3,4]] 输出：2 解释：最长的数对链是 [1,2] -> [3,4] 提示：
给出数对的个数在 [1, 1000] 范围内。 ### 方法一：动态规划 func findLongestChain(pairs [][]int) int { sort.Slice(pairs, func(i, j int) bool { return pairs[i][0] &amp;lt; pairs[j][0] }) n := len(pairs) dp := make([]int, n) for i, p := range pairs { dp[i] = 1 // 初始化时，dp 需要全部赋值为 1 for j, q := range pairs[:i] { if p[0] &amp;gt; q[1] { dp[i] = max(dp[i], dp[j] + 1) } } } return dp[n-1] } func max(a, b int) int { if a &amp;gt; b { return a } return b } 复杂度分析 时间复杂度：O(n^2)，其中 n 为 pairs 的长度。排序的时间复杂度为O(nlogn)，两层 for 循环的时间复杂度为 O(n^2)。</description></item><item><title>【2022-09-02每日一题】687. 最长同值路径</title><link>/study/leetcode/longest-univalue-path/</link><pubDate>Fri, 02 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/longest-univalue-path/</guid><description>2022-09-02每日一题：687. 最长同值路径 难度：Medium 标签：树 、 深度优先搜索 、 二叉树 给定一个二叉树的&amp;nbsp;root&amp;nbsp;，返回&amp;nbsp;最长的路径的长度 ，这个路径中的&amp;nbsp;每个节点具有相同值&amp;nbsp;。 这条路径可以经过也可以不经过根节点。
两个节点之间的路径长度&amp;nbsp;由它们之间的边数表示。
&amp;nbsp;
示例 1:
输入：root = [5,4,5,1,1,5] 输出：2 示例 2:
输入：root = [1,4,5,4,4,5] 输出：2 &amp;nbsp;
提示:
树的节点数的范围是&amp;nbsp;[0, 104]&amp;nbsp; -1000 &amp;lt;= Node.val &amp;lt;= 1000 树的深度将不超过 1000&amp;nbsp; ### 方法一：深度优先遍历（递归） /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func longestUnivaluePath(root *TreeNode) (ans int) { var dfs func(*TreeNode) int dfs = func (node *TreeNode) int { if node == nil { return 0 } left, right := dfs(node.</description></item><item><title>【2022-09-01每日一题】1475. 商品折扣后的最终价格</title><link>/study/leetcode/final-prices-with-a-special-discount-in-a-shop/</link><pubDate>Thu, 01 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/final-prices-with-a-special-discount-in-a-shop/</guid><description>2022-09-01每日一题：1475. 商品折扣后的最终价格 难度：Easy 标签：栈 、 数组 、 单调栈 给你一个数组&amp;nbsp;prices&amp;nbsp;，其中&amp;nbsp;prices[i]&amp;nbsp;是商店里第&amp;nbsp;i&amp;nbsp;件商品的价格。
商店里正在进行促销活动，如果你要买第&amp;nbsp;i&amp;nbsp;件商品，那么你可以得到与 prices[j] 相等的折扣，其中&amp;nbsp;j&amp;nbsp;是满足&amp;nbsp;j &amp;gt; i&amp;nbsp;且&amp;nbsp;prices[j] &amp;lt;= prices[i]&amp;nbsp;的&amp;nbsp;最小下标&amp;nbsp;，如果没有满足条件的&amp;nbsp;j&amp;nbsp;，你将没有任何折扣。
请你返回一个数组，数组中第&amp;nbsp;i&amp;nbsp;个元素是折扣后你购买商品 i&amp;nbsp;最终需要支付的价格。
&amp;nbsp;
示例 1：
输入：prices = [8,4,6,2,3] 输出：[4,2,4,2,3] 解释： 商品 0 的价格为 price[0]=8 ，你将得到 prices[1]=4 的折扣，所以最终价格为 8 - 4 = 4 。 商品 1 的价格为 price[1]=4 ，你将得到 prices[3]=2 的折扣，所以最终价格为 4 - 2 = 2 。 商品 2 的价格为 price[2]=6 ，你将得到 prices[3]=2 的折扣，所以最终价格为 6 - 2 = 4 。 商品 3 和 4 都没有折扣。 示例 2：
输入：prices = [1,2,3,4,5] 输出：[1,2,3,4,5] 解释：在这个例子中，所有商品都没有折扣。 示例 3：</description></item><item><title>【2022-08-31每日一题】946. 验证栈序列</title><link>/study/leetcode/validate-stack-sequences/</link><pubDate>Wed, 31 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/validate-stack-sequences/</guid><description>2022-08-31每日一题：946. 验证栈序列 难度：Medium 标签：栈 、 数组 、 模拟 给定&amp;nbsp;pushed&amp;nbsp;和&amp;nbsp;popped&amp;nbsp;两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false&amp;nbsp;。
&amp;nbsp;
示例 1：
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1] 输出：true 解释：我们可以按以下顺序执行： push(1), push(2), push(3), push(4), pop() -&amp;gt; 4, push(5), pop() -&amp;gt; 5, pop() -&amp;gt; 3, pop() -&amp;gt; 2, pop() -&amp;gt; 1 示例 2：
输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2] 输出：false 解释：1 不能在 2 之前弹出。 &amp;nbsp;
提示：
1 &amp;lt;= pushed.length &amp;lt;= 1000 0 &amp;lt;= pushed[i] &amp;lt;= 1000 pushed 的所有元素 互不相同 popped.</description></item><item><title>【2022-08-30每日一题】998. 最大二叉树 II</title><link>/study/leetcode/maximum-binary-tree-ii/</link><pubDate>Tue, 30 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximum-binary-tree-ii/</guid><description>2022-08-30每日一题：998. 最大二叉树 II 难度：Medium 标签：树 、 二叉树 最大树 定义：一棵树，并满足：其中每个节点的值都大于其子树中的任何其他值。
给你最大树的根节点 root 和一个整数 val 。
就像 之前的问题 那样，给定的树是利用 Construct(a)&amp;nbsp;例程从列表&amp;nbsp;a（root = Construct(a)）递归地构建的：
如果 a 为空，返回&amp;nbsp;null 。 否则，令&amp;nbsp;a[i] 作为 a 的最大元素。创建一个值为&amp;nbsp;a[i]&amp;nbsp;的根节点 root 。 root&amp;nbsp;的左子树将被构建为&amp;nbsp;Construct([a[0], a[1], ..., a[i - 1]]) 。 root&amp;nbsp;的右子树将被构建为&amp;nbsp;Construct([a[i + 1], a[i + 2], ..., a[a.length - 1]]) 。 返回&amp;nbsp;root 。 请注意，题目没有直接给出 a ，只是给出一个根节点&amp;nbsp;root = Construct(a) 。
假设 b 是 a 的副本，并在末尾附加值 val。题目数据保证 b 中的值互不相同。
返回&amp;nbsp;Construct(b) 。
&amp;nbsp;
示例 1：
输入：root = [4,1,3,null,null,2], val = 5 输出：[5,4,null,1,3,null,null,2] 解释：a = [1,4,2,3], b = [1,4,2,3,5] 示例 2：</description></item><item><title>【2022-08-29每日一题】1470. 重新排列数组</title><link>/study/leetcode/shuffle-the-array/</link><pubDate>Mon, 29 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/shuffle-the-array/</guid><description>2022-08-29每日一题：1470. 重新排列数组 难度：Easy 标签：数组 给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,...,xn,y1,y2,...,yn] 的格式排列。
请你将数组按 [x1,y1,x2,y2,...,xn,yn] 格式重新排列，返回重排后的数组。
&amp;nbsp;
示例 1：
输入：nums = [2,5,1,3,4,7], n = 3 输出：[2,3,5,4,1,7] 解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7] 示例 2：
输入：nums = [1,2,3,4,4,3,2,1], n = 4 输出：[1,4,2,3,3,2,4,1] 示例 3：
输入：nums = [1,1,2,2], n = 2 输出：[1,2,1,2] &amp;nbsp;
提示：
1 &amp;lt;= n &amp;lt;= 500 nums.length == 2n 1 &amp;lt;= nums[i] &amp;lt;= 10^3 ### 直接模拟 // 写法一 func shuffle(nums []int, n int) []int { ans := make([]int, 2 * n) for i := 0; i &amp;lt; n; i++ { ans[2*i] = nums[i] ans[2*i+1] = nums[n+i] } return ans } // 写法二 func shuffle(nums []int, n int) []int { ans := make([]int,0, 2 * n) for i := 0; i &amp;lt; n; i++ { ans = append(ans, nums[i]) ans = append(ans, nums[n+i]) } return ans } // 写法三 func shuffle(nums []int, n int) []int { ans := make([]int, 2 * n) for i, num := range nums[:n] { ans[2*i] = num ans[2*i+1] = nums[n+i] } return ans } 原地模拟 数据范围：1 &amp;lt;= nums[i] &amp;lt;= 10^3</description></item><item><title>【2022-08-28每日一题】793. 阶乘函数后 K 个零</title><link>/study/leetcode/preimage-size-of-factorial-zeroes-function/</link><pubDate>Sun, 28 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/preimage-size-of-factorial-zeroes-function/</guid><description>2022-08-28每日一题：793. 阶乘函数后 K 个零 难度：Hard 标签：数学 、 二分查找 &amp;nbsp;f(x)&amp;nbsp;是&amp;nbsp;x!&amp;nbsp;末尾是 0 的数量。回想一下&amp;nbsp;x! = 1 * 2 * 3 * ... * x，且 0! = 1&amp;nbsp;。
例如，&amp;nbsp;f(3) = 0&amp;nbsp;，因为 3! = 6 的末尾没有 0 ；而 f(11) = 2&amp;nbsp;，因为 11!= 39916800 末端有 2 个 0 。 给定&amp;nbsp;k，找出返回能满足 f(x) = k&amp;nbsp;的非负整数 x&amp;nbsp;的数量。
&amp;nbsp;
示例 1： 输入：k = 0 输出：5 解释：0!, 1!, 2!, 3!, 和 4!&amp;nbsp;均符合 k = 0 的条件。 示例 2：
输入：k = 5 输出：0 解释：没有匹配到这样的 x!，符合 k = 5 的条件。 示例 3:</description></item><item><title>【2022-08-27每日一题】662. 二叉树最大宽度</title><link>/study/leetcode/maximum-width-of-binary-tree/</link><pubDate>Sat, 27 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximum-width-of-binary-tree/</guid><description>2022-08-27每日一题：662. 二叉树最大宽度 难度：Medium 标签：树 、 深度优先搜索 、 广度优先搜索 、 二叉树 给你一棵二叉树的根节点 root ，返回树的 最大宽度 。
树的 最大宽度 是所有层中最大的 宽度 。
每一层的 宽度 被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的 null 节点，这些 null 节点也计入长度。
题目数据保证答案将会在&amp;nbsp; 32 位 带符号整数范围内。
&amp;nbsp;
示例 1：
输入：root = [1,3,2,5,3,null,9] 输出：4 解释：最大宽度出现在树的第 3 层，宽度为 4 (5,3,null,9) 。 示例 2：
输入：root = [1,3,2,5,null,null,9,6,null,7] 输出：7 解释：最大宽度出现在树的第 4 层，宽度为 7 (6,null,null,null,null,null,7) 。 示例 3：
输入：root = [1,3,2,5] 输出：2 解释：最大宽度出现在树的第 2 层，宽度为 2 (3,2) 。 &amp;nbsp;
提示：
树中节点的数目范围是 [1, 3000] -100 &amp;lt;= Node.</description></item><item><title>【2022-08-26每日一题】1464. 数组中两元素的最大乘积</title><link>/study/leetcode/maximum-product-of-two-elements-in-an-array/</link><pubDate>Fri, 26 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximum-product-of-two-elements-in-an-array/</guid><description>2022-08-26每日一题：1464. 数组中两元素的最大乘积 难度：Easy 标签：数组 、 排序 、 堆（优先队列） 给你一个整数数组 nums，请你选择数组的两个不同下标 i 和 j，使 (nums[i]-1)*(nums[j]-1) 取得最大值。
请你计算并返回该式的最大值。
&amp;nbsp;
示例 1：
输入：nums = [3,4,5,2] 输出：12 解释：如果选择下标 i=1 和 j=2（下标从 0 开始），则可以获得最大值，(nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12 。 示例 2：
输入：nums = [1,5,4,5] 输出：16 解释：选择下标 i=1 和 j=3（下标从 0 开始），则可以获得最大值 (5-1)*(5-1) = 16 。 示例 3：
输入：nums = [3,7] 输出：12 &amp;nbsp;
提示：
2 &amp;lt;= nums.length &amp;lt;= 500 1 &amp;lt;= nums[i] &amp;lt;= 10^3 方法一：一次遍历找出最大的两个数 func maxProduct(nums []int) int { a, b := nums[0], nums[1] for i := 2; i &amp;lt; len(nums); i++ { // 每次和最小的数进行比较并更新对应数字 if a &amp;lt; b &amp;amp;&amp;amp; a &amp;lt; nums[i] { a = nums[i] } else if b &amp;lt; nums[i] { b = nums[i] } } return (a-1)*(b-1) } 复杂度分析 时间复杂度：O(n) 空间复杂度：O(1) 方法二：排序，取最大两个数 func maxProduct(nums []int) int { sort.</description></item><item><title>【2022-08-25每日一题】658. 找到 K 个最接近的元素</title><link>/study/leetcode/find-k-closest-elements/</link><pubDate>Thu, 25 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/find-k-closest-elements/</guid><description>2022-08-25每日一题：658. 找到 K 个最接近的元素 难度：Medium 标签：数组 、 双指针 、 二分查找 、 排序 、 堆（优先队列） 给定一个 排序好 的数组&amp;nbsp;arr ，两个整数 k 和 x ，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。
整数 a 比整数 b 更接近 x 需要满足：
|a - x| &amp;lt; |b - x| 或者 |a - x| == |b - x| 且 a &amp;lt; b &amp;nbsp;
示例 1：
输入：arr = [1,2,3,4,5], k = 4, x = 3 输出：[1,2,3,4] 示例 2：
输入：arr = [1,2,3,4,5], k = 4, x = -1 输出：[1,2,3,4] &amp;nbsp;</description></item><item><title>【2022-08-24每日一题】1460. 通过翻转子数组使两个数组相等</title><link>/study/leetcode/make-two-arrays-equal-by-reversing-sub-arrays/</link><pubDate>Wed, 24 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/make-two-arrays-equal-by-reversing-sub-arrays/</guid><description>2022-08-24每日一题：1460. 通过翻转子数组使两个数组相等 难度：Easy 标签：数组 、 哈希表 、 排序 给你两个长度相同的整数数组&amp;nbsp;target&amp;nbsp;和&amp;nbsp;arr&amp;nbsp;。每一步中，你可以选择&amp;nbsp;arr&amp;nbsp;的任意 非空子数组&amp;nbsp;并将它翻转。你可以执行此过程任意次。
如果你能让 arr&amp;nbsp;变得与 target&amp;nbsp;相同，返回 True；否则，返回 False 。
&amp;nbsp;
示例 1：
输入：target = [1,2,3,4], arr = [2,4,1,3] 输出：true 解释：你可以按照如下步骤使 arr 变成 target： 1- 翻转子数组 [2,4,1] ，arr 变成 [1,4,2,3] 2- 翻转子数组 [4,2] ，arr 变成 [1,2,4,3] 3- 翻转子数组 [4,3] ，arr 变成 [1,2,3,4] 上述方法并不是唯一的，还存在多种将 arr 变成 target 的方法。 示例 2：
输入：target = [7], arr = [7] 输出：true 解释：arr 不需要做任何翻转已经与 target 相等。 示例 3：
输入：target = [3,7,9], arr = [3,7,11] 输出：false 解释：arr 没有数字 9 ，所以无论如何也无法变成 target 。 &amp;nbsp;</description></item><item><title>【2022-08-23每日一题】782. 变为棋盘</title><link>/study/leetcode/transform-to-chessboard/</link><pubDate>Tue, 23 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/transform-to-chessboard/</guid><description>2022-08-23每日一题：782. 变为棋盘 难度：Hard 标签：位运算 、 数组 、 数学 、 矩阵 一个&amp;nbsp;n x n&amp;nbsp;的二维网络&amp;nbsp;board&amp;nbsp;仅由&amp;nbsp;0&amp;nbsp;和&amp;nbsp;1&amp;nbsp;组成&amp;nbsp;。每次移动，你能任意交换两列或是两行的位置。
返回 将这个矩阵变为&amp;nbsp; “棋盘”&amp;nbsp;&amp;nbsp;所需的最小移动次数&amp;nbsp;。如果不存在可行的变换，输出 -1。
“棋盘” 是指任意一格的上下左右四个方向的值均与本身不同的矩阵。
&amp;nbsp;
示例 1:
输入: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]] 输出: 2 解释:一种可行的变换方式如下，从左到右： 第一次移动交换了第一列和第二列。 第二次移动交换了第二行和第三行。 示例 2:
输入: board = [[0, 1], [1, 0]] 输出: 0 解释: 注意左上角的格值为0时也是合法的棋盘，也是合法的棋盘. 示例 3:
输入: board = [[1, 0], [1, 0]] 输出: -1 解释: 任意的变换都不能使这个输入变为合法的棋盘。 &amp;nbsp;
提示：
n == board.length n == board[i].length 2 &amp;lt;= n &amp;lt;= 30 board[i][j]&amp;nbsp;将只包含&amp;nbsp;0或&amp;nbsp;1 func getMoves(mask uint, count, n int) int { ones := bits.</description></item><item><title>【2022-08-22每日一题】655. 输出二叉树</title><link>/study/leetcode/print-binary-tree/</link><pubDate>Mon, 22 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/print-binary-tree/</guid><description>2022-08-22每日一题：655. 输出二叉树 难度：Medium 标签：树 、 深度优先搜索 、 广度优先搜索 、 二叉树 给你一棵二叉树的根节点 root ，请你构造一个下标从 0 开始、大小为 m x n 的字符串矩阵 res ，用以表示树的 格式化布局 。构造此格式化布局矩阵需要遵循以下规则：
树的 高度 为 height ，矩阵的行数 m 应该等于 height + 1 。 矩阵的列数 n 应该等于 2height+1 - 1 。 根节点 需要放置在 顶行 的 正中间 ，对应位置为 res[0][(n-1)/2] 。 对于放置在矩阵中的每个节点，设对应位置为 res[r][c] ，将其左子节点放置在 res[r+1][c-2height-r-1] ，右子节点放置在 res[r+1][c+2height-r-1] 。 继续这一过程，直到树中的所有节点都妥善放置。 任意空单元格都应该包含空字符串 "" 。 返回构造得到的矩阵 res 。
&amp;nbsp;
&amp;nbsp;
示例 1：
输入：root = [1,2] 输出： [["","1",""], &amp;nbsp;["2","",""]] 示例 2：</description></item><item><title>【2022-08-21每日一题】1455. 检查单词是否为句中其他单词的前缀</title><link>/study/leetcode/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/</link><pubDate>Sun, 21 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/</guid><description>2022-08-21每日一题：1455. 检查单词是否为句中其他单词的前缀 难度：Easy 标签：字符串 、 字符串匹配 给你一个字符串 sentence 作为句子并指定检索词为 searchWord ，其中句子由若干用 单个空格 分隔的单词组成。请你检查检索词 searchWord 是否为句子 sentence 中任意单词的前缀。
如果&amp;nbsp;searchWord 是某一个单词的前缀，则返回句子&amp;nbsp;sentence 中该单词所对应的下标（下标从 1 开始）。如果 searchWord 是多个单词的前缀，则返回匹配的第一个单词的下标（最小下标）。如果 searchWord 不是任何单词的前缀，则返回 -1 。
字符串 s 的 前缀 是 s 的任何前导连续子字符串。
&amp;nbsp;
示例 1：
输入：sentence = "i love eating burger", searchWord = "burg" 输出：4 解释："burg" 是 "burger" 的前缀，而 "burger" 是句子中第 4 个单词。 示例 2：
输入：sentence = "this problem is an easy problem", searchWord = "pro" 输出：2 解释："pro" 是 "problem" 的前缀，而 "problem" 是句子中第 2 个也是第 6 个单词，但是应该返回最小下标 2 。 示例 3：</description></item><item><title>【2022-08-20每日一题】654. 最大二叉树</title><link>/study/leetcode/maximum-binary-tree/</link><pubDate>Sat, 20 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximum-binary-tree/</guid><description>2022-08-20每日一题：654. 最大二叉树 难度：Medium 标签：栈 、 树 、 数组 、 分治 、 二叉树 、 单调栈 给定一个不重复的整数数组&amp;nbsp;nums 。&amp;nbsp;最大二叉树&amp;nbsp;可以用下面的算法从&amp;nbsp;nums 递归地构建:
创建一个根节点，其值为&amp;nbsp;nums 中的最大值。 递归地在最大值&amp;nbsp;左边&amp;nbsp;的&amp;nbsp;子数组前缀上&amp;nbsp;构建左子树。 递归地在最大值 右边 的&amp;nbsp;子数组后缀上&amp;nbsp;构建右子树。 返回&amp;nbsp;nums 构建的 最大二叉树 。
&amp;nbsp;
示例 1：
输入：nums = [3,2,1,6,0,5] 输出：[6,3,5,null,2,0,null,null,1] 解释：递归调用如下所示： - [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。 - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。 - 空数组，无子节点。 - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。 - 空数组，无子节点。 - 只有一个元素，所以子节点是一个值为 1 的节点。 - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。 - 只有一个元素，所以子节点是一个值为 0 的节点。 - 空数组，无子节点。 示例 2：</description></item><item><title>【2022-08-19每日一题】1450. 在既定时间做作业的学生人数</title><link>/study/leetcode/number-of-students-doing-homework-at-a-given-time/</link><pubDate>Fri, 19 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/number-of-students-doing-homework-at-a-given-time/</guid><description>2022-08-19每日一题：1450. 在既定时间做作业的学生人数 难度：Easy 标签：数组 给你两个整数数组 startTime（开始时间）和 endTime（结束时间），并指定一个整数 queryTime 作为查询时间。
已知，第 i 名学生在 startTime[i] 时开始写作业并于 endTime[i] 时完成作业。
请返回在查询时间 queryTime 时正在做作业的学生人数。形式上，返回能够使 queryTime 处于区间 [startTime[i], endTime[i]]（含）的学生人数。
&amp;nbsp;
示例 1：
输入：startTime = [1,2,3], endTime = [3,2,7], queryTime = 4 输出：1 解释：一共有 3 名学生。 第一名学生在时间 1 开始写作业，并于时间 3 完成作业，在时间 4 没有处于做作业的状态。 第二名学生在时间 2 开始写作业，并于时间 2 完成作业，在时间 4 没有处于做作业的状态。 第三名学生在时间 3 开始写作业，预计于时间 7 完成作业，这是是唯一一名在时间 4 时正在做作业的学生。 示例 2：
输入：startTime = [4], endTime = [4], queryTime = 4 输出：1 解释：在查询时间只有一名学生在做作业。 示例 3：</description></item><item><title>【2022-08-18每日一题】1224. 最大相等频率</title><link>/study/leetcode/maximum-equal-frequency/</link><pubDate>Thu, 18 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximum-equal-frequency/</guid><description>2022-08-18每日一题：1224. 最大相等频率 难度：Hard 标签：数组 、 哈希表 给你一个正整数数组&amp;nbsp;nums，请你帮忙从该数组中找出能满足下面要求的 最长 前缀，并返回该前缀的长度：
从前缀中 恰好删除一个 元素后，剩下每个数字的出现次数都相同。 如果删除这个元素后没有剩余元素存在，仍可认为每个数字都具有相同的出现次数（也就是 0 次）。
&amp;nbsp;
示例 1：
输入：nums = [2,2,1,1,5,3,3,5] 输出：7 解释：对于长度为 7 的子数组 [2,2,1,1,5,3,3]，如果我们从中删去 nums[4] = 5，就可以得到 [2,2,1,1,3,3]，里面每个数字都出现了两次。 示例 2：
输入：nums = [1,1,1,2,2,2,3,3,3,4,4,4,5] 输出：13 &amp;nbsp;
提示：
2 &amp;lt;= nums.length &amp;lt;= 105 1 &amp;lt;= nums[i] &amp;lt;= 105 #### 题解 func maxEqualFreq(nums []int) (ans int) { // count 存放数字的个数 // freq 记录出现次数为 f 的数的数目为 freq[f] // maxFreq 记录最大的数字频率 count, freq, maxFreq := map[int]int{}, map[int]int{}, 0 for i, num := range nums { if count[num] &amp;gt; 0 { freq[count[num]]-- } count[num]++ maxFreq = max(maxFreq, count[num]) freq[count[num]]++ // 三种情况： // 1、所有数的频率都是1，如：[1,2,3,4,5] 去掉任意一个数都满足条件 // 2、去掉一个数后其他数的频率相等，如[44,44,55,55,33]去掉一个33 // 3、去掉一个数后包含当前数的所有数频率相等，如[21,21,11,11,31,31,31]去掉一个31 if maxFreq == 1 || maxFreq * freq[maxFreq] == i || maxFreq + (maxFreq - 1) * freq[maxFreq-1] == i + 1 { ans = max(ans, i+1) } } return ans } func max(a, b int) int { if a &amp;lt; b { return b } return a } LeetCode题库地址 https://leetcode.</description></item><item><title>【2022-08-17每日一题】1302. 层数最深叶子节点的和</title><link>/study/leetcode/deepest-leaves-sum/</link><pubDate>Wed, 17 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/deepest-leaves-sum/</guid><description>2022-08-17每日一题：1302. 层数最深叶子节点的和 难度：Medium 标签：树 、 深度优先搜索 、 广度优先搜索 、 二叉树 给你一棵二叉树的根节点 root ，请你返回 层数最深的叶子节点的和 。
示例 1：
输入：root = [1,2,3,4,5,null,6,7,null,null,null,null,8] 输出：15 示例 2：
输入：root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5] 输出：19 提示：
树中节点数目在范围 [1, 104] 之间。 1 &lt;= Node.val &lt;= 100 ### 方法一：BFS（广度优先遍历） /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func deepestLeavesSum(root *TreeNode) (ans int) { if root == nil { return ans } queue := []*TreeNode{root} for len(queue) &amp;gt; 0 { ans = 0 for n := len(queue); n &amp;gt; 0; n-- { node := queue[0] queue = queue[1:] if node.</description></item><item><title>【2022-08-16每日一题】1656. 设计有序流</title><link>/study/leetcode/design-an-ordered-stream/</link><pubDate>Tue, 16 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/design-an-ordered-stream/</guid><description>2022-08-16每日一题：1656. 设计有序流 难度：Easy 标签：设计 、 数组 、 哈希表 、 数据流 有 n 个 (id, value) 对，其中 id 是 1 到 n 之间的一个整数，value 是一个字符串。不存在 id 相同的两个 (id, value) 对。
设计一个流，以 任意 顺序获取 n 个 (id, value) 对，并在多次调用时 按 id 递增的顺序 返回一些值。
实现 OrderedStream 类：
OrderedStream(int n) 构造一个能接收 n 个值的流，并将当前指针 ptr 设为 1 。 String[] insert(int id, String value) 向流中存储新的 (id, value) 对。存储后： 如果流存储有 id = ptr 的 (id, value) 对，则找出从 id = ptr 开始的 最长 id 连续递增序列 ，并 按顺序 返回与这些 id 关联的值的列表。然后，将 ptr 更新为最后那个 id + 1 。 否则，返回一个空列表。</description></item><item><title>【2022-08-15每日一题】641. 设计循环双端队列</title><link>/study/leetcode/design-circular-deque/</link><pubDate>Mon, 15 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/design-circular-deque/</guid><description>2022-08-15每日一题：641. 设计循环双端队列 难度：Medium 标签：设计 、 队列 、 数组 、 链表 设计实现双端队列。
实现 MyCircularDeque 类:
MyCircularDeque(int k)&amp;nbsp;：构造函数,双端队列最大为 k 。 boolean insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true&amp;nbsp;，否则返回 false 。 boolean insertLast()&amp;nbsp;：将一个元素添加到双端队列尾部。如果操作成功返回 true&amp;nbsp;，否则返回 false 。 boolean deleteFront()&amp;nbsp;：从双端队列头部删除一个元素。 如果操作成功返回 true&amp;nbsp;，否则返回 false 。 boolean deleteLast()&amp;nbsp;：从双端队列尾部删除一个元素。如果操作成功返回 true&amp;nbsp;，否则返回 false 。 int getFront()&amp;nbsp;)：从双端队列头部获得一个元素。如果双端队列为空，返回 -1&amp;nbsp;。 int getRear()&amp;nbsp;：获得双端队列的最后一个元素。&amp;nbsp;如果双端队列为空，返回 -1 。 boolean isEmpty()&amp;nbsp;：若双端队列为空，则返回&amp;nbsp;true&amp;nbsp;，否则返回 false &amp;nbsp;。 boolean isFull()&amp;nbsp;：若双端队列满了，则返回&amp;nbsp;true&amp;nbsp;，否则返回 false 。 &amp;nbsp;
示例 1：
输入 ["MyCircularDeque", "insertLast", "insertLast", "insertFront", "insertFront", "getRear", "isFull", "deleteLast", "insertFront", "getFront"] [[3], [1], [2], [3], [4], [], [], [], [4], []] 输出 [null, true, true, true, false, 2, true, true, true, 4] 解释 MyCircularDeque circularDeque = new MycircularDeque(3); // 设置容量大小为3 circularDeque.</description></item><item><title>【2022-08-14每日一题】1422. 分割字符串的最大得分</title><link>/study/leetcode/maximum-score-after-splitting-a-string/</link><pubDate>Sun, 14 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximum-score-after-splitting-a-string/</guid><description>2022-08-14每日一题：1422. 分割字符串的最大得分 难度：Easy 标签：字符串 给你一个由若干 0 和 1 组成的字符串 s ，请你计算并返回将该字符串分割成两个 非空 子字符串（即&amp;nbsp;左 子字符串和 右 子字符串）所能获得的最大得分。
「分割字符串的得分」为 左 子字符串中 0 的数量加上 右 子字符串中 1 的数量。
&amp;nbsp;
示例 1：
输入：s = &amp;quot;011101&amp;quot; 输出：5 解释： 将字符串 s 划分为两个非空子字符串的可行方案有： 左子字符串 = &amp;quot;0&amp;quot; 且 右子字符串 = &amp;quot;11101&amp;quot;，得分 = 1 + 4 = 5 左子字符串 = &amp;quot;01&amp;quot; 且 右子字符串 = &amp;quot;1101&amp;quot;，得分 = 1 + 3 = 4 左子字符串 = &amp;quot;011&amp;quot; 且 右子字符串 = &amp;quot;101&amp;quot;，得分 = 1 + 2 = 3 左子字符串 = &amp;quot;0111&amp;quot; 且 右子字符串 = &amp;quot;01&amp;quot;，得分 = 1 + 1 = 2 左子字符串 = &amp;quot;01110&amp;quot; 且 右子字符串 = &amp;quot;1&amp;quot;，得分 = 2 + 1 = 3 示例 2：</description></item><item><title>【2022-08-13每日一题】768. 最多能完成排序的块 II</title><link>/study/leetcode/max-chunks-to-make-sorted-ii/</link><pubDate>Sat, 13 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/max-chunks-to-make-sorted-ii/</guid><description>2022-08-13每日一题：768. 最多能完成排序的块 II 难度：Hard 标签：栈 、 贪心 、 数组 、 排序 、 单调栈 这个问题和&amp;ldquo;最多能完成排序的块&amp;rdquo;相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10**8。
arr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个&amp;ldquo;块&amp;rdquo;，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。
我们最多能将数组分成多少块？
示例&amp;nbsp;1:
输入: arr = [5,4,3,2,1] 输出: 1 解释: 将数组分成2块或者更多块，都无法得到所需的结果。 例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 示例 2:
输入: arr = [2,1,3,4,4] 输出: 4 解释: 我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。 然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。 注意:
arr的长度在[1, 2000]之间。 arr[i]的大小在[0, 10**8]之间。 ### 方法一：单调栈 思路 对于已经分好块的数组，若块数大于 1，则可以得到以下结论：右边的块的所有数字均大于或等于左边的块的所有数字。考虑这个问题：对于已经分好块的数组，若在其末尾添加一个数字，如何求得新数组的分块方式？
新添加的数字可能会改变原数组的分块方式。如果新添加的数字大于或等于原数组最后一个块的最大值，则这个新添加的数字可以自己形成一个块。如果新添加的数字小于原数组最后一个块的最大值，则它必须融入最后一个块。如果它大于或等于原数组倒数第二个块（如果有）的最大值，那么这个过程可以停止，新数组的分块方式已经求得。否则，它将继续融合原数组倒数第二个块，直到遇到一个块，使得该块的最大值小于或等于这个新添加的数，或者这个数字已经融合了所有块。
上述分析过程中，我们只用到了块的最大值来进行比较，比较过程又是从右到左，符合栈的思想，因此可以用类似单调栈的数据结构来存储块的最大值。
代码 func maxChunksToSorted(arr []int) int { st := []int{} for _, x := range arr { if len(st) == 0 || x &amp;gt;= st[len(st)-1] { st = append(st, x) } else { mx := st[len(st)-1] st = st[:len(st)-1] for len(st) &amp;gt; 0 &amp;amp;&amp;amp; st[len(st)-1] &amp;gt; x { st = st[:len(st)-1] } st = append(st, mx) } } return len(st) } 复杂度分析 时间复杂度：O(n)，其中 n 是输入数组 arr 的长度。需要遍历一遍数组，入栈的操作最多为 n 次。</description></item><item><title>【2022-08-12每日一题】1282. 用户分组</title><link>/study/leetcode/group-the-people-given-the-group-size-they-belong-to/</link><pubDate>Fri, 12 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/group-the-people-given-the-group-size-they-belong-to/</guid><description>2022-08-12每日一题：1282. 用户分组 难度：Medium 标签：数组 、 哈希表 有&amp;nbsp;n&amp;nbsp;个人被分成数量未知的组。每个人都被标记为一个从 0 到 n - 1 的唯一ID&amp;nbsp;。
给定一个整数数组 groupSizes ，其中&amp;nbsp;groupSizes[i]&amp;nbsp;是第 i 个人所在的组的大小。例如，如果&amp;nbsp;groupSizes[1] = 3&amp;nbsp;，则第 1 个人必须位于大小为 3 的组中。
返回一个组列表，使每个人 i 都在一个大小为&amp;nbsp;groupSizes[i]&amp;nbsp;的组中。
每个人应该&amp;nbsp;恰好只&amp;nbsp;出现在&amp;nbsp;一个组&amp;nbsp;中，并且每个人必须在一个组中。如果有多个答案，返回其中&amp;nbsp;任何&amp;nbsp;一个。可以&amp;nbsp;保证&amp;nbsp;给定输入&amp;nbsp;至少有一个&amp;nbsp;有效的解。
示例 1：
输入：groupSizes = [3,3,3,3,3,1,3] 输出：[[5],[0,1,2],[3,4,6]] 解释： 第一组是 [5]，大小为 1，groupSizes[5] = 1。 第二组是 [0,1,2]，大小为 3，groupSizes[0] = groupSizes[1] = groupSizes[2] = 3。 第三组是 [3,4,6]，大小为 3，groupSizes[3] = groupSizes[4] = groupSizes[6] = 3。 其他可能的解决方案有 [[2,1,6],[5],[0,4,3]] 和 [[5],[0,6,2],[4,3,1]]。 示例 2：
输入：groupSizes = [2,1,3,3,3,2] 输出：[[1],[0,5],[2,3,4]] 提示：
groupSizes.length == n 1 &amp;lt;= n&amp;nbsp;&amp;lt;= 500 1 &amp;lt;=&amp;nbsp;groupSizes[i] &amp;lt;= n ### 方法一：哈希表 由于给定的输入一定存在有效的解，因此对于数组groupSizes 中的每个元素 x，当 x 在数组中出现 y 次时，y 一定能被 x 整除，且大小为 x 的组有 y/x个。</description></item><item><title>【2022-08-10每日一题】640. 求解方程</title><link>/study/leetcode/solve-the-equation/</link><pubDate>Wed, 10 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/solve-the-equation/</guid><description>2022-08-10每日一题：640. 求解方程 难度：Medium 标签：数学 、 字符串 、 模拟 求解一个给定的方程，将x以字符串 "x=#value"&amp;nbsp;的形式返回。该方程仅包含 '+' ， '-' 操作，变量&amp;nbsp;x&amp;nbsp;和其对应系数。
如果方程没有解，请返回&amp;nbsp;"No solution"&amp;nbsp;。如果方程有无限解，则返回 “Infinite solutions” 。
如果方程中只有一个解，要保证返回值 'x'&amp;nbsp;是一个整数。
&amp;nbsp;
示例 1：
输入: equation = &amp;quot;x+5-3+x=6+x-2&amp;quot; 输出: &amp;quot;x=2&amp;quot; 示例 2:
输入: equation = &amp;quot;x=x&amp;quot; 输出: &amp;quot;Infinite solutions&amp;quot; 示例 3:
输入: equation = &amp;quot;2x=x&amp;quot; 输出: &amp;quot;x=0&amp;quot; &amp;nbsp;
&amp;nbsp;
提示:
3 &amp;lt;= equation.length &amp;lt;= 1000 equation&amp;nbsp;只有一个&amp;nbsp;'='. equation&amp;nbsp;方程由整数组成，其绝对值在&amp;nbsp;[0, 100]&amp;nbsp;范围内，不含前导零和变量 'x' 。&amp;nbsp;​​​ ### 方法一：模拟 根据题意进行模拟即可，设factor表示合并同类项的x的系数，val表示合并数字的值
首先我们对方程左右两边的表达式进行合并同类项 遍历左表达式，默认为正号 若字符是x，加到factor上 若字符是+或者-，改变符号位 若字符是数字，则判断后边有没有跟x，有则加到factor上，没有加到val上 遍历右表达式，默认为负号，相当于右边的表达式移动到左边（解析同上只是符号相反） 若factor == 0，判断val是否为0，为0则表示无穷解，不为0表示没有解 若factor != 0,直接解方程即可，现在的方程变为factor * x = -val,则x = (-val / factor) func solveEquation(equation string) string { factor, val := 0, 0 i, n, sign := 0, len(equation), 1 // 等式左边默认系数为正 for i &amp;lt; n { if equation[i] == '=' { sign = -1 // 等式右边默认系数为负 i++ continue } s := sign if equation[i] == '+' { // 去掉前面的符号 i++ } else if equation[i] == '-' { s = -s i++ } num, valid := 0, false for i &amp;lt; n &amp;amp;&amp;amp; unicode.</description></item><item><title>【2022-08-09每日一题】1413. 逐步求和得到正数的最小值</title><link>/study/leetcode/minimum-value-to-get-positive-step-by-step-sum/</link><pubDate>Tue, 09 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/minimum-value-to-get-positive-step-by-step-sum/</guid><description>2022-08-09每日一题：1413. 逐步求和得到正数的最小值 难度：Easy 标签：数组 、 前缀和 给你一个整数数组 nums&amp;nbsp;。你可以选定任意的&amp;nbsp;正数 startValue 作为初始值。
你需要从左到右遍历 nums&amp;nbsp;数组，并将 startValue 依次累加上&amp;nbsp;nums&amp;nbsp;数组中的值。
请你在确保累加和始终大于等于 1 的前提下，选出一个最小的&amp;nbsp;正数&amp;nbsp;作为 startValue 。
示例 1：
输入：nums = [-3,2,-3,4,2] 输出：5 解释：如果你选择 startValue = 4，在第三次累加时，和小于 1 。 累加求和 startValue = 4 | startValue = 5 | nums (4 - 3) = 1 | (5 - 3) = 2 | -3 (1 + 2) = 3 | (2 + 2) = 4 | 2 (3 - 3) = 0 | (4 - 3) = 1 | -3 (0 + 4) = 4 | (1 + 4) = 5 | 4 (4 + 2) = 6 | (5 + 2) = 7 | 2 示例 2：</description></item><item><title>【2022-08-08每日一题】761. 特殊的二进制序列</title><link>/study/leetcode/special-binary-string/</link><pubDate>Mon, 08 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/special-binary-string/</guid><description>2022-08-08每日一题：761. 特殊的二进制序列 难度：Hard
标签：递归 、 字符串
特殊的二进制序列是具有以下两个性质的二进制序列：
0 的数量与 1 的数量相等。 二进制序列的每一个前缀码中 1 的数量要大于等于 0 的数量。 给定一个特殊的二进制序列&amp;nbsp;S，以字符串形式表示。定义一个操作 为首先选择&amp;nbsp;S&amp;nbsp;的两个连续且非空的特殊的子串，然后将它们交换。（两个子串为连续的当且仅当第一个子串的最后一个字符恰好为第二个子串的第一个字符的前一个字符。)
在任意次数的操作之后，交换后的字符串按照字典序排列的最大的结果是什么？
示例 1:
输入: S = &amp;quot;11011000&amp;quot; 输出: &amp;quot;11100100&amp;quot; 解释: 将子串 &amp;quot;10&amp;quot; （在S[1]出现） 和 &amp;quot;1100&amp;quot; （在S[3]出现）进行交换。 这是在进行若干次操作后按字典序排列最大的结果。 说明:
S&amp;nbsp;的长度不超过&amp;nbsp;50。 S&amp;nbsp;保证为一个满足上述定义的特殊 的二进制序列。 ### 解题 此题可以看成是有效的括号，将 1 看成左括号 (，0 看成右括号 )，比如，&amp;ldquo;1100&amp;rdquo; 可以看做是 &amp;ldquo;(())&amp;quot;，这样就比较好理解。也就是说最后我们需要通过一系列操作（有效的括号子串交换位置）之后让左括号尽量在右括号前面，比如，对于 &amp;ldquo;(()(()))&amp;quot;，我们可以把中间 &amp;ldquo;()&amp;rdquo; 和 &amp;ldquo;(())&amp;rdquo; 交换之后变成 &amp;ldquo;((())())&amp;quot;。
那么，代码就比较容易写了，我们可以遍历整个字符串，找到它的有效子串，再把这些子串降序排个序就完事了，当然，这里在找到这些子串之后，子串内部也可以使用相同的规则去做处理，所以，我们可以使用递归来搞。
func makeLargestSpecial(s string) string { if len(s) &amp;lt;= 2 { return s } subs := sort.StringSlice{} cnt, left := 0, 0 for i, ch := range s { if ch == '1' { cnt++ } else if cnt--; cnt == 0 { subs = append(subs, &amp;quot;1&amp;quot;+makeLargestSpecial(s[left+1:i])+&amp;quot;0&amp;quot;) left = i + 1 } } sort.</description></item><item><title>【2022-08-07每日一题】636. 函数的独占时间</title><link>/study/leetcode/exclusive-time-of-functions/</link><pubDate>Sun, 07 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/exclusive-time-of-functions/</guid><description>2022-08-07每日一题：636. 函数的独占时间 有一个 单线程 CPU 正在运行一个含有 n 道函数的程序。每道函数都有一个位于 0 和 n-1 之间的唯一标识符。
函数调用 存储在一个 调用栈 上 ：当一个函数调用开始时，它的标识符将会推入栈中。而当一个函数调用结束时，它的标识符将会从栈中弹出。标识符位于栈顶的函数是 当前正在执行的函数 。每当一个函数开始或者结束时，将会记录一条日志，包括函数标识符、是开始还是结束、以及相应的时间戳。
给你一个由日志组成的列表 logs ，其中 logs[i] 表示第 i 条日志消息，该消息是一个按 "{function_id}:{"start" | "end"}:{timestamp}" 进行格式化的字符串。例如，"0:start:3" 意味着标识符为 0 的函数调用在时间戳 3 的 起始开始执行 ；而 "1:end:2" 意味着标识符为 1 的函数调用在时间戳 2 的 末尾结束执行。注意，函数可以 调用多次，可能存在递归调用 。
函数的 独占时间 定义是在这个函数在程序所有函数调用中执行时间的总和，调用其他函数花费的时间不算该函数的独占时间。例如，如果一个函数被调用两次，一次调用执行 2 单位时间，另一次调用执行 1 单位时间，那么该函数的 独占时间 为 2 + 1 = 3 。
以数组形式返回每个函数的 独占时间 ，其中第 i 个下标对应的值表示标识符 i 的函数的独占时间。
示例 1：
输入：n = 2, logs = ["</description></item><item><title>【2022-08-06每日一题】1408. 数组中的字符串匹配</title><link>/study/leetcode/string-matching-in-an-array/</link><pubDate>Sat, 06 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/string-matching-in-an-array/</guid><description>2022-08-06每日一题：1408. 数组中的字符串匹配 给你一个字符串数组 words ，数组中的每个字符串都可以看作是一个单词。请你按 任意 顺序返回 words 中是其他单词的子字符串的所有单词。
如果你可以删除 words[j]&amp;nbsp;最左侧和/或最右侧的若干字符得到 words[i] ，那么字符串 words[i] 就是 words[j] 的一个子字符串。
&amp;nbsp;
示例 1：
输入：words = [&amp;quot;mass&amp;quot;,&amp;quot;as&amp;quot;,&amp;quot;hero&amp;quot;,&amp;quot;superhero&amp;quot;] 输出：[&amp;quot;as&amp;quot;,&amp;quot;hero&amp;quot;] 解释：&amp;quot;as&amp;quot; 是 &amp;quot;mass&amp;quot; 的子字符串，&amp;quot;hero&amp;quot; 是 &amp;quot;superhero&amp;quot; 的子字符串。 [&amp;quot;hero&amp;quot;,&amp;quot;as&amp;quot;] 也是有效的答案。 示例 2：
输入：words = [&amp;quot;leetcode&amp;quot;,&amp;quot;et&amp;quot;,&amp;quot;code&amp;quot;] 输出：[&amp;quot;et&amp;quot;,&amp;quot;code&amp;quot;] 解释：&amp;quot;et&amp;quot; 和 &amp;quot;code&amp;quot; 都是 &amp;quot;leetcode&amp;quot; 的子字符串。 示例 3：
输入：words = [&amp;quot;blue&amp;quot;,&amp;quot;green&amp;quot;,&amp;quot;bu&amp;quot;] 输出：[] &amp;nbsp;
提示：
1 &amp;lt;= words.length &amp;lt;= 100 1 &amp;lt;= words[i].length &amp;lt;= 30 words[i] 仅包含小写英文字母。 题目数据 保证 每个 words[i] 都是独一无二的。 方法一：穷举， 暴力双层循环 func stringMatching(words []string) []string { ans := []string{} for i, wordi := range words { for j, wordj := range words { if i !</description></item><item><title>2022-08-05每日一题：623. 在二叉树中增加一行</title><link>/study/leetcode/add-one-row-to-tree/</link><pubDate>Fri, 05 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/add-one-row-to-tree/</guid><description>2022-08-05每日一题：623. 在二叉树中增加一行 给定一个二叉树的根&amp;nbsp;root&amp;nbsp;和两个整数 val 和&amp;nbsp;depth&amp;nbsp;，在给定的深度&amp;nbsp;depth&amp;nbsp;处添加一个值为 val 的节点行。
注意，根节点&amp;nbsp;root&amp;nbsp;位于深度&amp;nbsp;1&amp;nbsp;。
加法规则如下:
给定整数&amp;nbsp;depth，对于深度为&amp;nbsp;depth - 1 的每个非空树节点 cur ，创建两个值为 val 的树节点作为 cur 的左子树根和右子树根。 cur 原来的左子树应该是新的左子树根的左子树。 cur 原来的右子树应该是新的右子树根的右子树。 如果 depth == 1 意味着&amp;nbsp;depth - 1&amp;nbsp;根本没有深度，那么创建一个树节点，值 val 作为整个原始树的新根，而原始树就是新根的左子树。 &amp;nbsp;
示例 1:
输入: root = [4,2,6,3,1,5], val = 1, depth = 2 输出: [4,1,1,2,null,null,6,3,1,5] 示例 2:
输入: root = [4,2,null,3,1], val = 1, depth = 3 输出: [4,2,null,1,1,3,null,null,1] &amp;nbsp;
提示:
节点数在&amp;nbsp;[1, 104]&amp;nbsp;范围内 树的深度在&amp;nbsp;[1, 104]范围内 -100 &amp;lt;= Node.val &amp;lt;= 100 -105&amp;nbsp;&amp;lt;= val &amp;lt;= 105 1 &amp;lt;= depth &amp;lt;= the depth of tree + 1 方法一：深度优先遍历 当depth 为 1 时，需要创建一个新的 root，并将原 root 作为新 root 的左子节点。</description></item><item><title>2022-08-04每日一题：1403. 非递增顺序的最小子序列</title><link>/study/leetcode/minimum-subsequence-in-non-increasing-order/</link><pubDate>Thu, 04 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/minimum-subsequence-in-non-increasing-order/</guid><description>2022-08-04每日一题：1403. 非递增顺序的最小子序列 给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。
如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。
与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。
注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。
&amp;nbsp;
示例 1：
输入：nums = [4,3,10,9,8] 输出：[10,9] 解释：子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。&amp;nbsp; 示例 2：
输入：nums = [4,4,7,6,7] 输出：[7,7,6] 解释：子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 = 4 + 4 + 6）。因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。 示例 3：
输入：nums = [6] 输出：[6] &amp;nbsp;
提示：
1 &amp;lt;= nums.length &amp;lt;= 500 1 &amp;lt;= nums[i] &amp;lt;= 100 ### 写法一 要求的子序列的和大于整个数组和的一半，且是略大于（因为要求长度最小）
题目中要求的&amp;quot;非递增顺序&amp;quot;给了很大的暗示：可以排序，然后从后往前找，找到最短的、和大于整个数组和一半的、子数组即可
func minSubsequence(nums []int) []int { // 降序 sort.</description></item><item><title>2022-08-03每日一题：899. 有序队列</title><link>/study/leetcode/orderly-queue/</link><pubDate>Wed, 03 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/orderly-queue/</guid><description>2022-08-03每日一题：899. 有序队列 给定一个字符串 s 和一个整数 k&amp;nbsp;。你可以从 s 的前 k 个字母中选择一个，并把它加到字符串的末尾。
返回 在应用上述步骤的任意数量的移动后，字典上最小的字符串&amp;nbsp;。
&amp;nbsp;
示例 1：
输入：s = "cba", k = 1 输出："acb" 解释： 在第一步中，我们将第一个字符（“c”）移动到最后，获得字符串 “bac”。 在第二步中，我们将第一个字符（“b”）移动到最后，获得最终结果 “acb”。 示例 2：
输入：s = "baaca", k = 3 输出："aaabc" 解释： 在第一步中，我们将第一个字符（“b”）移动到最后，获得字符串 “aacab”。 在第二步中，我们将第三个字符（“c”）移动到最后，获得最终结果 “aaabc”。 &amp;nbsp;
提示：
1 &amp;lt;= k&amp;nbsp;&amp;lt;= S.length&amp;nbsp;&amp;lt;= 1000 s&amp;nbsp;只由小写字母组成。 func orderlyQueue(s string, k int) string { if k == 1 { // 当k = 1时，共有 n 种候选方案, 遍历求其最小的字典序 ans := s for i := 1; i &amp;lt; len(s); i++ { s = s[1:] + s[:1] if s &amp;lt; ans { ans = s } } return ans } // 当k &amp;gt; 1时，经过不断的变换，我们总能让序列有序，直接对字符串进行字典序排序即可 t := []byte(s) sort.</description></item><item><title>2022-08-01每日一题：622 设计循环队列</title><link>/study/leetcode/design-circular-queue/</link><pubDate>Tue, 02 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/design-circular-queue/</guid><description>622 设计循环队列 设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为&amp;ldquo;环形缓冲器&amp;rdquo;。
循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。
你的实现应该支持如下操作：
MyCircularQueue(k): 构造器，设置队列长度为 k 。 Front: 从队首获取元素。如果队列为空，返回 -1 。 Rear: 获取队尾元素。如果队列为空，返回 -1 。 enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。 deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。 isEmpty(): 检查循环队列是否为空。 isFull(): 检查循环队列是否已满。 &amp;nbsp;
示例：
MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3 circularQueue.enQueue(1); &amp;nbsp;// 返回 true circularQueue.enQueue(2); &amp;nbsp;// 返回 true circularQueue.enQueue(3); &amp;nbsp;// 返回 true circularQueue.enQueue(4); &amp;nbsp;// 返回 false，队列已满 circularQueue.Rear(); &amp;nbsp;// 返回 3 circularQueue.isFull(); &amp;nbsp;// 返回 true circularQueue.deQueue(); &amp;nbsp;// 返回 true circularQueue.enQueue(4); &amp;nbsp;// 返回 true circularQueue.Rear(); &amp;nbsp;// 返回 4 &amp;nbsp;
提示：</description></item><item><title>2022-08-01每日一题：1374 生成每种字符都是奇数个的字符串</title><link>/study/leetcode/generate-a-string-with-characters-that-have-odd-counts/</link><pubDate>Mon, 01 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/generate-a-string-with-characters-that-have-odd-counts/</guid><description>1374 生成每种字符都是奇数个的字符串 给你一个整数 n，请你返回一个含 n 个字符的字符串，其中每种字符在该字符串中都恰好出现 奇数次 。
返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可。
&amp;nbsp;
示例 1：
输入：n = 4 输出：&amp;quot;pppz&amp;quot; 解释：&amp;quot;pppz&amp;quot; 是一个满足题目要求的字符串，因为 &amp;#39;p&amp;#39; 出现 3 次，且 &amp;#39;z&amp;#39; 出现 1 次。当然，还有很多其他字符串也满足题目要求，比如：&amp;quot;ohhh&amp;quot; 和 &amp;quot;love&amp;quot;。 示例 2：
输入：n = 2 输出：&amp;quot;xy&amp;quot; 解释：&amp;quot;xy&amp;quot; 是一个满足题目要求的字符串，因为 &amp;#39;x&amp;#39; 和 &amp;#39;y&amp;#39; 各出现 1 次。当然，还有很多其他字符串也满足题目要求，比如：&amp;quot;ag&amp;quot; 和 &amp;quot;ur&amp;quot;。 示例 3：
输入：n = 7 输出：&amp;quot;holasss&amp;quot; &amp;nbsp;
提示：
1 &amp;lt;= n &amp;lt;= 500 ### 方法一：分类讨论 解题思路 n为奇数时可以用一个字符即可，本身就是奇数次；
n为偶数时可以用两个字符，奇+奇=偶
go func generateTheString(n int) string { if n%2 == 0 { return strings.Repeat(&amp;quot;l&amp;quot;, n-1) + &amp;quot;b&amp;quot; } return strings.</description></item><item><title>处理 Go 中的 'connection reset by peer' 错误</title><link>/2022/07/28/connection-reset-by-peer/</link><pubDate>Thu, 28 Jul 2022 17:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2022/07/28/connection-reset-by-peer/</guid><description>原文链接：https://gosamples.dev/connection-reset-by-peer/ 这connection reset by peer是在另一端（对等方）意外关闭连接时发生的TCP/IP错误。 当你从你的一端发送一个数据包，但另一端崩溃并强行关闭与RST 数据包的连接而不是TCP FIN 正常情况下用于关闭连接的连接时，就会发生这种情况。在 Go 中，您可以connection reset by peer通过检查对等方返回的错误是否等于 来检测syscall.ECONNRESET 。
重现connection reset by peer错误 我们可以通过创建执行以下操作的服务器和客户端来重现错误：
服务器读取一个字节然后关闭连接 客户端发送超过一个字节 如果服务器使用套接字接收缓冲区中的剩余字节关闭连接，则RST向客户端发送一个数据包。当客户端试图从这样一个关闭的连接中读取时，它会得到connection reset by peer错误。
请参阅以下示例，该示例模拟了此行为。
package main import ( &amp;quot;errors&amp;quot; &amp;quot;log&amp;quot; &amp;quot;net&amp;quot; &amp;quot;os&amp;quot; &amp;quot;syscall&amp;quot; &amp;quot;time&amp;quot; ) func server() { listener, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;:8080&amp;quot;) if err != nil { log.Fatal(err) } defer listener.Close() conn, err := listener.Accept() if err != nil { log.Fatal(&amp;quot;server&amp;quot;, err) os.Exit(1) } data := make([]byte, 1) if _, err := conn.</description></item><item><title>云原生时代的CoreDNS学习指南 笔记</title><link>/2022/07/11/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%97%B6%E4%BB%A3%E7%9A%84coredns%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E7%AC%94%E8%AE%B0/</link><pubDate>Mon, 11 Jul 2022 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2022/07/11/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%97%B6%E4%BB%A3%E7%9A%84coredns%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97-%E7%AC%94%E8%AE%B0/</guid><description>主文件格式的记录一般是以下格式：
[NAME] [TTL] [CLASS] TYPE RDATA NAME字段包含资源记录附加的域名。它可以是以“.”结尾的完全限定域名（Fully Qualified Domain Name，FQDN），也可以是不以“.”结尾的相对域名。相对域名被解释为以当前的源结尾，在默认情况下，它是区域数据文件描述的区域的域名。
TTL字段指定了资源记录的生存时间值，该值控制递归DNS服务器可以缓存该记录的时间。TTL是一个32位整数表示的秒数，除此之外，你还可以使用扩展因子表示TTL，如“s”表示秒、“m”表示分钟、“h”表示小时、“d”表示天、“w”表示周。例如，“1d”表示1天，“30m”表示30分钟，“1h30m”表示1小时30分钟。
CLASS字段几乎总是IN，代表互联网，因此IN作为默认值也就不足为奇了。此外确实还有其他的值，如用于ChaosNet的CH和用于Hesiod的HS。
安装etcd rm -rf /tmp/etcd-data.tmp &amp;amp;&amp;amp; mkdir -p /tmp/etcd-data.tmp &amp;amp;&amp;amp; \ docker run \ -p 2379:2379 \ -p 2380:2380 \ --mount type=bind,source=/tmp/etcd-data.tmp,destination=/etcd-data \ --name etcd-gcr-v3.5.4 \ quay.io/coreos/etcd:v3.5.4 \ /usr/local/bin/etcd \ --name s1 \ --data-dir /etcd-data \ --listen-client-urls http://0.0.0.0:2379 \ --advertise-client-urls http://0.0.0.0:2379 \ --listen-peer-urls http://0.0.0.0:2380 \ --initial-advertise-peer-urls http://0.0.0.0:2380 \ --initial-cluster s1=http://0.0.0.0:2380 \ --initial-cluster-token tkn \ --initial-cluster-state new \ --log-level info \ --logger zap \ --log-outputs stderr 关注公众号获得更多精彩文章</description></item><item><title>KubeSphere 安装</title><link>/cloud-native/kubesphere/</link><pubDate>Fri, 01 Jul 2022 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/cloud-native/kubesphere/</guid><description>KubeSphere | Stopping if default StorageClass was not found local-storage.yaml https://kubesphere.com.cn/forum/d/3705-kubernetes-stop-if-storageclass-was-not-found https://github.com/kubesphere/kubesphere/issues/4558 https://kubesphere.com.cn/forum/d/7194-kubekeyk8skubesphere-default-storageclass-was-not-found https://blog.imdst.com/kubernetesshang-an-zhuang-kubesphere/ kind: StorageClass apiVersion: storage.k8s.io/v1 metadata: annotations: storageclass.kubernetes.io/is-default-class: &amp;quot;true&amp;quot; name: local-storage provisioner: kubernetes.io/no-provisioner volumeBindingMode: WaitForFirstConsumer kubectl apply -f https://mirror.ghproxy.com/https://github.com/kubesphere/ks-installer/releases/download/v3.3.0/kubesphere-installer.yaml kubectl apply -f https://mirror.ghproxy.com/https://github.com/kubesphere/ks-installer/releases/download/v3.3.0/cluster-configuration.yaml kubectl get svc/ks-console -n kubesphere-system ssh -L 30880:10.100.128.134:30880 -p 10088 root@10.90.100.19 ssh -L 30880:localhost:30880 -p 10088 root@10.90.100.19 OpenEBS Local PV Hostpath User Guide https://openebs.io/docs/user-guides/localpv-hostpath helm repo add openebs https://openebs.github.io/charts helm repo update helm install --namespace openebs --name openebs openebs/openebs apiVersion: storage.</description></item><item><title>Google SRE</title><link>/2022/06/21/google-sre/</link><pubDate>Tue, 21 Jun 2022 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2022/06/21/google-sre/</guid><description>第4章 服务质量目标 服务质量术语 服务质量指标（SLI）—— indicator 服务质量目标（SLO）——Objective 服务质量协议（SLA）——Agreement 单词 指标（indicator） 持久性（durability） 可用性（availability） 目标（Objective） 协议（Agreement） 第5章 减少琐事 4个黄金指标 延迟、流量、错误和饱和度（saturation）
第7章 自动化 自动化工具：Puppet、Chef、cfengine
Chubby服务器
第10章基于时间序列数据进行有效报警 监控：Pormetheus、Riemann、Heka和Bosun
time-series 第11章 on-call轮值 最理想的方法论是这样的：在有足够数据支撑的时候按步骤解决问题，同时不停地审视和验证目前所有的假设。
最重要的资源有：
● 清晰的问题升级路线。
● 清晰定义的应急事件处理步骤。
● 无指责，对事不对人的文化氛围。
第12章 有效的故障排查手段 1.对通用的故障排查过程的理解（不依靠任何特定系统）。
2.对发生故障的系统的足够了解
读者应该小心避免： ● 关注了错误的系统现象，或者错误地理解了系统现象的含义。这样会在错误的方向上浪费时间。
● 不能正确修改系统的配置信息、输入信息或者系统运行环境，造成不能安全和有效地测试假设。
● 将问题过早地归结为极为不可能的因素（例如认为是宇宙射线造成数据变化，虽然有可能发生，但是并不应该在解决问题初期做这个假设），或者念念不忘之前曾经发生过的系统问题，认为一旦发生过一次，就有可能再次发生。
● 试图解决与当前系统问题相关的一些问题，却没有认识到这些其实只是巧合，或者这些问题其实是由于当前系统的问题造成的。（比如发现数据库压力大的情况下，环境温度也有所上升，于是试图解决环境温度问题。）
Dapper 提供了非常有用的了解分布式系统工作情况的一种方式
单词 监测指标（telemetry）
定位（triage）
相关性（correlation）
因果关系（causation）
问题分解（Divide &amp;amp; Conquer）
对分法（bisection）
第14章 紧急事故管理 一次流程管理良好的事故 第17章 测试可靠性 传统测试 单元测试（unit test） 集成测试（integration test） 依赖注入（dependency injection） 系统测试（system test） 冒烟测试（smoke test）：冒烟测试有时也被称为理性测试 性能测试（performance test） 回归测试（regression test） 生产测试 变更发布与测试 配置测试 金丝雀测试 第18章 SRE 部门中的软件工程实践 Auxon 案例 基于意图的容量规划 1.</description></item><item><title>使用 Docker 在 1 分钟内完成 ClickHouse 服务器</title><link>/cloud-native/docker/clickhouse-server-in-1-minute-with-docker/</link><pubDate>Wed, 06 Apr 2022 13:00:48 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/cloud-native/docker/clickhouse-server-in-1-minute-with-docker/</guid><description>ClickHouse 是一个开源的面向列的 DBMS（由 Yandex 开发）。ClickHouse 的工作速度比传统方法快 100-1000 倍。 它适用于大数据、业务分析和时间序列数据。ClickHouse 是第一个与 Sybase IQ、Vertica 和 Snowflake 等专有数据库的性能、成熟度和可扩展性相匹配的开源 SQL 数据仓库。
在这个小教程中，我将向您展示如何以最少的设置安装 ClickHouse。
对于本教程，我们需要安装 Docker 和 docker-compose。
首先，您需要创建一个目录，在其中创建必要的文件和目录。
cd /home/username mkdir my-clickhouse cd my-clickhouse 然后你需要创建一个目录来存储 ClickHouse 数据。
mkdir db 最后一步是创建 docker-compose.yml 文件。
version: '3' services: ch_server: image: yandex/clickhouse-server ports: - &amp;quot;8123:8123&amp;quot; volumes: - ./db:/var/lib/clickhouse networks: - ch_ntw ch_client: image: yandex/clickhouse-client entrypoint: - /bin/sleep command: - infinity networks: - ch_ntw networks: ch_ntw: driver: bridge ipam: config: - subnet: 10.222.1.0/24 让我们检查一下我们做了什么。一个文件（docker-compose.yml）和一个目录（db）。</description></item><item><title>LeetCode 回文串系列</title><link>/study/leetcode/leetcode-palindromic/</link><pubDate>Wed, 16 Mar 2022 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/leetcode-palindromic/</guid><description>剑指 Offer II 018. 有效的回文 剑指 Offer II 086. 分割回文子字符串 剑指 Offer II 020. 回文子字符串的个数 336. 回文对 125. 验证回文串 647. 回文子串 680. 验证回文字符串 Ⅱ 409. 最长回文串 131. 分割回文串 https://leetcode-cn.com/submissions/detail/152376203/ 132. 分割回文串 II 1278. 分割回文串 III 1745. 回文串分割 IV 5. 最长回文子串 1616. 分割两个字符串得到回文串 42. 接雨水 268. 丢失的数字 688. 骑士在棋盘上的概率 1005. K 次取反后最大化的数组和 1380. 矩阵中的幸运数</description></item><item><title>LeetCode每日一题</title><link>/study/leetcode/2022-03-04-leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</link><pubDate>Tue, 01 Mar 2022 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/2022-03-04-leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</guid><description>(03-25) 892. 三维形体的表面积 class Solution { /** * @param Integer[][] $grid * @return Integer */ function surfaceArea($grid) { $n = count($grid); $area = 0; for ($i = 0; $i &amp;lt; $n; $i++) { for ($j = 0; $j &amp;lt; $n; $j++) { $level = $grid[$i][$j]; if ($level &amp;gt; 0) { //贡献的面积 &amp;lt;&amp;lt; 2 相当于 * 4 $area += 2 + ($level &amp;lt;&amp;lt; 2); //减去重合的面积 &amp;lt;&amp;lt; 1 相当于 * 2 $area -= $i &amp;gt; 0 ? min($level, $grid[$i - 1][$j]) &amp;lt;&amp;lt; 1 : 0; //减去重合的面积 $area -= $j &amp;gt; 0 ?</description></item><item><title>2022年02月LeetCode每日一题</title><link>/study/leetcode/2022-02-00-leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</link><pubDate>Tue, 01 Feb 2022 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/2022-02-00-leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</guid><description>20220216 1719. 重构一棵树的方案数 困难 func checkWays(pairs [][]int) int { adj := map[int]map[int]bool{} for _, p := range pairs { x, y := p[0], p[1] if adj[x] == nil { adj[x] = map[int]bool{} } adj[x][y] = true if adj[y] == nil { adj[y] = map[int]bool{} } adj[y][x] = true } // 检测是否存在根节点 root := -1 for node, neighbours := range adj { if len(neighbours) == len(adj)-1 { root = node break } } if root == -1 { return 0 } ans := 1 for node, neighbours := range adj { if node == root { continue } currDegree := len(neighbours) parent := -1 parentDegree := math.</description></item><item><title>使用Docker一分钟搭建免费VPN</title><link>/cloud-native/%E4%BD%BF%E7%94%A8docker%E4%B8%80%E5%88%86%E9%92%9F%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9vpn/</link><pubDate>Fri, 17 Dec 2021 09:00:48 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/cloud-native/%E4%BD%BF%E7%94%A8docker%E4%B8%80%E5%88%86%E9%92%9F%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9vpn/</guid><description>在这个简短的指南中，我将向您展示如何使用现有的 Docker 镜像快速安装 OpenVPN 服务器。可以安装 OpenVPN 服务器，但使用 Docker 一切都容易得多。您无需购买第三方服务，一切都是完全免费的。
您必须拥有自己的 VPS 服务器。如果没有，您可以在 DigitalOcean 上购买 VPS。您可以购买最便宜的，每月 2 美元到 5 美元不等。
我将使用基于 Docker 的现成 VPN 解决方案：https://github.com/kylemanna/docker-openvpn 第一步所需要做的就是安装 Docker。我使用 Ubuntu 操作系统。 如果安装了 Docker，让我们继续下一步。
我将使用以下变量：
ovpn-data-example-uk - 用于数据量容器。
vpn.yourdomain.com - 该值应该是域名或 IP 地址。
uk.vpn.yourdomain.com - 它将用作客户端定义。
这些变量是测试变量。你必须使用你的变量。
让我们从创建 docker 卷开始。
docker volume create -- name ovpn - data - example - uk 下一步是初始化容器。
docker run \ -v ovpn-data-example-uk:/etc/openvpn \ --log-driver=none \ --rm \ kylemanna/openvpn \ ovpn_genconfig \ -u udp://vpn.yourdomain.com 容器将要求您输入密码来保护新生成的证书颁发机构使用的私钥。</description></item><item><title>云原生训练营作业</title><link>/cloud-native/work/</link><pubDate>Sun, 12 Dec 2021 18:53:48 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/cloud-native/work/</guid><description>资料 https://cncamp.notion.site/cncamp/kubernetes-8a9d48ee26284b3c8ddf9de4c62ea895 模块一：Go 语言特性 无作业
模块二：Go语言进阶 必做 编写一个 HTTP 服务器，大家视个人不同情况决定完成到哪个环节，但尽量把 1 都做完。
接收客户端 request，并将 request 中带的 header 写入 response header 读取当前系统的环境变量中的 VERSION 配置，并写入 response header Server 端记录访问日志包括客户端 IP，HTTP 返回码，输出到 server 端的标准输出 当访问 localhost/healthz 时，应返回 200 作业提交链接： https://jinshuju.net/f/PlZ3xg 提交截止时间：10 月 7 日晚 23:59 前
模块三：Docker核心技术 必做 构建本地镜像。 编写 Dockerfile 将练习 2.2 编写的 httpserver 容器化（请思考有哪些最佳实践可以引入到 Dockerfile 中来）。 将镜像推送至 Docker 官方镜像仓库。 通过 Docker 命令本地启动 httpserver。 通过 nsenter 进入容器查看 IP 配置。 作业需编写并提交 Dockerfile 及源代码。
作业提交链接： https://jinshuju.net/f/rxeJhn 提交截止时间：10 月 17 日 23:59</description></item><item><title>cert-manager 和 alidns-webhook 安装</title><link>/cloud-native/cert-manager/</link><pubDate>Wed, 08 Dec 2021 20:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/cloud-native/cert-manager/</guid><description>安装 https://cert-manager.io/ https://cert-manager.io/docs/installation/helm/ helm repo add jetstack https://charts.jetstack.io helm repo update # kubectl apply -f https://github.com/jetstack/cert-manager/releases/download/v1.6.1/cert-manager.crds.yaml wget https://hub.fastgit.org/jetstack/cert-manager/releases/download/v1.6.1/cert-manager.crds.yaml kubectl apply -f cert-manager.crds.yaml helm install \ cert-manager jetstack/cert-manager \ --namespace cert-manager \ --create-namespace \ --version v1.6.1 # alidns https://github.com/DEVmachine-fr/cert-manager-alidns-webhook helm repo add cert-manager-alidns-webhook https://devmachine-fr.github.io/cert-manager-alidns-webhook helm repo update helm install --namespace cert-manager alidns-webhook cert-manager-alidns-webhook/alidns-webhook helm template --namespace cert-manager alidns-webhook cert-manager-alidns-webhook/alidns-webhook kubectl create secret generic alidns-secrets --from-literal=&amp;quot;access-token=AccessKey ID&amp;quot; --from-literal=&amp;quot;secret-key=AccessKey Secret&amp;quot; 卸载 kubectl get Issuers,ClusterIssuers,Certificates,CertificateRequests,Orders,Challenges --all-namespaces helm --namespace cert-manager delete cert-manager kubectl delete namespace cert-manager kubectl delete -f cert-manager.</description></item><item><title>Tars服务容器化</title><link>/cloud-native/tars%E5%AE%B9%E5%99%A8%E5%8C%96/</link><pubDate>Thu, 25 Nov 2021 13:30:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/cloud-native/tars%E5%AE%B9%E5%99%A8%E5%8C%96/</guid><description>tars容器化逻辑 tars 协议文件 module tars { struct AdapterConf{ 0 require string servant; 1 require string endpoint; 2 optional string protocol; 3 optional int maxConns; 4 optional int threadNum; 5 optional int queueCap; 6 optional int queueTimeout; }; struct onStartupReq{ 0 require string nodeName; 1 require string application; 2 require string server; 3 optional string setID; 4 optional vector&amp;lt;AdapterConf&amp;gt; adapters; 5 optional bool disableFlow; 6 optional string State = &amp;quot;active&amp;quot;; 7 optional string Version; 8 optional string templateName; 9 optional string serverType; }; struct onPrestopReq{ 0 require string nodeName; 1 optional string application; 2 optional string server; }; struct keepAliveReq{ 0 require string nodeName; 1 require string state; // inactive or active 2 optional string application; 3 optional string server; }; struct RegisterMetricsReq{ 0 require string nodeName; 1 require string application; 2 require string server; 3 require int metricsPort; }; struct GetMetricsAdaptersReq{ 0 optional map&amp;lt;string, string&amp;gt; filter; // enable in feature }; struct MetricsAdapterInfo{ 0 optional vector&amp;lt;string&amp;gt; targets; 1 optional map&amp;lt;string, string&amp;gt; labels; }; interface tarsregistry { void onStartup(onStartupReq req); void onPrestop(onPrestopReq req); void keepAlive(keepAliveReq req); void registerMetrics(RegisterMetricsReq req); void getMetricsAdapters(GetMetricsAdaptersReq req, out vector&amp;lt;MetricsAdapterInfo&amp;gt; rsp); }; }; onStartup -- 增加 t_node_info 记录	insert into t_node_info(node_name, node_obj, endpoint_ip, endpoint_port, last_reg_time, last_heartbeat, setting_state, present_state) values(?</description></item><item><title>云原生常用学习网址</title><link>/cloud-native/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%B8%B8%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%BD%91%E5%9D%80/</link><pubDate>Tue, 23 Nov 2021 09:53:48 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/cloud-native/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%B8%B8%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%BD%91%E5%9D%80/</guid><description>软件版本（孟老师的建议）
Go：1.17 Docker：20.10.8 K8s：1.22.0 Istio：1.9 服务器或本机环境配置要求：
本机如果能创建4核CPU 12G内存，30G磁盘的虚拟机就可以 如果用云主机建议类似配置，如果选择更小的服务器比如4C 8G，建议至少两台 如果更小的2C 4G服务器，至少三台 更小的服务器不适合 训练营所有示例代码，都放在孟凡杰老师的 Github：https://github.com/cncamp/golang Go 语言官网：https://golang.google.cn/dl/
下载并安装 Go 的编程工具：https://code.visualstudio.com/download
安装 Go 语言插件：https://marketplace.visualstudio.com/items?itemName=golang.go
下载并安装 Git Command Line：https://git-scm.com/downloads
从老师的 Github 上下载代码的命令行：git clone https://github.com/cncamp/golang.git Golang Playground（可以直接在网页里编写和运行 Go 语言程序）：https://play.golang.org/
国内可以访问的 Playground：https://goplay.tools/
Go 语言教程（Go Bible）：https://docs.hacknode.org/gopl-zh/ch1/ch1-01.html
Golang 调度原理：https://learnku.com/articles/41728
Go Channel 原理：https://www.ardanlabs.com/blog/2014/02/the-nature-of-channels-in-go.html
Go Channel 原理（中文博客）：https://juejin.cn/post/6844904016254599176
Go 语言高性能 httpserver 代码实现细节：https://pouncing-waterfall-7c4.notion.site/http-server-socket-detail-e1f350d63c7c4d9f86ce140949bd90c2
模块二 K8s 日常运维代码调试场景案例（空指针）：https://github.com/kubernetes/kubernetes/pull/102229
模块二 K8s 日常运维代码调试场景案例（kube-proxy）：https://github.com/kubernetes/kubernetes/pull/79444
Makefiles 教程：https://makefiletutorial.com/
cgroupfs cgroup 和 systemd 有什么区别：https://www.codenong.com/cs109603870/
关注公众号获得更多精彩文章</description></item><item><title>Hugo + Github Actions 实现自动化部署</title><link>/2021/11/20/hugo--github-actions-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</link><pubDate>Sat, 20 Nov 2021 20:33:21 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2021/11/20/hugo--github-actions-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</guid><description>参考连接 Hugo + Github Actions 实现自动化部署 GitHub Actions 实战 - 用 Hugo 自动构建 搭建 GitHub Pages HUGO + Github + Github Action持续集成部署个人博客 使用 Markdown 在 hugo 帖子内容中创建带有 &amp;rsquo;target=&amp;quot;_blank&amp;quot;&amp;rsquo; 的链接吗？ 您需要在/layouts/_default/_markup/ called处创建一个新文件render-link.html
在该文件中，您可以将其自定义为：
&amp;lt;a href=&amp;quot;{{ .Destination | safeURL }}&amp;quot;{{ with .Title}} title=&amp;quot;{{ . }}&amp;quot;{{ end }}{{ if strings.HasPrefix .Destination &amp;quot;http&amp;quot; }} target=&amp;quot;_blank&amp;quot; rel=&amp;quot;noopener&amp;quot;{{ end }}&amp;gt;{{ .Text | safeHTML }}&amp;lt;/a&amp;gt; 以下是会发生的情况：
- [link1](../something/ title=&amp;quot;title&amp;quot;) =&amp;gt; &amp;lt;a href=&amp;quot;../something/&amp;quot; title=&amp;quot;title&amp;quot;&amp;gt;link1&amp;lt;/a&amp;gt; - [link2](https://example.com) =&amp;gt; &amp;lt;a href=&amp;quot;https://example.com&amp;quot;&amp;gt;link2&amp;lt;/a&amp;gt; 它只会将其添加到带有“http”和“https”的 URL。
渲染挂钩的文档可在此处获得：https://gohugo.io/templates/render-hooks/ 关注公众号获得更多精彩文章</description></item><item><title>Docker修改默认网段</title><link>/2021/11/20/docker%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E7%BD%91%E6%AE%B5/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2021/11/20/docker%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E7%BD%91%E6%AE%B5/</guid><description>cat /etc/docker/daemon.json { &amp;quot;registry-mirrors&amp;quot;: [ &amp;quot;https://mirror.ccs.tencentyun.com&amp;quot; ], &amp;quot;bip&amp;quot;:&amp;quot;192.168.100.1/24&amp;quot; } 关注公众号获得更多精彩文章</description></item><item><title>fabric一些简单用法总结</title><link>/2021/11/20/fabric%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2021/11/20/fabric%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</guid><description>1.支持中文
#!/usr/bin/python env # -*- coding: utf-8 -*- 2.支持颜色
from fabric.colors import * print(red(&amp;quot;红色&amp;quot;) + green(&amp;quot;绿色&amp;quot;，bold=False) + blue(&amp;quot;蓝色&amp;quot;,bold=True) + white(&amp;quot;白色&amp;quot;) + yellow(&amp;quot;黄色&amp;quot;) + cyan(&amp;quot;蓝绿色&amp;quot;) + magenta(&amp;quot;品红色&amp;quot;)) 3.设置主机组及账号密码
主机密码不同时：
env.hosts = ['tomcat@192.168.244.128','tomcat@192.168.244.129'] env.passwords = {'tomcat@192.168.244.128:22':'111111','tomcat@192.168.244.129:22':'111111'} 主机密码相同时:
env.hosts=[ 'tomcat@192.168.244.128:22', 'tomcat@192.168.244.129:22', ] env.password = '1111' 使用ssh keyfile:
env.key_filename = ['/opt/fab/server_key'] env.user = 'tomcat' env.password = '111111' env.port = '2862' 4.运行shell命令
在本地运行命令:
local('pwd') local('set -m ; /etc/init.d/tomcat restart') # 如果是脚本，要加set -m 支持后台执行并返回状态，否则会报错 在服务器上运行命令:
run('uname -a') 5.切换目录执行
with cd('/opt/tomcat') run('set -m ; .</description></item><item><title>LeetCode</title><link>/study/leetcode/leetcode/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/leetcode/</guid><description>数组和链表 206. 反转链表 24. 两两交换链表中的节点 141. 环形链表 142. 环形链表 II 24. 两两交换链表中的节点 21. 合并两个有序链表 25.K 个一组翻转链表 86.分隔链表 92.反转链表 II /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* reverseBetween(ListNode* head, int m, int n) { int change_len = n - m + 1; ListNode *pre_head = NULL; ListNode *result = head; while (head &amp;amp;&amp;amp; --m) { pre_head = head; head = head-&amp;gt;next; } ListNode *modify_list_tail = head; ListNode *new_head = NULL; while (head &amp;amp;&amp;amp; change_len--) { ListNode *next = head-&amp;gt;next; head-&amp;gt;next = new_head; new_head = head; head = next; } //连接为翻转部分 modify_list_tail-&amp;gt;next = head; if (pre_head) { pre_head-&amp;gt;next = new_head; } else { result = new_head; } return result; } }; /** * Definition for a singly-linked list.</description></item><item><title>nginx lua直接阶段</title><link>/2021/11/20/nginx-lua%E7%9B%B4%E6%8E%A5%E9%98%B6%E6%AE%B5/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2021/11/20/nginx-lua%E7%9B%B4%E6%8E%A5%E9%98%B6%E6%AE%B5/</guid><description>对刚接触Ngx_lua的读者来说，可能会存在下面两个困惑。
1、Lua在Nginx的哪些阶段可以执行代码？ 2、Lua在Nginx的每个阶段可以执行哪些操作？
只有理解了这两个问题，才能在业务中巧妙地利用Ngx_Lua来完成各项需求。
Nginx的11个执行阶段，每个阶段都有自己能够执行的指令，并可以实现不同的功能。Ngx_Lua的功能大部分是基于Nginx这11个执行阶段开发和配置的，Lua代码在这些指令块中执行，并依赖于它们的执行顺序。本章将对Ngx_Lua的执行阶段进行一一讲解。
一、 init_by_lua_block init_by_lua_block是init_by_lua的替代版本，在OpenResty 1.9.3.1或Lua-Nginx-Modulev 0.9.17之前使用的都是init_by_lua。init_by_lua_block比init_by_lua更灵活，所以建议优先选用init_by_lua_block。 本章中的执行阶段都采用*_block格式的指令，后续不再说明。
1.1　阶段说明 语法：init_by_lua_block {lua-script-str} 配置环境：http 阶段：loading-config 含义：当Nginx的master进程加载Nginx配置文件（加载或重启Nginx进程）时，会在全局的Lua VM（Virtual Machine，虚拟机）层上运行 指定的代码，每次当Nginx获得HUP（即Hangup）重载信号加载进程时，代码都会被重新执行。
1.2　初始化配置 在loading-config阶段一般会执行如下操作。 1．初始化Lua全局变量，特别适合用来处理在启动master进程时就要求存在的数据，对CPU消耗较多的功能也可以在此处处理。 2．预加载模块。 3．初始化lua_shared_dict共享内存的数据（关于共享内存详见第10章）。 示例如下：
user webuser webuser; worker_processes 1; worker_rlimit_nofile 10240; events { use epoll; worker_connections 10240; } http { include mime.types; default_type application/octet-stream; log_format main '$remote_addr-$remote_user[$time_local] &amp;quot;$request&amp;quot; ' '$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; ' '&amp;quot;$http_user_agent&amp;quot; &amp;quot;$http_x_forwarded_for&amp;quot; &amp;quot;$request_time&amp;quot; &amp;quot;$upstream_addr $upstream_status $upstream_response_time&amp;quot; &amp;quot;upstream_time_sum:$upstream_time_sum&amp;quot; &amp;quot;jk_uri:$jk_uri&amp;quot;'; access_log logs/access.log main; sendfile on; keepalive_timeout 65; lua_package_path &amp;quot;/usr/local/nginx_1.12.2/conf/lua_modules/?.lua;;&amp;quot;; lua_package_cpath &amp;quot;/usr/local/nginx_1.</description></item><item><title>OpenVpn搭建</title><link>/2021/11/20/openvpn%E6%90%AD%E5%BB%BA/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2021/11/20/openvpn%E6%90%AD%E5%BB%BA/</guid><description>初始化 # 证书密码见服务器 mm.md # 创建目录 mkdir -p /data/openvpn/conf # 初始化 openvpn 配置 docker run -v /data/openvpn:/etc/openvpn --rm kylemanna/openvpn ovpn_genconfig -u udp://vpn.lbbniu.com # 初始化证书 根据提示数据证书密码和组织名称 docker run -v /data/openvpn:/etc/openvpn --rm -ti kylemanna/openvpn ovpn_initpki # 增加用户 docker run -v /data/openvpn:/etc/openvpn --rm -ti kylemanna/openvpn easyrsa build-client-full lbbniu nopass # 导出用户配置文件 docker run -v /data/openvpn:/etc/openvpn --rm -ti kylemanna/openvpn ovpn_getclient lbbniu &amp;gt; /data/openvpn/conf/lbbniu.ovpn # 启动服务 docker run --name openvpn -v /data/openvpn:/etc/openvpn -d -p 1194:1194/udp --cap-add=NET_ADMIN kylemanna/openvpn 添加用户脚本 #!/bin/bash # openvpn_useradd.</description></item><item><title>第八课动态规划</title><link>/study/batj%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/8.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/batj%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/8.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid><description>70. 爬楼梯 class Solution { public: int climbStairs(int n) { std::vector&amp;lt;int&amp;gt; dp(n + 3, 0); dp[1] = 1; dp[2] = 1; for (int i = 3; i &amp;lt;= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; } }; 198. 打家劫舍 class Solution { public: int rob(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.size() == 0) { return 0; } if (nums.size() == 1) { return nums[0]; } //设第一个房间的最优解dp[i] std::vector&amp;lt;int&amp;gt; dp(nums.size(), 0); dp[0] = nums[0]; dp[1] = std::max(nums[0], nums[1]); for (int i = 2; i &amp;lt; nums.</description></item><item><title>解决k8s相关组件安装镜像无法拉取</title><link>/cloud-native/k8s-install/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/cloud-native/k8s-install/</guid><description>替换阿里云 docker pull registry.aliyuncs.com/google_containers/ docker tag registry.aliyuncs.com/google_containers/ k8s.gcr.io/sig-storage/ docker rmi registry.aliyuncs.com/google_containers/ rook 镜像 docker pull registry.aliyuncs.com/google_containers/csi-node-driver-registrar:v2.3.0 docker tag registry.aliyuncs.com/google_containers/csi-node-driver-registrar:v2.3.0 k8s.gcr.io/sig-storage/csi-node-driver-registrar:v2.3.0 docker rmi registry.aliyuncs.com/google_containers/csi-node-driver-registrar:v2.3.0 docker pull registry.aliyuncs.com/google_containers/csi-provisioner:v3.0.0 docker tag registry.aliyuncs.com/google_containers/csi-provisioner:v3.0.0 k8s.gcr.io/sig-storage/csi-provisioner:v3.0.0 docker rmi registry.aliyuncs.com/google_containers/csi-provisioner:v3.0.0 docker pull registry.aliyuncs.com/google_containers/csi-resizer:v1.3.0 docker tag registry.aliyuncs.com/google_containers/csi-resizer:v1.3.0 k8s.gcr.io/sig-storage/csi-resizer:v1.3.0 docker rmi registry.aliyuncs.com/google_containers/csi-resizer:v1.3.0 docker pull registry.aliyuncs.com/google_containers/csi-attacher:v3.3.0 docker tag registry.aliyuncs.com/google_containers/csi-attacher:v3.3.0 k8s.gcr.io/sig-storage/csi-attacher:v3.3.0 docker rmi registry.aliyuncs.com/google_containers/csi-attacher:v3.3.0 docker pull registry.aliyuncs.com/google_containers/csi-snapshotter:v4.2.0 docker tag registry.aliyuncs.com/google_containers/csi-snapshotter:v4.2.0 k8s.gcr.io/sig-storage/csi-snapshotter:v4.2.0 docker rmi registry.aliyuncs.com/google_containers/csi-snapshotter:v4.2.0 ingress-nginx 镜像 docker pull registry.aliyuncs.com/google_containers/nginx-ingress-controller:v1.0.0 docker tag registry.aliyuncs.com/google_containers/nginx-ingress-controller:v1.0.0 k8s.gcr.io/ingress-nginx/controller:v1.0.0 docker rmi registry.aliyuncs.com/google_containers/nginx-ingress-controller:v1.0.0 docker pull registry.</description></item><item><title>静态博客工具</title><link>/2021/11/20/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2021/11/20/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7/</guid><description> ruby 编写的 Jekyll [GitHub Pages支持]
Node.js 编写的 Hexo
Vue.js 编写的 vuepress
Go 编写的 Hugo
Python 编写的 Pelican
以及更人性化的 Gridea
GitHub Pages 搭建教程 hugo相关博客</description></item><item><title>临时记录</title><link>/temp/</link><pubDate>Sat, 20 Nov 2021 15:22:23 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/temp/</guid><description>Go Go程序员面试笔试宝典 https://github.com/golang-design/go-questions NoSay Mac 工具 Cutter draw.io MachOView dbeaver licecap130 Sequel-Pro 云原生 https://kubernetes.io/zh/docs/tasks/extend-kubectl/kubectl-plugins/ https://github.com/kubernetes/sample-cli-plugin https://mp.weixin.qq.com/s/r7RzGUuem1GPuKnLc8XEuw kubectl 插件 https://krew.sigs.k8s.io/plugins/ knew # https://krew.sigs.k8s.io/docs/user-guide/setup/install/ ( set -x; cd &amp;quot;$(mktemp -d)&amp;quot; &amp;amp;&amp;amp; OS=&amp;quot;$(uname | tr '[:upper:]' '[:lower:]')&amp;quot; &amp;amp;&amp;amp; ARCH=&amp;quot;$(uname -m | sed -e 's/x86_64/amd64/' -e 's/\(arm\)\(64\)\?.*/\1\2/' -e 's/aarch64$/arm64/')&amp;quot; &amp;amp;&amp;amp; KREW=&amp;quot;krew-${OS}_${ARCH}&amp;quot; &amp;amp;&amp;amp; curl -fsSLO &amp;quot;https://github.com/kubernetes-sigs/krew/releases/latest/download/${KREW}.tar.gz&amp;quot; &amp;amp;&amp;amp; tar zxvf &amp;quot;${KREW}.tar.gz&amp;quot; &amp;amp;&amp;amp; ./&amp;quot;${KREW}&amp;quot; install krew ) export PATH=&amp;quot;${KREW_ROOT:-$HOME/.krew}/bin:$PATH&amp;quot; 数据库 redis 集群/Proxy： Twemproxy、Codis、Redis Cluster
dbproxy： 小米Gaea、MyCat、ShardingSphere
dts： maxwell、canal
MySQL HA： MMM | MHA | orchestrator | XenON | arksentinel | MGR | PXC</description></item><item><title>临时记录整理</title><link>/cloud-native/temp1/</link><pubDate>Sat, 20 Nov 2021 15:22:23 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/cloud-native/temp1/</guid><description>QCon大会演讲 Go Go程序员面试笔试宝典 https://github.com/golang-design/go-questions NoSay 理解 reflect elem 和 value 的一段测试代码 gorm 源码阅读之 callback gorm 源码阅读之 schema knew # https://krew.sigs.k8s.io/docs/user-guide/setup/install/ ( set -x; cd &amp;quot;$(mktemp -d)&amp;quot; &amp;amp;&amp;amp; OS=&amp;quot;$(uname | tr '[:upper:]' '[:lower:]')&amp;quot; &amp;amp;&amp;amp; ARCH=&amp;quot;$(uname -m | sed -e 's/x86_64/amd64/' -e 's/\(arm\)\(64\)\?.*/\1\2/' -e 's/aarch64$/arm64/')&amp;quot; &amp;amp;&amp;amp; KREW=&amp;quot;krew-${OS}_${ARCH}&amp;quot; &amp;amp;&amp;amp; curl -fsSLO &amp;quot;https://github.com/kubernetes-sigs/krew/releases/latest/download/${KREW}.tar.gz&amp;quot; &amp;amp;&amp;amp; tar zxvf &amp;quot;${KREW}.tar.gz&amp;quot; &amp;amp;&amp;amp; ./&amp;quot;${KREW}&amp;quot; install krew ) export PATH=&amp;quot;${KREW_ROOT:-$HOME/.krew}/bin:$PATH&amp;quot; Java进阶实战 数据库 redis proxy: twemproxy
dbproxy: 小米Gaea、mycat、ShardingSphere
dts: maxwell、canal
MySQL HA: MMM | MHA | orchestrator | XenON | arksentinel | MGR | PXC</description></item><item><title>云原生临时记录</title><link>/cloud-native/temp/</link><pubDate>Sat, 20 Nov 2021 15:22:23 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/cloud-native/temp/</guid><description>Crane Crane-Colocation crane-full-capabilities 云原生 https://kubernetes.io/zh/docs/tasks/extend-kubectl/kubectl-plugins/ https://github.com/kubernetes/sample-cli-plugin https://mp.weixin.qq.com/s/r7RzGUuem1GPuKnLc8XEuw kubectl plugin https://krew.sigs.k8s.io/plugins/ 首先得出一个设计的proposal看下，包括原理，设计，代码结构，功能等 用插件扩展 kubectl 使用 Go 从零开发并发布一个 Kubectl 插件 https://github.com/kubernetes/sample-cli-plugin question 删除namespace为什么会Terminating？ kubectl get ns kubesphere-controls-system -o json | jq '.spec.finalizers=[]' &amp;gt; ns-without-finalizers.json cat ns-without-finalizers.json kubectl get ns kubesphere-monitoring-system -o json | jq '.metadata.finalizers=[]' &amp;gt; ns-without-finalizers.json cat ns-without-finalizers.json kubectl proxy &amp;amp; PID=$! curl -X PUT http://localhost:8001/api/v1/namespaces/kubesphere-monitoring-system/finalize -H &amp;quot;Content-Type: application/json&amp;quot; --data-binary @ns-without-finalizers.json kill $ID helm repo add gocrane https://finops-helm.pkg.coding.net/gocrane/gocrane helm repo add prometheus-community https://finops-helm.pkg.coding.net/gocrane/prometheus-community helm repo add grafana https://finops-helm.</description></item></channel></rss>