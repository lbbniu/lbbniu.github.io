<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>单调队列 on lbbniu</title><link>/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</link><description>Recent content in 单调队列 on lbbniu</description><generator>Hugo -- gohugo.io</generator><language>zh</language><managingEditor>lbbniu@gmail.com (lbbniu)</managingEditor><webMaster>lbbniu@gmail.com (lbbniu)</webMaster><copyright>&amp;copy; 2021 &lt;a href="https://blog.lbbniu.com/">lbbniu&lt;/a></copyright><lastBuildDate>Mon, 05 Dec 2022 00:01:00 +0800</lastBuildDate><atom:link href="/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/index.xml" rel="self" type="application/rss+xml"/><item><title>剑指 Offer 59 - I 滑动窗口的最大值</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/hua-dong-chuang-kou-de-zui-da-zhi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/hua-dong-chuang-kou-de-zui-da-zhi-lcof/</guid><description>剑指 Offer 59 - I 滑动窗口的最大值 给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。
示例:
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 输出: [3,3,5,5,6,7] 解释: 滑动窗口的位置 最大值 --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 &amp;nbsp;</description></item><item><title>剑指 Offer 59 - II 队列的最大值</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/dui-lie-de-zui-da-zhi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/dui-lie-de-zui-da-zhi-lcof/</guid><description>剑指 Offer 59 - II 队列的最大值 请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。
若队列为空，pop_front 和 max_value&amp;nbsp;需要返回 -1
示例 1：
输入: [&amp;quot;MaxQueue&amp;quot;,&amp;quot;push_back&amp;quot;,&amp;quot;push_back&amp;quot;,&amp;quot;max_value&amp;quot;,&amp;quot;pop_front&amp;quot;,&amp;quot;max_value&amp;quot;] [[],[1],[2],[],[],[]] 输出:&amp;nbsp;[null,null,null,2,1,2] 示例 2：
输入: [&amp;quot;MaxQueue&amp;quot;,&amp;quot;pop_front&amp;quot;,&amp;quot;max_value&amp;quot;] [[],[],[]] 输出:&amp;nbsp;[null,-1,-1] &amp;nbsp;
限制：
1 &amp;lt;= push_back,pop_front,max_value的总操作数&amp;nbsp;&amp;lt;= 10000 1 &amp;lt;= value &amp;lt;= 10^5 type MaxQueue struct { } func Constructor() MaxQueue { } func (this *MaxQueue) Max_value() int { } func (this *MaxQueue) Push_back(value int) { } func (this *MaxQueue) Pop_front() int { } /** * Your MaxQueue object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.</description></item><item><title>面试题59 - II 队列的最大值</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/dui-lie-de-zui-da-zhi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/dui-lie-de-zui-da-zhi-lcof/</guid><description>面试题59 - II 队列的最大值 请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。
若队列为空，pop_front 和 max_value&amp;nbsp;需要返回 -1
示例 1：
输入: [&amp;quot;MaxQueue&amp;quot;,&amp;quot;push_back&amp;quot;,&amp;quot;push_back&amp;quot;,&amp;quot;max_value&amp;quot;,&amp;quot;pop_front&amp;quot;,&amp;quot;max_value&amp;quot;] [[],[1],[2],[],[],[]] 输出:&amp;nbsp;[null,null,null,2,1,2] 示例 2：
输入: [&amp;quot;MaxQueue&amp;quot;,&amp;quot;pop_front&amp;quot;,&amp;quot;max_value&amp;quot;] [[],[],[]] 输出:&amp;nbsp;[null,-1,-1] &amp;nbsp;
限制：
1 &amp;lt;= push_back,pop_front,max_value的总操作数&amp;nbsp;&amp;lt;= 10000 1 &amp;lt;= value &amp;lt;= 10^5 type MaxQueue struct { } func Constructor() MaxQueue { } func (this *MaxQueue) Max_value() int { } func (this *MaxQueue) Push_back(value int) { } func (this *MaxQueue) Pop_front() int { } /** * Your MaxQueue object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.</description></item><item><title>【2022-12-05每日一题】1687. 从仓库到码头运输箱子[Hard]</title><link>/study/leetcode/delivering-boxes-from-storage-to-ports/</link><pubDate>Mon, 05 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/delivering-boxes-from-storage-to-ports/</guid><description>2022-12-05每日一题：1687. 从仓库到码头运输箱子 难度：Hard
标签：线段树 、 队列 、 数组 、 动态规划 、 单调队列 、 堆（优先队列）
你有一辆货运卡车，你需要用这一辆车把一些箱子从仓库运送到码头。这辆卡车每次运输有 箱子数目的限制 和 总重量的限制 。
给你一个箱子数组 boxes 和三个整数 portsCount, maxBoxes 和 maxWeight ，其中 boxes[i] = [ports​​i​, weighti] 。
ports​​i 表示第 i 个箱子需要送达的码头， weightsi 是第 i 个箱子的重量。 portsCount 是码头的数目。 maxBoxes 和 maxWeight 分别是卡车每趟运输箱子数目和重量的限制。 箱子需要按照 数组顺序 运输，同时每次运输需要遵循以下步骤：
卡车从 boxes 队列中按顺序取出若干个箱子，但不能违反 maxBoxes 和 maxWeight 限制。 对于在卡车上的箱子，我们需要 按顺序 处理它们，卡车会通过 一趟行程 将最前面的箱子送到目的地码头并卸货。如果卡车已经在对应的码头，那么不需要 额外行程 ，箱子也会立马被卸货。 卡车上所有箱子都被卸货后，卡车需要 一趟行程 回到仓库，从箱子队列里再取出一些箱子。 卡车在将所有箱子运输并卸货后，最后必须回到仓库。
请你返回将所有箱子送到相应码头的 最少行程 次数。
示例 1：
输入：boxes = [[1,1],[2,1],[1,1]], portsCount = 2, maxBoxes = 3, maxWeight = 3 输出：4 解释：最优策略如下： - 卡车将所有箱子装上车，到达码头 1 ，然后去码头 2 ，然后再回到码头 1 ，最后回到仓库，总共需要 4 趟行程。 所以总行程数为 4 。 注意到第一个和第三个箱子不能同时被卸货，因为箱子需要按顺序处理（也就是第二个箱子需要先被送到码头 2 ，然后才能处理第三个箱子）。 示例 2：</description></item><item><title>【2022-10-26每日一题】862. 和至少为 K 的最短子数组[Hard]</title><link>/study/leetcode/shortest-subarray-with-sum-at-least-k/</link><pubDate>Wed, 26 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/shortest-subarray-with-sum-at-least-k/</guid><description>2022-10-26每日一题：862. 和至少为 K 的最短子数组 难度：Hard
标签：队列 、 数组 、 二分查找 、 前缀和 、 滑动窗口 、 单调队列 、 堆（优先队列）
给你一个整数数组 nums 和一个整数 k ，找出 nums 中和至少为 k 的 最短非空子数组 ，并返回该子数组的长度。如果不存在这样的 子数组 ，返回 -1 。
子数组 是数组中 连续 的一部分。
&amp;nbsp;
示例 1：
输入：nums = [1], k = 1 输出：1 示例 2：
输入：nums = [1,2], k = 4 输出：-1 示例 3：
输入：nums = [2,-1,2], k = 3 输出：3 &amp;nbsp;
提示：
1 &amp;lt;= nums.length &amp;lt;= 105 -105 &amp;lt;= nums[i] &amp;lt;= 105 1 &amp;lt;= k &amp;lt;= 109 方法一：前缀和 + 单调双端队列 推荐题解 func shortestSubarray(nums []int, k int) int { n := len(nums) preSum := make([]int, n+1) for i, num := range nums { preSum[i+1] = preSum[i] + num // 计算前缀和 } ans := n + 1 q := []int{} for i, curSum := range preSum { for len(q) &amp;gt; 0 &amp;amp;&amp;amp; curSum - preSum[q[0]] &amp;gt;= k { ans = min(ans, i-q[0]) q = q[1:] // 上面计算后 q[0] 没有用了，直接移除 } for len(q) &amp;gt;0 &amp;amp;&amp;amp; preSum[q[len(q)-1]] &amp;gt;= curSum { q = q[:len(q)-1] // 移除队列中大约等于当前数的元素 } q = append(q, i) } if ans &amp;lt; n + 1 { return ans } return -1 } func min(a, b int) int { if a &amp;lt; b { return a } return b } 复杂度分析 LeetCode题库地址 https://leetcode.</description></item></channel></rss>