<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>矩阵 on lbbniu</title><link>/tags/%E7%9F%A9%E9%98%B5/</link><description>Recent content in 矩阵 on lbbniu</description><generator>Hugo -- gohugo.io</generator><language>zh</language><managingEditor>lbbniu@gmail.com (lbbniu)</managingEditor><webMaster>lbbniu@gmail.com (lbbniu)</webMaster><copyright>&amp;copy; 2021 &lt;a href="https://blog.lbbniu.com/">lbbniu&lt;/a></copyright><lastBuildDate>Thu, 10 Nov 2022 00:01:00 +0800</lastBuildDate><atom:link href="/tags/%E7%9F%A9%E9%98%B5/index.xml" rel="self" type="application/rss+xml"/><item><title>剑指 Offer 04 二维数组中的查找</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-wei-shu-zu-zhong-de-cha-zhao-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-wei-shu-zu-zhong-de-cha-zhao-lcof/</guid><description>剑指 Offer 04 二维数组中的查找 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
示例:
现有矩阵 matrix 如下：
[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。
给定 target = 20，返回 false。
限制：
0 &lt;= n &lt;= 1000
0 &lt;= m &lt;= 1000
注意：本题与主站 240 题相同：https://leetcode-cn.com/problems/search-a-2d-matrix-ii/
func findNumberIn2DArray(matrix [][]int, target int) bool { } LeetCode题库地址 https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof</description></item><item><title>面试题 01.07 旋转矩阵</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/rotate-matrix-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/rotate-matrix-lcci/</guid><description>面试题 01.07 旋转矩阵 给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。
不占用额外内存空间能否做到？
示例 1:
给定 matrix = [ [1,2,3], [4,5,6], [7,8,9] ], 原地旋转输入矩阵，使其变为: [ [7,4,1], [8,5,2], [9,6,3] ] 示例 2:
给定 matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], 原地旋转输入矩阵，使其变为: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ] 注意：本题与主站 48 题相同：https://leetcode-cn.com/problems/rotate-image/
func rotate(matrix [][]int) { } LeetCode题库地址 https://leetcode.cn/problems/rotate-matrix-lcci</description></item><item><title>面试题 01.08 零矩阵</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/zero-matrix-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/zero-matrix-lcci/</guid><description>面试题 01.08 零矩阵 编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。
&amp;nbsp;
示例 1：
输入： [ [1,1,1], [1,0,1], [1,1,1] ] 输出： [ [1,0,1], [0,0,0], [1,0,1] ] 示例 2：
输入： [ [0,1,2,0], [3,4,5,2], [1,3,1,5] ] 输出： [ [0,0,0,0], [0,4,5,0], [0,3,1,0] ] func setZeroes(matrix [][]int) { } LeetCode题库地址 https://leetcode.cn/problems/zero-matrix-lcci</description></item><item><title>剑指 Offer 12 矩阵中的路径</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ju-zhen-zhong-de-lu-jing-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ju-zhen-zhong-de-lu-jing-lcof/</guid><description>剑指 Offer 12 矩阵中的路径 给定一个&amp;nbsp;m x n 二维字符网格&amp;nbsp;board 和一个字符串单词&amp;nbsp;word 。如果&amp;nbsp;word 存在于网格中，返回 true ；否则，返回 false 。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
&amp;nbsp;
例如，在下面的 3×4 的矩阵中包含单词 "ABCCED"（单词中的字母已标出）。
&amp;nbsp;
示例 1：
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED" 输出：true 示例 2：
输入：board = [["a","b"],["c","d"]], word = "abcd" 输出：false &amp;nbsp;
提示：
m == board.length n = board[i].length 1 &amp;lt;= m, n &amp;lt;= 6 1 &amp;lt;= word.length &amp;lt;= 15 board 和 word 仅由大小写英文字母组成 注意：本题与主站 79 题相同：https://leetcode-cn.com/problems/word-search/
func exist(board [][]byte, word string) bool { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer II 013 二维子矩阵的和</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/o4ndxx/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/o4ndxx/</guid><description>剑指 Offer II 013 二维子矩阵的和 给定一个二维矩阵 matrix，以下类型的多个请求：
计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1,&amp;nbsp;col1) ，右下角为 (row2,&amp;nbsp;col2) 。 实现 NumMatrix 类：
NumMatrix(int[][] matrix)&amp;nbsp;给定整数矩阵 matrix 进行初始化 int sumRegion(int row1, int col1, int row2, int col2)&amp;nbsp;返回左上角 (row1,&amp;nbsp;col1)&amp;nbsp;、右下角&amp;nbsp;(row2,&amp;nbsp;col2)&amp;nbsp;的子矩阵的元素总和。 &amp;nbsp;
示例 1：
输入: [&amp;quot;NumMatrix&amp;quot;,&amp;quot;sumRegion&amp;quot;,&amp;quot;sumRegion&amp;quot;,&amp;quot;sumRegion&amp;quot;] [[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]] 输出: [null, 8, 11, 12] 解释: NumMatrix numMatrix = new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]]); numMatrix.sumRegion(2, 1, 4, 3); // return 8 (红色矩形框的元素总和) numMatrix.sumRegion(1, 1, 2, 2); // return 11 (绿色矩形框的元素总和) numMatrix.sumRegion(1, 2, 2, 4); // return 12 (蓝色矩形框的元素总和) &amp;nbsp;
提示：
m == matrix.length n == matrix[i].</description></item><item><title>剑指 Offer 29 顺时针打印矩阵</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shun-shi-zhen-da-yin-ju-zhen-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shun-shi-zhen-da-yin-ju-zhen-lcof/</guid><description>剑指 Offer 29 顺时针打印矩阵 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。
&amp;nbsp;
示例 1：
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,3,6,9,8,7,4,5] 示例 2：
输入：matrix =&amp;nbsp;[[1,2,3,4],[5,6,7,8],[9,10,11,12]] 输出：[1,2,3,4,8,12,11,10,9,5,6,7] &amp;nbsp;
限制：
0 &amp;lt;= matrix.length &amp;lt;= 100 0 &amp;lt;= matrix[i].length&amp;nbsp;&amp;lt;= 100 注意：本题与主站 54 题相同：https://leetcode-cn.com/problems/spiral-matrix/
func spiralOrder(matrix [][]int) []int { } LeetCode题库地址 https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof</description></item><item><title>剑指 Offer II 040 矩阵中最大的矩形</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/plyxkq/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/plyxkq/</guid><description>剑指 Offer II 040 矩阵中最大的矩形 给定一个由&amp;nbsp;0 和 1&amp;nbsp;组成的矩阵 matrix&amp;nbsp;，找出只包含 1 的最大矩形，并返回其面积。
注意：此题 matrix&amp;nbsp;输入格式为一维 01 字符串数组。
&amp;nbsp;
示例 1：
输入：matrix = ["10100","10111","11111","10010"] 输出：6 解释：最大矩形如上图所示。 示例 2：
输入：matrix = [] 输出：0 示例 3：
输入：matrix = ["0"] 输出：0 示例 4：
输入：matrix = ["1"] 输出：1 示例 5：
输入：matrix = ["00"] 输出：0 &amp;nbsp;
提示：
rows == matrix.length cols == matrix[0].length 0 &amp;lt;= row, cols &amp;lt;= 200 matrix[i][j] 为 '0' 或 '1' &amp;nbsp;
注意：本题与主站 85 题相同（输入参数格式不同）：&amp;nbsp;https://leetcode-cn.com/problems/maximal-rectangle/
func maximalRectangle(matrix []string) int { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 08.02 迷路的机器人</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/robot-in-a-grid-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/robot-in-a-grid-lcci/</guid><description>面试题 08.02 迷路的机器人 设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。设计一种算法，寻找机器人从左上角移动到右下角的路径。
网格中的障碍物和空位置分别用 1 和 0 来表示。
返回一条可行的路径，路径由经过的网格的行号和列号组成。左上角为 0 行 0 列。如果没有可行的路径，返回空数组。
示例&amp;nbsp;1:
输入: [ &amp;nbsp; [0,0,0], &amp;nbsp; [0,1,0], &amp;nbsp; [0,0,0] ] 输出: [[0,0],[0,1],[0,2],[1,2],[2,2]] 解释: 输入中标粗的位置即为输出表示的路径，即 0行0列（左上角） -&amp;gt; 0行1列 -&amp;gt; 0行2列 -&amp;gt; 1行2列 -&amp;gt; 2行2列（右下角） 说明：r&amp;nbsp;和 c 的值均不超过 100。
func pathWithObstacles(obstacleGrid [][]int) [][]int { } LeetCode题库地址 https://leetcode.cn/problems/robot-in-a-grid-lcci</description></item><item><title>剑指 Offer 47 礼物的最大价值</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/li-wu-de-zui-da-jie-zhi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/li-wu-de-zui-da-jie-zhi-lcof/</guid><description>剑指 Offer 47 礼物的最大价值 在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？
&amp;nbsp;
示例 1:
输入: [ &amp;nbsp; [1,3,1], &amp;nbsp; [1,5,1], &amp;nbsp; [4,2,1] ] 输出: 12 解释: 路径 1&amp;rarr;3&amp;rarr;5&amp;rarr;2&amp;rarr;1 可以拿到最多价值的礼物 &amp;nbsp;
提示：
0 &amp;lt; grid.length &amp;lt;= 200 0 &amp;lt; grid[0].length &amp;lt;= 200 func maxValue(grid [][]int) int { } LeetCode题库地址 https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof</description></item><item><title>面试题 08.10 颜色填充</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/color-fill-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/color-fill-lcci/</guid><description>面试题 08.10 颜色填充 编写函数，实现许多图片编辑软件都支持的「颜色填充」功能。
待填充的图像用二维数组 image 表示，元素为初始颜色值。初始坐标点的行坐标为 sr 列坐标为 sc。需要填充的新颜色为 newColor 。
「周围区域」是指颜色相同且在上、下、左、右四个方向上存在相连情况的若干元素。
请用新颜色填充初始坐标点的周围区域，并返回填充后的图像。
示例：
输入： image = [[1,1,1],[1,1,0],[1,0,1]] sr = 1, sc = 1, newColor = 2 输出：[[2,2,2],[2,2,0],[2,0,1]] 解释: 初始坐标点位于图像的正中间，坐标 (sr,sc)=(1,1) 。 初始坐标点周围区域上所有符合条件的像素点的颜色都被更改成 2 。 注意，右下角的像素没有更改为 2 ，因为它不属于初始坐标点的周围区域。 提示：
image 和 image[0] 的长度均在范围 [1, 50] 内。 初始坐标点 (sr,sc) 满足 0 &lt;= sr &lt; image.length 和 0 &lt;= sc &lt; image[0].length 。 image[i][j] 和 newColor 表示的颜色值在范围 [0, 65535] 内。 func floodFill(image [][]int, sr int, sc int, newColor int) [][]int { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 10.09 排序矩阵查找</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sorted-matrix-search-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sorted-matrix-search-lcci/</guid><description>面试题 10.09 排序矩阵查找 给定M&amp;times;N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。
示例:
现有矩阵 matrix 如下：
[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target&amp;nbsp;=&amp;nbsp;5，返回&amp;nbsp;true。
给定&amp;nbsp;target&amp;nbsp;=&amp;nbsp;20，返回&amp;nbsp;false。
func searchMatrix(matrix [][]int, target int) bool { } LeetCode题库地址 https://leetcode.cn/problems/sorted-matrix-search-lcci</description></item><item><title>面试题 16.04 井字游戏</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/tic-tac-toe-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/tic-tac-toe-lcci/</guid><description>面试题 16.04 井字游戏 设计一个算法，判断玩家是否赢了井字游戏。输入是一个 N x N 的数组棋盘，由字符&amp;quot; &amp;quot;，&amp;quot;X&amp;quot;和&amp;quot;O&amp;quot;组成，其中字符&amp;quot; &amp;quot;代表一个空位。
以下是井字游戏的规则：
玩家轮流将字符放入空位（&amp;quot; &amp;quot;）中。 第一个玩家总是放字符&amp;quot;O&amp;quot;，且第二个玩家总是放字符&amp;quot;X&amp;quot;。 &amp;quot;X&amp;quot;和&amp;quot;O&amp;quot;只允许放置在空位中，不允许对已放有字符的位置进行填充。 当有N个相同（且非空）的字符填充任何行、列或对角线时，游戏结束，对应该字符的玩家获胜。 当所有位置非空时，也算为游戏结束。 如果游戏结束，玩家不允许再放置字符。 如果游戏存在获胜者，就返回该游戏的获胜者使用的字符（&amp;quot;X&amp;quot;或&amp;quot;O&amp;quot;）；如果游戏以平局结束，则返回 &amp;quot;Draw&amp;quot;；如果仍会有行动（游戏未结束），则返回 &amp;quot;Pending&amp;quot;。
示例 1：
输入： board = [&amp;quot;O X&amp;quot;,&amp;quot; XO&amp;quot;,&amp;quot;X O&amp;quot;] 输出： &amp;quot;X&amp;quot; 示例 2：
输入： board = [&amp;quot;OOX&amp;quot;,&amp;quot;XXO&amp;quot;,&amp;quot;OXO&amp;quot;] 输出： &amp;quot;Draw&amp;quot; 解释： 没有玩家获胜且不存在空位 示例 3：
输入： board = [&amp;quot;OOX&amp;quot;,&amp;quot;XXO&amp;quot;,&amp;quot;OX &amp;quot;] 输出： &amp;quot;Pending&amp;quot; 解释： 没有玩家获胜且仍存在空位 提示：
1 &amp;lt;= board.length == board[i].length &amp;lt;= 100 输入一定遵循井字棋规则 func tictactoe(board []string) string { } LeetCode题库地址 https://leetcode.cn/problems/tic-tac-toe-lcci</description></item><item><title>面试题 16.19 水域大小</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/pond-sizes-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/pond-sizes-lcci/</guid><description>面试题 16.19 水域大小 你有一个用于表示一片土地的整数矩阵land，该矩阵中每个点的值代表对应地点的海拔高度。若值为0则表示水域。由垂直、水平或对角连接的水域为池塘。池塘的大小是指相连接的水域的个数。编写一个方法来计算矩阵中所有池塘的大小，返回值需要从小到大排序。
示例：
输入： [ [0,2,1,0], [0,1,0,1], [1,1,0,1], [0,1,0,1] ] 输出： [1,2,4] 提示：
0 &lt; len(land) &lt;= 1000 0 &lt; len(land[i]) &lt;= 1000 func pondSizes(land [][]int) []int { } LeetCode题库地址 https://leetcode.cn/problems/pond-sizes-lcci</description></item><item><title>面试题 16.22 兰顿蚂蚁</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/langtons-ant-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/langtons-ant-lcci/</guid><description>面试题 16.22 兰顿蚂蚁 一只蚂蚁坐在由白色和黑色方格构成的无限网格上。开始时，网格全白，蚂蚁面向右侧。每行走一步，蚂蚁执行以下操作。
(1) 如果在白色方格上，则翻转方格的颜色，向右(顺时针)转 90 度，并向前移动一个单位。
(2) 如果在黑色方格上，则翻转方格的颜色，向左(逆时针方向)转 90 度，并向前移动一个单位。
编写程序来模拟蚂蚁执行的前 K 个动作，并返回最终的网格。
网格由数组表示，每个元素是一个字符串，代表网格中的一行，黑色方格由&amp;nbsp;&amp;#39;X&amp;#39;&amp;nbsp;表示，白色方格由&amp;nbsp;&amp;#39;_&amp;#39;&amp;nbsp;表示，蚂蚁所在的位置由&amp;nbsp;&amp;#39;L&amp;#39;, &amp;#39;U&amp;#39;, &amp;#39;R&amp;#39;, &amp;#39;D&amp;#39;&amp;nbsp;表示，分别表示蚂蚁&amp;nbsp;左、上、右、下 的朝向。只需要返回能够包含蚂蚁走过的所有方格的最小矩形。
示例 1:
输入: 0 输出: [&amp;quot;R&amp;quot;] 示例 2:
输入: 2 输出: [ &amp;nbsp; &amp;quot;_X&amp;quot;, &amp;nbsp; &amp;quot;LX&amp;quot; ] 示例 3:
输入: 5 输出: [ &amp;nbsp; &amp;quot;_U&amp;quot;, &amp;nbsp; &amp;quot;X_&amp;quot;, &amp;nbsp; &amp;quot;XX&amp;quot; ] 说明：
K &amp;lt;= 100000 func printKMoves(K int) []string { } LeetCode题库地址 https://leetcode.cn/problems/langtons-ant-lcci</description></item><item><title>剑指 Offer II 099 最小路径之和</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/0i0mdw/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/0i0mdw/</guid><description>剑指 Offer II 099 最小路径之和 给定一个包含非负整数的 m&amp;nbsp;x&amp;nbsp;n&amp;nbsp;网格&amp;nbsp;grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明：一个机器人每次只能向下或者向右移动一步。
&amp;nbsp;
示例 1：
输入：grid = [[1,3,1],[1,5,1],[4,2,1]] 输出：7 解释：因为路径 1&amp;rarr;3&amp;rarr;1&amp;rarr;1&amp;rarr;1 的总和最小。 示例 2：
输入：grid = [[1,2,3],[4,5,6]] 输出：12 &amp;nbsp;
提示：
m == grid.length n == grid[i].length 1 &amp;lt;= m, n &amp;lt;= 200 0 &amp;lt;= grid[i][j] &amp;lt;= 100 &amp;nbsp;
注意：本题与主站 64&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/minimum-path-sum/
func minPathSum(grid [][]int) int { } LeetCode题库地址 https://leetcode.cn/problems/0i0mDW</description></item><item><title>剑指 Offer II 105 岛屿的最大面积</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/zl6zan/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/zl6zan/</guid><description>剑指 Offer II 105 岛屿的最大面积 给定一个由&amp;nbsp;0 和 1 组成的非空二维数组&amp;nbsp;grid&amp;nbsp;，用来表示海洋岛屿地图。
一个&amp;nbsp;岛屿&amp;nbsp;是由一些相邻的&amp;nbsp;1&amp;nbsp;(代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设&amp;nbsp;grid 的四个边缘都被 0（代表水）包围着。
找到给定的二维数组中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。
&amp;nbsp;
示例 1:
输入: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]] 输出: 6 解释: 对于上面这个给定矩阵应返回&amp;nbsp;6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。 示例 2:
输入: grid = [[0,0,0,0,0,0,0,0]] 输出: 0 &amp;nbsp;
提示：
m == grid.length n == grid[i].length 1 &amp;lt;= m, n &amp;lt;= 50 grid[i][j] is either 0 or 1 &amp;nbsp;
注意：本题与主站 695&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/max-area-of-island/
func maxAreaOfIsland(grid [][]int) int { } LeetCode题库地址 https://leetcode.cn/problems/ZL6zAn</description></item><item><title>面试题 17.23 最大黑方阵</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/max-black-square-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/max-black-square-lcci/</guid><description>面试题 17.23 最大黑方阵 给定一个方阵，其中每个单元(像素)非黑即白。设计一个算法，找出 4 条边皆为黑色像素的最大子方阵。
返回一个数组 [r, c, size] ，其中&amp;nbsp;r,&amp;nbsp;c&amp;nbsp;分别代表子方阵左上角的行号和列号，size 是子方阵的边长。若有多个满足条件的子方阵，返回 r 最小的，若 r 相同，返回 c 最小的子方阵。若无满足条件的子方阵，返回空数组。
示例 1:
输入: [ &amp;nbsp; [1,0,1], &amp;nbsp; [0,0,1], &amp;nbsp; [0,0,1] ] 输出: [1,0,2] 解释: 输入中 0 代表黑色，1 代表白色，标粗的元素即为满足条件的最大子方阵 示例 2:
输入: [ &amp;nbsp; [0,1,1], &amp;nbsp; [1,0,1], &amp;nbsp; [1,1,0] ] 输出: [0,0,1] 提示：
matrix.length == matrix[0].length &amp;lt;= 200 func findSquare(matrix [][]int) []int { } LeetCode题库地址 https://leetcode.cn/problems/max-black-square-lcci</description></item><item><title>剑指 Offer II 107 矩阵中的距离</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/2bcmpm/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/2bcmpm/</guid><description>剑指 Offer II 107 矩阵中的距离 给定一个由 0 和 1 组成的矩阵 mat&amp;nbsp;，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。
两个相邻元素间的距离为 1 。
&amp;nbsp;
示例 1：
输入：mat = [[0,0,0],[0,1,0],[0,0,0]] 输出：[[0,0,0],[0,1,0],[0,0,0]] 示例 2：
输入：mat = [[0,0,0],[0,1,0],[1,1,1]] 输出：[[0,0,0],[0,1,0],[1,2,1]] &amp;nbsp;
提示：
m == mat.length n == mat[i].length 1 &amp;lt;= m, n &amp;lt;= 104 1 &amp;lt;= m * n &amp;lt;= 104 mat[i][j] is either 0 or 1. mat 中至少有一个 0&amp;nbsp; &amp;nbsp;
注意：本题与主站 542&amp;nbsp;题相同：https://leetcode-cn.com/problems/01-matrix/
func updateMatrix(mat [][]int) [][]int { } LeetCode题库地址 https://leetcode.cn/problems/2bCMpM</description></item><item><title>面试题 17.24 最大子矩阵</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/max-submatrix-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/max-submatrix-lcci/</guid><description>面试题 17.24 最大子矩阵 给定一个正整数、负整数和 0 组成的 N &amp;times; M&amp;nbsp;矩阵，编写代码找出元素总和最大的子矩阵。
返回一个数组 [r1, c1, r2, c2]，其中 r1, c1 分别代表子矩阵左上角的行号和列号，r2, c2 分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。
注意：本题相对书上原题稍作改动
示例：
输入： [ &amp;nbsp; [-1,0], &amp;nbsp; [0,-1] ] 输出：[0,1,0,1] 解释：输入中标粗的元素即为输出所表示的矩阵 &amp;nbsp;
说明：
1 &amp;lt;= matrix.length, matrix[0].length &amp;lt;= 200 func getMaxMatrix(matrix [][]int) []int { } LeetCode题库地址 https://leetcode.cn/problems/max-submatrix-lcci</description></item><item><title>剑指 Offer II 112 最长递增路径</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/fptfwp/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/fptfwp/</guid><description>剑指 Offer II 112 最长递增路径 给定一个&amp;nbsp;m x n 整数矩阵&amp;nbsp;matrix ，找出其中 最长递增路径 的长度。
对于每个单元格，你可以往上，下，左，右四个方向移动。 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。
&amp;nbsp;
示例 1：
输入：matrix = [[9,9,4],[6,6,8],[2,1,1]] 输出：4 解释：最长递增路径为&amp;nbsp;[1, 2, 6, 9]。 示例 2：
输入：matrix = [[3,4,5],[3,2,6],[2,2,1]] 输出：4 解释：最长递增路径是&amp;nbsp;[3, 4, 5, 6]。注意不允许在对角线方向上移动。 示例 3：
输入：matrix = [[1]] 输出：1 &amp;nbsp;
提示：
m == matrix.length n == matrix[i].length 1 &amp;lt;= m, n &amp;lt;= 200 0 &amp;lt;= matrix[i][j] &amp;lt;= 231 - 1 &amp;nbsp;
注意：本题与主站 329&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/
func longestIncreasingPath(matrix [][]int) int { } LeetCode题库地址 https://leetcode.</description></item><item><title>【2022-11-10每日一题】864. 获取所有钥匙的最短路径[Hard]</title><link>/study/leetcode/shortest-path-to-get-all-keys/</link><pubDate>Thu, 10 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/shortest-path-to-get-all-keys/</guid><description>2022-11-10每日一题：864. 获取所有钥匙的最短路径 难度：Hard
标签：位运算 、 广度优先搜索 、 数组 、 矩阵
给定一个二维网格&amp;nbsp;grid&amp;nbsp;，其中：
'.' 代表一个空房间 '#' 代表一堵 '@'&amp;nbsp;是起点 小写字母代表钥匙 大写字母代表锁 我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。
假设 k&amp;nbsp;为 钥匙/锁 的个数，且满足&amp;nbsp;1 &amp;lt;= k&amp;nbsp;&amp;lt;= 6，字母表中的前 k&amp;nbsp;个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。
返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回&amp;nbsp;-1&amp;nbsp;。
&amp;nbsp;
示例 1：
输入：grid = ["@.a.#","###.#","b.A.B"] 输出：8 解释：目标是获得所有钥匙，而不是打开所有锁。 示例 2：
输入：grid = ["@..aA","..B#.","....b"] 输出：6 示例 3:
输入: grid = ["@Aa"] 输出: -1 &amp;nbsp;
提示：
m == grid.length n == grid[i].length 1 &amp;lt;= m, n &amp;lt;= 30 grid[i][j]&amp;nbsp;只含有&amp;nbsp;'.',&amp;nbsp;'#',&amp;nbsp;'@',&amp;nbsp;'a'-'f'&amp;nbsp;以及&amp;nbsp;'A'-'F' 钥匙的数目范围是&amp;nbsp;[1, 6]&amp;nbsp; 每个钥匙都对应一个 不同 的字母 每个钥匙正好打开一个对应的锁 方法一：状态压缩+广度优先搜索 写法一 func shortestPathAllKeys(grid []string) int { // 获取钥匙个数和起点坐标 var k, si, sj int for i, row := range grid { for j, c := range row { if c == '@' { si, sj = i, j // 起点 } else if c &amp;gt;= 'a' &amp;amp;&amp;amp; c &amp;lt;= 'z' { k++ // 累加钥匙个数 } } } m, n := len(grid), len(grid[0]) type tuple struct { i, j, state int } q := []tuple{{si, sj, 0}} // 初始化队列 visited := map[tuple]bool{{si, sj, 0}: true} // 判重初始化 dirs := []int{-1, 0, 1, 0, -1} // 上右下左 四个方向 ans := 0 // 结果 // 广度优先搜索 for len(q) &amp;gt; 0 { for t := len(q); t &amp;gt; 0; t-- { p := q[0] q = q[1:] i, j, state := p.</description></item><item><title>【2022-10-25每日一题】934. 最短的桥[Medium]</title><link>/study/leetcode/shortest-bridge/</link><pubDate>Tue, 25 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/shortest-bridge/</guid><description>2022-10-25每日一题：934. 最短的桥 难度：Medium
标签：深度优先搜索 、 广度优先搜索 、 数组 、 矩阵
给你一个大小为 n x n 的二元矩阵 grid ，其中 1 表示陆地，0 表示水域。
岛 是由四面相连的 1 形成的一个最大组，即不会与非组内的任何其他 1 相连。grid 中 恰好存在两座岛 。
你可以将任意数量的 0 变为 1 ，以使两座岛连接起来，变成 一座岛 。
返回必须翻转的 0 的最小数目。
&amp;nbsp;
示例 1：
输入：grid = [[0,1],[1,0]] 输出：1 示例 2：
输入：grid = [[0,1,0],[0,0,0],[0,0,1]] 输出：2 示例 3：
输入：grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]] 输出：1 &amp;nbsp;
提示：
n == grid.length == grid[i].length 2 &amp;lt;= n &amp;lt;= 100 grid[i][j] 为 0 或 1 grid 中恰有两个岛 方法一：深度优先搜索 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读</description></item><item><title>【2022-09-30每日一题】面试题 01.08. 零矩阵[Medium]</title><link>/study/leetcode/zero-matrix-lcci/</link><pubDate>Fri, 30 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/zero-matrix-lcci/</guid><description>2022-09-30每日一题：面试题 01.08. 零矩阵 难度：Medium
标签：数组 、 哈希表 、 矩阵
编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。
&amp;nbsp;
示例 1：
输入： [ [1,1,1], [1,0,1], [1,1,1] ] 输出： [ [1,0,1], [0,0,0], [1,0,1] ] 示例 2：
输入： [ [0,1,2,0], [3,4,5,2], [1,3,1,5] ] 输出： [ [0,0,0,0], [0,4,5,0], [0,3,1,0] ] 方法一：自己思路 func setZeroes(matrix [][]int) { queue := [][]int{} // 找到所有为0的坐标 for i, row := range matrix { for j, x := range row { if x == 0 { queue = append(queue, []int{i, j}) } } } // 遍历所有为0的坐标，分别处理对应的行和列，这里可能重复处理同一行和同一列，没有去重 for _, q := range queue { i, j := q[0], q[1] for k := range matrix[i] { matrix[i][k] = 0 } for k := range matrix { matrix[k][j] = 0 } } } 复杂度分析 时间复杂度：O(mn) 空间复杂度：O(mn) 方法二：使用两个标记数组 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读</description></item><item><title>【2022-09-18每日一题】827. 最大人工岛</title><link>/study/leetcode/making-a-large-island/</link><pubDate>Sun, 18 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/making-a-large-island/</guid><description>2022-09-18每日一题：827. 最大人工岛 难度：Hard
标签：深度优先搜索 、 广度优先搜索 、 并查集 、 数组 、 矩阵
给你一个大小为 n x n 二进制矩阵 grid 。最多 只能将一格 0 变成 1 。
返回执行此操作后，grid 中最大的岛屿面积是多少？
岛屿 由一组上、下、左、右四个方向相连的 1 形成。
示例 1:
输入: grid = [[1, 0], [0, 1]] 输出: 3 解释: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。 示例 2:
输入: grid = [[1, 1], [1, 0]] 输出: 4 解释: 将一格0变成1，岛屿的面积扩大为 4。 示例 3:
输入: grid = [[1, 1], [1, 1]] 输出: 4 解释: 没有0可以让我们变成1，面积依然为 4。 提示：
n == grid.</description></item><item><title>【2022-09-04每日一题】1582. 二进制矩阵中的特殊位置</title><link>/study/leetcode/special-positions-in-a-binary-matrix/</link><pubDate>Sun, 04 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/special-positions-in-a-binary-matrix/</guid><description>2022-09-04每日一题：1582. 二进制矩阵中的特殊位置 难度：Easy 标签：数组 、 矩阵 给你一个大小为 rows x cols 的矩阵 mat，其中 mat[i][j] 是 0 或 1，请返回 矩阵&amp;nbsp;mat 中特殊位置的数目 。
特殊位置 定义：如果 mat[i][j] == 1 并且第 i 行和第 j 列中的所有其他元素均为 0（行和列的下标均 从 0 开始 ），则位置 (i, j) 被称为特殊位置。
&amp;nbsp;
示例 1：
输入：mat = [[1,0,0], &amp;nbsp; [0,0,1], &amp;nbsp; [1,0,0]] 输出：1 解释：(1,2) 是一个特殊位置，因为 mat[1][2] == 1 且所处的行和列上所有其他元素都是 0 示例 2：
输入：mat = [[1,0,0], &amp;nbsp; [0,1,0], &amp;nbsp; [0,0,1]] 输出：3 解释：(0,0), (1,1) 和 (2,2) 都是特殊位置 示例 3：
输入：mat = [[0,0,0,1], &amp;nbsp; [1,0,0,0], &amp;nbsp; [0,1,1,0], &amp;nbsp; [0,0,0,0]] 输出：2 示例 4：</description></item><item><title>【2022-08-23每日一题】782. 变为棋盘</title><link>/study/leetcode/transform-to-chessboard/</link><pubDate>Tue, 23 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/transform-to-chessboard/</guid><description>2022-08-23每日一题：782. 变为棋盘 难度：Hard 标签：位运算 、 数组 、 数学 、 矩阵 一个&amp;nbsp;n x n&amp;nbsp;的二维网络&amp;nbsp;board&amp;nbsp;仅由&amp;nbsp;0&amp;nbsp;和&amp;nbsp;1&amp;nbsp;组成&amp;nbsp;。每次移动，你能任意交换两列或是两行的位置。
返回 将这个矩阵变为&amp;nbsp; “棋盘”&amp;nbsp;&amp;nbsp;所需的最小移动次数&amp;nbsp;。如果不存在可行的变换，输出 -1。
“棋盘” 是指任意一格的上下左右四个方向的值均与本身不同的矩阵。
&amp;nbsp;
示例 1:
输入: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]] 输出: 2 解释:一种可行的变换方式如下，从左到右： 第一次移动交换了第一列和第二列。 第二次移动交换了第二行和第三行。 示例 2:
输入: board = [[0, 1], [1, 0]] 输出: 0 解释: 注意左上角的格值为0时也是合法的棋盘，也是合法的棋盘. 示例 3:
输入: board = [[1, 0], [1, 0]] 输出: -1 解释: 任意的变换都不能使这个输入变为合法的棋盘。 &amp;nbsp;
提示：
n == board.length n == board[i].length 2 &amp;lt;= n &amp;lt;= 30 board[i][j]&amp;nbsp;将只包含&amp;nbsp;0或&amp;nbsp;1 func getMoves(mask uint, count, n int) int { ones := bits.</description></item></channel></rss>