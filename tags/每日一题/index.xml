<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>每日一题 on lbbniu</title><link>/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</link><description>Recent content in 每日一题 on lbbniu</description><generator>Hugo -- gohugo.io</generator><language>zh</language><managingEditor>lbbniu@gmail.com (lbbniu)</managingEditor><webMaster>lbbniu@gmail.com (lbbniu)</webMaster><copyright>&amp;copy; 2021 &lt;a href="https://blog.lbbniu.com/">lbbniu&lt;/a></copyright><lastBuildDate>Tue, 01 Feb 2022 17:18:16 +0800</lastBuildDate><atom:link href="/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/index.xml" rel="self" type="application/rss+xml"/><item><title>2022年02月LeetCode每日一题</title><link>/study/leetcode/2022-02-00-leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</link><pubDate>Tue, 01 Feb 2022 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/2022-02-00-leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</guid><description>20220216 1719. 重构一棵树的方案数 困难 func checkWays(pairs [][]int) int { adj := map[int]map[int]bool{} for _, p := range pairs { x, y := p[0], p[1] if adj[x] == nil { adj[x] = map[int]bool{} } adj[x][y] = true if adj[y] == nil { adj[y] = map[int]bool{} } adj[y][x] = true } // 检测是否存在根节点 root := -1 for node, neighbours := range adj { if len(neighbours) == len(adj)-1 { root = node break } } if root == -1 { return 0 } ans := 1 for node, neighbours := range adj { if node == root { continue } currDegree := len(neighbours) parent := -1 parentDegree := math.</description></item></channel></rss>