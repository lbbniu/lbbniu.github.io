<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tars on lbbniu</title><link>/tags/tars/</link><description>Recent content in Tars on lbbniu</description><generator>Hugo -- gohugo.io</generator><language>zh</language><managingEditor>lbbniu@gmail.com (lbbniu)</managingEditor><webMaster>lbbniu@gmail.com (lbbniu)</webMaster><copyright>&amp;copy; 2021 &lt;a href="https://blog.lbbniu.com/">lbbniu&lt;/a></copyright><lastBuildDate>Sun, 18 Jun 2023 15:20:00 +0800</lastBuildDate><atom:link href="/tags/tars/index.xml" rel="self" type="application/rss+xml"/><item><title>写给go开发者的Tars教程-Tars协议基础</title><link>/2023/06/18/tarsgo-protocol/</link><pubDate>Sun, 18 Jun 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/06/18/tarsgo-protocol/</guid><description>简介 Tars这个名字取自于电影&amp;quot;星际穿越&amp;quot;中的机器人，它是基于名字服务使用Tars协议的高性能RPC开发框架，配套一体化的运营管理平台，并通过伸缩调度，实现运维半托管服务。
Tars是腾讯从2008年到今天一直在使用的后台逻辑层的统一应用框架TAF（Total Application Framework），目前支持C++、Java、PHP、Nodejs、Go语言。该框架为用户提供了涉及到开发、运维、以及测试的一整套解决方案，帮助一个产品或者服务快速开发、部署、测试、上线。 它集可扩展协议编解码、高性能RPC通信框架、名字路由与发现、发布监控、日志统计、配置管理等于一体，通过它可以快速用微服务的方式构建自己的稳定可靠的分布式应用，并实现完整有效的服务治理。
目前该框架在腾讯内部，各大核心业务都在使用，颇受欢迎，基于该框架部署运行的服务节点规模达到上万个。
支持平台 目前运行的操作系统平台如下：
Linux
Mac(&amp;gt;=2.1.0 support)
支持语言 目前支持的开发语言如下：
C++
Java
Nodejs
PHP
Go
版本管理 Tars由多种模块组成, 分散在多个仓库中, 并且基础框架版本和语言版本可以独立发展, 鉴于此, 从2.1.0版本开始, 框架的版本TAG打在TarsFramework仓库上, 不再体现在Tars这个仓库上.
Tars IDL 所谓序列化通俗来说就是把内存的一段数据转化成二进制并存储或者通过网络传输，而读取磁盘或另一端收到后可以在内存中重建这段数据
1、tars协议是跨语言跨平台的序列化协议。
2、tars协议本身也可以被用于非RPC场景，如存储
json、 xml都是一种序列化的方式，只是他们不需要提前预定义idl，且具备可读性，当然他们传输的体积也因此较大，可以说是各有优劣。
关键字 void,struct,bool,byte,short,int,double,float,long,string,vector,map,key,routekey,module,interface,out,require,optional,false,true,enum,const 注释 采用 c++的注释规范：
//表示注释一行 /**/表示注释范围中的所有代码。 基本类型 基本类型会涉及到不同语言和编码方式，这里只整理tars和go类型对照表
.tars Type Go Type Notes void 函数无返回值 只能在函数的返回值表示 bool bool 布尔类型 byte int8 有符号字符 unsigned byte uint8 无符号字符 short int16 有符号短整型 unsigned short uint16 无符号短整形 int int32 有符号整型 unsigned int uint32 无符号整形 long int64 有符号长整型 float float32 32位浮点数 double float64 64位浮点数 string string 字符串 复杂类型 .</description></item><item><title>写给Go开发者的Tars教程-通信模式</title><link>/2023/06/18/tarsgo-rpc/</link><pubDate>Sun, 18 Jun 2023 15:20:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/2023/06/18/tarsgo-rpc/</guid><description>本篇为【写给Go开发者的Tars教程系列】第二篇
第一篇：Tars协议基础 第二篇：通信模式 上一篇介绍了如何编写 Tars 的 idl，并使用 idl 生成了 TarsGo RPC 的代码，现在来看看如何编写客户端和服务端的代码
Tars 示例 IDL module order { struct Order { 1 require string id; 2 optional vector&amp;lt;string&amp;gt; items; 3 optional string description; 4 require float price; 5 optional string destination; }; interface OrderManagement { Order getOrder(string orderId); }; }; 生成 go 协议编解码代码 tars2go -outdir=. \ -module=github.com/lbbniu/TarsGo-tutorial \ proto/order.tars order ├── order.go └── OrderManagement.tars.go proto └── order.tars server 实现 服务端开发 1、由 Tars 文件生成的 Go 代码中包含了 interface 的接口定义，它和我们定义的 idl 是吻合的</description></item><item><title>Tars服务容器化</title><link>/cloud-native/tars%E5%AE%B9%E5%99%A8%E5%8C%96/</link><pubDate>Thu, 25 Nov 2021 13:30:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/cloud-native/tars%E5%AE%B9%E5%99%A8%E5%8C%96/</guid><description>tars容器化逻辑 tars 协议文件 module tars { struct AdapterConf{ 0 require string servant; 1 require string endpoint; 2 optional string protocol; 3 optional int maxConns; 4 optional int threadNum; 5 optional int queueCap; 6 optional int queueTimeout; }; struct onStartupReq{ 0 require string nodeName; 1 require string application; 2 require string server; 3 optional string setID; 4 optional vector&amp;lt;AdapterConf&amp;gt; adapters; 5 optional bool disableFlow; 6 optional string State = &amp;quot;active&amp;quot;; 7 optional string Version; 8 optional string templateName; 9 optional string serverType; }; struct onPrestopReq{ 0 require string nodeName; 1 optional string application; 2 optional string server; }; struct keepAliveReq{ 0 require string nodeName; 1 require string state; // inactive or active 2 optional string application; 3 optional string server; }; struct RegisterMetricsReq{ 0 require string nodeName; 1 require string application; 2 require string server; 3 require int metricsPort; }; struct GetMetricsAdaptersReq{ 0 optional map&amp;lt;string, string&amp;gt; filter; // enable in feature }; struct MetricsAdapterInfo{ 0 optional vector&amp;lt;string&amp;gt; targets; 1 optional map&amp;lt;string, string&amp;gt; labels; }; interface tarsregistry { void onStartup(onStartupReq req); void onPrestop(onPrestopReq req); void keepAlive(keepAliveReq req); void registerMetrics(RegisterMetricsReq req); void getMetricsAdapters(GetMetricsAdaptersReq req, out vector&amp;lt;MetricsAdapterInfo&amp;gt; rsp); }; }; onStartup -- 增加 t_node_info 记录 insert into t_node_info(node_name, node_obj, endpoint_ip, endpoint_port, last_reg_time, last_heartbeat, setting_state, present_state) values(?</description></item></channel></rss>