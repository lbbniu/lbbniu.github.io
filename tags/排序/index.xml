<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>排序 on lbbniu</title><link>/tags/%E6%8E%92%E5%BA%8F/</link><description>Recent content in 排序 on lbbniu</description><generator>Hugo -- gohugo.io</generator><language>zh</language><managingEditor>lbbniu@gmail.com (lbbniu)</managingEditor><webMaster>lbbniu@gmail.com (lbbniu)</webMaster><copyright>&amp;copy; 2021 &lt;a href="https://blog.lbbniu.com/">lbbniu&lt;/a></copyright><lastBuildDate>Sat, 31 Dec 2022 00:01:00 +0800</lastBuildDate><atom:link href="/tags/%E6%8E%92%E5%BA%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>剑指 Offer 03 数组中重复的数字</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/</guid><description>剑指 Offer 03 数组中重复的数字 找出数组中重复的数字。
在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
示例 1：
输入： [2, 3, 1, 0, 2, 5, 3] 输出：2 或 3 &amp;nbsp;
限制：
2 &amp;lt;= n &amp;lt;= 100000
func findRepeatNumber(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof</description></item><item><title>面试题 01.01 判定字符是否唯一</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/is-unique-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/is-unique-lcci/</guid><description>面试题 01.01 判定字符是否唯一 实现一个算法，确定一个字符串 s 的所有字符是否全都不同。
示例 1：
输入: s = "leetcode" 输出: false 示例 2：
输入: s = "abc" 输出: true 限制：
0 &amp;lt;= len(s) &amp;lt;= 100 s[i]仅包含小写字母 如果你不使用额外的数据结构，会很加分。 func isUnique(astr string) bool { } LeetCode题库地址 https://leetcode.cn/problems/is-unique-lcci</description></item><item><title>面试题 01.02 判定是否互为字符重排</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/check-permutation-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/check-permutation-lcci/</guid><description>面试题 01.02 判定是否互为字符重排 给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。
示例 1：
输入: s1 = &amp;quot;abc&amp;quot;, s2 = &amp;quot;bca&amp;quot; 输出: true 示例 2：
输入: s1 = &amp;quot;abc&amp;quot;, s2 = &amp;quot;bad&amp;quot; 输出: false 说明：
0 &amp;lt;= len(s1) &amp;lt;= 100 0 &amp;lt;= len(s2) &amp;lt;= 100 func CheckPermutation(s1 string, s2 string) bool { } LeetCode题库地址 https://leetcode.cn/problems/check-permutation-lcci</description></item><item><title>剑指 Offer II 007 数组中和为 0 的三个数</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/1fgaju/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/1fgaju/</guid><description>剑指 Offer II 007 数组中和为 0 的三个数 给定一个包含 n 个整数的数组&amp;nbsp;nums，判断&amp;nbsp;nums&amp;nbsp;中是否存在三个元素&amp;nbsp;a ，b ，c ，使得&amp;nbsp;a + b + c = 0 ？请找出所有和为 0 且&amp;nbsp;不重复&amp;nbsp;的三元组。
&amp;nbsp;
示例 1：
输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 示例 2：
输入：nums = [] 输出：[] 示例 3：
输入：nums = [0] 输出：[] &amp;nbsp;
提示：
0 &amp;lt;= nums.length &amp;lt;= 3000 -105 &amp;lt;= nums[i] &amp;lt;= 105 &amp;nbsp;
注意：本题与主站 15&amp;nbsp;题相同：https://leetcode-cn.com/problems/3sum/
func threeSum(nums []int) [][]int { } LeetCode题库地址 https://leetcode.cn/problems/1fGaJU</description></item><item><title>剑指 Offer 21 调整数组顺序使奇数位于偶数前面</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/</guid><description>剑指 Offer 21 调整数组顺序使奇数位于偶数前面 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。
&amp;nbsp;
示例：
输入：nums =&amp;nbsp;[1,2,3,4] 输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一。 &amp;nbsp;
提示：
0 &amp;lt;= nums.length &amp;lt;= 50000 0 &amp;lt;= nums[i] &amp;lt;= 10000 func exchange(nums []int) []int { } LeetCode题库地址 https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof</description></item><item><title>剑指 Offer II 032 有效的变位词</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/dkk3p7/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/dkk3p7/</guid><description>剑指 Offer II 032 有效的变位词 给定两个字符串 s 和 t ，编写一个函数来判断它们是不是一组变位词（字母异位词）。
注意：若&amp;nbsp;s 和 t&amp;nbsp;中每个字符出现的次数都相同且字符顺序不完全相同，则称&amp;nbsp;s 和 t&amp;nbsp;互为变位词（字母异位词）。
&amp;nbsp;
示例&amp;nbsp;1:
输入: s = &amp;quot;anagram&amp;quot;, t = &amp;quot;nagaram&amp;quot; 输出: true 示例 2:
输入: s = &amp;quot;rat&amp;quot;, t = &amp;quot;car&amp;quot; 输出: false 示例 3:
输入: s = &amp;quot;a&amp;quot;, t = &amp;quot;a&amp;quot; 输出: false &amp;nbsp;
提示:
1 &amp;lt;= s.length, t.length &amp;lt;= 5 * 104 s&amp;nbsp;and&amp;nbsp;t&amp;nbsp;仅包含小写字母 &amp;nbsp;
进阶:&amp;nbsp;如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？
&amp;nbsp;
注意：本题与主站 242&amp;nbsp;题相似（字母异位词定义不同）：https://leetcode-cn.com/problems/valid-anagram/
func isAnagram(s string, t string) bool { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer II 033 变位词组</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/sfvd7v/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/sfvd7v/</guid><description>剑指 Offer II 033 变位词组 给定一个字符串数组 strs ，将&amp;nbsp;变位词&amp;nbsp;组合在一起。 可以按任意顺序返回结果列表。
注意：若两个字符串中每个字符出现的次数都相同，则称它们互为变位词。
&amp;nbsp;
示例 1:
输入: strs = [&amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;tan&amp;quot;, &amp;quot;ate&amp;quot;, &amp;quot;nat&amp;quot;, &amp;quot;bat&amp;quot;] 输出: [[&amp;quot;bat&amp;quot;],[&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;],[&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;]] 示例 2:
输入: strs = [&amp;quot;&amp;quot;] 输出: [[&amp;quot;&amp;quot;]] 示例 3:
输入: strs = [&amp;quot;a&amp;quot;] 输出: [[&amp;quot;a&amp;quot;]] &amp;nbsp;
提示：
1 &amp;lt;= strs.length &amp;lt;= 104 0 &amp;lt;= strs[i].length &amp;lt;= 100 strs[i]&amp;nbsp;仅包含小写字母 &amp;nbsp;
注意：本题与主站 49&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/group-anagrams/
func groupAnagrams(strs []string) [][]string { } LeetCode题库地址 https://leetcode.cn/problems/sfvd7V</description></item><item><title>剑指 Offer II 035 最小时间差</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/569nqc/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/569nqc/</guid><description>剑指 Offer II 035 最小时间差 给定一个 24 小时制（小时:分钟 &amp;quot;HH:MM&amp;quot;）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。
&amp;nbsp;
示例 1：
输入：timePoints = [&amp;quot;23:59&amp;quot;,&amp;quot;00:00&amp;quot;] 输出：1 示例 2：
输入：timePoints = [&amp;quot;00:00&amp;quot;,&amp;quot;23:59&amp;quot;,&amp;quot;00:00&amp;quot;] 输出：0 &amp;nbsp;
提示：
2 &amp;lt;= timePoints &amp;lt;= 2 * 104 timePoints[i] 格式为 &amp;quot;HH:MM&amp;quot; &amp;nbsp;
注意：本题与主站 539&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/minimum-time-difference/
func findMinDifference(timePoints []string) int { } LeetCode题库地址 https://leetcode.cn/problems/569nqc</description></item><item><title>剑指 Offer 39 数组中出现次数超过一半的数字</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/</guid><description>剑指 Offer 39 数组中出现次数超过一半的数字 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。
&amp;nbsp;
你可以假设数组是非空的，并且给定的数组总是存在多数元素。
&amp;nbsp;
示例&amp;nbsp;1:
输入: [1, 2, 3, 2, 2, 2, 5, 4, 2] 输出: 2 &amp;nbsp;
限制：
1 &amp;lt;= 数组长度 &amp;lt;= 50000
&amp;nbsp;
注意：本题与主站 169 题相同：https://leetcode-cn.com/problems/majority-element/
&amp;nbsp;
func majorityElement(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof</description></item><item><title>剑指 Offer 40 最小的k个数</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zui-xiao-de-kge-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zui-xiao-de-kge-shu-lcof/</guid><description>剑指 Offer 40 最小的k个数 输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。
&amp;nbsp;
示例 1：
输入：arr = [3,2,1], k = 2 输出：[1,2] 或者 [2,1] 示例 2：
输入：arr = [0,1,2,1], k = 1 输出：[0] &amp;nbsp;
限制：
0 &amp;lt;= k &amp;lt;= arr.length &amp;lt;= 10000 0 &amp;lt;= arr[i]&amp;nbsp;&amp;lt;= 10000 func getLeastNumbers(arr []int, k int) []int { } LeetCode题库地址 https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof</description></item><item><title>剑指 Offer 41 数据流中的中位数</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/</guid><description>剑指 Offer 41 数据流中的中位数 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。
例如，
[2,3,4]&amp;nbsp;的中位数是 3
[2,3] 的中位数是 (2 + 3) / 2 = 2.5
设计一个支持以下两种操作的数据结构：
void addNum(int num) - 从数据流中添加一个整数到数据结构中。 double findMedian() - 返回目前所有元素的中位数。 示例 1：
输入： [&amp;quot;MedianFinder&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;] [[],[1],[2],[],[3],[]] 输出：[null,null,null,1.50000,null,2.00000] 示例 2：
输入： [&amp;quot;MedianFinder&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;] [[],[2],[],[3],[]] 输出：[null,null,2.00000,null,2.50000] &amp;nbsp;
限制：
最多会对&amp;nbsp;addNum、findMedian 进行&amp;nbsp;50000&amp;nbsp;次调用。 注意：本题与主站 295 题相同：https://leetcode-cn.com/problems/find-median-from-data-stream/
type MedianFinder struct { } /** initialize your data structure here. */ func Constructor() MedianFinder { } func (this *MedianFinder) AddNum(num int) { } func (this *MedianFinder) FindMedian() float64 { } /** * Your MedianFinder object will be instantiated and called as such: * obj := Constructor(); * obj.</description></item><item><title>剑指 Offer 45 把数组排成最小的数</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/</guid><description>剑指 Offer 45 把数组排成最小的数 输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。
&amp;nbsp;
示例 1:
输入: [10,2] 输出: &amp;quot;102&amp;quot; 示例&amp;nbsp;2:
输入: [3,30,34,5,9] 输出: &amp;quot;3033459&amp;quot; &amp;nbsp;
提示:
0 &amp;lt; nums.length &amp;lt;= 100 说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数 拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0 func minNumber(nums []int) string { } LeetCode题库地址 https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof</description></item><item><title>面试题 08.13 堆箱子</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/pile-box-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/pile-box-lcci/</guid><description>面试题 08.13 堆箱子 堆箱子。给你一堆n个箱子，箱子宽 wi、深 di、高 hi。箱子不能翻转，将箱子堆起来时，下面箱子的宽度、高度和深度必须大于上面的箱子。实现一种方法，搭出最高的一堆箱子。箱堆的高度为每个箱子高度的总和。
输入使用数组[wi, di, hi]表示每个箱子。
示例1:
输入：box = [[1, 1, 1], [2, 2, 2], [3, 3, 3]] 输出：6 示例2:
输入：box = [[1, 1, 1], [2, 3, 4], [2, 6, 7], [3, 4, 5]] 输出：10 提示:
箱子的数目不大于3000个。 func pileBox(box [][]int) int { } LeetCode题库地址 https://leetcode.cn/problems/pile-box-lcci</description></item><item><title>面试题 10.01 合并排序的数组</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sorted-merge-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sorted-merge-lcci/</guid><description>面试题 10.01 合并排序的数组 给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。
初始化&amp;nbsp;A 和 B 的元素数量分别为&amp;nbsp;m 和 n。
示例:
输入: A = [1,2,3,0,0,0], m = 3 B = [2,5,6], n = 3 输出:&amp;nbsp;[1,2,2,3,5,6] 说明:
A.length == n + m func merge(A []int, m int, B []int, n int) { } LeetCode题库地址 https://leetcode.cn/problems/sorted-merge-lcci</description></item><item><title>面试题 10.02 变位词组</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/group-anagrams-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/group-anagrams-lcci/</guid><description>面试题 10.02 变位词组 编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。
注意：本题相对原题稍作修改
示例:
输入: [&amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;tan&amp;quot;, &amp;quot;ate&amp;quot;, &amp;quot;nat&amp;quot;, &amp;quot;bat&amp;quot;], 输出: [ [&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;], [&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;], [&amp;quot;bat&amp;quot;] ] 说明：
所有输入均为小写字母。 不考虑答案输出的顺序。 func groupAnagrams(strs []string) [][]string { } LeetCode题库地址 https://leetcode.cn/problems/group-anagrams-lcci</description></item><item><title>剑指 Offer II 057 值和下标之差都在给定的范围内</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/7wqedu/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/7wqedu/</guid><description>剑指 Offer II 057 值和下标之差都在给定的范围内 给你一个整数数组 nums 和两个整数&amp;nbsp;k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得&amp;nbsp;abs(nums[i] - nums[j]) &amp;lt;= t ，同时又满足 abs(i - j) &amp;lt;= k 。
如果存在则返回 true，不存在返回 false。
&amp;nbsp;
示例&amp;nbsp;1：
输入：nums = [1,2,3,1], k = 3, t = 0 输出：true 示例 2：
输入：nums = [1,0,1,1], k = 1, t = 2 输出：true 示例 3：
输入：nums = [1,5,9,1,5,9], k = 2, t = 3 输出：false &amp;nbsp;
提示：
0 &amp;lt;= nums.length &amp;lt;= 2 * 104 -231 &amp;lt;= nums[i] &amp;lt;= 231 - 1 0 &amp;lt;= k &amp;lt;= 104 0 &amp;lt;= t &amp;lt;= 231 - 1 &amp;nbsp;</description></item><item><title>剑指 Offer II 060 出现频率最高的 k 个数字</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/g5c51o/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/g5c51o/</guid><description>剑指 Offer II 060 出现频率最高的 k 个数字 给定一个整数数组 nums 和一个整数 k&amp;nbsp;，请返回其中出现频率前 k 高的元素。可以按 任意顺序 返回答案。
&amp;nbsp;
示例 1:
输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2] 示例 2:
输入: nums = [1], k = 1 输出: [1] &amp;nbsp;
提示：
1 &amp;lt;= nums.length &amp;lt;= 105 k 的取值范围是 [1, 数组中不相同的元素的个数] 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的 &amp;nbsp;
进阶：所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n&amp;nbsp;是数组大小。
&amp;nbsp;
注意：本题与主站 347&amp;nbsp;题相同：https://leetcode-cn.com/problems/top-k-frequent-elements/
func topKFrequent(nums []int, k int) []int { } LeetCode题库地址 https://leetcode.cn/problems/g5c51o</description></item><item><title>面试题 10.11 峰与谷</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/peaks-and-valleys-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/peaks-and-valleys-lcci/</guid><description>面试题 10.11 峰与谷 在一个整数数组中，&amp;ldquo;峰&amp;rdquo;是大于或等于相邻整数的元素，相应地，&amp;ldquo;谷&amp;rdquo;是小于或等于相邻整数的元素。例如，在数组{5, 8, 4, 2, 3, 4, 6}中，{8, 6}是峰， {5, 2}是谷。现在给定一个整数数组，将该数组按峰与谷的交替顺序排序。
示例:
输入: [5, 3, 1, 2, 3] 输出:&amp;nbsp;[5, 1, 3, 2, 3] 提示：
nums.length &amp;lt;= 10000 func wiggleSort(nums []int) { } LeetCode题库地址 https://leetcode.cn/problems/peaks-and-valleys-lcci</description></item><item><title>剑指 Offer 61 扑克牌中的顺子</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/bu-ke-pai-zhong-de-shun-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/bu-ke-pai-zhong-de-shun-zi-lcof/</guid><description>剑指 Offer 61 扑克牌中的顺子 从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。
&amp;nbsp;
示例&amp;nbsp;1:
输入: [1,2,3,4,5] 输出: True &amp;nbsp;
示例&amp;nbsp;2:
输入: [0,0,1,2,5] 输出: True &amp;nbsp;
限制：
数组长度为 5&amp;nbsp;
数组的数取值为 [0, 13] .
func isStraight(nums []int) bool { } LeetCode题库地址 https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof</description></item><item><title>面试题 16.06 最小差</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/smallest-difference-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/smallest-difference-lcci/</guid><description>面试题 16.06 最小差 给定两个整数数组a和b，计算具有最小差绝对值的一对数值（每个数组中取一个值），并返回该对数值的差
示例：
输入：{1, 3, 15, 11, 2}, {23, 127, 235, 19, 8} 输出：3，即数值对(11, 8) 提示：
1 &lt;= a.length, b.length &lt;= 100000 -2147483648 &lt;= a[i], b[i] &lt;= 2147483647 正确结果在区间 [0, 2147483647] 内 func smallestDifference(a []int, b []int) int { } LeetCode题库地址 https://leetcode.cn/problems/smallest-difference-lcci</description></item><item><title>剑指 Offer II 074 合并区间</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/ssgohc/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/ssgohc/</guid><description>剑指 Offer II 074 合并区间 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。
&amp;nbsp;
示例 1：
输入：intervals = [[1,3],[2,6],[8,10],[15,18]] 输出：[[1,6],[8,10],[15,18]] 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例&amp;nbsp;2：
输入：intervals = [[1,4],[4,5]] 输出：[[1,5]] 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。 &amp;nbsp;
提示：
1 &amp;lt;= intervals.length &amp;lt;= 104 intervals[i].length == 2 0 &amp;lt;= starti &amp;lt;= endi &amp;lt;= 104 &amp;nbsp;
注意：本题与主站 56&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/merge-intervals/
func merge(intervals [][]int) [][]int { } LeetCode题库地址 https://leetcode.cn/problems/SsGoHC</description></item><item><title>剑指 Offer II 075 数组相对排序</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/0h97zc/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/0h97zc/</guid><description>剑指 Offer II 075 数组相对排序 给定两个数组，arr1 和&amp;nbsp;arr2，
arr2&amp;nbsp;中的元素各不相同 arr2 中的每个元素都出现在&amp;nbsp;arr1&amp;nbsp;中 对 arr1&amp;nbsp;中的元素进行排序，使 arr1 中项的相对顺序和&amp;nbsp;arr2&amp;nbsp;中的相对顺序相同。未在&amp;nbsp;arr2&amp;nbsp;中出现过的元素需要按照升序放在&amp;nbsp;arr1&amp;nbsp;的末尾。
&amp;nbsp;
示例：
输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6] 输出：[2,2,2,1,4,3,3,9,6,7,19] &amp;nbsp;
提示：
1 &amp;lt;= arr1.length, arr2.length &amp;lt;= 1000 0 &amp;lt;= arr1[i], arr2[i] &amp;lt;= 1000 arr2&amp;nbsp;中的元素&amp;nbsp;arr2[i]&amp;nbsp;各不相同 arr2 中的每个元素&amp;nbsp;arr2[i]&amp;nbsp;都出现在&amp;nbsp;arr1&amp;nbsp;中 &amp;nbsp;
注意：本题与主站 1122&amp;nbsp;题相同：https://leetcode-cn.com/problems/relative-sort-array/&amp;nbsp;
func relativeSortArray(arr1 []int, arr2 []int) []int { } LeetCode题库地址 https://leetcode.cn/problems/0H97ZC</description></item><item><title>剑指 Offer II 076 数组中的第 k 大的数字</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/xx4gt2/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/xx4gt2/</guid><description>剑指 Offer II 076 数组中的第 k 大的数字 给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。
请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
&amp;nbsp;
示例 1:
输入: [3,2,1,5,6,4] 和 k = 2 输出: 5 示例&amp;nbsp;2:
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4 输出: 4 &amp;nbsp;
提示： 1 &amp;lt;= k &amp;lt;= nums.length &amp;lt;= 104 -104&amp;nbsp;&amp;lt;= nums[i] &amp;lt;= 104 &amp;nbsp;
注意：本题与主站 215&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/kth-largest-element-in-an-array/
func findKthLargest(nums []int, k int) int { } LeetCode题库地址 https://leetcode.cn/problems/xx4gT2</description></item><item><title>面试题 16.16 部分排序</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sub-sort-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sub-sort-lcci/</guid><description>面试题 16.16 部分排序 给定一个整数数组，编写一个函数，找出索引m和n，只要将索引区间[m,n]的元素排好序，整个数组就是有序的。注意：n-m尽量最小，也就是说，找出符合条件的最短序列。函数返回值为[m,n]，若不存在这样的m和n（例如整个数组是有序的），请返回[-1,-1]。
示例：
输入： [1,2,4,7,10,11,7,12,6,7,16,18,19] 输出： [3,9] 提示：
0 &lt;= len(array) &lt;= 1000000 func subSort(array []int) []int { } LeetCode题库地址 https://leetcode.cn/problems/sub-sort-lcci</description></item><item><title>剑指 Offer II 077 链表排序</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/7whec2/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/7whec2/</guid><description>剑指 Offer II 077 链表排序 给定链表的头结点&amp;nbsp;head&amp;nbsp;，请将其按 升序 排列并返回 排序后的链表 。
&amp;nbsp;
示例 1：
输入：head = [4,2,1,3] 输出：[1,2,3,4] 示例 2：
输入：head = [-1,5,3,4,0] 输出：[-1,0,3,4,5] 示例 3：
输入：head = [] 输出：[] &amp;nbsp;
提示：
链表中节点的数目在范围&amp;nbsp;[0, 5 * 104]&amp;nbsp;内 -105&amp;nbsp;&amp;lt;= Node.val &amp;lt;= 105 &amp;nbsp;
进阶：你可以在&amp;nbsp;O(n&amp;nbsp;log&amp;nbsp;n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？
&amp;nbsp;
注意：本题与主站 148&amp;nbsp;题相同：https://leetcode-cn.com/problems/sort-list/
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func sortList(head *ListNode) *ListNode { } LeetCode题库地址 https://leetcode.cn/problems/7WHec2</description></item><item><title>面试题 16.21 交换和</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sum-swap-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sum-swap-lcci/</guid><description>面试题 16.21 交换和 给定两个整数数组，请交换一对数值（每个数组中取一个数值），使得两个数组所有元素的和相等。
返回一个数组，第一个元素是第一个数组中要交换的元素，第二个元素是第二个数组中要交换的元素。若有多个答案，返回任意一个均可。若无满足条件的数值，返回空数组。
示例:
输入: array1 = [4, 1, 2, 1, 1, 2], array2 = [3, 6, 3, 3] 输出: [1, 3] 示例:
输入: array1 = [1, 2, 3], array2 = [4, 5, 6] 输出: [] 提示：
1 &amp;lt;= array1.length, array2.length &amp;lt;= 100000 func findSwapValues(array1 []int, array2 []int) []int { } LeetCode题库地址 https://leetcode.cn/problems/sum-swap-lcci</description></item><item><title>面试题 16.24 数对和</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/pairs-with-sum-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/pairs-with-sum-lcci/</guid><description>面试题 16.24 数对和 设计一个算法，找出数组中两数之和为指定值的所有整数对。一个数只能属于一个数对。
示例 1:
输入: nums = [5,6,5], target = 11 输出: [[5,6]] 示例 2:
输入: nums = [5,6,5,6], target = 11 输出: [[5,6],[5,6]] 提示：
nums.length &amp;lt;= 100000 func pairSums(nums []int, target int) [][]int { } LeetCode题库地址 https://leetcode.cn/problems/pairs-with-sum-lcci</description></item><item><title>面试题 17.04 消失的数字</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/missing-number-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/missing-number-lcci/</guid><description>面试题 17.04 消失的数字 数组nums包含从0到n的所有整数，但其中缺了一个。请编写代码找出那个缺失的整数。你有办法在O(n)时间内完成吗？
注意：本题相对书上原题稍作改动
示例 1：
输入：[3,0,1] 输出：2 &amp;nbsp;
示例 2：
输入：[9,6,4,2,3,5,7,0,1] 输出：8 func missingNumber(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/missing-number-lcci</description></item><item><title>面试题 17.08 马戏团人塔</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/circus-tower-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/circus-tower-lcci/</guid><description>面试题 17.08 马戏团人塔 有个马戏团正在设计叠罗汉的表演节目，一个人要站在另一人的肩膀上。出于实际和美观的考虑，在上面的人要比下面的人矮一点且轻一点。已知马戏团每个人的身高和体重，请编写代码计算叠罗汉最多能叠几个人。
示例：
输入：height = [65,70,56,75,60,68] weight = [100,150,90,190,95,110] 输出：6 解释：从上往下数，叠罗汉最多能叠 6 层：(56,90), (60,95), (65,100), (68,110), (70,150), (75,190) 提示：
height.length == weight.length &lt;= 10000 func bestSeqAtIndex(height []int, weight []int) int { } LeetCode题库地址 https://leetcode.cn/problems/circus-tower-lcci</description></item><item><title>面试题 17.14 最小K个数</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/smallest-k-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/smallest-k-lcci/</guid><description>面试题 17.14 最小K个数 设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。
示例：
输入： arr = [1,3,5,7,2,4,6,8], k = 4 输出： [1,2,3,4] 提示：
0 &amp;lt;= len(arr) &amp;lt;= 100000 0 &amp;lt;= k &amp;lt;= min(100000, len(arr)) func smallestK(arr []int, k int) []int { } LeetCode题库地址 https://leetcode.cn/problems/smallest-k-lcci</description></item><item><title>面试题 17.20 连续中值</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/continuous-median-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/continuous-median-lcci/</guid><description>面试题 17.20 连续中值 随机产生数字并传递给一个方法。你能否完成这个方法，在每次产生新值时，寻找当前所有值的中间值（中位数）并保存。
中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。
例如，
[2,3,4]&amp;nbsp;的中位数是 3
[2,3] 的中位数是 (2 + 3) / 2 = 2.5
设计一个支持以下两种操作的数据结构：
void addNum(int num) - 从数据流中添加一个整数到数据结构中。 double findMedian() - 返回目前所有元素的中位数。 示例：
addNum(1) addNum(2) findMedian() -&amp;gt; 1.5 addNum(3) findMedian() -&amp;gt; 2 type MedianFinder struct { } /** initialize your data structure here. */ func Constructor() MedianFinder { } func (this *MedianFinder) AddNum(num int) { } func (this *MedianFinder) FindMedian() float64 { } /** * Your MedianFinder object will be instantiated and called as such: * obj := Constructor(); * obj.</description></item><item><title>面试题 17.26 稀疏相似度</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sparse-similarity-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sparse-similarity-lcci/</guid><description>面试题 17.26 稀疏相似度 两个(具有不同单词的)文档的交集(intersection)中元素的个数除以并集(union)中元素的个数，就是这两个文档的相似度。例如，{1, 5, 3} 和 {1, 7, 2, 3} 的相似度是 0.4，其中，交集的元素有 2 个，并集的元素有 5 个。给定一系列的长篇文档，每个文档元素各不相同，并与一个 ID 相关联。它们的相似度非常&amp;ldquo;稀疏&amp;rdquo;，也就是说任选 2 个文档，相似度都很接近 0。请设计一个算法返回每对文档的 ID 及其相似度。只需输出相似度大于 0 的组合。请忽略空文档。为简单起见，可以假定每个文档由一个含有不同整数的数组表示。
输入为一个二维数组 docs，docs[i]&amp;nbsp;表示&amp;nbsp;id 为 i 的文档。返回一个数组，其中每个元素是一个字符串，代表每对相似度大于 0 的文档，其格式为 {id1},{id2}: {similarity}，其中 id1 为两个文档中较小的 id，similarity 为相似度，精确到小数点后 4 位。以任意顺序返回数组均可。
示例:
输入: [ &amp;nbsp; [14, 15, 100, 9, 3], &amp;nbsp; [32, 1, 9, 3, 5], &amp;nbsp; [15, 29, 2, 6, 8, 7], &amp;nbsp; [7, 10] ] 输出: [ &amp;nbsp; &amp;quot;0,1: 0.2500&amp;quot;, &amp;nbsp; &amp;quot;0,2: 0.1000&amp;quot;, &amp;nbsp; &amp;quot;2,3: 0.</description></item><item><title>【2022-12-31每日一题】2037. 使每位学生都有座位的最少移动次数[Easy]</title><link>/study/leetcode/minimum-number-of-moves-to-seat-everyone/</link><pubDate>Sat, 31 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/minimum-number-of-moves-to-seat-everyone/</guid><description>2022-12-31每日一题：2037. 使每位学生都有座位的最少移动次数 难度：Easy
标签：数组 、 排序
一个房间里有 n&amp;nbsp;个座位和 n&amp;nbsp;名学生，房间用一个数轴表示。给你一个长度为 n&amp;nbsp;的数组&amp;nbsp;seats&amp;nbsp;，其中&amp;nbsp;seats[i] 是第 i&amp;nbsp;个座位的位置。同时给你一个长度为 n&amp;nbsp;的数组&amp;nbsp;students&amp;nbsp;，其中&amp;nbsp;students[j]&amp;nbsp;是第 j&amp;nbsp;位学生的位置。
你可以执行以下操作任意次：
增加或者减少第&amp;nbsp;i&amp;nbsp;位学生的位置，每次变化量为 1&amp;nbsp;（也就是将第 i&amp;nbsp;位学生从位置 x&amp;nbsp;移动到 x + 1&amp;nbsp;或者 x - 1） 请你返回使所有学生都有座位坐的 最少移动次数&amp;nbsp;，并确保没有两位学生的座位相同。
请注意，初始时有可能有多个座位或者多位学生在 同一&amp;nbsp;位置。
&amp;nbsp;
示例 1：
输入：seats = [3,1,5], students = [2,7,4] 输出：4 解释：学生移动方式如下： - 第一位学生从位置 2 移动到位置 1 ，移动 1 次。 - 第二位学生从位置 7 移动到位置 5 ，移动 2 次。 - 第三位学生从位置 4 移动到位置 3 ，移动 1 次。 总共 1 + 2 + 1 = 4 次移动。 示例 2：</description></item><item><title>【2022-12-14每日一题】1697. 检查边长度限制的路径是否存在[Hard]</title><link>/study/leetcode/checking-existence-of-edge-length-limited-paths/</link><pubDate>Wed, 14 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/checking-existence-of-edge-length-limited-paths/</guid><description>2022-12-14每日一题：1697. 检查边长度限制的路径是否存在 难度：Hard
标签：并查集 、 图 、 数组 、 排序
给你一个 n 个点组成的无向图边集 edgeList ，其中 edgeList[i] = [ui, vi, disi] 表示点 ui 和点 vi 之间有一条长度为 disi 的边。请注意，两个点之间可能有 超过一条边 。
给你一个查询数组queries ，其中 queries[j] = [pj, qj, limitj] ，你的任务是对于每个查询 queries[j] ，判断是否存在从 pj 到 qj 的路径，且这条路径上的每一条边都 严格小于 limitj 。
请你返回一个 布尔数组 answer ，其中 answer.length == queries.length ，当 queries[j] 的查询结果为 true 时， answer 第 j 个值为 true ，否则为 false 。
示例 1：
输入：n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]] 输出：[false,true] 解释：上图为给定的输入数据。注意到 0 和 1 之间有两条重边，分别为 2 和 16 。 对于第一个查询，0 和 1 之间没有小于 2 的边，所以我们返回 false 。 对于第二个查询，有一条路径（0 -> 1 -> 2）两条边都小于 5 ，所以这个查询我们返回 true 。 示例 2：</description></item><item><title>【2022-12-10每日一题】1691. 堆叠长方体的最大高度[Hard]</title><link>/study/leetcode/maximum-height-by-stacking-cuboids/</link><pubDate>Sat, 10 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximum-height-by-stacking-cuboids/</guid><description>2022-12-10每日一题：1691. 堆叠长方体的最大高度 难度：Hard
标签：数组 、 动态规划 、 排序
给你 n 个长方体 cuboids ，其中第 i 个长方体的长宽高表示为 cuboids[i] = [widthi, lengthi, heighti]（下标从 0 开始）。请你从 cuboids 选出一个 子集 ，并将它们堆叠起来。
如果 widthi &lt;= widthj 且 lengthi &lt;= lengthj 且 heighti &lt;= heightj ，你就可以将长方体 i 堆叠在长方体 j 上。你可以通过旋转把长方体的长宽高重新排列，以将它放在另一个长方体上。
返回 堆叠长方体 cuboids 可以得到的 最大高度 。
示例 1：
输入：cuboids = [[50,45,20],[95,37,53],[45,23,12]] 输出：190 解释： 第 1 个长方体放在底部，53x37 的一面朝下，高度为 95 。 第 0 个长方体放在中间，45x20 的一面朝下，高度为 50 。 第 2 个长方体放在上面，23x12 的一面朝下，高度为 45 。 总高度是 95 + 50 + 45 = 190 。 示例 2：</description></item><item><title>【2022-11-18每日一题】891. 子序列宽度之和[Hard]</title><link>/study/leetcode/sum-of-subsequence-widths/</link><pubDate>Fri, 18 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/sum-of-subsequence-widths/</guid><description>2022-11-18每日一题：891. 子序列宽度之和 难度：Hard
标签：数组 、 数学 、 排序
一个序列的 宽度 定义为该序列中最大元素和最小元素的差值。
给你一个整数数组 nums ，返回 nums 的所有非空 子序列 的 宽度之和 。由于答案可能非常大，请返回对 109 + 7 取余 后的结果。
子序列 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，[3,6,2,7] 就是数组 [0,3,1,6,2,2,7] 的一个子序列。
&amp;nbsp;
示例 1：
输入：nums = [2,1,3] 输出：6 解释：子序列为 [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3] 。 相应的宽度是 0, 0, 0, 1, 1, 2, 2 。 宽度之和是 6 。 示例 2：
输入：nums = [2] 输出：0 &amp;nbsp;
提示：
1 &amp;lt;= nums.length &amp;lt;= 105 1 &amp;lt;= nums[i] &amp;lt;= 105 方法一：数学（排序 + 枚举元素计算贡献） 推荐题解一 推荐题解二 const mod int = 1e9+7 // 写法一： func sumSubseqWidths(nums []int) (ans int) { sort.</description></item><item><title>【2022-11-17每日一题】792. 匹配子序列的单词数[Medium]</title><link>/study/leetcode/number-of-matching-subsequences/</link><pubDate>Thu, 17 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/number-of-matching-subsequences/</guid><description>2022-11-17每日一题：792. 匹配子序列的单词数 难度：Medium
标签：字典树 、 哈希表 、 字符串 、 排序
给定字符串 s&amp;nbsp;和字符串数组&amp;nbsp;words, 返回&amp;nbsp;&amp;nbsp;words[i]&amp;nbsp;中是s的子序列的单词个数&amp;nbsp;。
字符串的 子序列 是从原始字符串中生成的新字符串，可以从中删去一些字符(可以是none)，而不改变其余字符的相对顺序。
例如， “ace” 是 “abcde” 的子序列。 &amp;nbsp;
示例 1:
输入: s = "abcde", words = ["a","bb","acd","ace"] 输出: 3 解释: 有三个是&amp;nbsp;s 的子序列的单词: "a", "acd", "ace"。 Example 2:
输入: s = "dsahjpjauf", words = ["ahjpjau","ja","ahbwzgqnuk","tnmlanowax"] 输出: 2 &amp;nbsp;
提示:
1 &amp;lt;= s.length &amp;lt;= 5 * 104 1 &amp;lt;= words.length &amp;lt;= 5000 1 &amp;lt;= words[i].length &amp;lt;= 50 words[i]和 s&amp;nbsp;都只由小写字母组成。 ​​​​ 方法一：分桶 详细解释 func numMatchingSubseq(s string, words []string) (ans int) { d := [26][]string{} for _, w := range words { d[w[0]-'a'] = append(d[w[0]-'a'], w) // 按首字母分桶 } for _, c := range s { q := d[c-'a'] d[c-'a'] = nil for _, t := range q { if len(t) == 1 { // 长度加一 ans++ } else { d[t[1]-'a'] = append(d[t[1]-'a'], t[1:]) // 按第二个字母继续分桶 } } } return ans } 复杂度分析 方法二：分桶优化（多指针） // 写法一： func numMatchingSubseq(s string, words []string) (ans int) { type pair struct { i, j int } d := [26][]pair{} for i, w := range words { d[w[0]-'a'] = append(d[w[0]-'a'], pair{i, 0}) } for _, c := range s { q := d[c-'a'] d[c-'a'] = []pair{} for _, p := range q { i, j := p.</description></item><item><title>【2022-11-15每日一题】1710. 卡车上的最大单元数[Easy]</title><link>/study/leetcode/maximum-units-on-a-truck/</link><pubDate>Tue, 15 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximum-units-on-a-truck/</guid><description>2022-11-15每日一题：1710. 卡车上的最大单元数 难度：Easy
标签：贪心 、 数组 、 排序
请你将一些箱子装在 一辆卡车 上。给你一个二维数组 boxTypes ，其中 boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi] ：
numberOfBoxesi 是类型 i 的箱子的数量。 numberOfUnitsPerBoxi 是类型 i 每个箱子可以装载的单元数量。 整数 truckSize 表示卡车上可以装载 箱子 的 最大数量 。只要箱子数量不超过 truckSize ，你就可以选择任意箱子装到卡车上。
返回卡车可以装载 单元 的 最大 总数。
示例 1：
输入：boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4 输出：8 解释：箱子的情况如下： - 1 个第一类的箱子，里面含 3 个单元。 - 2 个第二类的箱子，每个里面含 2 个单元。 - 3 个第三类的箱子，每个里面含 1 个单元。 可以选择第一类和第二类的所有箱子，以及第三类的一个箱子。 单元总数 = (1 * 3) + (2 * 2) + (1 * 1) = 8 示例 2：</description></item><item><title>【2022-11-13每日一题】791. 自定义字符串排序[Medium]</title><link>/study/leetcode/custom-sort-string/</link><pubDate>Sun, 13 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/custom-sort-string/</guid><description>2022-11-13每日一题：791. 自定义字符串排序 难度：Medium
标签：哈希表 、 字符串 、 排序
给定两个字符串 order 和 s 。order 的所有单词都是 唯一 的，并且以前按照一些自定义的顺序排序。
对 s 的字符进行置换，使其与排序的&amp;nbsp;order&amp;nbsp;相匹配。更具体地说，如果在&amp;nbsp;order&amp;nbsp;中的字符 x 出现字符 y 之前，那么在排列后的字符串中， x&amp;nbsp;也应该出现在 y 之前。
返回 满足这个性质的 s 的任意排列&amp;nbsp;。
&amp;nbsp;
示例 1:
输入: order = "cba", s = "abcd" 输出: "cbad" 解释: “a”、“b”、“c”是按顺序出现的，所以“a”、“b”、“c”的顺序应该是“c”、“b”、“a”。 因为“d”不是按顺序出现的，所以它可以在返回的字符串中的任何位置。“dcba”、“cdba”、“cbda”也是有效的输出。 示例 2:
输入: order = "cbafg", s = "abcd" 输出: "cbad" &amp;nbsp;
提示:
1 &amp;lt;= order.length &amp;lt;= 26 1 &amp;lt;= s.length &amp;lt;= 200 order&amp;nbsp;和&amp;nbsp;s&amp;nbsp;由小写英文字母组成 order&amp;nbsp;中的所有字符都 不同 方法一：哈希表 + 按字母索引排序 // 写法一 func customSortString(order string, s string) string { n := len(order) ht := make(map[byte]int, n) // 此处可以用 [26]int{} 代替 for i := 0; i &amp;lt; n; i++ { ht[order[i]] = i } ss := []byte(s) sort.</description></item><item><title>【2022-10-22每日一题】1235. 规划兼职工作[Hard]</title><link>/study/leetcode/maximum-profit-in-job-scheduling/</link><pubDate>Sat, 22 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximum-profit-in-job-scheduling/</guid><description>2022-10-22每日一题：1235. 规划兼职工作 难度：Hard
标签：数组 、 二分查找 、 动态规划 、 排序
你打算利用空闲时间来做兼职工作赚些零花钱。
这里有&amp;nbsp;n&amp;nbsp;份兼职工作，每份工作预计从&amp;nbsp;startTime[i]&amp;nbsp;开始到&amp;nbsp;endTime[i]&amp;nbsp;结束，报酬为&amp;nbsp;profit[i]。
给你一份兼职工作表，包含开始时间&amp;nbsp;startTime，结束时间&amp;nbsp;endTime&amp;nbsp;和预计报酬&amp;nbsp;profit&amp;nbsp;三个数组，请你计算并返回可以获得的最大报酬。
注意，时间上出现重叠的 2 份工作不能同时进行。
如果你选择的工作在时间&amp;nbsp;X&amp;nbsp;结束，那么你可以立刻进行在时间&amp;nbsp;X&amp;nbsp;开始的下一份工作。
&amp;nbsp;
示例 1：
输入：startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70] 输出：120 解释： 我们选出第 1 份和第 4 份工作， 时间范围是 [1-3]+[3-6]，共获得报酬 120 = 50 + 70。 示例 2：
输入：startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60] 输出：150 解释： 我们选择第 1，4，5 份工作。 共获得报酬 150 = 20 + 70 + 60。 示例 3：
输入：startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4] 输出：6 &amp;nbsp;</description></item><item><title>【2022-10-13每日一题】769. 最多能完成排序的块[Medium]</title><link>/study/leetcode/max-chunks-to-make-sorted/</link><pubDate>Thu, 13 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/max-chunks-to-make-sorted/</guid><description>2022-10-13每日一题：769. 最多能完成排序的块 难度：Medium
标签：栈 、 贪心 、 数组 、 排序 、 单调栈
给定一个长度为 n 的整数数组 arr ，它表示在 [0, n - 1] 范围内的整数的排列。
我们将 arr 分割成若干 块 (即分区)，并对每个块单独排序。将它们连接起来后，使得连接的结果和按升序排序后的原数组相同。
返回数组能分成的最多块数量。
&amp;nbsp;
示例 1:
输入: arr = [4,3,2,1,0] 输出: 1 解释: 将数组分成2块或者更多块，都无法得到所需的结果。 例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。 示例 2:
输入: arr = [1,0,2,3,4] 输出: 4 解释: 我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。 然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。 &amp;nbsp;
提示:</description></item><item><title>【2022-10-08每日一题】870. 优势洗牌[Medium]</title><link>/study/leetcode/advantage-shuffle/</link><pubDate>Sat, 08 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/advantage-shuffle/</guid><description>2022-10-08每日一题：870. 优势洗牌 难度：Medium
标签：贪心 、 数组 、 双指针 、 排序
给定两个大小相等的数组&amp;nbsp;nums1&amp;nbsp;和&amp;nbsp;nums2，nums1&amp;nbsp;相对于 nums&amp;nbsp;的优势可以用满足&amp;nbsp;nums1[i] &amp;gt; nums2[i]&amp;nbsp;的索引 i&amp;nbsp;的数目来描述。
返回 nums1&amp;nbsp;的任意排列，使其相对于 nums2&amp;nbsp;的优势最大化。
&amp;nbsp;
示例 1：
输入：nums1 = [2,7,11,15], nums2 = [1,10,4,11] 输出：[2,11,7,15] 示例 2：
输入：nums1 = [12,24,8,32], nums2 = [13,25,32,11] 输出：[24,32,8,12] &amp;nbsp;
提示：
1 &amp;lt;= nums1.length &amp;lt;= 105 nums2.length == nums1.length 0 &amp;lt;= nums1[i], nums2[i] &amp;lt;= 109 方法一：排序+贪心算法 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
func advantageCount(nums1 []int, nums2 []int) []int { // 构造索引数组 n := len(nums1) idx1 := make([]int, n) idx2 := make([]int, n) for i := 1; i &amp;lt; n; i++ { idx1[i] = i idx2[i] = i } // 对索引数组升序排序，比较巧妙 sort.</description></item><item><title>【2022-09-27每日一题】面试题 01.02. 判定是否互为字符重排[Easy]</title><link>/study/leetcode/check-permutation-lcci/</link><pubDate>Tue, 27 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/check-permutation-lcci/</guid><description>2022-09-27每日一题：面试题 01.02. 判定是否互为字符重排 难度：Easy
标签：哈希表 、 字符串 、 排序
给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。
示例 1：
输入: s1 = &amp;quot;abc&amp;quot;, s2 = &amp;quot;bca&amp;quot; 输出: true 示例 2：
输入: s1 = &amp;quot;abc&amp;quot;, s2 = &amp;quot;bad&amp;quot; 输出: false 说明：
0 &amp;lt;= len(s1) &amp;lt;= 100 0 &amp;lt;= len(s2) &amp;lt;= 100 方法一：排序 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
func CheckPermutation(s1 string, s2 string) bool { b1, b2 := []byte(s1), []byte(s2) sort.Slice(b1, func(i, j int) bool {return b1[i] &amp;lt; b1[j]}) sort.Slice(b2, func(i, j int) bool {return b2[i] &amp;lt; b2[j]}) // return reflect.</description></item><item><title>【2022-09-19每日一题】1636. 按照频率将数组升序排序</title><link>/study/leetcode/sort-array-by-increasing-frequency/</link><pubDate>Mon, 19 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/sort-array-by-increasing-frequency/</guid><description>2022-09-19每日一题：1636. 按照频率将数组升序排序 难度：Easy
标签：数组 、 哈希表 、 排序
给你一个整数数组 nums ，请你将数组按照每个值的频率 升序 排序。如果有多个值的频率相同，请你按照数值本身将它们 降序 排序。 请你返回排序后的数组。
示例 1：
输入：nums = [1,1,2,2,2,3] 输出：[3,1,1,2,2,2] 解释：'3' 频率为 1，'1' 频率为 2，'2' 频率为 3 。 示例 2：
输入：nums = [2,3,1,3,2] 输出：[1,3,3,2,2] 解释：'2' 和 '3' 频率都为 2 ，所以它们之间按照数值本身降序排序。 示例 3：
输入：nums = [-1,1,-6,4,5,-6,1,4,1] 输出：[5,-1,4,4,-6,-6,1,1,1] 提示：
1 &amp;lt;= nums.length &amp;lt;= 100 -100 &amp;lt;= nums[i] &amp;lt;= 100 方法一：模拟 func frequencySort(nums []int) []int { mp := make(map[int]int) for _, num := range nums { mp[num]++ } slice := make([][2]int, 0, len(mp)) for num, count := range mp { slice = append(slice, [2]int{count, num}) } sort.</description></item><item><title>【2022-09-14每日一题】1619. 删除某些元素后的数组均值</title><link>/study/leetcode/mean-of-array-after-removing-some-elements/</link><pubDate>Wed, 14 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/mean-of-array-after-removing-some-elements/</guid><description>2022-09-14每日一题：1619. 删除某些元素后的数组均值 难度：Easy 标签：数组 、 排序 给你一个整数数组 arr ，请你删除最小 5% 的数字和最大 5% 的数字后，剩余数字的平均值。
与 标准答案 误差在 10-5 的结果都被视为正确结果。
示例 1：
输入：arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3] 输出：2.00000 解释：删除数组中最大和最小的元素后，所有元素都等于 2，所以平均值为 2 。 示例 2：
输入：arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0] 输出：4.00000 示例 3：
输入：arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4] 输出：4.77778 示例 4：
输入：arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3] 输出：5.27778 示例 5：
输入：arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1] 输出：5.29167 提示：
20 &lt;= arr.length &lt;= 1000 arr.length 是 20 的 倍数 0 &lt;= arr[i] &lt;= 105 ### 方法一：排序 func trimMean(arr []int) float64 { sort.</description></item><item><title>【2022-09-12每日一题】1608. 特殊数组的特征值</title><link>/study/leetcode/special-array-with-x-elements-greater-than-or-equal-x/</link><pubDate>Mon, 12 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/special-array-with-x-elements-greater-than-or-equal-x/</guid><description>2022-09-12每日一题：1608. 特殊数组的特征值 难度：Easy 标签：数组 、 二分查找 、 排序 给你一个非负整数数组 nums 。如果存在一个数 x ，使得 nums 中恰好有 x 个元素 大于或者等于 x ，那么就称 nums 是一个 特殊数组 ，而 x 是该数组的 特征值 。
注意： x 不必 是 nums 的中的元素。
如果数组 nums 是一个 特殊数组 ，请返回它的特征值 x 。否则，返回 -1 。可以证明的是，如果 nums 是特殊数组，那么其特征值 x 是 唯一的 。
&amp;nbsp;
示例 1：
输入：nums = [3,5] 输出：2 解释：有 2 个元素（3 和 5）大于或等于 2 。 示例 2：
输入：nums = [0,0] 输出：-1 解释：没有满足题目要求的特殊数组，故而也不存在特征值 x 。 如果 x = 0，应该有 0 个元素 &amp;gt;= x，但实际有 2 个。 如果 x = 1，应该有 1 个元素 &amp;gt;= x，但实际有 0 个。 如果 x = 2，应该有 2 个元素 &amp;gt;= x，但实际有 0 个。 x 不能取更大的值，因为 nums 中只有两个元素。 示例 3：</description></item><item><title>【2022-09-11每日一题】：857. 雇佣 K 名工人的最低成本</title><link>/study/leetcode/minimum-cost-to-hire-k-workers/</link><pubDate>Sun, 11 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/minimum-cost-to-hire-k-workers/</guid><description>2022-09-11每日一题：857. 雇佣 K 名工人的最低成本 难度：Hard 标签：贪心 、 数组 、 排序 、 堆（优先队列） 有 n&amp;nbsp;名工人。&amp;nbsp;给定两个数组&amp;nbsp;quality&amp;nbsp;和&amp;nbsp;wage&amp;nbsp;，其中，quality[i]&amp;nbsp;表示第&amp;nbsp;i&amp;nbsp;名工人的工作质量，其最低期望工资为&amp;nbsp;wage[i]&amp;nbsp;。
现在我们想雇佣&amp;nbsp;k&amp;nbsp;名工人组成一个工资组。在雇佣&amp;nbsp;一组 k&amp;nbsp;名工人时，我们必须按照下述规则向他们支付工资：
对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资。 工资组中的每名工人至少应当得到他们的最低期望工资。 给定整数 k ，返回 组成满足上述条件的付费群体所需的最小金额&amp;nbsp;。在实际答案的&amp;nbsp;10-5&amp;nbsp;以内的答案将被接受。。
&amp;nbsp;
示例 1：
输入： quality = [10,20,5], wage = [70,50,30], k = 2 输出： 105.00000 解释： 我们向 0 号工人支付 70，向 2 号工人支付 35。 示例 2：
输入： quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3 输出： 30.66667 解释： 我们向 0 号工人支付 4，向 2 号和 3 号分别支付 13.33333。 &amp;nbsp;
提示：
n == quality.length == wage.</description></item><item><title>【2022-09-03每日一题】646. 最长数对链</title><link>/study/leetcode/maximum-length-of-pair-chain/</link><pubDate>Sat, 03 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximum-length-of-pair-chain/</guid><description>2022-09-03每日一题：646. 最长数对链 难度：Medium 标签：贪心 、 数组 、 动态规划 、 排序 给出 n 个数对。 在每一个数对中，第一个数字总是比第二个数字小。
现在，我们定义一种跟随关系，当且仅当 b &lt; c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。
给定一个数对集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。
示例：
输入：[[1,2], [2,3], [3,4]] 输出：2 解释：最长的数对链是 [1,2] -> [3,4] 提示：
给出数对的个数在 [1, 1000] 范围内。 ### 方法一：动态规划 func findLongestChain(pairs [][]int) int { sort.Slice(pairs, func(i, j int) bool { return pairs[i][0] &amp;lt; pairs[j][0] }) n := len(pairs) dp := make([]int, n) for i, p := range pairs { dp[i] = 1 // 初始化时，dp 需要全部赋值为 1 for j, q := range pairs[:i] { if p[0] &amp;gt; q[1] { dp[i] = max(dp[i], dp[j] + 1) } } } return dp[n-1] } func max(a, b int) int { if a &amp;gt; b { return a } return b } 复杂度分析 时间复杂度：O(n^2)，其中 n 为 pairs 的长度。排序的时间复杂度为O(nlogn)，两层 for 循环的时间复杂度为 O(n^2)。</description></item><item><title>【2022-08-26每日一题】1464. 数组中两元素的最大乘积</title><link>/study/leetcode/maximum-product-of-two-elements-in-an-array/</link><pubDate>Fri, 26 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximum-product-of-two-elements-in-an-array/</guid><description>2022-08-26每日一题：1464. 数组中两元素的最大乘积 难度：Easy 标签：数组 、 排序 、 堆（优先队列） 给你一个整数数组 nums，请你选择数组的两个不同下标 i 和 j，使 (nums[i]-1)*(nums[j]-1) 取得最大值。
请你计算并返回该式的最大值。
&amp;nbsp;
示例 1：
输入：nums = [3,4,5,2] 输出：12 解释：如果选择下标 i=1 和 j=2（下标从 0 开始），则可以获得最大值，(nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12 。 示例 2：
输入：nums = [1,5,4,5] 输出：16 解释：选择下标 i=1 和 j=3（下标从 0 开始），则可以获得最大值 (5-1)*(5-1) = 16 。 示例 3：
输入：nums = [3,7] 输出：12 &amp;nbsp;
提示：
2 &amp;lt;= nums.length &amp;lt;= 500 1 &amp;lt;= nums[i] &amp;lt;= 10^3 方法一：一次遍历找出最大的两个数 func maxProduct(nums []int) int { a, b := nums[0], nums[1] for i := 2; i &amp;lt; len(nums); i++ { // 每次和最小的数进行比较并更新对应数字 if a &amp;lt; b &amp;amp;&amp;amp; a &amp;lt; nums[i] { a = nums[i] } else if b &amp;lt; nums[i] { b = nums[i] } } return (a-1)*(b-1) } 复杂度分析 时间复杂度：O(n) 空间复杂度：O(1) 方法二：排序，取最大两个数 func maxProduct(nums []int) int { sort.</description></item><item><title>【2022-08-25每日一题】658. 找到 K 个最接近的元素</title><link>/study/leetcode/find-k-closest-elements/</link><pubDate>Thu, 25 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/find-k-closest-elements/</guid><description>2022-08-25每日一题：658. 找到 K 个最接近的元素 难度：Medium 标签：数组 、 双指针 、 二分查找 、 排序 、 堆（优先队列） 给定一个 排序好 的数组&amp;nbsp;arr ，两个整数 k 和 x ，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。
整数 a 比整数 b 更接近 x 需要满足：
|a - x| &amp;lt; |b - x| 或者 |a - x| == |b - x| 且 a &amp;lt; b &amp;nbsp;
示例 1：
输入：arr = [1,2,3,4,5], k = 4, x = 3 输出：[1,2,3,4] 示例 2：
输入：arr = [1,2,3,4,5], k = 4, x = -1 输出：[1,2,3,4] &amp;nbsp;</description></item><item><title>【2022-08-24每日一题】1460. 通过翻转子数组使两个数组相等</title><link>/study/leetcode/make-two-arrays-equal-by-reversing-sub-arrays/</link><pubDate>Wed, 24 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/make-two-arrays-equal-by-reversing-sub-arrays/</guid><description>2022-08-24每日一题：1460. 通过翻转子数组使两个数组相等 难度：Easy 标签：数组 、 哈希表 、 排序 给你两个长度相同的整数数组&amp;nbsp;target&amp;nbsp;和&amp;nbsp;arr&amp;nbsp;。每一步中，你可以选择&amp;nbsp;arr&amp;nbsp;的任意 非空子数组&amp;nbsp;并将它翻转。你可以执行此过程任意次。
如果你能让 arr&amp;nbsp;变得与 target&amp;nbsp;相同，返回 True；否则，返回 False 。
&amp;nbsp;
示例 1：
输入：target = [1,2,3,4], arr = [2,4,1,3] 输出：true 解释：你可以按照如下步骤使 arr 变成 target： 1- 翻转子数组 [2,4,1] ，arr 变成 [1,4,2,3] 2- 翻转子数组 [4,2] ，arr 变成 [1,2,4,3] 3- 翻转子数组 [4,3] ，arr 变成 [1,2,3,4] 上述方法并不是唯一的，还存在多种将 arr 变成 target 的方法。 示例 2：
输入：target = [7], arr = [7] 输出：true 解释：arr 不需要做任何翻转已经与 target 相等。 示例 3：
输入：target = [3,7,9], arr = [3,7,11] 输出：false 解释：arr 没有数字 9 ，所以无论如何也无法变成 target 。 &amp;nbsp;</description></item><item><title>【2022-08-13每日一题】768. 最多能完成排序的块 II</title><link>/study/leetcode/max-chunks-to-make-sorted-ii/</link><pubDate>Sat, 13 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/max-chunks-to-make-sorted-ii/</guid><description>2022-08-13每日一题：768. 最多能完成排序的块 II 难度：Hard 标签：栈 、 贪心 、 数组 、 排序 、 单调栈 这个问题和&amp;ldquo;最多能完成排序的块&amp;rdquo;相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10**8。
arr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个&amp;ldquo;块&amp;rdquo;，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。
我们最多能将数组分成多少块？
示例&amp;nbsp;1:
输入: arr = [5,4,3,2,1] 输出: 1 解释: 将数组分成2块或者更多块，都无法得到所需的结果。 例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 示例 2:
输入: arr = [2,1,3,4,4] 输出: 4 解释: 我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。 然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。 注意:
arr的长度在[1, 2000]之间。 arr[i]的大小在[0, 10**8]之间。 ### 方法一：单调栈 思路 对于已经分好块的数组，若块数大于 1，则可以得到以下结论：右边的块的所有数字均大于或等于左边的块的所有数字。考虑这个问题：对于已经分好块的数组，若在其末尾添加一个数字，如何求得新数组的分块方式？
新添加的数字可能会改变原数组的分块方式。如果新添加的数字大于或等于原数组最后一个块的最大值，则这个新添加的数字可以自己形成一个块。如果新添加的数字小于原数组最后一个块的最大值，则它必须融入最后一个块。如果它大于或等于原数组倒数第二个块（如果有）的最大值，那么这个过程可以停止，新数组的分块方式已经求得。否则，它将继续融合原数组倒数第二个块，直到遇到一个块，使得该块的最大值小于或等于这个新添加的数，或者这个数字已经融合了所有块。
上述分析过程中，我们只用到了块的最大值来进行比较，比较过程又是从右到左，符合栈的思想，因此可以用类似单调栈的数据结构来存储块的最大值。
代码 func maxChunksToSorted(arr []int) int { st := []int{} for _, x := range arr { if len(st) == 0 || x &amp;gt;= st[len(st)-1] { st = append(st, x) } else { mx := st[len(st)-1] st = st[:len(st)-1] for len(st) &amp;gt; 0 &amp;amp;&amp;amp; st[len(st)-1] &amp;gt; x { st = st[:len(st)-1] } st = append(st, mx) } } return len(st) } 复杂度分析 时间复杂度：O(n)，其中 n 是输入数组 arr 的长度。需要遍历一遍数组，入栈的操作最多为 n 次。</description></item><item><title>2022-08-04每日一题：1403. 非递增顺序的最小子序列</title><link>/study/leetcode/minimum-subsequence-in-non-increasing-order/</link><pubDate>Thu, 04 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/minimum-subsequence-in-non-increasing-order/</guid><description>2022-08-04每日一题：1403. 非递增顺序的最小子序列 给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。
如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。
与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。
注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。
&amp;nbsp;
示例 1：
输入：nums = [4,3,10,9,8] 输出：[10,9] 解释：子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。&amp;nbsp; 示例 2：
输入：nums = [4,4,7,6,7] 输出：[7,7,6] 解释：子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 = 4 + 4 + 6）。因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。 示例 3：
输入：nums = [6] 输出：[6] &amp;nbsp;
提示：
1 &amp;lt;= nums.length &amp;lt;= 500 1 &amp;lt;= nums[i] &amp;lt;= 100 ### 写法一 要求的子序列的和大于整个数组和的一半，且是略大于（因为要求长度最小）
题目中要求的&amp;quot;非递增顺序&amp;quot;给了很大的暗示：可以排序，然后从后往前找，找到最短的、和大于整个数组和一半的、子数组即可
func minSubsequence(nums []int) []int { // 降序 sort.</description></item><item><title>2022-08-03每日一题：899. 有序队列</title><link>/study/leetcode/orderly-queue/</link><pubDate>Wed, 03 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/orderly-queue/</guid><description>2022-08-03每日一题：899. 有序队列 给定一个字符串 s 和一个整数 k&amp;nbsp;。你可以从 s 的前 k 个字母中选择一个，并把它加到字符串的末尾。
返回 在应用上述步骤的任意数量的移动后，字典上最小的字符串&amp;nbsp;。
&amp;nbsp;
示例 1：
输入：s = "cba", k = 1 输出："acb" 解释： 在第一步中，我们将第一个字符（“c”）移动到最后，获得字符串 “bac”。 在第二步中，我们将第一个字符（“b”）移动到最后，获得最终结果 “acb”。 示例 2：
输入：s = "baaca", k = 3 输出："aaabc" 解释： 在第一步中，我们将第一个字符（“b”）移动到最后，获得字符串 “aacab”。 在第二步中，我们将第三个字符（“c”）移动到最后，获得最终结果 “aaabc”。 &amp;nbsp;
提示：
1 &amp;lt;= k&amp;nbsp;&amp;lt;= S.length&amp;nbsp;&amp;lt;= 1000 s&amp;nbsp;只由小写字母组成。 func orderlyQueue(s string, k int) string { if k == 1 { // 当k = 1时，共有 n 种候选方案, 遍历求其最小的字典序 ans := s for i := 1; i &amp;lt; len(s); i++ { s = s[1:] + s[:1] if s &amp;lt; ans { ans = s } } return ans } // 当k &amp;gt; 1时，经过不断的变换，我们总能让序列有序，直接对字符串进行字典序排序即可 t := []byte(s) sort.</description></item></channel></rss>