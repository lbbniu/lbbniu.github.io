<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>计数 on lbbniu</title><link>/tags/%E8%AE%A1%E6%95%B0/</link><description>Recent content in 计数 on lbbniu</description><generator>Hugo -- gohugo.io</generator><language>zh</language><managingEditor>lbbniu@gmail.com (lbbniu)</managingEditor><webMaster>lbbniu@gmail.com (lbbniu)</webMaster><copyright>&amp;copy; 2021 &lt;a href="https://blog.lbbniu.com/">lbbniu&lt;/a></copyright><lastBuildDate>Tue, 17 Jan 2023 00:01:00 +0800</lastBuildDate><atom:link href="/tags/%E8%AE%A1%E6%95%B0/index.xml" rel="self" type="application/rss+xml"/><item><title>剑指 Offer 39 数组中出现次数超过一半的数字</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/</guid><description>剑指 Offer 39 数组中出现次数超过一半的数字 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。
&amp;nbsp;
你可以假设数组是非空的，并且给定的数组总是存在多数元素。
&amp;nbsp;
示例&amp;nbsp;1:
输入: [1, 2, 3, 2, 2, 2, 5, 4, 2] 输出: 2 &amp;nbsp;
限制：
1 &amp;lt;= 数组长度 &amp;lt;= 50000
&amp;nbsp;
注意：本题与主站 169 题相同：https://leetcode-cn.com/problems/majority-element/
&amp;nbsp;
func majorityElement(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof</description></item><item><title>剑指 Offer 50 第一个只出现一次的字符</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/</guid><description>剑指 Offer 50 第一个只出现一次的字符 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。
示例 1:
输入：s = "abaccdeff" 输出：'b' 示例 2:
输入：s = "" 输出：' ' &amp;nbsp;
限制：
0 &amp;lt;= s 的长度 &amp;lt;= 50000
func firstUniqChar(s string) byte { } LeetCode题库地址 https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof</description></item><item><title>剑指 Offer II 060 出现频率最高的 k 个数字</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/g5c51o/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/g5c51o/</guid><description>剑指 Offer II 060 出现频率最高的 k 个数字 给定一个整数数组 nums 和一个整数 k&amp;nbsp;，请返回其中出现频率前 k 高的元素。可以按 任意顺序 返回答案。
&amp;nbsp;
示例 1:
输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2] 示例 2:
输入: nums = [1], k = 1 输出: [1] &amp;nbsp;
提示：
1 &amp;lt;= nums.length &amp;lt;= 105 k 的取值范围是 [1, 数组中不相同的元素的个数] 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的 &amp;nbsp;
进阶：所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n&amp;nbsp;是数组大小。
&amp;nbsp;
注意：本题与主站 347&amp;nbsp;题相同：https://leetcode-cn.com/problems/top-k-frequent-elements/
func topKFrequent(nums []int, k int) []int { } LeetCode题库地址 https://leetcode.cn/problems/g5c51o</description></item><item><title>面试题 16.04 井字游戏</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/tic-tac-toe-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/tic-tac-toe-lcci/</guid><description>面试题 16.04 井字游戏 设计一个算法，判断玩家是否赢了井字游戏。输入是一个 N x N 的数组棋盘，由字符&amp;quot; &amp;quot;，&amp;quot;X&amp;quot;和&amp;quot;O&amp;quot;组成，其中字符&amp;quot; &amp;quot;代表一个空位。
以下是井字游戏的规则：
玩家轮流将字符放入空位（&amp;quot; &amp;quot;）中。 第一个玩家总是放字符&amp;quot;O&amp;quot;，且第二个玩家总是放字符&amp;quot;X&amp;quot;。 &amp;quot;X&amp;quot;和&amp;quot;O&amp;quot;只允许放置在空位中，不允许对已放有字符的位置进行填充。 当有N个相同（且非空）的字符填充任何行、列或对角线时，游戏结束，对应该字符的玩家获胜。 当所有位置非空时，也算为游戏结束。 如果游戏结束，玩家不允许再放置字符。 如果游戏存在获胜者，就返回该游戏的获胜者使用的字符（&amp;quot;X&amp;quot;或&amp;quot;O&amp;quot;）；如果游戏以平局结束，则返回 &amp;quot;Draw&amp;quot;；如果仍会有行动（游戏未结束），则返回 &amp;quot;Pending&amp;quot;。
示例 1：
输入： board = [&amp;quot;O X&amp;quot;,&amp;quot; XO&amp;quot;,&amp;quot;X O&amp;quot;] 输出： &amp;quot;X&amp;quot; 示例 2：
输入： board = [&amp;quot;OOX&amp;quot;,&amp;quot;XXO&amp;quot;,&amp;quot;OXO&amp;quot;] 输出： &amp;quot;Draw&amp;quot; 解释： 没有玩家获胜且不存在空位 示例 3：
输入： board = [&amp;quot;OOX&amp;quot;,&amp;quot;XXO&amp;quot;,&amp;quot;OX &amp;quot;] 输出： &amp;quot;Pending&amp;quot; 解释： 没有玩家获胜且仍存在空位 提示：
1 &amp;lt;= board.length == board[i].length &amp;lt;= 100 输入一定遵循井字棋规则 func tictactoe(board []string) string { } LeetCode题库地址 https://leetcode.cn/problems/tic-tac-toe-lcci</description></item><item><title>面试题 16.10 生存人数</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/living-people-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/living-people-lcci/</guid><description>面试题 16.10 生存人数 给定 N 个人的出生年份和死亡年份，第 i 个人的出生年份为 birth[i]，死亡年份为 death[i]，实现一个方法以计算生存人数最多的年份。
你可以假设所有人都出生于 1900 年至 2000 年（含 1900 和 2000 ）之间。如果一个人在某一年的任意时期处于生存状态，那么他应该被纳入那一年的统计中。例如，生于 1908 年、死于 1909 年的人应当被列入 1908 年和 1909 年的计数。
如果有多个年份生存人数相同且均为最大值，输出其中最小的年份。
示例：
输入： birth = {1900, 1901, 1950} death = {1948, 1951, 2000} 输出： 1901 提示：
0 &lt; birth.length == death.length &lt;= 10000 birth[i] &lt;= death[i] func maxAliveYear(birth []int, death []int) int { } LeetCode题库地址 https://leetcode.cn/problems/living-people-lcci</description></item><item><title>面试题 16.15 珠玑妙算</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/master-mind-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/master-mind-lcci/</guid><description>面试题 16.15 珠玑妙算 珠玑妙算游戏（the game of master mind）的玩法如下。
计算机有4个槽，每个槽放一个球，颜色可能是红色（R）、黄色（Y）、绿色（G）或蓝色（B）。例如，计算机可能有RGGB 4种（槽1为红色，槽2、3为绿色，槽4为蓝色）。作为用户，你试图猜出颜色组合。打个比方，你可能会猜YRGB。要是猜对某个槽的颜色，则算一次“猜中”；要是只猜对颜色但槽位猜错了，则算一次“伪猜中”。注意，“猜中”不能算入“伪猜中”。
给定一种颜色组合solution和一个猜测guess，编写一个方法，返回猜中和伪猜中的次数answer，其中answer[0]为猜中的次数，answer[1]为伪猜中的次数。
示例：
输入： solution="RGBY",guess="GGRR" 输出： [1,1] 解释： 猜中1次，伪猜中1次。 提示：
len(solution) = len(guess) = 4 solution和guess仅包含"R","G","B","Y"这4种字符 func masterMind(solution string, guess string) []int { } LeetCode题库地址 https://leetcode.cn/problems/master-mind-lcci</description></item><item><title>面试题 16.24 数对和</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/pairs-with-sum-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/pairs-with-sum-lcci/</guid><description>面试题 16.24 数对和 设计一个算法，找出数组中两数之和为指定值的所有整数对。一个数只能属于一个数对。
示例 1:
输入: nums = [5,6,5], target = 11 输出: [[5,6]] 示例 2:
输入: nums = [5,6,5,6], target = 11 输出: [[5,6],[5,6]] 提示：
nums.length &amp;lt;= 100000 func pairSums(nums []int, target int) [][]int { } LeetCode题库地址 https://leetcode.cn/problems/pairs-with-sum-lcci</description></item><item><title>面试题 17.07 婴儿名字</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/baby-names-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/baby-names-lcci/</guid><description>面试题 17.07 婴儿名字 每年，政府都会公布一万个最常见的婴儿名字和它们出现的频率，也就是同名婴儿的数量。有些名字有多种拼法，例如，John 和 Jon 本质上是相同的名字，但被当成了两个名字公布出来。给定两个列表，一个是名字及对应的频率，另一个是本质相同的名字对。设计一个算法打印出每个真实名字的实际频率。注意，如果 John 和 Jon 是相同的，并且 Jon 和 Johnny 相同，则 John 与 Johnny 也相同，即它们有传递和对称性。
在结果列表中，选择 字典序最小 的名字作为真实名字。
示例：
输入：names = ["John(15)","Jon(12)","Chris(13)","Kris(4)","Christopher(19)"], synonyms = ["(Jon,John)","(John,Johnny)","(Chris,Kris)","(Chris,Christopher)"] 输出：["John(27)","Chris(36)"] 提示：
names.length &lt;= 100000 func trulyMostPopular(names []string, synonyms []string) []string { } LeetCode题库地址 https://leetcode.cn/problems/baby-names-lcci</description></item><item><title>面试题 17.10 主要元素</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/find-majority-element-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/find-majority-element-lcci/</guid><description>面试题 17.10 主要元素 数组中占比超过一半的元素称之为主要元素。给你一个 整数 数组，找出其中的主要元素。若没有，返回 -1 。请设计时间复杂度为 O(N) 、空间复杂度为 O(1) 的解决方案。
示例 1：
输入：[1,2,5,9,5,9,5,5,5] 输出：5 示例 2：
输入：[3,2] 输出：-1 示例 3：
输入：[2,2,1,1,1,2,2] 输出：2 func majorityElement(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/find-majority-element-lcci</description></item><item><title>【2023-01-17每日一题】1814. 统计一个数组中好对子的数目[Medium]</title><link>/study/leetcode/count-nice-pairs-in-an-array/</link><pubDate>Tue, 17 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/count-nice-pairs-in-an-array/</guid><description>2023-01-17每日一题：1814. 统计一个数组中好对子的数目 难度：Medium
标签：数组 、 哈希表 、 数学 、 计数
给你一个数组 nums ，数组中只包含非负整数。定义 rev(x) 的值为将整数 x 各个数字位反转得到的结果。比方说 rev(123) = 321 ， rev(120) = 21 。我们称满足下面条件的下标对 (i, j) 是 好的 ：
0 &amp;lt;= i &amp;lt; j &amp;lt; nums.length nums[i] + rev(nums[j]) == nums[j] + rev(nums[i]) 请你返回好下标对的数目。由于结果可能会很大，请将结果对 109 + 7 取余 后返回。
示例 1：
输入：nums = [42,11,1,97] 输出：2 解释：两个坐标对为： - (0,3)：42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121 。 - (1,2)：11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12 。 示例 2：</description></item><item><title>【2023-01-14每日一题】1819. 序列中不同最大公约数的数目[Hard]</title><link>/study/leetcode/number-of-different-subsequences-gcds/</link><pubDate>Sat, 14 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/number-of-different-subsequences-gcds/</guid><description>2023-01-14每日一题：1819. 序列中不同最大公约数的数目 难度：Hard
标签：数组 、 数学 、 计数 、 数论
给你一个由正整数组成的数组 nums 。
数字序列的 最大公约数 定义为序列中所有整数的共有约数中的最大整数。
例如，序列 [4,6,16] 的最大公约数是 2 。 数组的一个 子序列 本质是一个序列，可以通过删除数组中的某些元素（或者不删除）得到。
例如，[2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。 计算并返回 nums 的所有 非空 子序列中 不同 最大公约数的 数目 。
示例 1：
输入：nums = [6,10,3] 输出：5 解释：上图显示了所有的非空子序列与各自的最大公约数。 不同的最大公约数为 6 、10 、3 、2 和 1 。 示例 2：
输入：nums = [5,15,40,5,6] 输出：7 提示：
1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 2 * 105 方法一： 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
func countDifferentSubsequenceGCDs(nums []int) int { } 复杂度分析 LeetCode题库地址 https://leetcode.</description></item><item><title>【2023-01-13每日一题】2287. 重排字符形成目标字符串[Easy]</title><link>/study/leetcode/rearrange-characters-to-make-target-string/</link><pubDate>Fri, 13 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/rearrange-characters-to-make-target-string/</guid><description>2023-01-13每日一题：2287. 重排字符形成目标字符串 难度：Easy
标签：哈希表 、 字符串 、 计数
给你两个下标从 0 开始的字符串 s 和 target 。你可以从 s 取出一些字符并将其重排，得到若干新的字符串。
从 s 中取出字符并重新排列，返回可以形成 target 的 最大 副本数。
&amp;nbsp;
示例 1：
输入：s = "ilovecodingonleetcode", target = "code" 输出：2 解释： 对于 "code" 的第 1 个副本，选取下标为 4 、5 、6 和 7 的字符。 对于 "code" 的第 2 个副本，选取下标为 17 、18 、19 和 20 的字符。 形成的字符串分别是 "ecod" 和 "code" ，都可以重排为 "code" 。 可以形成最多 2 个 "code" 的副本，所以返回 2 。 示例 2：
输入：s = "</description></item><item><title>【2023-01-11每日一题】2283. 判断一个数的数字计数是否等于数位的值[Easy]</title><link>/study/leetcode/check-if-number-has-equal-digit-count-and-digit-value/</link><pubDate>Wed, 11 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/check-if-number-has-equal-digit-count-and-digit-value/</guid><description>2023-01-11每日一题：2283. 判断一个数的数字计数是否等于数位的值 难度：Easy
标签：哈希表 、 字符串 、 计数
给你一个下标从 0&amp;nbsp;开始长度为 n&amp;nbsp;的字符串&amp;nbsp;num&amp;nbsp;，它只包含数字。
如果对于 每个&amp;nbsp;0 &amp;lt;= i &amp;lt; n&amp;nbsp;的下标&amp;nbsp;i&amp;nbsp;，都满足数位&amp;nbsp;i&amp;nbsp;在 num&amp;nbsp;中出现了&amp;nbsp;num[i]次，那么请你返回&amp;nbsp;true&amp;nbsp;，否则返回&amp;nbsp;false&amp;nbsp;。
&amp;nbsp;
示例 1：
输入：num = "1210" 输出：true 解释： num[0] = '1' 。数字 0 在 num 中出现了一次。 num[1] = '2' 。数字 1 在 num 中出现了两次。 num[2] = '1' 。数字 2 在 num 中出现了一次。 num[3] = '0' 。数字 3 在 num 中出现了零次。 "1210" 满足题目要求条件，所以返回 true 。 示例 2：
输入：num = "030" 输出：false 解释： num[0] = '0' 。数字 0 应该出现 0 次，但是在 num 中出现了一次。 num[1] = '3' 。数字 1 应该出现 3 次，但是在 num 中出现了零次。 num[2] = '0' 。数字 2 在 num 中出现了 0 次。 下标 0 和 1 都违反了题目要求，所以返回 false 。 &amp;nbsp;</description></item><item><title>【2023-01-01每日一题】2351. 第一个出现两次的字母[Easy]</title><link>/study/leetcode/first-letter-to-appear-twice/</link><pubDate>Sun, 01 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/first-letter-to-appear-twice/</guid><description>2023-01-01每日一题：2351. 第一个出现两次的字母 难度：Easy
标签：哈希表 、 字符串 、 计数
给你一个由小写英文字母组成的字符串 s ，请你找出并返回第一个出现 两次 的字母。
注意：
如果 a 的 第二次 出现比 b 的 第二次 出现在字符串中的位置更靠前，则认为字母 a 在字母 b 之前出现两次。 s 包含至少一个出现两次的字母。 &amp;nbsp;
示例 1：
输入：s = "abccbaacz" 输出："c" 解释： 字母 'a' 在下标 0 、5 和 6 处出现。 字母 'b' 在下标 1 和 4 处出现。 字母 'c' 在下标 2 、3 和 7 处出现。 字母 'z' 在下标 8 处出现。 字母 'c' 是第一个出现两次的字母，因为在所有字母中，'c' 第二次出现的下标是最小的。 示例 2：
输入：s = "abcdd" 输出："d" 解释： 只有字母 'd' 出现两次，所以返回 'd' 。 &amp;nbsp;</description></item><item><title>【2022-12-12每日一题】1781. 所有子字符串美丽值之和[Medium]</title><link>/study/leetcode/sum-of-beauty-of-all-substrings/</link><pubDate>Mon, 12 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/sum-of-beauty-of-all-substrings/</guid><description>2022-12-12每日一题：1781. 所有子字符串美丽值之和 难度：Medium
标签：哈希表 、 字符串 、 计数
一个字符串的 美丽值 定义为：出现频率最高字符与出现频率最低字符的出现次数之差。
比方说，"abaacc" 的美丽值为 3 - 1 = 2 。 给你一个字符串 s ，请你返回它所有子字符串的 美丽值 之和。
示例 1：
输入：s = "aabcb" 输出：5 解释：美丽值不为零的字符串包括 ["aab","aabc","aabcb","abcb","bcb"] ，每一个字符串的美丽值都为 1 。 示例 2：
输入：s = "aabcbaa" 输出：17 提示：
1 &lt;= s.length &lt;= 500 s 只包含小写英文字母。 方法一：暴力枚举+计数 func beautySum(s string) (ans int) { for i := 0; i &amp;lt; len(s); i++ { cnt, mx := [26]int{}, 0 for j := i; j &amp;lt; len(s); j++ { cnt[s[j]-'a']++ mx = max(mx, cnt[s[j]-'a']) mi := len(s) for _, c := range cnt { if c &amp;gt; 0 { mi = min(mi, c) } } ans += mx-mi } } return ans } func min(a, b int) int { if a &amp;lt; b { return a } return b } func max(a, b int) int { if a &amp;gt; b { return a } return b } 复杂度分析 时间复杂度：$O(C×n^2)$，其中 C 是 s 的元素种类，n 是 s 的长度。</description></item><item><title>【2022-12-07每日一题】1775. 通过最少操作次数使数组的和相等[Medium]</title><link>/study/leetcode/equal-sum-arrays-with-minimum-number-of-operations/</link><pubDate>Wed, 07 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/equal-sum-arrays-with-minimum-number-of-operations/</guid><description>2022-12-07每日一题：1775. 通过最少操作次数使数组的和相等 难度：Medium
标签：贪心 、 数组 、 哈希表 、 计数
给你两个长度可能不等的整数数组 nums1 和 nums2 。两个数组中的所有值都在 1 到 6 之间（包含 1 和 6）。
每次操作中，你可以选择 任意 数组中的任意一个整数，将它变成 1 到 6 之间 任意 的值（包含 1 和 6）。
请你返回使 nums1 中所有数的和与 nums2 中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回 -1 。
示例 1：
输入：nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2] 输出：3 解释：你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。 - 将 nums2[0] 变为 6 。 nums1 = [1,2,3,4,5,6], nums2 = [6,1,2,2,2,2] 。 - 将 nums1[5] 变为 1 。 nums1 = [1,2,3,4,5,1], nums2 = [6,1,2,2,2,2] 。 - 将 nums1[2] 变为 2 。 nums1 = [1,2,2,4,5,1], nums2 = [6,1,2,2,2,2] 。 示例 2：</description></item><item><title>【2022-11-23每日一题】1742. 盒子中小球的最大数量[Easy]</title><link>/study/leetcode/maximum-number-of-balls-in-a-box/</link><pubDate>Wed, 23 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximum-number-of-balls-in-a-box/</guid><description>2022-11-23每日一题：1742. 盒子中小球的最大数量 难度：Easy
标签：哈希表 、 数学 、 计数
你在一家生产小球的玩具厂工作，有 n 个小球，编号从 lowLimit 开始，到 highLimit 结束（包括 lowLimit 和 highLimit ，即 n == highLimit - lowLimit + 1）。另有无限数量的盒子，编号从 1 到 infinity 。
你的工作是将每个小球放入盒子中，其中盒子的编号应当等于小球编号上每位数字的和。例如，编号 321 的小球应当放入编号 3 + 2 + 1 = 6 的盒子，而编号 10 的小球应当放入编号 1 + 0 = 1 的盒子。
给你两个整数 lowLimit 和 highLimit ，返回放有最多小球的盒子中的小球数量。如果有多个盒子都满足放有最多小球，只需返回其中任一盒子的小球数量。
示例 1：
输入：lowLimit = 1, highLimit = 10 输出：2 解释： 盒子编号：1 2 3 4 5 6 7 8 9 10 11 .</description></item><item><title>【2022-11-11每日一题】1704. 判断字符串的两半是否相似[Easy]</title><link>/study/leetcode/determine-if-string-halves-are-alike/</link><pubDate>Fri, 11 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/determine-if-string-halves-are-alike/</guid><description>2022-11-11每日一题：1704. 判断字符串的两半是否相似 难度：Easy
标签：字符串 、 计数
给你一个偶数长度的字符串 s 。将其拆分成长度相同的两半，前一半为 a ，后一半为 b 。
两个字符串 相似 的前提是它们都含有相同数目的元音（'a'，'e'，'i'，'o'，'u'，'A'，'E'，'I'，'O'，'U'）。注意，s 可能同时含有大写和小写字母。
如果 a 和 b 相似，返回 true ；否则，返回 false 。
&amp;nbsp;
示例 1：
输入：s = "book" 输出：true 解释：a = "bo" 且 b = "ok" 。a 中有 1 个元音，b 也有 1 个元音。所以，a 和 b 相似。 示例 2：
输入：s = "textbook" 输出：false 解释：a = "text" 且 b = "book" 。a 中有 1 个元音，b 中有 2 个元音。因此，a 和 b 不相似。 注意，元音 o 在 b 中出现两次，记为 2 个。 &amp;nbsp;</description></item><item><title>【2022-10-11每日一题】1790. 仅执行一次字符串交换能否使两个字符串相等[Easy]</title><link>/study/leetcode/check-if-one-string-swap-can-make-strings-equal/</link><pubDate>Tue, 11 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/check-if-one-string-swap-can-make-strings-equal/</guid><description>2022-10-11每日一题：1790. 仅执行一次字符串交换能否使两个字符串相等 难度：Easy
标签：哈希表 、 字符串 、 计数
给你长度相等的两个字符串 s1 和 s2 。一次 字符串交换 操作的步骤如下：选出某个字符串中的两个下标（不必不同），并交换这两个下标所对应的字符。
如果对 其中一个字符串 执行 最多一次字符串交换 就可以使两个字符串相等，返回 true ；否则，返回 false 。
示例 1：
输入：s1 = "bank", s2 = "kanb" 输出：true 解释：例如，交换 s2 中的第一个和最后一个字符可以得到 "bank" 示例 2：
输入：s1 = "attack", s2 = "defend" 输出：false 解释：一次字符串交换无法使两个字符串相等 示例 3：
输入：s1 = "kelb", s2 = "kelb" 输出：true 解释：两个字符串已经相等，所以不需要进行字符串交换 示例 4：
输入：s1 = "abcd", s2 = "dcba" 输出：false 提示：
1 &amp;lt;= s1.length, s2.length &amp;lt;= 100 s1.length == s2.</description></item><item><title>【2022-10-05每日一题】811. 子域名访问计数[Medium]</title><link>/study/leetcode/subdomain-visit-count/</link><pubDate>Wed, 05 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/subdomain-visit-count/</guid><description>2022-10-05每日一题：811. 子域名访问计数 难度：Medium
标签：数组 、 哈希表 、 字符串 、 计数
网站域名 "discuss.leetcode.com" 由多个子域名组成。顶级域名为 "com" ，二级域名为 "leetcode.com" ，最低一级为 "discuss.leetcode.com" 。当访问域名 "discuss.leetcode.com" 时，同时也会隐式访问其父域名 "leetcode.com" 以及 "com" 。
计数配对域名 是遵循 "rep d1.d2.d3" 或 "rep d1.d2" 格式的一个域名表示，其中 rep 表示访问域名的次数，d1.d2.d3 为域名本身。
例如，"9001 discuss.leetcode.com" 就是一个 计数配对域名 ，表示 discuss.leetcode.com 被访问了 9001 次。 给你一个 计数配对域名 组成的数组 cpdomains ，解析得到输入中每个子域名对应的&amp;nbsp;计数配对域名 ，并以数组形式返回。可以按 任意顺序 返回答案。
&amp;nbsp;
示例 1：
输入：cpdomains = ["9001 discuss.leetcode.com"] 输出：["9001 leetcode.com","9001 discuss.leetcode.com","9001 com"] 解释：例子中仅包含一个网站域名："discuss.leetcode.com"。 按照前文描述，子域名 "leetcode.com" 和 "com" 都会被访问，所以它们都被访问了 9001 次。 示例 2：
输入：cpdomains = ["</description></item></channel></rss>