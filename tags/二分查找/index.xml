<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>二分查找 on lbbniu</title><link>/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link><description>Recent content in 二分查找 on lbbniu</description><generator>Hugo -- gohugo.io</generator><language>zh</language><managingEditor>lbbniu@gmail.com (lbbniu)</managingEditor><webMaster>lbbniu@gmail.com (lbbniu)</webMaster><copyright>&amp;copy; 2021 &lt;a href="https://blog.lbbniu.com/">lbbniu&lt;/a></copyright><lastBuildDate>Sat, 07 Jan 2023 00:01:00 +0800</lastBuildDate><atom:link href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/index.xml" rel="self" type="application/rss+xml"/><item><title>剑指 Offer 04 二维数组中的查找</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-wei-shu-zu-zhong-de-cha-zhao-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-wei-shu-zu-zhong-de-cha-zhao-lcof/</guid><description>剑指 Offer 04 二维数组中的查找 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
示例:
现有矩阵 matrix 如下：
[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。
给定 target = 20，返回 false。
限制：
0 &lt;= n &lt;= 1000
0 &lt;= m &lt;= 1000
注意：本题与主站 240 题相同：https://leetcode-cn.com/problems/search-a-2d-matrix-ii/
func findNumberIn2DArray(matrix [][]int, target int) bool { } LeetCode题库地址 https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof</description></item><item><title>剑指 Offer II 006 排序数组中两个数字之和</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/kll5u1/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/kll5u1/</guid><description>剑指 Offer II 006 排序数组中两个数字之和 给定一个已按照 升序排列&amp;nbsp; 的整数数组&amp;nbsp;numbers ，请你从数组中找出两个数满足相加之和等于目标数&amp;nbsp;target 。
函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 0&amp;nbsp;开始计数 ，所以答案数组应当满足 0&amp;nbsp;&amp;lt;= answer[0] &amp;lt; answer[1] &amp;lt;&amp;nbsp;numbers.length&amp;nbsp;。
假设数组中存在且只存在一对符合条件的数字，同时一个数字不能使用两次。
&amp;nbsp;
示例 1：
输入：numbers = [1,2,4,6,10], target = 8 输出：[1,3] 解释：2 与 6 之和等于目标数 8 。因此 index1 = 1, index2 = 3 。 示例 2：
输入：numbers = [2,3,4], target = 6 输出：[0,2] 示例 3：
输入：numbers = [-1,0], target = -1 输出：[0,1] &amp;nbsp;
提示：
2 &amp;lt;= numbers.length &amp;lt;= 3 * 104 -1000 &amp;lt;= numbers[i] &amp;lt;= 1000 numbers 按 递增顺序 排列 -1000 &amp;lt;= target &amp;lt;= 1000 仅存在一个有效答案 &amp;nbsp;</description></item><item><title>剑指 Offer II 008 和大于等于 target 的最短子数组</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/2vg8kg/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/2vg8kg/</guid><description>剑指 Offer II 008 和大于等于 target 的最短子数组 给定一个含有&amp;nbsp;n&amp;nbsp;个正整数的数组和一个正整数 target 。
找出该数组中满足其和 &amp;ge; target 的长度最小的 连续子数组&amp;nbsp;[numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。
&amp;nbsp;
示例 1：
输入：target = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组&amp;nbsp;[4,3]&amp;nbsp;是该条件下的长度最小的子数组。 示例 2：
输入：target = 4, nums = [1,4,4] 输出：1 示例 3：
输入：target = 11, nums = [1,1,1,1,1,1,1,1] 输出：0 &amp;nbsp;
提示：
1 &amp;lt;= target &amp;lt;= 109 1 &amp;lt;= nums.length &amp;lt;= 105 1 &amp;lt;= nums[i] &amp;lt;= 105 &amp;nbsp;
进阶：
如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。 &amp;nbsp;</description></item><item><title>剑指 Offer 11 旋转数组的最小数字</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/</guid><description>剑指 Offer 11 旋转数组的最小数字 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
给你一个可能存在&amp;nbsp;重复&amp;nbsp;元素值的数组&amp;nbsp;numbers&amp;nbsp;，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组&amp;nbsp;[3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。&amp;nbsp;&amp;nbsp;
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。
&amp;nbsp;
示例 1：
输入：numbers = [3,4,5,1,2] 输出：1 示例 2：
输入：numbers = [2,2,2,0,1] 输出：0 &amp;nbsp;
提示：
n == numbers.length 1 &amp;lt;= n &amp;lt;= 5000 -5000 &amp;lt;= numbers[i] &amp;lt;= 5000 numbers 原来是一个升序排序的数组，并进行了 1 至 n 次旋转 注意：本题与主站 154 题相同：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/
func minArray(numbers []int) int { } LeetCode题库地址 https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof</description></item><item><title>面试题 08.03 魔术索引</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/magic-index-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/magic-index-lcci/</guid><description>面试题 08.03 魔术索引 魔术索引。 在数组A[0...n-1]中，有所谓的魔术索引，满足条件A[i] = i。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。
示例1:
输入：nums = [0, 2, 3, 4, 5] 输出：0 说明: 0下标的元素为0 示例2:
输入：nums = [1, 1, 1] 输出：1 说明:
nums长度在[1, 1000000]之间 此题为原书中的 Follow-up，即数组中可能包含重复元素的版本 func findMagicIndex(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/magic-index-lcci</description></item><item><title>剑指 Offer 44 数字序列中某一位的数字</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/</guid><description>剑指 Offer 44 数字序列中某一位的数字 数字以0123456789101112131415&amp;hellip;的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。
请写一个函数，求任意第n位对应的数字。
&amp;nbsp;
示例 1：
输入：n = 3 输出：3 示例 2：
输入：n = 11 输出：0 &amp;nbsp;
限制：
0 &amp;lt;= n &amp;lt;&amp;nbsp;2^31 注意：本题与主站 400 题相同：https://leetcode-cn.com/problems/nth-digit/
func findNthDigit(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof</description></item><item><title>剑指 Offer 51 数组中的逆序对</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zu-zhong-de-ni-xu-dui-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zu-zhong-de-ni-xu-dui-lcof/</guid><description>剑指 Offer 51 数组中的逆序对 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。
&amp;nbsp;
示例 1:
输入: [7,5,6,4] 输出: 5 &amp;nbsp;
限制：
0 &amp;lt;= 数组长度 &amp;lt;= 50000
func reversePairs(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof</description></item><item><title>剑指 Offer 53 - I 在排序数组中查找数字 I</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/</guid><description>剑指 Offer 53 - I 在排序数组中查找数字 I 统计一个数字在排序数组中出现的次数。
示例 1:
输入: nums = [5,7,7,8,8,10], target = 8 输出: 2 示例 2:
输入: nums = [5,7,7,8,8,10], target = 6 输出: 0 提示：
0 &lt;= nums.length &lt;= 105 -109 &lt;= nums[i] &lt;= 109 nums 是一个非递减数组 -109 &lt;= target &lt;= 109 注意：本题与主站 34 题相同（仅返回值不同）：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/
func search(nums []int, target int) int { } LeetCode题库地址 https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof</description></item><item><title>剑指 Offer 53 - II 0～n-1中缺失的数字</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/que-shi-de-shu-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/que-shi-de-shu-zi-lcof/</guid><description>剑指 Offer 53 - II 0～n-1中缺失的数字 一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。
&amp;nbsp;
示例 1:
输入: [0,1,3] 输出: 2 示例&amp;nbsp;2:
输入: [0,1,2,3,4,5,6,7,9] 输出: 8 &amp;nbsp;
限制：
1 &amp;lt;= 数组长度 &amp;lt;= 10000
func missingNumber(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/que-shi-de-shu-zi-lcof</description></item><item><title>面试题 10.03 搜索旋转数组</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/search-rotate-array-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/search-rotate-array-lcci/</guid><description>面试题 10.03 搜索旋转数组 搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。
示例1:
输入: arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 5 输出: 8（元素5在该数组中的索引） 示例2:
输入：arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 11 输出：-1 （没有找到） 提示:
arr 长度范围在[1, 1000000]之间 func search(arr []int, target int) int { } LeetCode题库地址 https://leetcode.cn/problems/search-rotate-array-lcci</description></item><item><title>剑指 Offer II 058 日程表</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/fi9suh/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/fi9suh/</guid><description>剑指 Offer II 058 日程表 请实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内没有其他安排，则可以存储这个新的日程安排。
MyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数&amp;nbsp;x 的范围为， &amp;nbsp;start &amp;lt;= x &amp;lt; end。
当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生重复预订。
每次调用 MyCalendar.book方法时，如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 true。否则，返回 false&amp;nbsp;并且不要将该日程安排添加到日历中。
请按照以下步骤调用 MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)
&amp;nbsp;
示例:
输入: [&amp;quot;MyCalendar&amp;quot;,&amp;quot;book&amp;quot;,&amp;quot;book&amp;quot;,&amp;quot;book&amp;quot;] [[],[10,20],[15,25],[20,30]] 输出: [null,true,false,true] 解释: MyCalendar myCalendar = new MyCalendar(); MyCalendar.book(10, 20); // returns true MyCalendar.book(15, 25); // returns false ，第二个日程安排不能添加到日历中，因为时间 15 已经被第一个日程安排预定了 MyCalendar.book(20, 30); // returns true ，第三个日程安排可以添加到日历中，因为第一个日程安排并不包含时间 20 &amp;nbsp;</description></item><item><title>面试题 10.05 稀疏数组搜索</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sparse-array-search-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sparse-array-search-lcci/</guid><description>面试题 10.05 稀疏数组搜索 稀疏数组搜索。有个排好序的字符串数组，其中散布着一些空字符串，编写一种方法，找出给定字符串的位置。
示例1:
输入: words = [&amp;quot;at&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;ball&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;car&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;,&amp;quot;dad&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;], s = &amp;quot;ta&amp;quot; 输出：-1 说明: 不存在返回-1。 示例2:
输入：words = [&amp;quot;at&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;ball&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;car&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;,&amp;quot;dad&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;], s = &amp;quot;ball&amp;quot; 输出：4 提示:
words的长度在[1, 1000000]之间 func findString(words []string, s string) int { } LeetCode题库地址 https://leetcode.cn/problems/sparse-array-search-lcci</description></item><item><title>面试题 10.09 排序矩阵查找</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sorted-matrix-search-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sorted-matrix-search-lcci/</guid><description>面试题 10.09 排序矩阵查找 给定M&amp;times;N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。
示例:
现有矩阵 matrix 如下：
[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target&amp;nbsp;=&amp;nbsp;5，返回&amp;nbsp;true。
给定&amp;nbsp;target&amp;nbsp;=&amp;nbsp;20，返回&amp;nbsp;false。
func searchMatrix(matrix [][]int, target int) bool { } LeetCode题库地址 https://leetcode.cn/problems/sorted-matrix-search-lcci</description></item><item><title>剑指 Offer 57 和为s的两个数字</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/he-wei-sde-liang-ge-shu-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/he-wei-sde-liang-ge-shu-zi-lcof/</guid><description>剑指 Offer 57 和为s的两个数字 输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。
&amp;nbsp;
示例 1：
输入：nums = [2,7,11,15], target = 9 输出：[2,7] 或者 [7,2] 示例 2：
输入：nums = [10,26,30,31,47,60], target = 40 输出：[10,30] 或者 [30,10] &amp;nbsp;
限制：
1 &amp;lt;= nums.length &amp;lt;= 10^5 1 &amp;lt;= nums[i]&amp;nbsp;&amp;lt;= 10^6 func twoSum(nums []int, target int) []int { } LeetCode题库地址 https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof</description></item><item><title>面试题 10.10 数字流的秩</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/rank-from-stream-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/rank-from-stream-lcci/</guid><description>面试题 10.10 数字流的秩 假设你正在读取一串整数。每隔一段时间，你希望能找出数字 x 的秩(小于或等于 x 的值的个数)。请实现数据结构和算法来支持这些操作，也就是说：
实现 track(int x)&amp;nbsp;方法，每读入一个数字都会调用该方法；
实现 getRankOfNumber(int x) 方法，返回小于或等于 x 的值的个数。
注意：本题相对原题稍作改动
示例:
输入: [&amp;quot;StreamRank&amp;quot;, &amp;quot;getRankOfNumber&amp;quot;, &amp;quot;track&amp;quot;, &amp;quot;getRankOfNumber&amp;quot;] [[], [1], [0], [0]] 输出: [null,0,null,1] 提示：
x &amp;lt;= 50000 track&amp;nbsp;和&amp;nbsp;getRankOfNumber 方法的调用次数均不超过 2000 次 type StreamRank struct { } func Constructor() StreamRank { } func (this *StreamRank) Track(x int) { } func (this *StreamRank) GetRankOfNumber(x int) int { } /** * Your StreamRank object will be instantiated and called as such: * obj := Constructor(); * obj.</description></item><item><title>面试题 16.06 最小差</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/smallest-difference-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/smallest-difference-lcci/</guid><description>面试题 16.06 最小差 给定两个整数数组a和b，计算具有最小差绝对值的一对数值（每个数组中取一个值），并返回该对数值的差
示例：
输入：{1, 3, 15, 11, 2}, {23, 127, 235, 19, 8} 输出：3，即数值对(11, 8) 提示：
1 &lt;= a.length, b.length &lt;= 100000 -2147483648 &lt;= a[i], b[i] &lt;= 2147483647 正确结果在区间 [0, 2147483647] 内 func smallestDifference(a []int, b []int) int { } LeetCode题库地址 https://leetcode.cn/problems/smallest-difference-lcci</description></item><item><title>剑指 Offer II 068 查找插入位置</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/n6ydxv/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/n6ydxv/</guid><description>剑指 Offer II 068 查找插入位置 给定一个排序的整数数组 nums&amp;nbsp;和一个整数目标值 target ，请在数组中找到&amp;nbsp;target&amp;nbsp;，并返回其下标。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
请必须使用时间复杂度为 O(log n) 的算法。
&amp;nbsp;
示例 1:
输入: nums = [1,3,5,6], target = 5 输出: 2 示例&amp;nbsp;2:
输入: nums = [1,3,5,6], target = 2 输出: 1 示例 3:
输入: nums = [1,3,5,6], target = 7 输出: 4 示例 4:
输入: nums = [1,3,5,6], target = 0 输出: 0 示例 5:
输入: nums = [1], target = 0 输出: 0 &amp;nbsp;
提示:
1 &amp;lt;= nums.length &amp;lt;= 104 -104 &amp;lt;= nums[i] &amp;lt;= 104 nums 为无重复元素的升序排列数组 -104 &amp;lt;= target &amp;lt;= 104 &amp;nbsp;</description></item><item><title>剑指 Offer II 069 山峰数组的顶部</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/b1iidl/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/b1iidl/</guid><description>剑指 Offer II 069 山峰数组的顶部 符合下列属性的数组 arr 称为 山峰数组（山脉数组） ：
arr.length &amp;gt;= 3 存在 i（0 &amp;lt; i&amp;nbsp;&amp;lt; arr.length - 1）使得： arr[0] &amp;lt; arr[1] &amp;lt; ... arr[i-1] &amp;lt; arr[i] arr[i] &amp;gt; arr[i+1] &amp;gt; ... &amp;gt; arr[arr.length - 1] 给定由整数组成的山峰数组 arr ，返回任何满足 arr[0] &amp;lt; arr[1] &amp;lt; ... arr[i - 1] &amp;lt; arr[i] &amp;gt; arr[i + 1] &amp;gt; ... &amp;gt; arr[arr.length - 1] 的下标 i&amp;nbsp;，即山峰顶部。
&amp;nbsp;
示例 1：
输入：arr = [0,1,0] 输出：1 示例 2：
输入：arr = [1,3,5,4,2] 输出：2 示例 3：</description></item><item><title>剑指 Offer II 070 排序数组中只出现一次的数字</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/skftm2/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/skftm2/</guid><description>剑指 Offer II 070 排序数组中只出现一次的数字 给定一个只包含整数的有序数组 nums&amp;nbsp;，每个元素都会出现两次，唯有一个数只会出现一次，请找出这个唯一的数字。
你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。
&amp;nbsp;
示例 1:
输入: nums = [1,1,2,3,3,4,4,8,8] 输出: 2 示例 2:
输入: nums = [3,3,7,7,10,11,11] 输出: 10 &amp;nbsp;
提示:
1 &amp;lt;= nums.length &amp;lt;= 105 0 &amp;lt;= nums[i]&amp;nbsp;&amp;lt;= 105 &amp;nbsp;
注意：本题与主站 540&amp;nbsp;题相同：https://leetcode-cn.com/problems/single-element-in-a-sorted-array/
func singleNonDuplicate(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/skFtm2</description></item><item><title>剑指 Offer II 071 按权重生成随机数</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/cuyjef/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/cuyjef/</guid><description>剑指 Offer II 071 按权重生成随机数 给定一个正整数数组&amp;nbsp;w ，其中&amp;nbsp;w[i]&amp;nbsp;代表下标 i&amp;nbsp;的权重（下标从 0 开始），请写一个函数&amp;nbsp;pickIndex&amp;nbsp;，它可以随机地获取下标 i，选取下标 i&amp;nbsp;的概率与&amp;nbsp;w[i]&amp;nbsp;成正比。
例如，对于 w = [1, 3]，挑选下标 0 的概率为 1 / (1 + 3)&amp;nbsp;= 0.25 （即，25%），而选取下标 1 的概率为 3 / (1 + 3)&amp;nbsp;= 0.75（即，75%）。
也就是说，选取下标 i 的概率为 w[i] / sum(w) 。
&amp;nbsp;
示例 1：
输入： inputs = [&amp;quot;Solution&amp;quot;,&amp;quot;pickIndex&amp;quot;] inputs = [[[1]],[]] 输出： [null,0] 解释： Solution solution = new Solution([1]); solution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。 示例 2：
输入： inputs = [&amp;quot;Solution&amp;quot;,&amp;quot;pickIndex&amp;quot;,&amp;quot;pickIndex&amp;quot;,&amp;quot;pickIndex&amp;quot;,&amp;quot;pickIndex&amp;quot;,&amp;quot;pickIndex&amp;quot;] inputs = [[[1,3]],[],[],[],[],[]] 输出： [null,1,1,1,1,0] 解释： Solution solution = new Solution([1, 3]); solution.</description></item><item><title>剑指 Offer II 072 求平方根</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/jj0w9p/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/jj0w9p/</guid><description>剑指 Offer II 072 求平方根 给定一个非负整数 x ，计算并返回 x 的平方根，即实现&amp;nbsp;int sqrt(int x)&amp;nbsp;函数。
正数的平方根有两个，只输出其中的正数平方根。
如果平方根不是整数，输出只保留整数的部分，小数部分将被舍去。
&amp;nbsp;
示例 1:
输入: x = 4 输出: 2 示例 2:
输入: x = 8 输出: 2 解释: 8 的平方根是 2.82842...，由于小数部分将被舍去，所以返回 2 &amp;nbsp;
提示:
0 &amp;lt;= x &amp;lt;= 231&amp;nbsp;- 1 &amp;nbsp;
注意：本题与主站 69&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/sqrtx/
func mySqrt(x int) int { } LeetCode题库地址 https://leetcode.cn/problems/jJ0w9p</description></item><item><title>剑指 Offer II 073 狒狒吃香蕉</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/nzzqjq/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/nzzqjq/</guid><description>剑指 Offer II 073 狒狒吃香蕉 狒狒喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有&amp;nbsp;piles[i]&amp;nbsp;根香蕉。警卫已经离开了，将在 h 小时后回来。
狒狒可以决定她吃香蕉的速度 k （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉，下一个小时才会开始吃另一堆的香蕉。&amp;nbsp;&amp;nbsp;
狒狒喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。
返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。
&amp;nbsp;
示例 1：
输入：piles = [3,6,7,11], h = 8 输出：4 示例 2：
输入：piles = [30,11,23,4,20], h = 5 输出：30 示例 3：
输入：piles = [30,11,23,4,20], h = 6 输出：23 &amp;nbsp;
提示：
1 &amp;lt;= piles.length &amp;lt;= 104 piles.length &amp;lt;= h &amp;lt;= 109 1 &amp;lt;= piles[i] &amp;lt;= 109 &amp;nbsp;
注意：本题与主站 875&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/koko-eating-bananas/
func minEatingSpeed(piles []int, h int) int { } LeetCode题库地址 https://leetcode.</description></item><item><title>面试题 16.21 交换和</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sum-swap-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sum-swap-lcci/</guid><description>面试题 16.21 交换和 给定两个整数数组，请交换一对数值（每个数组中取一个数值），使得两个数组所有元素的和相等。
返回一个数组，第一个元素是第一个数组中要交换的元素，第二个元素是第二个数组中要交换的元素。若有多个答案，返回任意一个均可。若无满足条件的数值，返回空数组。
示例:
输入: array1 = [4, 1, 2, 1, 1, 2], array2 = [3, 6, 3, 3] 输出: [1, 3] 示例:
输入: array1 = [1, 2, 3], array2 = [4, 5, 6] 输出: [] 提示：
1 &amp;lt;= array1.length, array2.length &amp;lt;= 100000 func findSwapValues(array1 []int, array2 []int) []int { } LeetCode题库地址 https://leetcode.cn/problems/sum-swap-lcci</description></item><item><title>面试题 17.08 马戏团人塔</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/circus-tower-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/circus-tower-lcci/</guid><description>面试题 17.08 马戏团人塔 有个马戏团正在设计叠罗汉的表演节目，一个人要站在另一人的肩膀上。出于实际和美观的考虑，在上面的人要比下面的人矮一点且轻一点。已知马戏团每个人的身高和体重，请编写代码计算叠罗汉最多能叠几个人。
示例：
输入：height = [65,70,56,75,60,68] weight = [100,150,90,190,95,110] 输出：6 解释：从上往下数，叠罗汉最多能叠 6 层：(56,90), (60,95), (65,100), (68,110), (70,150), (75,190) 提示：
height.length == weight.length &lt;= 10000 func bestSeqAtIndex(height []int, weight []int) int { } LeetCode题库地址 https://leetcode.cn/problems/circus-tower-lcci</description></item><item><title>【2023-01-07每日一题】1658. 将 x 减到 0 的最小操作数[Medium]</title><link>/study/leetcode/minimum-operations-to-reduce-x-to-zero/</link><pubDate>Sat, 07 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/minimum-operations-to-reduce-x-to-zero/</guid><description>2023-01-07每日一题：1658. 将 x 减到 0 的最小操作数 难度：Medium
标签：数组 、 哈希表 、 二分查找 、 前缀和 、 滑动窗口
给你一个整数数组 nums 和一个整数 x 。每一次操作时，你应当移除数组 nums 最左边或最右边的元素，然后从 x 中减去该元素的值。请注意，需要 修改 数组以供接下来的操作使用。
如果可以将 x 恰好 减到 0 ，返回 最小操作数 ；否则，返回 -1 。
示例 1：
输入：nums = [1,1,4,2,3], x = 5 输出：2 解释：最佳解决方案是移除后两个元素，将 x 减到 0 。 示例 2：
输入：nums = [5,6,7,8,9], x = 4 输出：-1 示例 3：
输入：nums = [3,2,20,1,1,3], x = 10 输出：5 解释：最佳解决方案是移除后三个元素和前两个元素（总共 5 次操作），将 x 减到 0 。 提示：</description></item><item><title>【2023-01-04每日一题】1802. 有界数组中指定下标处的最大值[Medium]</title><link>/study/leetcode/maximum-value-at-a-given-index-in-a-bounded-array/</link><pubDate>Wed, 04 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximum-value-at-a-given-index-in-a-bounded-array/</guid><description>2023-01-04每日一题：1802. 有界数组中指定下标处的最大值 难度：Medium
标签：贪心 、 二分查找
给你三个正整数 n、index 和 maxSum 。你需要构造一个同时满足下述所有条件的数组 nums（下标 从 0 开始 计数）：
nums.length == n nums[i] 是 正整数 ，其中 0 &amp;lt;= i &amp;lt; n abs(nums[i] - nums[i+1]) &amp;lt;= 1 ，其中 0 &amp;lt;= i &amp;lt; n-1 nums 中所有元素之和不超过 maxSum nums[index] 的值被 最大化 返回你所构造的数组中的 nums[index] 。
注意：abs(x) 等于 x 的前提是 x &amp;gt;= 0 ；否则，abs(x) 等于 -x 。
示例 1：
输入：n = 4, index = 2, maxSum = 6 输出：2 解释：数组 [1,1,2,1] 和 [1,2,2,1] 满足所有条件。不存在其他在指定下标处具有更大值的有效数组。 示例 2：</description></item><item><title>【2022-12-25每日一题】1739. 放置盒子[Hard]</title><link>/study/leetcode/building-boxes/</link><pubDate>Sun, 25 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/building-boxes/</guid><description>2022-12-25每日一题：1739. 放置盒子 难度：Hard
标签：贪心 、 数学 、 二分查找
有一个立方体房间，其长度、宽度和高度都等于 n 个单位。请你在房间里放置 n 个盒子，每个盒子都是一个单位边长的立方体。放置规则如下：
你可以把盒子放在地板上的任何地方。 如果盒子 x 需要放置在盒子 y 的顶部，那么盒子 y 竖直的四个侧面都 必须 与另一个盒子或墙相邻。 给你一个整数 n ，返回接触地面的盒子的 最少 可能数量。
示例 1：
输入：n = 3 输出：3 解释：上图是 3 个盒子的摆放位置。 这些盒子放在房间的一角，对应左侧位置。 示例 2：
输入：n = 4 输出：3 解释：上图是 3 个盒子的摆放位置。 这些盒子放在房间的一角，对应左侧位置。 示例 3：
输入：n = 10 输出：6 解释：上图是 10 个盒子的摆放位置。 这些盒子放在房间的一角，对应后方位置。 提示：
1 &lt;= n &lt;= 109 方法一：ylb https://leetcode.cn/problems/building-boxes/solutions/2031828/by-lcbin-nbq1/ func minimumBoxes(n int) int { s, k := 0, 1 for s+k*(k+1)/2 &amp;lt;= n { s += k*(k+1)/2 k++ } k-- ans := k*(k+1)/2 for s &amp;lt; n { ans++ s += k k++ } return ans } 复杂度分析 时间复杂度: $O(\sqrt{n})$，空间复杂度 $O(1)$。其中 n 为题目给定的盒子数量。 方法二：灵茶山艾府 https://leetcode.</description></item><item><title>【2022-12-20每日一题】1760. 袋子里最少数目的球[Medium]</title><link>/study/leetcode/minimum-limit-of-balls-in-a-bag/</link><pubDate>Tue, 20 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/minimum-limit-of-balls-in-a-bag/</guid><description>2022-12-20每日一题：1760. 袋子里最少数目的球 难度：Medium
标签：数组 、 二分查找
给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。
你可以进行如下操作至多 maxOperations 次：
选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 正整数 个球。 &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;比方说，一个袋子里有 &amp;lt;code&amp;gt;5&amp;lt;/code&amp;gt; 个球，你可以把它们分到两个新袋子里，分别有 &amp;lt;code&amp;gt;1&amp;lt;/code&amp;gt; 个和 &amp;lt;code&amp;gt;4&amp;lt;/code&amp;gt; 个球，或者分别有 &amp;lt;code&amp;gt;2&amp;lt;/code&amp;gt; 个和 &amp;lt;code&amp;gt;3&amp;lt;/code&amp;gt; 个球。&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/li&amp;gt; 你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。
请你返回进行上述操作后的最小开销。
示例 1：
输入：nums = [9], maxOperations = 2 输出：3 解释： - 将装有 9 个球的袋子分成装有 6 个和 3 个球的袋子。[9] -> [6,3] 。 - 将装有 6 个球的袋子分成装有 3 个和 3 个球的袋子。[6,3] -> [3,3,3] 。 装有最多球的袋子里装有 3 个球，所以开销为 3 并返回 3 。 示例 2：</description></item><item><title>【2022-11-22每日一题】878. 第 N 个神奇数字[Hard]</title><link>/study/leetcode/nth-magical-number/</link><pubDate>Tue, 22 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/nth-magical-number/</guid><description>2022-11-22每日一题：878. 第 N 个神奇数字 难度：Hard
标签：数学 、 二分查找
一个正整数如果能被 a 或 b 整除，那么它是神奇的。
给定三个整数 n ,&amp;nbsp;a , b ，返回第 n 个神奇的数字。因为答案可能很大，所以返回答案&amp;nbsp;对&amp;nbsp;109&amp;nbsp;+ 7 取模&amp;nbsp;后的值。
&amp;nbsp;
示例 1：
输入：n = 1, a = 2, b = 3 输出：2 示例&amp;nbsp;2：
输入：n = 4, a = 2, b = 3 输出：6 &amp;nbsp;
提示：
1 &amp;lt;= n &amp;lt;= 109 2 &amp;lt;= a, b &amp;lt;= 4 * 104 &amp;nbsp;
方法一：数学+二分查找 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
const mod int = 1e9+7 // 系统库二分查找 func nthMagicalNumber(n int, a int, b int) int { c := a * b / gcd(a, b) // a,b最少公倍数 r := (a + b) * n return sort.</description></item><item><title>【2022-11-04每日一题】754. 到达终点数字[Medium]</title><link>/study/leetcode/reach-a-number/</link><pubDate>Fri, 04 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/reach-a-number/</guid><description>2022-11-04每日一题：754. 到达终点数字 难度：Medium
标签：数学 、 二分查找
在一根无限长的数轴上，你站在0的位置。终点在target的位置。
你可以做一些数量的移动 numMoves :
每次你可以选择向左或向右移动。 第 i&amp;nbsp;次移动（从 &amp;nbsp;i == 1&amp;nbsp;开始，到&amp;nbsp;i == numMoves ），在选择的方向上走 i&amp;nbsp;步。 给定整数&amp;nbsp;target ，返回 到达目标所需的 最小&amp;nbsp;移动次数(即最小 numMoves )&amp;nbsp;。
&amp;nbsp;
示例 1:
输入: target = 2 输出: 3 解释: 第一次移动，从 0 到 1 。 第二次移动，从 1 到 -1 。 第三次移动，从 -1 到 2 。 示例 2:
输入: target = 3 输出: 2 解释: 第一次移动，从 0 到 1 。 第二次移动，从 1 到 3 。 &amp;nbsp;
提示:
-109&amp;nbsp;&amp;lt;= target &amp;lt;= 109 target !</description></item><item><title>【2022-10-26每日一题】862. 和至少为 K 的最短子数组[Hard]</title><link>/study/leetcode/shortest-subarray-with-sum-at-least-k/</link><pubDate>Wed, 26 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/shortest-subarray-with-sum-at-least-k/</guid><description>2022-10-26每日一题：862. 和至少为 K 的最短子数组 难度：Hard
标签：队列 、 数组 、 二分查找 、 前缀和 、 滑动窗口 、 单调队列 、 堆（优先队列）
给你一个整数数组 nums 和一个整数 k ，找出 nums 中和至少为 k 的 最短非空子数组 ，并返回该子数组的长度。如果不存在这样的 子数组 ，返回 -1 。
子数组 是数组中 连续 的一部分。
&amp;nbsp;
示例 1：
输入：nums = [1], k = 1 输出：1 示例 2：
输入：nums = [1,2], k = 4 输出：-1 示例 3：
输入：nums = [2,-1,2], k = 3 输出：3 &amp;nbsp;
提示：
1 &amp;lt;= nums.length &amp;lt;= 105 -105 &amp;lt;= nums[i] &amp;lt;= 105 1 &amp;lt;= k &amp;lt;= 109 方法一：前缀和 + 单调双端队列 推荐题解 func shortestSubarray(nums []int, k int) int { n := len(nums) preSum := make([]int, n+1) for i, num := range nums { preSum[i+1] = preSum[i] + num // 计算前缀和 } ans := n + 1 q := []int{} for i, curSum := range preSum { for len(q) &amp;gt; 0 &amp;amp;&amp;amp; curSum - preSum[q[0]] &amp;gt;= k { ans = min(ans, i-q[0]) q = q[1:] // 上面计算后 q[0] 没有用了，直接移除 } for len(q) &amp;gt;0 &amp;amp;&amp;amp; preSum[q[len(q)-1]] &amp;gt;= curSum { q = q[:len(q)-1] // 移除队列中大约等于当前数的元素 } q = append(q, i) } if ans &amp;lt; n + 1 { return ans } return -1 } func min(a, b int) int { if a &amp;lt; b { return a } return b } 复杂度分析 LeetCode题库地址 https://leetcode.</description></item><item><title>【2022-10-22每日一题】1235. 规划兼职工作[Hard]</title><link>/study/leetcode/maximum-profit-in-job-scheduling/</link><pubDate>Sat, 22 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximum-profit-in-job-scheduling/</guid><description>2022-10-22每日一题：1235. 规划兼职工作 难度：Hard
标签：数组 、 二分查找 、 动态规划 、 排序
你打算利用空闲时间来做兼职工作赚些零花钱。
这里有&amp;nbsp;n&amp;nbsp;份兼职工作，每份工作预计从&amp;nbsp;startTime[i]&amp;nbsp;开始到&amp;nbsp;endTime[i]&amp;nbsp;结束，报酬为&amp;nbsp;profit[i]。
给你一份兼职工作表，包含开始时间&amp;nbsp;startTime，结束时间&amp;nbsp;endTime&amp;nbsp;和预计报酬&amp;nbsp;profit&amp;nbsp;三个数组，请你计算并返回可以获得的最大报酬。
注意，时间上出现重叠的 2 份工作不能同时进行。
如果你选择的工作在时间&amp;nbsp;X&amp;nbsp;结束，那么你可以立刻进行在时间&amp;nbsp;X&amp;nbsp;开始的下一份工作。
&amp;nbsp;
示例 1：
输入：startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70] 输出：120 解释： 我们选出第 1 份和第 4 份工作， 时间范围是 [1-3]+[3-6]，共获得报酬 120 = 50 + 70。 示例 2：
输入：startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60] 输出：150 解释： 我们选择第 1，4，5 份工作。 共获得报酬 150 = 20 + 70 + 60。 示例 3：
输入：startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4] 输出：6 &amp;nbsp;</description></item><item><title>【2022-10-18每日一题】902. 最大为 N 的数字组合[Hard]</title><link>/study/leetcode/numbers-at-most-n-given-digit-set/</link><pubDate>Tue, 18 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/numbers-at-most-n-given-digit-set/</guid><description>2022-10-18每日一题：902. 最大为 N 的数字组合 难度：Hard
标签：数组 、 数学 、 字符串 、 二分查找 、 动态规划
给定一个按&amp;nbsp;非递减顺序&amp;nbsp;排列的数字数组&amp;nbsp;digits&amp;nbsp;。你可以用任意次数&amp;nbsp;digits[i]&amp;nbsp;来写的数字。例如，如果&amp;nbsp;digits = ['1','3','5']，我们可以写数字，如&amp;nbsp;'13',&amp;nbsp;'551', 和&amp;nbsp;'1351315'。
返回 可以生成的小于或等于给定整数 n 的正整数的个数&amp;nbsp;。
&amp;nbsp;
示例 1：
输入：digits = ["1","3","5","7"], n = 100 输出：20 解释： 可写出的 20 个数字是： 1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77. 示例 2：
输入：digits = ["1","4","9"], n = 1000000000 输出：29523 解释： 我们可以写 3 个一位数字，9 个两位数字，27 个三位数字， 81 个四位数字，243 个五位数字，729 个六位数字， 2187 个七位数字，6561 个八位数字和 19683 个九位数字。 总共，可以使用D中的数字写出 29523 个整数。 示例 3:</description></item><item><title>【2022-09-12每日一题】1608. 特殊数组的特征值</title><link>/study/leetcode/special-array-with-x-elements-greater-than-or-equal-x/</link><pubDate>Mon, 12 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/special-array-with-x-elements-greater-than-or-equal-x/</guid><description>2022-09-12每日一题：1608. 特殊数组的特征值 难度：Easy 标签：数组 、 二分查找 、 排序 给你一个非负整数数组 nums 。如果存在一个数 x ，使得 nums 中恰好有 x 个元素 大于或者等于 x ，那么就称 nums 是一个 特殊数组 ，而 x 是该数组的 特征值 。
注意： x 不必 是 nums 的中的元素。
如果数组 nums 是一个 特殊数组 ，请返回它的特征值 x 。否则，返回 -1 。可以证明的是，如果 nums 是特殊数组，那么其特征值 x 是 唯一的 。
&amp;nbsp;
示例 1：
输入：nums = [3,5] 输出：2 解释：有 2 个元素（3 和 5）大于或等于 2 。 示例 2：
输入：nums = [0,0] 输出：-1 解释：没有满足题目要求的特殊数组，故而也不存在特征值 x 。 如果 x = 0，应该有 0 个元素 &amp;gt;= x，但实际有 2 个。 如果 x = 1，应该有 1 个元素 &amp;gt;= x，但实际有 0 个。 如果 x = 2，应该有 2 个元素 &amp;gt;= x，但实际有 0 个。 x 不能取更大的值，因为 nums 中只有两个元素。 示例 3：</description></item><item><title>【2022-08-28每日一题】793. 阶乘函数后 K 个零</title><link>/study/leetcode/preimage-size-of-factorial-zeroes-function/</link><pubDate>Sun, 28 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/preimage-size-of-factorial-zeroes-function/</guid><description>2022-08-28每日一题：793. 阶乘函数后 K 个零 难度：Hard 标签：数学 、 二分查找 &amp;nbsp;f(x)&amp;nbsp;是&amp;nbsp;x!&amp;nbsp;末尾是 0 的数量。回想一下&amp;nbsp;x! = 1 * 2 * 3 * ... * x，且 0! = 1&amp;nbsp;。
例如，&amp;nbsp;f(3) = 0&amp;nbsp;，因为 3! = 6 的末尾没有 0 ；而 f(11) = 2&amp;nbsp;，因为 11!= 39916800 末端有 2 个 0 。 给定&amp;nbsp;k，找出返回能满足 f(x) = k&amp;nbsp;的非负整数 x&amp;nbsp;的数量。
&amp;nbsp;
示例 1： 输入：k = 0 输出：5 解释：0!, 1!, 2!, 3!, 和 4!&amp;nbsp;均符合 k = 0 的条件。 示例 2：
输入：k = 5 输出：0 解释：没有匹配到这样的 x!，符合 k = 5 的条件。 示例 3:</description></item><item><title>【2022-08-25每日一题】658. 找到 K 个最接近的元素</title><link>/study/leetcode/find-k-closest-elements/</link><pubDate>Thu, 25 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/find-k-closest-elements/</guid><description>2022-08-25每日一题：658. 找到 K 个最接近的元素 难度：Medium 标签：数组 、 双指针 、 二分查找 、 排序 、 堆（优先队列） 给定一个 排序好 的数组&amp;nbsp;arr ，两个整数 k 和 x ，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。
整数 a 比整数 b 更接近 x 需要满足：
|a - x| &amp;lt; |b - x| 或者 |a - x| == |b - x| 且 a &amp;lt; b &amp;nbsp;
示例 1：
输入：arr = [1,2,3,4,5], k = 4, x = 3 输出：[1,2,3,4] 示例 2：
输入：arr = [1,2,3,4,5], k = 4, x = -1 输出：[1,2,3,4] &amp;nbsp;</description></item></channel></rss>