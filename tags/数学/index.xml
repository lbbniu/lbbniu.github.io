<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>数学 on lbbniu</title><link>/tags/%E6%95%B0%E5%AD%A6/</link><description>Recent content in 数学 on lbbniu</description><generator>Hugo -- gohugo.io</generator><language>zh</language><managingEditor>lbbniu@gmail.com (lbbniu)</managingEditor><webMaster>lbbniu@gmail.com (lbbniu)</webMaster><copyright>&amp;copy; 2021 &lt;a href="https://blog.lbbniu.com/">lbbniu&lt;/a></copyright><lastBuildDate>Tue, 17 Jan 2023 00:01:00 +0800</lastBuildDate><atom:link href="/tags/%E6%95%B0%E5%AD%A6/index.xml" rel="self" type="application/rss+xml"/><item><title>剑指 Offer II 001 整数除法</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/xoh6oh/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/xoh6oh/</guid><description>剑指 Offer II 001 整数除法 给定两个整数 a 和 b ，求它们的除法的商 a/b ，要求不得使用乘号 &amp;#39;*&amp;#39;、除号 &amp;#39;/&amp;#39; 以及求余符号 &amp;#39;%&amp;#39;&amp;nbsp;。
&amp;nbsp;
注意：
整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8&amp;nbsp;以及&amp;nbsp;truncate(-2.7335) = -2 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [&amp;minus;231,&amp;nbsp;231&amp;minus;1]。本题中，如果除法结果溢出，则返回 231&amp;nbsp;&amp;minus; 1 &amp;nbsp;
示例 1：
输入：a = 15, b = 2 输出：7 解释：15/2 = truncate(7.5) = 7 示例 2：
输入：a = 7, b = -3 输出：-2 解释：7/-3 = truncate(-2.33333..) = -2 示例 3：
输入：a = 0, b = 1 输出：0 示例 4：
输入：a = 1, b = 1 输出：1 &amp;nbsp;</description></item><item><title>剑指 Offer II 002 二进制加法</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/jfetk5/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/jfetk5/</guid><description>剑指 Offer II 002 二进制加法 给定两个 01 字符串&amp;nbsp;a&amp;nbsp;和&amp;nbsp;b&amp;nbsp;，请计算它们的和，并以二进制字符串的形式输出。
输入为 非空 字符串且只包含数字&amp;nbsp;1&amp;nbsp;和&amp;nbsp;0。
&amp;nbsp;
示例&amp;nbsp;1:
输入: a = &amp;quot;11&amp;quot;, b = &amp;quot;10&amp;quot; 输出: &amp;quot;101&amp;quot; 示例&amp;nbsp;2:
输入: a = &amp;quot;1010&amp;quot;, b = &amp;quot;1011&amp;quot; 输出: &amp;quot;10101&amp;quot; &amp;nbsp;
提示：
每个字符串仅由字符 &amp;#39;0&amp;#39; 或 &amp;#39;1&amp;#39; 组成。 1 &amp;lt;= a.length, b.length &amp;lt;= 10^4 字符串如果不是 &amp;quot;0&amp;quot; ，就都不含前导零。 &amp;nbsp;
注意：本题与主站 67&amp;nbsp;题相同：https://leetcode-cn.com/problems/add-binary/
func addBinary(a string, b string) string { } LeetCode题库地址 https://leetcode.cn/problems/JFETK5</description></item><item><title>剑指 Offer 10- I 斐波那契数列</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/fei-bo-na-qi-shu-lie-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/fei-bo-na-qi-shu-lie-lcof/</guid><description>剑指 Offer 10- I 斐波那契数列 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：
F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N > 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
示例 1：
输入：n = 2 输出：1 示例 2：
输入：n = 5 输出：5 提示：
0 &lt;= n &lt;= 100 func fib(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof</description></item><item><title>面试题 01.07 旋转矩阵</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/rotate-matrix-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/rotate-matrix-lcci/</guid><description>面试题 01.07 旋转矩阵 给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。
不占用额外内存空间能否做到？
示例 1:
给定 matrix = [ [1,2,3], [4,5,6], [7,8,9] ], 原地旋转输入矩阵，使其变为: [ [7,4,1], [8,5,2], [9,6,3] ] 示例 2:
给定 matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], 原地旋转输入矩阵，使其变为: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ] 注意：本题与主站 48 题相同：https://leetcode-cn.com/problems/rotate-image/
func rotate(matrix [][]int) { } LeetCode题库地址 https://leetcode.cn/problems/rotate-matrix-lcci</description></item><item><title>剑指 Offer 10- II 青蛙跳台阶问题</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/qing-wa-tiao-tai-jie-wen-ti-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/qing-wa-tiao-tai-jie-wen-ti-lcof/</guid><description>剑指 Offer 10- II 青蛙跳台阶问题 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n&amp;nbsp;级的台阶总共有多少种跳法。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
示例 1：
输入：n = 2 输出：2 示例 2：
输入：n = 7 输出：21 示例 3：
输入：n = 0 输出：1 提示：
0 &amp;lt;= n &amp;lt;= 100 注意：本题与主站 70 题相同：https://leetcode-cn.com/problems/climbing-stairs/
&amp;nbsp;
func numWays(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof</description></item><item><title>剑指 Offer 14- I 剪绳子</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/jian-sheng-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/jian-sheng-zi-lcof/</guid><description>剑指 Offer 14- I 剪绳子 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&amp;gt;1并且m&amp;gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
示例 1：
输入: 2 输出: 1 解释: 2 = 1 + 1, 1 &amp;times; 1 = 1 示例&amp;nbsp;2:
输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 &amp;times;&amp;nbsp;3 &amp;times;&amp;nbsp;4 = 36 提示：
2 &amp;lt;= n &amp;lt;= 58 注意：本题与主站 343 题相同：https://leetcode-cn.com/problems/integer-break/
func cuttingRope(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/jian-sheng-zi-lcof</description></item><item><title>剑指 Offer 14- II 剪绳子 II</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/jian-sheng-zi-ii-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/jian-sheng-zi-ii-lcof/</guid><description>剑指 Offer 14- II 剪绳子 II 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m&amp;nbsp;段（m、n都是整数，n&amp;gt;1并且m&amp;gt;1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
&amp;nbsp;
示例 1：
输入: 2 输出: 1 解释: 2 = 1 + 1, 1 &amp;times; 1 = 1 示例&amp;nbsp;2:
输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 &amp;times;&amp;nbsp;3 &amp;times;&amp;nbsp;4 = 36 &amp;nbsp;
提示：
2 &amp;lt;= n &amp;lt;= 1000 注意：本题与主站 343 题相同：https://leetcode-cn.com/problems/integer-break/
func cuttingRope(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/jian-sheng-zi-ii-lcof</description></item><item><title>面试题 02.05 链表求和</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sum-lists-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sum-lists-lcci/</guid><description>面试题 02.05 链表求和 给定两个用链表表示的整数，每个节点包含一个数位。
这些数位是反向存放的，也就是个位排在链表首部。
编写函数对这两个整数求和，并用链表形式返回结果。
&amp;nbsp;
示例：
输入：(7 -&amp;gt; 1 -&amp;gt; 6) + (5 -&amp;gt; 9 -&amp;gt; 2)，即617 + 295 输出：2 -&amp;gt; 1 -&amp;gt; 9，即912 进阶：思考一下，假设这些数位是正向存放的，又该如何解决呢?
示例：
输入：(6 -&amp;gt; 1 -&amp;gt; 7) + (2 -&amp;gt; 9 -&amp;gt; 5)，即617 + 295 输出：9 -&amp;gt; 1 -&amp;gt; 2，即912 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer 16 数值的整数次方</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zhi-de-zheng-shu-ci-fang-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zhi-de-zheng-shu-ci-fang-lcof/</guid><description>剑指 Offer 16 数值的整数次方 实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。
示例 1：
输入：x = 2.00000, n = 10 输出：1024.00000 示例 2：
输入：x = 2.10000, n = 3 输出：9.26100 示例 3：
输入：x = 2.00000, n = -2 输出：0.25000 解释：2-2 = 1/22 = 1/4 = 0.25 提示：
-100.0 &lt; x &lt; 100.0 -231 &lt;= n &lt;= 231-1 -104 &lt;= xn &lt;= 104 注意：本题与主站 50 题相同：https://leetcode-cn.com/problems/powx-n/
func myPow(x float64, n int) float64 { } LeetCode题库地址 https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof</description></item><item><title>剑指 Offer 17 打印从1到最大的n位数</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/</guid><description>剑指 Offer 17 打印从1到最大的n位数 输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。
示例 1:
输入: n = 1 输出: [1,2,3,4,5,6,7,8,9] &amp;nbsp;
说明：
用返回一个整数列表来代替打印 n 为正整数 func printNumbers(n int) []int { } LeetCode题库地址 https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof</description></item><item><title>剑指 Offer II 025 链表中的两数相加</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/lmsnwu/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/lmsnwu/</guid><description>剑指 Offer II 025 链表中的两数相加 给定两个 非空链表 l1和 l2&amp;nbsp;来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。
可以假设除了数字 0 之外，这两个数字都不会以零开头。
&amp;nbsp;
示例1：
输入：l1 = [7,2,4,3], l2 = [5,6,4] 输出：[7,8,0,7] 示例2：
输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[8,0,7] 示例3：
输入：l1 = [0], l2 = [0] 输出：[0] &amp;nbsp;
提示：
链表的长度范围为 [1, 100] 0 &amp;lt;= node.val &amp;lt;= 9 输入数据保证链表代表的数字无前导 0 &amp;nbsp;
进阶：如果输入链表不能修改该如何处理？换句话说，不能对列表中的节点进行翻转。
&amp;nbsp;
注意：本题与主站 445&amp;nbsp;题相同：https://leetcode-cn.com/problems/add-two-numbers-ii/
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer II 030 插入、删除和随机访问都是 O(1) 的容器</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/fortpu/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/fortpu/</guid><description>剑指 Offer II 030 插入、删除和随机访问都是 O(1) 的容器 设计一个支持在平均&amp;nbsp;时间复杂度 O(1)&amp;nbsp;下，执行以下操作的数据结构：
insert(val)：当元素 val 不存在时返回 true&amp;nbsp;，并向集合中插入该项，否则返回 false 。 remove(val)：当元素 val 存在时返回 true&amp;nbsp;，并从集合中移除该项，否则返回 false&amp;nbsp;。 getRandom：随机返回现有集合中的一项。每个元素应该有&amp;nbsp;相同的概率&amp;nbsp;被返回。 &amp;nbsp;
示例 :
输入: inputs = [&amp;quot;RandomizedSet&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;remove&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;getRandom&amp;quot;, &amp;quot;remove&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;getRandom&amp;quot;] [[], [1], [2], [2], [], [1], [2], []] 输出: [null, true, false, true, 2, true, false, 2] 解释: RandomizedSet randomSet = new RandomizedSet(); // 初始化一个空的集合 randomSet.insert(1); // 向集合中插入 1 ， 返回 true 表示 1 被成功地插入 randomSet.remove(2); // 返回 false，表示集合中不存在 2 randomSet.</description></item><item><title>剑指 Offer II 035 最小时间差</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/569nqc/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/569nqc/</guid><description>剑指 Offer II 035 最小时间差 给定一个 24 小时制（小时:分钟 &amp;quot;HH:MM&amp;quot;）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。
&amp;nbsp;
示例 1：
输入：timePoints = [&amp;quot;23:59&amp;quot;,&amp;quot;00:00&amp;quot;] 输出：1 示例 2：
输入：timePoints = [&amp;quot;00:00&amp;quot;,&amp;quot;23:59&amp;quot;,&amp;quot;00:00&amp;quot;] 输出：0 &amp;nbsp;
提示：
2 &amp;lt;= timePoints &amp;lt;= 2 * 104 timePoints[i] 格式为 &amp;quot;HH:MM&amp;quot; &amp;nbsp;
注意：本题与主站 539&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/minimum-time-difference/
func findMinDifference(timePoints []string) int { } LeetCode题库地址 https://leetcode.cn/problems/569nqc</description></item><item><title>面试题 05.02 二进制数转字符串</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/bianry-number-to-string-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/bianry-number-to-string-lcci/</guid><description>面试题 05.02 二进制数转字符串 二进制数转字符串。给定一个介于0和1之间的实数（如0.72），类型为double，打印它的二进制表达式。如果该数字无法精确地用32位以内的二进制表示，则打印“ERROR”。
示例1:
输入：0.625 输出："0.101" 示例2:
输入：0.1 输出："ERROR" 提示：0.1无法被二进制准确表示 &amp;nbsp;
提示：
32位包括输出中的 "0." 这两位。 题目保证输入用例的小数位数最多只有 6 位 func printBin(num float64) string { } LeetCode题库地址 https://leetcode.cn/problems/bianry-number-to-string-lcci</description></item><item><title>剑指 Offer II 036 后缀表达式</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/8zf90g/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/8zf90g/</guid><description>剑指 Offer II 036 后缀表达式 根据 逆波兰表示法，求该后缀表达式的计算结果。
有效的算符包括&amp;nbsp;+、-、*、/&amp;nbsp;。每个运算对象可以是整数，也可以是另一个逆波兰表达式。
&amp;nbsp;
说明：
整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 &amp;nbsp;
示例&amp;nbsp;1：
输入：tokens = [&amp;quot;2&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;+&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;*&amp;quot;] 输出：9 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 示例&amp;nbsp;2：
输入：tokens = [&amp;quot;4&amp;quot;,&amp;quot;13&amp;quot;,&amp;quot;5&amp;quot;,&amp;quot;/&amp;quot;,&amp;quot;+&amp;quot;] 输出：6 解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6 示例&amp;nbsp;3：
输入：tokens = [&amp;quot;10&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;+&amp;quot;,&amp;quot;-11&amp;quot;,&amp;quot;*&amp;quot;,&amp;quot;/&amp;quot;,&amp;quot;*&amp;quot;,&amp;quot;17&amp;quot;,&amp;quot;+&amp;quot;,&amp;quot;5&amp;quot;,&amp;quot;+&amp;quot;] 输出：22 解释： 该算式转化为常见的中缀算术表达式为： ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 &amp;nbsp;</description></item><item><title>面试题 05.08 绘制直线</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/draw-line-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/draw-line-lcci/</guid><description>面试题 05.08 绘制直线 已知一个由像素点组成的单色屏幕，每行均有 w 个像素点，所有像素点初始为 0，左上角位置为 (0,0)。
现将每行的像素点按照「每 32 个像素点」为一组存放在一个 int 中，再依次存入长度为 length 的一维数组中。
我们将在屏幕上绘制一条从点 (x1,y) 到点 (x2,y) 的直线（即像素点修改为 1），请返回绘制过后的数组。
&amp;nbsp;
注意：
用例保证屏幕宽度 w 可被 32 整除（即一个 int 不会分布在两行上） &amp;nbsp;
示例1:
输入：length = 1, w = 32, x1 = 30, x2 = 31, y = 0 输出：[3] 解释：在第 0 行的第 30 位到第 31 位画一条直线，屏幕二进制形式表示为 [00000000000000000000000000000011]，因此返回 [3] 示例2:
输入：length = 3, w = 96, x1 = 0, x2 = 95, y = 0 输出：[-1, -1, -1] 解释：由于二进制 11111111111111111111111111111111 的 int 类型代表 -1，因此返回 [-1,-1,-1] &amp;nbsp;</description></item><item><title>面试题 08.01 三步问题</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/three-steps-problem-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/three-steps-problem-lcci/</guid><description>面试题 08.01 三步问题 三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。
示例1:
输入：n = 3 输出：4 说明: 有四种走法 示例2:
输入：n = 5 输出：13 提示:
n范围在[1, 1000000]之间 func waysToStep(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/three-steps-problem-lcci</description></item><item><title>剑指 Offer 43 1～n 整数中 1 出现的次数</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/</guid><description>剑指 Offer 43 1～n 整数中 1 出现的次数 输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。
例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。
示例 1：
输入：n = 12 输出：5 示例 2：
输入：n = 13 输出：6 限制：
1 &lt;= n &lt; 2^31 注意：本题与主站 233 题相同：https://leetcode-cn.com/problems/number-of-digit-one/
func countDigitOne(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof</description></item><item><title>剑指 Offer 44 数字序列中某一位的数字</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/</guid><description>剑指 Offer 44 数字序列中某一位的数字 数字以0123456789101112131415&amp;hellip;的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。
请写一个函数，求任意第n位对应的数字。
&amp;nbsp;
示例 1：
输入：n = 3 输出：3 示例 2：
输入：n = 11 输出：0 &amp;nbsp;
限制：
0 &amp;lt;= n &amp;lt;&amp;nbsp;2^31 注意：本题与主站 400 题相同：https://leetcode-cn.com/problems/nth-digit/
func findNthDigit(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof</description></item><item><title>面试题 08.05 递归乘法</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/recursive-mulitply-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/recursive-mulitply-lcci/</guid><description>面试题 08.05 递归乘法 递归乘法。 写一个递归函数，不使用 * 运算符， 实现两个正整数的相乘。可以使用加号、减号、位移，但要吝啬一些。
示例1:
输入：A = 1, B = 10 输出：10 示例2:
输入：A = 3, B = 4 输出：12 提示:
保证乘法范围不会溢出 func multiply(A int, B int) int { } LeetCode题库地址 https://leetcode.cn/problems/recursive-mulitply-lcci</description></item><item><title>剑指 Offer 49 丑数</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/chou-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/chou-shu-lcof/</guid><description>剑指 Offer 49 丑数 我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。
&amp;nbsp;
示例:
输入: n = 10 输出: 12 解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 说明:&amp;nbsp;&amp;nbsp;
1&amp;nbsp;是丑数。 n&amp;nbsp;不超过1690。 注意：本题与主站 264 题相同：https://leetcode-cn.com/problems/ugly-number-ii/
func nthUglyNumber(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/chou-shu-lcof</description></item><item><title>面试题 08.11 硬币</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/coin-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/coin-lcci/</guid><description>面试题 08.11 硬币 硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)
示例1:
输入: n = 5 输出：2 解释: 有两种方式可以凑成总金额: 5=5 5=1+1+1+1+1 示例2:
输入: n = 10 输出：4 解释: 有四种方式可以凑成总金额: 10=10 10=5+5 10=5+1+1+1+1+1 10=1+1+1+1+1+1+1+1+1+1 说明：
注意:
你可以假设：
0 &amp;lt;= n (总金额) &amp;lt;= 1000000 func waysToChange(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/coin-lcci</description></item><item><title>剑指 Offer 53 - II 0～n-1中缺失的数字</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/que-shi-de-shu-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/que-shi-de-shu-zi-lcof/</guid><description>剑指 Offer 53 - II 0～n-1中缺失的数字 一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。
&amp;nbsp;
示例 1:
输入: [0,1,3] 输出: 2 示例&amp;nbsp;2:
输入: [0,1,2,3,4,5,6,7,9] 输出: 8 &amp;nbsp;
限制：
1 &amp;lt;= 数组长度 &amp;lt;= 10000
func missingNumber(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/que-shi-de-shu-zi-lcof</description></item><item><title>剑指 Offer 57 - II 和为s的连续正数序列</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/</guid><description>剑指 Offer 57 - II 和为s的连续正数序列 输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。
序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。
&amp;nbsp;
示例 1：
输入：target = 9 输出：[[2,3,4],[4,5]] 示例 2：
输入：target = 15 输出：[[1,2,3,4,5],[4,5,6],[7,8]] &amp;nbsp;
限制：
1 &amp;lt;= target &amp;lt;= 10^5 &amp;nbsp;
func findContinuousSequence(target int) [][]int { } LeetCode题库地址 https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof</description></item><item><title>面试题 16.01 交换数字</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/swap-numbers-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/swap-numbers-lcci/</guid><description>面试题 16.01 交换数字 编写一个函数，不用临时变量，直接交换numbers = [a, b]中a与b的值。
示例：
输入: numbers = [1,2] 输出: [2,1] 提示：
numbers.length == 2 -2147483647 &lt;= numbers[i] &lt;= 2147483647 func swapNumbers(numbers []int) []int { } LeetCode题库地址 https://leetcode.cn/problems/swap-numbers-lcci</description></item><item><title>剑指 Offer 58 - II 左旋转字符串</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zuo-xuan-zhuan-zi-fu-chuan-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zuo-xuan-zhuan-zi-fu-chuan-lcof/</guid><description>剑指 Offer 58 - II 左旋转字符串 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&amp;quot;abcdefg&amp;quot;和数字2，该函数将返回左旋转两位得到的结果&amp;quot;cdefgab&amp;quot;。
&amp;nbsp;
示例 1：
输入: s = &amp;quot;abcdefg&amp;quot;, k = 2 输出:&amp;nbsp;&amp;quot;cdefgab&amp;quot; 示例 2：
输入: s = &amp;quot;lrloseumgh&amp;quot;, k = 6 输出:&amp;nbsp;&amp;quot;umghlrlose&amp;quot; &amp;nbsp;
限制：
1 &amp;lt;= k &amp;lt; s.length &amp;lt;= 10000 func reverseLeftWords(s string, n int) string { } LeetCode题库地址 https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof</description></item><item><title>面试题 16.03 交点</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/intersection-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/intersection-lcci/</guid><description>面试题 16.03 交点 给定两条线段（表示为起点start = {X1, Y1}和终点end = {X2, Y2}），如果它们有交点，请计算其交点，没有交点则返回空值。
要求浮点型误差不超过10^-6。若有多个交点（线段重叠）则返回 X 值最小的点，X 坐标相同则返回 Y 值最小的点。
&amp;nbsp;
示例 1：
输入： line1 = {0, 0}, {1, 0} line2 = {1, 1}, {0, -1} 输出： {0.5, 0} 示例 2：
输入： line1 = {0, 0}, {3, 3} line2 = {1, 1}, {2, 2} 输出： {1, 1} 示例 3：
输入： line1 = {0, 0}, {1, 1} line2 = {1, 0}, {2, 1} 输出： {}，两条线段没有交点 &amp;nbsp;
提示：
坐标绝对值不会超过 2^7 输入的坐标均是有效的二维坐标 func intersection(start1 []int, end1 []int, start2 []int, end2 []int) []float64 { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer 60 n个骰子的点数</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/nge-tou-zi-de-dian-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/nge-tou-zi-de-dian-shu-lcof/</guid><description>剑指 Offer 60 n个骰子的点数 把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。
&amp;nbsp;
你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。
&amp;nbsp;
示例 1:
输入: 1 输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667] 示例&amp;nbsp;2:
输入: 2 输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778] &amp;nbsp;
限制：
1 &amp;lt;= n &amp;lt;= 11
func dicesProbability(n int) []float64 { } LeetCode题库地址 https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof</description></item><item><title>面试题 16.05 阶乘尾数</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/factorial-zeros-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/factorial-zeros-lcci/</guid><description>面试题 16.05 阶乘尾数 设计一个算法，算出 n 阶乘有多少个尾随零。
示例 1:
输入: 3 输出: 0 解释:&amp;nbsp;3! = 6, 尾数中没有零。 示例&amp;nbsp;2:
输入: 5 输出: 1 解释:&amp;nbsp;5! = 120, 尾数中有 1 个零. 说明: 你算法的时间复杂度应为&amp;nbsp;O(log&amp;nbsp;n)&amp;nbsp;。
func trailingZeroes(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/factorial-zeros-lcci</description></item><item><title>剑指 Offer 62 圆圈中最后剩下的数字</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</guid><description>剑指 Offer 62 圆圈中最后剩下的数字 0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。
例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。
示例 1：
输入: n = 5, m = 3 输出: 3 示例 2：
输入: n = 10, m = 17 输出: 2 限制：
1 &lt;= n &lt;= 10^5 1 &lt;= m &lt;= 10^6 func lastRemaining(n int, m int) int { } LeetCode题库地址 https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof</description></item><item><title>面试题 16.07 最大数值</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/maximum-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/maximum-lcci/</guid><description>面试题 16.07 最大数值 编写一个方法，找出两个数字a和b中最大的那一个。不得使用if-else或其他比较运算符。
示例：
输入： a = 1, b = 2 输出： 2 func maximum(a int, b int) int { } LeetCode题库地址 https://leetcode.cn/problems/maximum-lcci</description></item><item><title>面试题 16.08 整数的英语表示</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/english-int-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/english-int-lcci/</guid><description>面试题 16.08 整数的英语表示 给定一个整数，打印该整数的英文描述。
示例 1:
输入: 123 输出: "One Hundred Twenty Three" 示例 2:
输入: 12345 输出: "Twelve Thousand Three Hundred Forty Five" 示例 3:
输入: 1234567 输出: "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven" 示例 4:
输入: 1234567891 输出: "One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One" 注意：本题与 273 题相同：https://leetcode-cn.com/problems/integer-to-english-words/
func numberToWords(num int) string { } LeetCode题库地址 https://leetcode.cn/problems/english-int-lcci</description></item><item><title>面试题 16.09 运算</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/operations-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/operations-lcci/</guid><description>面试题 16.09 运算 请实现整数数字的乘法、减法和除法运算，运算结果均为整数数字，程序中只允许使用加法运算符和逻辑运算符，允许程序中出现正负常数，不允许使用位运算。
你的实现应该支持如下操作：
Operations() 构造函数 minus(a, b) 减法，返回a - b multiply(a, b) 乘法，返回a * b divide(a, b) 除法，返回a / b 示例：
Operations operations = new Operations(); operations.minus(1, 2); //返回-1 operations.multiply(3, 4); //返回12 operations.divide(5, -2); //返回-2 提示：
你可以假设函数输入一定是有效的，例如不会出现除法分母为0的情况 单个用例的函数调用次数不会超过1000次 type Operations struct { } func Constructor() Operations { } func (this *Operations) Minus(a int, b int) int { } func (this *Operations) Multiply(a int, b int) int { } func (this *Operations) Divide(a int, b int) int { } /** * Your Operations object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.</description></item><item><title>剑指 Offer 65 不用加减乘除做加法</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/</guid><description>剑指 Offer 65 不用加减乘除做加法 写一个函数，求两个整数之和，要求在函数体内不得使用 &amp;ldquo;+&amp;rdquo;、&amp;ldquo;-&amp;rdquo;、&amp;ldquo;*&amp;rdquo;、&amp;ldquo;/&amp;rdquo; 四则运算符号。
&amp;nbsp;
示例:
输入: a = 1, b = 1 输出: 2 &amp;nbsp;
提示：
a,&amp;nbsp;b&amp;nbsp;均可能是负数或 0 结果不会溢出 32 位整数 func add(a int, b int) int { } LeetCode题库地址 https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof</description></item><item><title>剑指 Offer II 071 按权重生成随机数</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/cuyjef/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/cuyjef/</guid><description>剑指 Offer II 071 按权重生成随机数 给定一个正整数数组&amp;nbsp;w ，其中&amp;nbsp;w[i]&amp;nbsp;代表下标 i&amp;nbsp;的权重（下标从 0 开始），请写一个函数&amp;nbsp;pickIndex&amp;nbsp;，它可以随机地获取下标 i，选取下标 i&amp;nbsp;的概率与&amp;nbsp;w[i]&amp;nbsp;成正比。
例如，对于 w = [1, 3]，挑选下标 0 的概率为 1 / (1 + 3)&amp;nbsp;= 0.25 （即，25%），而选取下标 1 的概率为 3 / (1 + 3)&amp;nbsp;= 0.75（即，75%）。
也就是说，选取下标 i 的概率为 w[i] / sum(w) 。
&amp;nbsp;
示例 1：
输入： inputs = [&amp;quot;Solution&amp;quot;,&amp;quot;pickIndex&amp;quot;] inputs = [[[1]],[]] 输出： [null,0] 解释： Solution solution = new Solution([1]); solution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。 示例 2：
输入： inputs = [&amp;quot;Solution&amp;quot;,&amp;quot;pickIndex&amp;quot;,&amp;quot;pickIndex&amp;quot;,&amp;quot;pickIndex&amp;quot;,&amp;quot;pickIndex&amp;quot;,&amp;quot;pickIndex&amp;quot;] inputs = [[[1,3]],[],[],[],[],[]] 输出： [null,1,1,1,1,0] 解释： Solution solution = new Solution([1, 3]); solution.</description></item><item><title>剑指 Offer II 072 求平方根</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/jj0w9p/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/jj0w9p/</guid><description>剑指 Offer II 072 求平方根 给定一个非负整数 x ，计算并返回 x 的平方根，即实现&amp;nbsp;int sqrt(int x)&amp;nbsp;函数。
正数的平方根有两个，只输出其中的正数平方根。
如果平方根不是整数，输出只保留整数的部分，小数部分将被舍去。
&amp;nbsp;
示例 1:
输入: x = 4 输出: 2 示例 2:
输入: x = 8 输出: 2 解释: 8 的平方根是 2.82842...，由于小数部分将被舍去，所以返回 2 &amp;nbsp;
提示:
0 &amp;lt;= x &amp;lt;= 231&amp;nbsp;- 1 &amp;nbsp;
注意：本题与主站 69&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/sqrtx/
func mySqrt(x int) int { } LeetCode题库地址 https://leetcode.cn/problems/jJ0w9p</description></item><item><title>面试题 16.11 跳水板</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/diving-board-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/diving-board-lcci/</guid><description>面试题 16.11 跳水板 你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。
返回的长度需要从小到大排列。
示例 1
输入： shorter = 1 longer = 2 k = 3 输出： [3,4,5,6] 解释： 可以使用 3 次 shorter，得到结果 3；使用 2 次 shorter 和 1 次 longer，得到结果 4 。以此类推，得到最终结果。 提示：
0 &amp;lt; shorter &amp;lt;= longer 0 &amp;lt;= k &amp;lt;= 100000 func divingBoard(shorter int, longer int, k int) []int { } LeetCode题库地址 https://leetcode.cn/problems/diving-board-lcci</description></item><item><title>面试题 16.13 平分正方形</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/bisect-squares-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/bisect-squares-lcci/</guid><description>面试题 16.13 平分正方形 给定两个正方形及一个二维平面。请找出将这两个正方形分割成两半的一条直线。假设正方形顶边和底边与 x 轴平行。
每个正方形的数据square包含3个数值，正方形的左下顶点坐标[X,Y] = [square[0],square[1]]，以及正方形的边长square[2]。所求直线穿过两个正方形会形成4个交点，请返回4个交点形成线段的两端点坐标（两个端点即为4个交点中距离最远的2个点，这2个点所连成的线段一定会穿过另外2个交点）。2个端点坐标[X1,Y1]和[X2,Y2]的返回格式为{X1,Y1,X2,Y2}，要求若X1 != X2，需保证X1 &amp;lt; X2，否则需保证Y1 &amp;lt;= Y2。
若同时有多条直线满足要求，则选择斜率最大的一条计算并返回（与Y轴平行的直线视为斜率无穷大）。
示例：
输入： square1 = {-1, -1, 2} square2 = {0, -1, 2} 输出： {-1,0,2,0} 解释： 直线 y = 0 能将两个正方形同时分为等面积的两部分，返回的两线段端点为[-1,0]和[2,0] 提示：
square.length == 3 square[2] &amp;gt; 0 func cutSquares(square1 []int, square2 []int) []float64 { } LeetCode题库地址 https://leetcode.cn/problems/bisect-squares-lcci</description></item><item><title>面试题 16.14 最佳直线</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/best-line-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/best-line-lcci/</guid><description>面试题 16.14 最佳直线 给定一个二维平面及平面上的 N 个点列表Points，其中第i个点的坐标为Points[i]=[Xi,Yi]。请找出一条直线，其通过的点的数目最多。
设穿过最多点的直线所穿过的全部点编号从小到大排序的列表为S，你仅需返回[S[0],S[1]]作为答案，若有多条直线穿过了相同数量的点，则选择S[0]值较小的直线返回，S[0]相同则选择S[1]值较小的直线返回。
示例：
输入： [[0,0],[1,1],[1,0],[2,0]] 输出： [0,2] 解释： 所求直线穿过的3个点的编号为[0,2,3] 提示：
2 &lt;= len(Points) &lt;= 300 len(Points[i]) = 2 func bestLine(points [][]int) []int { } LeetCode题库地址 https://leetcode.cn/problems/best-line-lcci</description></item><item><title>面试题 16.18 模式匹配</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/pattern-matching-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/pattern-matching-lcci/</guid><description>面试题 16.18 模式匹配 你有两个字符串，即pattern和value。 pattern字符串由字母&amp;quot;a&amp;quot;和&amp;quot;b&amp;quot;组成，用于描述字符串中的模式。例如，字符串&amp;quot;catcatgocatgo&amp;quot;匹配模式&amp;quot;aabab&amp;quot;（其中&amp;quot;cat&amp;quot;是&amp;quot;a&amp;quot;，&amp;quot;go&amp;quot;是&amp;quot;b&amp;quot;），该字符串也匹配像&amp;quot;a&amp;quot;、&amp;quot;ab&amp;quot;和&amp;quot;b&amp;quot;这样的模式。但需注意&amp;quot;a&amp;quot;和&amp;quot;b&amp;quot;不能同时表示相同的字符串。编写一个方法判断value字符串是否匹配pattern字符串。
示例 1：
输入： pattern = &amp;quot;abba&amp;quot;, value = &amp;quot;dogcatcatdog&amp;quot; 输出： true 示例 2：
输入： pattern = &amp;quot;abba&amp;quot;, value = &amp;quot;dogcatcatfish&amp;quot; 输出： false 示例 3：
输入： pattern = &amp;quot;aaaa&amp;quot;, value = &amp;quot;dogcatcatdog&amp;quot; 输出： false 示例 4：
输入： pattern = &amp;quot;abba&amp;quot;, value = &amp;quot;dogdogdogdog&amp;quot; 输出： true 解释： &amp;quot;a&amp;quot;=&amp;quot;dogdog&amp;quot;,b=&amp;quot;&amp;quot;，反之也符合规则 提示：
1 &amp;lt;= len(pattern) &amp;lt;= 1000 0 &amp;lt;= len(value) &amp;lt;= 1000 你可以假设pattern只包含字母&amp;quot;a&amp;quot;和&amp;quot;b&amp;quot;，value仅包含小写字母。 func patternMatching(pattern string, value string) bool { } LeetCode题库地址 https://leetcode.cn/problems/pattern-matching-lcci</description></item><item><title>面试题 16.26 计算器</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/calculator-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/calculator-lcci/</guid><description>面试题 16.26 计算器 给定一个包含正整数、加(+)、减(-)、乘(*)、除(/)的算数表达式(括号除外)，计算其结果。
表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格&amp;nbsp;&amp;nbsp;。 整数除法仅保留整数部分。
示例&amp;nbsp;1:
输入: &amp;quot;3+2*2&amp;quot; 输出: 7 示例 2:
输入: &amp;quot; 3/2 &amp;quot; 输出: 1 示例 3:
输入: &amp;quot; 3+5 / 2 &amp;quot; 输出: 5 说明：
你可以假设所给定的表达式都是有效的。 请不要使用内置的库函数 eval。 func calculate(s string) int { } LeetCode题库地址 https://leetcode.cn/problems/calculator-lcci</description></item><item><title>面试题 17.01 不用加号的加法</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/add-without-plus-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/add-without-plus-lcci/</guid><description>面试题 17.01 不用加号的加法 设计一个函数把两个数字相加。不得使用 + 或者其他算术运算符。
示例:
输入: a = 1, b = 1 输出: 2 &amp;nbsp;
提示：
a,&amp;nbsp;b&amp;nbsp;均可能是负数或 0 结果不会溢出 32 位整数 func add(a int, b int) int { } LeetCode题库地址 https://leetcode.cn/problems/add-without-plus-lcci</description></item><item><title>面试题 17.04 消失的数字</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/missing-number-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/missing-number-lcci/</guid><description>面试题 17.04 消失的数字 数组nums包含从0到n的所有整数，但其中缺了一个。请编写代码找出那个缺失的整数。你有办法在O(n)时间内完成吗？
注意：本题相对书上原题稍作改动
示例 1：
输入：[3,0,1] 输出：2 &amp;nbsp;
示例 2：
输入：[9,6,4,2,3,5,7,0,1] 输出：8 func missingNumber(nums []int) int { } LeetCode题库地址 https://leetcode.cn/problems/missing-number-lcci</description></item><item><title>面试题 17.06 2出现的次数</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/number-of-2s-in-range-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/number-of-2s-in-range-lcci/</guid><description>面试题 17.06 2出现的次数 编写一个方法，计算从 0 到 n (含 n) 中数字 2 出现的次数。
示例:
输入: 25 输出: 9 解释: (2, 12, 20, 21, 22, 23, 24, 25)(注意 22 应该算作两次) 提示：
n &amp;lt;= 10^9 func numberOf2sInRange(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/number-of-2s-in-range-lcci</description></item><item><title>面试题 17.09 第 k 个数</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/get-kth-magic-number-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/get-kth-magic-number-lcci/</guid><description>面试题 17.09 第 k 个数 有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。
示例 1:
输入: k = 5 输出: 9 func getKthMagicNumber(k int) int { } LeetCode题库地址 https://leetcode.cn/problems/get-kth-magic-number-lcci</description></item><item><title>剑指 Offer II 098 路径的数目</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/2aoefn/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/2aoefn/</guid><description>剑指 Offer II 098 路径的数目 一个机器人位于一个 m x n&amp;nbsp;网格的左上角 （起始点在下图中标记为 &amp;ldquo;Start&amp;rdquo; ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 &amp;ldquo;Finish&amp;rdquo; ）。
问总共有多少条不同的路径？
&amp;nbsp;
示例 1：
输入：m = 3, n = 7 输出：28 示例 2：
输入：m = 3, n = 2 输出：3 解释： 从左上角开始，总共有 3 条路径可以到达右下角。 1. 向右 -&amp;gt; 向下 -&amp;gt; 向下 2. 向下 -&amp;gt; 向下 -&amp;gt; 向右 3. 向下 -&amp;gt; 向右 -&amp;gt; 向下 示例 3：
输入：m = 7, n = 3 输出：28 示例 4：
输入：m = 3, n = 3 输出：6 &amp;nbsp;</description></item><item><title>剑指 Offer II 101 分割等和子集</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/nupfpr/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/nupfpr/</guid><description>剑指 Offer II 101 分割等和子集 给定一个非空的正整数数组 nums ，请判断能否将这些数字分成元素和相等的两部分。
&amp;nbsp;
示例&amp;nbsp;1：
输入：nums = [1,5,11,5] 输出：true 解释：nums 可以分割成 [1, 5, 5] 和 [11] 。 示例&amp;nbsp;2：
输入：nums = [1,2,3,5] 输出：false 解释：nums 不可以分为和相等的两部分 &amp;nbsp;
提示：
1 &amp;lt;= nums.length &amp;lt;= 200 1 &amp;lt;= nums[i] &amp;lt;= 100 &amp;nbsp;
注意：本题与主站 416&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/partition-equal-subset-sum/
func canPartition(nums []int) bool { } LeetCode题库地址 https://leetcode.cn/problems/NUPfPr</description></item><item><title>【2023-01-17每日一题】1814. 统计一个数组中好对子的数目[Medium]</title><link>/study/leetcode/count-nice-pairs-in-an-array/</link><pubDate>Tue, 17 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/count-nice-pairs-in-an-array/</guid><description>2023-01-17每日一题：1814. 统计一个数组中好对子的数目 难度：Medium
标签：数组 、 哈希表 、 数学 、 计数
给你一个数组 nums ，数组中只包含非负整数。定义 rev(x) 的值为将整数 x 各个数字位反转得到的结果。比方说 rev(123) = 321 ， rev(120) = 21 。我们称满足下面条件的下标对 (i, j) 是 好的 ：
0 &amp;lt;= i &amp;lt; j &amp;lt; nums.length nums[i] + rev(nums[j]) == nums[j] + rev(nums[i]) 请你返回好下标对的数目。由于结果可能会很大，请将结果对 109 + 7 取余 后返回。
示例 1：
输入：nums = [42,11,1,97] 输出：2 解释：两个坐标对为： - (0,3)：42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121 。 - (1,2)：11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12 。 示例 2：</description></item><item><title>【2023-01-14每日一题】1819. 序列中不同最大公约数的数目[Hard]</title><link>/study/leetcode/number-of-different-subsequences-gcds/</link><pubDate>Sat, 14 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/number-of-different-subsequences-gcds/</guid><description>2023-01-14每日一题：1819. 序列中不同最大公约数的数目 难度：Hard
标签：数组 、 数学 、 计数 、 数论
给你一个由正整数组成的数组 nums 。
数字序列的 最大公约数 定义为序列中所有整数的共有约数中的最大整数。
例如，序列 [4,6,16] 的最大公约数是 2 。 数组的一个 子序列 本质是一个序列，可以通过删除数组中的某些元素（或者不删除）得到。
例如，[2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。 计算并返回 nums 的所有 非空 子序列中 不同 最大公约数的 数目 。
示例 1：
输入：nums = [6,10,3] 输出：5 解释：上图显示了所有的非空子序列与各自的最大公约数。 不同的最大公约数为 6 、10 、3 、2 和 1 。 示例 2：
输入：nums = [5,15,40,5,6] 输出：7 提示：
1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 2 * 105 方法一： 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
func countDifferentSubsequenceGCDs(nums []int) int { } 复杂度分析 LeetCode题库地址 https://leetcode.</description></item><item><title>【2023-01-09每日一题】1806. 还原排列的最少操作步数[Medium]</title><link>/study/leetcode/minimum-number-of-operations-to-reinitialize-a-permutation/</link><pubDate>Mon, 09 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/minimum-number-of-operations-to-reinitialize-a-permutation/</guid><description>2023-01-09每日一题：1806. 还原排列的最少操作步数 难度：Medium
标签：数组 、 数学 、 模拟
给你一个偶数 n​​​​​​ ，已知存在一个长度为 n 的排列 perm ，其中 perm[i] == i​（下标 从 0 开始 计数）。
一步操作中，你将创建一个新数组 arr ，对于每个 i ：
如果 i % 2 == 0 ，那么 arr[i] = perm[i / 2] 如果 i % 2 == 1 ，那么 arr[i] = perm[n / 2 + (i - 1) / 2] 然后将 arr​​ 赋值​​给 perm 。
要想使 perm 回到排列初始值，至少需要执行多少步操作？返回最小的 非零 操作步数。
示例 1：
输入：n = 2 输出：1 解释：最初，perm = [0,1] 第 1 步操作后，perm = [0,1] 所以，仅需执行 1 步操作 示例 2：</description></item><item><title>【2023-01-06每日一题】2180. 统计各位数字之和为偶数的整数个数[Easy]</title><link>/study/leetcode/count-integers-with-even-digit-sum/</link><pubDate>Fri, 06 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/count-integers-with-even-digit-sum/</guid><description>2023-01-06每日一题：2180. 统计各位数字之和为偶数的整数个数 难度：Easy
标签：数学 、 模拟
给你一个正整数 num ，请你统计并返回 小于或等于 num 且各位数字之和为 偶数 的正整数的数目。
正整数的 各位数字之和 是其所有位上的对应数字相加的结果。
&amp;nbsp;
示例 1：
输入：num = 4 输出：2 解释： 只有 2 和 4 满足小于等于 4 且各位数字之和为偶数。 示例 2：
输入：num = 30 输出：14 解释： 只有 14 个整数满足小于等于 30 且各位数字之和为偶数，分别是： 2、4、6、8、11、13、15、17、19、20、22、24、26 和 28 。 &amp;nbsp;
提示：
1 &amp;lt;= num &amp;lt;= 1000 方法一： 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
func countEven(num int) int { } 复杂度分析 LeetCode题库地址 https://leetcode.cn/problems/count-integers-with-even-digit-sum</description></item><item><title>【2022-12-26每日一题】1759. 统计同构子字符串的数目[Medium]</title><link>/study/leetcode/count-number-of-homogenous-substrings/</link><pubDate>Mon, 26 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/count-number-of-homogenous-substrings/</guid><description>2022-12-26每日一题：1759. 统计同构子字符串的数目 难度：Medium
标签：数学 、 字符串
给你一个字符串 s ，返回 s 中 同构子字符串 的数目。由于答案可能很大，只需返回对 109 + 7 取余 后的结果。
同构字符串 的定义为：如果一个字符串中的所有字符都相同，那么该字符串就是同构字符串。
子字符串 是字符串中的一个连续字符序列。
示例 1：
输入：s = "abbcccaa" 输出：13 解释：同构子字符串如下所列： "a" 出现 3 次。 "aa" 出现 1 次。 "b" 出现 2 次。 "bb" 出现 1 次。 "c" 出现 3 次。 "cc" 出现 2 次。 "ccc" 出现 1 次。 3 + 1 + 2 + 1 + 3 + 2 + 1 = 13 示例 2：
输入：s = "</description></item><item><title>【2022-12-25每日一题】1739. 放置盒子[Hard]</title><link>/study/leetcode/building-boxes/</link><pubDate>Sun, 25 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/building-boxes/</guid><description>2022-12-25每日一题：1739. 放置盒子 难度：Hard
标签：贪心 、 数学 、 二分查找
有一个立方体房间，其长度、宽度和高度都等于 n 个单位。请你在房间里放置 n 个盒子，每个盒子都是一个单位边长的立方体。放置规则如下：
你可以把盒子放在地板上的任何地方。 如果盒子 x 需要放置在盒子 y 的顶部，那么盒子 y 竖直的四个侧面都 必须 与另一个盒子或墙相邻。 给你一个整数 n ，返回接触地面的盒子的 最少 可能数量。
示例 1：
输入：n = 3 输出：3 解释：上图是 3 个盒子的摆放位置。 这些盒子放在房间的一角，对应左侧位置。 示例 2：
输入：n = 4 输出：3 解释：上图是 3 个盒子的摆放位置。 这些盒子放在房间的一角，对应左侧位置。 示例 3：
输入：n = 10 输出：6 解释：上图是 10 个盒子的摆放位置。 这些盒子放在房间的一角，对应后方位置。 提示：
1 &lt;= n &lt;= 109 方法一：ylb https://leetcode.cn/problems/building-boxes/solutions/2031828/by-lcbin-nbq1/ func minimumBoxes(n int) int { s, k := 0, 1 for s+k*(k+1)/2 &amp;lt;= n { s += k*(k+1)/2 k++ } k-- ans := k*(k+1)/2 for s &amp;lt; n { ans++ s += k k++ } return ans } 复杂度分析 时间复杂度: $O(\sqrt{n})$，空间复杂度 $O(1)$。其中 n 为题目给定的盒子数量。 方法二：灵茶山艾府 https://leetcode.</description></item><item><title>【2022-12-22每日一题】1799. N 次操作后的最大分数和[Hard]</title><link>/study/leetcode/maximize-score-after-n-operations/</link><pubDate>Thu, 22 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximize-score-after-n-operations/</guid><description>2022-12-22每日一题：1799. N 次操作后的最大分数和 难度：Hard
标签：位运算 、 数组 、 数学 、 动态规划 、 回溯 、 状态压缩 、 数论
给你 nums ，它是一个大小为 2 * n 的正整数数组。你必须对这个数组执行 n 次操作。
在第 i 次操作时（操作编号从 1 开始），你需要：
选择两个元素 x 和 y 。 获得分数 i * gcd(x, y) 。 将 x 和 y 从 nums 中删除。 请你返回 n 次操作后你能获得的分数和最大为多少。
函数 gcd(x, y) 是 x 和 y 的最大公约数。
示例 1：
输入：nums = [1,2] 输出：1 解释：最优操作是： (1 * gcd(1, 2)) = 1 示例 2：</description></item><item><title>【2022-12-21每日一题】1753. 移除石子的最大得分[Medium]</title><link>/study/leetcode/maximum-score-from-removing-stones/</link><pubDate>Wed, 21 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximum-score-from-removing-stones/</guid><description>2022-12-21每日一题：1753. 移除石子的最大得分 难度：Medium
标签：贪心 、 数学 、 堆（优先队列）
你正在玩一个单人游戏，面前放置着大小分别为 a​​​​​​、b 和 c​​​​​​ 的 三堆 石子。
每回合你都要从两个 不同的非空堆 中取出一颗石子，并在得分上加 1 分。当存在 两个或更多 的空堆时，游戏停止。
给你三个整数 a 、b 和 c ，返回可以得到的 最大分数 。
示例 1：
输入：a = 2, b = 4, c = 6 输出：6 解释：石子起始状态是 (2, 4, 6) ，最优的一组操作是： - 从第一和第三堆取，石子状态现在是 (1, 4, 5) - 从第一和第三堆取，石子状态现在是 (0, 4, 4) - 从第二和第三堆取，石子状态现在是 (0, 3, 3) - 从第二和第三堆取，石子状态现在是 (0, 2, 2) - 从第二和第三堆取，石子状态现在是 (0, 1, 1) - 从第二和第三堆取，石子状态现在是 (0, 0, 0) 总分：6 分 。 示例 2：</description></item><item><title>【2022-12-09每日一题】1780. 判断一个数字是否可以表示成三的幂的和[Medium]</title><link>/study/leetcode/check-if-number-is-a-sum-of-powers-of-three/</link><pubDate>Fri, 09 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/check-if-number-is-a-sum-of-powers-of-three/</guid><description>2022-12-09每日一题：1780. 判断一个数字是否可以表示成三的幂的和 难度：Medium
标签：数学
给你一个整数 n ，如果你可以将 n 表示成若干个不同的三的幂之和，请你返回 true ，否则请返回 false 。
对于一个整数 y ，如果存在整数 x 满足 y == 3x ，我们称这个整数 y 是三的幂。
示例 1：
输入：n = 12 输出：true 解释：12 = 31 + 32 示例 2：
输入：n = 91 输出：true 解释：91 = 30 + 32 + 34 示例 3：
输入：n = 21 输出：false 提示：
1 &amp;lt;= n &amp;lt;= 107 方法一：三进制 思路与算法 我们可以将 n 转换成 3 进制。如果 n 的 3 进制表示中每一位均不为 2，那么答案为 True，否则为 False。
例如当 n=12 时，12=(110)3，满足要求；当 n=21 时，21=(210)3，不满足要求。</description></item><item><title>【2022-12-08每日一题】1812. 判断国际象棋棋盘中一个格子的颜色[Easy]</title><link>/study/leetcode/determine-color-of-a-chessboard-square/</link><pubDate>Thu, 08 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/determine-color-of-a-chessboard-square/</guid><description>2022-12-08每日一题：1812. 判断国际象棋棋盘中一个格子的颜色 难度：Easy
标签：数学 、 字符串
给你一个坐标 coordinates ，它是一个字符串，表示国际象棋棋盘中一个格子的坐标。下图是国际象棋棋盘示意图。
如果所给格子的颜色是白色，请你返回 true，如果是黑色，请返回 false 。
给定坐标一定代表国际象棋棋盘上一个存在的格子。坐标第一个字符是字母，第二个字符是数字。
示例 1：
输入：coordinates = "a1" 输出：false 解释：如上图棋盘所示，"a1" 坐标的格子是黑色的，所以返回 false 。 示例 2：
输入：coordinates = "h3" 输出：true 解释：如上图棋盘所示，"h3" 坐标的格子是白色的，所以返回 true 。 示例 3：
输入：coordinates = "c7" 输出：false 提示：
coordinates.length == 2 'a' &lt;= coordinates[0] &lt;= 'h' '1' &lt;= coordinates[1] &lt;= '8' 方法一：找规律 可以换算成2x2格子，行列相同为黑色返回false，不同为白色返回true
func squareIsWhite(coordinates string) bool { r := int(coordinates[1]-'1') % 2 c := int(coordinates[0]-'a') % 2 if r == c { return false } return true } 复杂度分析 时间复杂度：O(1)。仅使用常数时间。 空间复杂度：O(1)。仅使用常数空间。 方法二：数学 思路 经过观察可以发现，从左下角开始，棋盘的行数和列数（均从 1 开始计数）之和如果为奇数，则为白色格子，如果和为偶数，则为黑色格子。可以根据这个结论判断格子颜色。</description></item><item><title>【2022-11-23每日一题】1742. 盒子中小球的最大数量[Easy]</title><link>/study/leetcode/maximum-number-of-balls-in-a-box/</link><pubDate>Wed, 23 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximum-number-of-balls-in-a-box/</guid><description>2022-11-23每日一题：1742. 盒子中小球的最大数量 难度：Easy
标签：哈希表 、 数学 、 计数
你在一家生产小球的玩具厂工作，有 n 个小球，编号从 lowLimit 开始，到 highLimit 结束（包括 lowLimit 和 highLimit ，即 n == highLimit - lowLimit + 1）。另有无限数量的盒子，编号从 1 到 infinity 。
你的工作是将每个小球放入盒子中，其中盒子的编号应当等于小球编号上每位数字的和。例如，编号 321 的小球应当放入编号 3 + 2 + 1 = 6 的盒子，而编号 10 的小球应当放入编号 1 + 0 = 1 的盒子。
给你两个整数 lowLimit 和 highLimit ，返回放有最多小球的盒子中的小球数量。如果有多个盒子都满足放有最多小球，只需返回其中任一盒子的小球数量。
示例 1：
输入：lowLimit = 1, highLimit = 10 输出：2 解释： 盒子编号：1 2 3 4 5 6 7 8 9 10 11 .</description></item><item><title>【2022-11-22每日一题】878. 第 N 个神奇数字[Hard]</title><link>/study/leetcode/nth-magical-number/</link><pubDate>Tue, 22 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/nth-magical-number/</guid><description>2022-11-22每日一题：878. 第 N 个神奇数字 难度：Hard
标签：数学 、 二分查找
一个正整数如果能被 a 或 b 整除，那么它是神奇的。
给定三个整数 n ,&amp;nbsp;a , b ，返回第 n 个神奇的数字。因为答案可能很大，所以返回答案&amp;nbsp;对&amp;nbsp;109&amp;nbsp;+ 7 取模&amp;nbsp;后的值。
&amp;nbsp;
示例 1：
输入：n = 1, a = 2, b = 3 输出：2 示例&amp;nbsp;2：
输入：n = 4, a = 2, b = 3 输出：6 &amp;nbsp;
提示：
1 &amp;lt;= n &amp;lt;= 109 2 &amp;lt;= a, b &amp;lt;= 4 * 104 &amp;nbsp;
方法一：数学+二分查找 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
const mod int = 1e9+7 // 系统库二分查找 func nthMagicalNumber(n int, a int, b int) int { c := a * b / gcd(a, b) // a,b最少公倍数 r := (a + b) * n return sort.</description></item><item><title>【2022-11-21每日一题】808. 分汤[Medium]</title><link>/study/leetcode/soup-servings/</link><pubDate>Mon, 21 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/soup-servings/</guid><description>2022-11-21每日一题：808. 分汤 难度：Medium
标签：数学 、 动态规划 、 概率与统计
有&amp;nbsp;A&amp;nbsp;和&amp;nbsp;B 两种类型&amp;nbsp;的汤。一开始每种类型的汤有&amp;nbsp;n&amp;nbsp;毫升。有四种分配操作：
提供 100ml 的 汤A 和 0ml 的 汤B 。 提供 75ml 的 汤A 和 25ml 的 汤B 。 提供 50ml 的 汤A 和 50ml 的 汤B 。 提供 25ml 的 汤A 和 75ml 的 汤B 。 当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为 0.25 的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。
注意&amp;nbsp;不存在先分配 100 ml 汤B 的操作。
需要返回的值：&amp;nbsp;汤A&amp;nbsp;先分配完的概率 +&amp;nbsp;&amp;nbsp;汤A和汤B&amp;nbsp;同时分配完的概率 / 2。返回值在正确答案&amp;nbsp;10-5&amp;nbsp;的范围内将被认为是正确的。
&amp;nbsp;
示例 1:
输入: n = 50 输出: 0.62500 解释:如果我们选择前两个操作，A 首先将变为空。 对于第三个操作，A 和 B 会同时变为空。 对于第四个操作，B 首先将变为空。 所以 A 变为空的总概率加上 A 和 B 同时变为空的概率的一半是 0.</description></item><item><title>【2022-11-18每日一题】891. 子序列宽度之和[Hard]</title><link>/study/leetcode/sum-of-subsequence-widths/</link><pubDate>Fri, 18 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/sum-of-subsequence-widths/</guid><description>2022-11-18每日一题：891. 子序列宽度之和 难度：Hard
标签：数组 、 数学 、 排序
一个序列的 宽度 定义为该序列中最大元素和最小元素的差值。
给你一个整数数组 nums ，返回 nums 的所有非空 子序列 的 宽度之和 。由于答案可能非常大，请返回对 109 + 7 取余 后的结果。
子序列 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，[3,6,2,7] 就是数组 [0,3,1,6,2,2,7] 的一个子序列。
&amp;nbsp;
示例 1：
输入：nums = [2,1,3] 输出：6 解释：子序列为 [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3] 。 相应的宽度是 0, 0, 0, 1, 1, 2, 2 。 宽度之和是 6 。 示例 2：
输入：nums = [2] 输出：0 &amp;nbsp;
提示：
1 &amp;lt;= nums.length &amp;lt;= 105 1 &amp;lt;= nums[i] &amp;lt;= 105 方法一：数学（排序 + 枚举元素计算贡献） 推荐题解一 推荐题解二 const mod int = 1e9+7 // 写法一： func sumSubseqWidths(nums []int) (ans int) { sort.</description></item><item><title>【2022-11-16每日一题】775. 全局倒置与局部倒置[Medium]</title><link>/study/leetcode/global-and-local-inversions/</link><pubDate>Wed, 16 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/global-and-local-inversions/</guid><description>2022-11-16每日一题：775. 全局倒置与局部倒置 难度：Medium
标签：数组 、 数学
给你一个长度为 n 的整数数组 nums ，表示由范围 [0, n - 1] 内所有整数组成的一个排列。
全局倒置 的数目等于满足下述条件不同下标对 (i, j) 的数目：
0 &lt;= i &lt; j &lt; n nums[i] > nums[j] 局部倒置 的数目等于满足下述条件的下标 i 的数目：
0 &lt;= i &lt; n - 1 nums[i] > nums[i + 1] 当数组 nums 中 全局倒置 的数量等于 局部倒置 的数量时，返回 true ；否则，返回 false 。
示例 1：
输入：nums = [1,0,2] 输出：true 解释：有 1 个全局倒置，和 1 个局部倒置。 示例 2：
输入：nums = [1,2,0] 输出：false 解释：有 2 个全局倒置，和 1 个局部倒置。 提示：</description></item><item><title>【2022-11-14每日一题】805. 数组的均值分割[Hard]</title><link>/study/leetcode/split-array-with-same-average/</link><pubDate>Mon, 14 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/split-array-with-same-average/</guid><description>2022-11-14每日一题：805. 数组的均值分割 难度：Hard
标签：位运算 、 数组 、 数学 、 动态规划 、 状态压缩
给定你一个整数数组&amp;nbsp;nums
我们要将&amp;nbsp;nums&amp;nbsp;数组中的每个元素移动到&amp;nbsp;A&amp;nbsp;数组 或者&amp;nbsp;B&amp;nbsp;数组中，使得&amp;nbsp;A&amp;nbsp;数组和&amp;nbsp;B&amp;nbsp;数组不为空，并且&amp;nbsp;average(A) == average(B)&amp;nbsp;。
如果可以完成则返回true&amp;nbsp;， 否则返回 false&amp;nbsp;&amp;nbsp;。
注意：对于数组&amp;nbsp;arr&amp;nbsp;, &amp;nbsp;average(arr)&amp;nbsp;是&amp;nbsp;arr&amp;nbsp;的所有元素除以&amp;nbsp;arr&amp;nbsp;长度的和。
&amp;nbsp;
示例 1:
输入: nums = [1,2,3,4,5,6,7,8] 输出: true 解释: 我们可以将数组分割为 [1,4,5,8] 和 [2,3,6,7], 他们的平均值都是4.5。 示例 2:
输入: nums = [3,1] 输出: false &amp;nbsp;
提示:
1 &amp;lt;= nums.length &amp;lt;= 30 0 &amp;lt;= nums[i] &amp;lt;= 104 方法一：折半查找 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
题解一 题解二 func splitArraySameAverage(nums []int) bool { n := len(nums) if n == 1 { // 不符合A, B都有元素 return false } // 求和 sum := 0 for _, v := range nums { sum += v } // 预处理数组 for i, v := range nums { nums[i] = v * n - sum } m := n &amp;gt;&amp;gt; 1 // 相当于 n/2 left := map[int]bool{} // 左侧处理 for i := 1; i &amp;lt; 1&amp;lt;&amp;lt;m; i++ { total := 0 for j, v := range nums { if i&amp;gt;&amp;gt;j&amp;amp;1 &amp;gt; 0 { total += v } } if total == 0 { return true } left[total] = true } // 右半部分处理 rsum := 0 for _, v := range nums[m:] { rsum += v } for i := 1; i &amp;lt; 1&amp;lt;&amp;lt;(n-m); i++ { total := 0 for j, v := range nums[m:] { if i&amp;gt;&amp;gt;j&amp;amp;1 &amp;gt; 0 { total += v } } // rsum !</description></item><item><title>【2022-11-06 加练约瑟夫环】剑指 Offer 62. 圆圈中最后剩下的数字[Easy]</title><link>/study/leetcode/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</link><pubDate>Sun, 06 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</guid><description>加练：剑指 Offer 62. 圆圈中最后剩下的数字 难度：Easy
标签：递归 、 数学
0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。
例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。
示例 1：
输入: n = 5, m = 3 输出: 3 示例 2：
输入: n = 10, m = 17 输出: 2 限制：
1 &lt;= n &lt;= 10^5 1 &lt;= m &lt;= 10^6 方法一：递归 详细题解 核心思想：f(10,3)的结果就可以转化为f(9,3)的表达,后面也是同理：
f(10,3)=(f(9,3)+3)%10 f(9,3)=(f(8,3)+3)%9 …… f(2,3)=(f(1,3)+3)%2 f(1,3)=0 代码 func lastRemaining(n int, m int) int { if n == 1 { return 0 } return (lastRemaining(n-1, m) + m) % n } 复杂度分析 时间复杂度：O(n)。 空间复杂度：O(n)。 方法二：迭代 func lastRemaining(n int, m int) int { ans := 0 for i := 1; i &amp;lt;= n; i++ { ans = (ans + m) % i } return ans } 复杂度分析 时间复杂度：O(n)。 空间复杂度：O(1)。 LeetCode题库地址 https://leetcode.</description></item><item><title>【2022-11-04每日一题】754. 到达终点数字[Medium]</title><link>/study/leetcode/reach-a-number/</link><pubDate>Fri, 04 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/reach-a-number/</guid><description>2022-11-04每日一题：754. 到达终点数字 难度：Medium
标签：数学 、 二分查找
在一根无限长的数轴上，你站在0的位置。终点在target的位置。
你可以做一些数量的移动 numMoves :
每次你可以选择向左或向右移动。 第 i&amp;nbsp;次移动（从 &amp;nbsp;i == 1&amp;nbsp;开始，到&amp;nbsp;i == numMoves ），在选择的方向上走 i&amp;nbsp;步。 给定整数&amp;nbsp;target ，返回 到达目标所需的 最小&amp;nbsp;移动次数(即最小 numMoves )&amp;nbsp;。
&amp;nbsp;
示例 1:
输入: target = 2 输出: 3 解释: 第一次移动，从 0 到 1 。 第二次移动，从 1 到 -1 。 第三次移动，从 -1 到 2 。 示例 2:
输入: target = 3 输出: 2 解释: 第一次移动，从 0 到 1 。 第二次移动，从 1 到 3 。 &amp;nbsp;
提示:
-109&amp;nbsp;&amp;lt;= target &amp;lt;= 109 target !</description></item><item><title>【2022-10-27每日一题】1822. 数组元素积的符号[Easy]</title><link>/study/leetcode/sign-of-the-product-of-an-array/</link><pubDate>Thu, 27 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/sign-of-the-product-of-an-array/</guid><description>2022-10-27每日一题：1822. 数组元素积的符号 难度：Easy
标签：数组 、 数学
已知函数 signFunc(x) 将会根据 x 的正负返回特定值：
如果 x 是正数，返回 1 。 如果 x 是负数，返回 -1 。 如果 x 是等于 0 ，返回 0 。 给你一个整数数组 nums 。令 product 为数组 nums 中所有元素值的乘积。
返回 signFunc(product) 。
示例 1：
输入：nums = [-1,-2,-3,-4,3,2,1] 输出：1 解释：数组中所有值的乘积是 144 ，且 signFunc(144) = 1 示例 2：
输入：nums = [1,5,0,2,-3] 输出：0 解释：数组中所有值的乘积是 0 ，且 signFunc(0) = 0 示例 3：
输入：nums = [-1,1,-1,1,-1] 输出：-1 解释：数组中所有值的乘积是 -1 ，且 signFunc(-1) = -1 提示：</description></item><item><title>【2022-10-20每日一题】779. 第K个语法符号[Medium]</title><link>/study/leetcode/k-th-symbol-in-grammar/</link><pubDate>Thu, 20 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/k-th-symbol-in-grammar/</guid><description>2022-10-20每日一题：779. 第K个语法符号 难度：Medium
标签：位运算 、 递归 、 数学
我们构建了一个包含 n 行(&amp;nbsp;索引从 1&amp;nbsp; 开始&amp;nbsp;)的表。首先在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。
例如，对于 n = 3 ，第 1 行是 0 ，第 2 行是 01 ，第3行是 0110 。 给定行数&amp;nbsp;n&amp;nbsp;和序数 k，返回第 n 行中第 k&amp;nbsp;个字符。（&amp;nbsp;k&amp;nbsp;从索引 1 开始）
示例 1:
输入: n = 1, k = 1 输出: 0 解释: 第一行：0 示例 2:
输入: n = 2, k = 1 输出: 0 解释: 第一行: 0 第二行: 01 示例 3:
输入: n = 2, k = 2 输出: 1 解释: 第一行: 0 第二行: 01 &amp;nbsp;</description></item><item><title>【2022-10-18每日一题】902. 最大为 N 的数字组合[Hard]</title><link>/study/leetcode/numbers-at-most-n-given-digit-set/</link><pubDate>Tue, 18 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/numbers-at-most-n-given-digit-set/</guid><description>2022-10-18每日一题：902. 最大为 N 的数字组合 难度：Hard
标签：数组 、 数学 、 字符串 、 二分查找 、 动态规划
给定一个按&amp;nbsp;非递减顺序&amp;nbsp;排列的数字数组&amp;nbsp;digits&amp;nbsp;。你可以用任意次数&amp;nbsp;digits[i]&amp;nbsp;来写的数字。例如，如果&amp;nbsp;digits = ['1','3','5']，我们可以写数字，如&amp;nbsp;'13',&amp;nbsp;'551', 和&amp;nbsp;'1351315'。
返回 可以生成的小于或等于给定整数 n 的正整数的个数&amp;nbsp;。
&amp;nbsp;
示例 1：
输入：digits = ["1","3","5","7"], n = 100 输出：20 解释： 可写出的 20 个数字是： 1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77. 示例 2：
输入：digits = ["1","4","9"], n = 1000000000 输出：29523 解释： 我们可以写 3 个一位数字，9 个两位数字，27 个三位数字， 81 个四位数字，243 个五位数字，729 个六位数字， 2187 个七位数字，6561 个八位数字和 19683 个九位数字。 总共，可以使用D中的数字写出 29523 个整数。 示例 3:</description></item><item><title>【2022-10-06每日一题】927. 三等分[Hard]</title><link>/study/leetcode/three-equal-parts/</link><pubDate>Thu, 06 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/three-equal-parts/</guid><description>2022-10-06每日一题：927. 三等分 难度：Hard
标签：数组 、 数学
给定一个由 0 和 1 组成的数组&amp;nbsp;arr&amp;nbsp;，将数组分成 &amp;nbsp;3&amp;nbsp;个非空的部分 ，使得所有这些部分表示相同的二进制值。
如果可以做到，请返回任何&amp;nbsp;[i, j]，其中 i+1 &amp;lt; j，这样一来：
arr[0], arr[1], ..., arr[i]&amp;nbsp;为第一部分； arr[i + 1], arr[i + 2], ..., arr[j - 1]&amp;nbsp;为第二部分； arr[j], arr[j + 1], ..., arr[arr.length - 1]&amp;nbsp;为第三部分。 这三个部分所表示的二进制值相等。 如果无法做到，就返回&amp;nbsp;[-1, -1]。
注意，在考虑每个部分所表示的二进制时，应当将其看作一个整体。例如，[1,1,0]&amp;nbsp;表示十进制中的&amp;nbsp;6，而不会是&amp;nbsp;3。此外，前导零也是被允许的，所以&amp;nbsp;[0,1,1] 和&amp;nbsp;[1,1]&amp;nbsp;表示相同的值。
&amp;nbsp;
示例 1：
输入：arr = [1,0,1,0,1] 输出：[0,3] 示例 2：
输入：arr = [1,1,0,1,1] 输出：[-1,-1] 示例 3:
输入：arr = [1,1,0,0,1] 输出：[0,2] &amp;nbsp;
提示：
3 &amp;lt;= arr.length &amp;lt;= 3 * 104 arr[i]&amp;nbsp;是&amp;nbsp;0&amp;nbsp;或&amp;nbsp;1 方法一： 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读</description></item><item><title>【2022-09-28每日一题】面试题 17.09. 第 k 个数[Medium]</title><link>/study/leetcode/get-kth-magic-number-lcci/</link><pubDate>Wed, 28 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/get-kth-magic-number-lcci/</guid><description>2022-09-28每日一题：面试题 17.09. 第 k 个数 难度：Medium
标签：哈希表 、 数学 、 动态规划 、 堆（优先队列）
有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。
示例 1:
输入: k = 5 输出: 9 方法一：堆（优先队列） // 小顶堆 type hp struct { sort.IntSlice } func (h hp) Less(i, j int) bool { return h.IntSlice[i] &amp;lt; h.IntSlice[j] } func (h *hp) Push(v interface{}) {h.IntSlice = append(h.IntSlice, v.(int))} func (h *hp) Pop() (v interface{}) { v, h.IntSlice = h.IntSlice[h.Len()-1], h.IntSlice[:h.Len()-1]; return v} var factors = []int{3, 5, 7} func getKthMagicNumber(k int) int { h := hp{sort.</description></item><item><title>【2022-09-25每日一题】788. 旋转数字[Medium]</title><link>/study/leetcode/rotated-digits/</link><pubDate>Sun, 25 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/rotated-digits/</guid><description>2022-09-25每日一题：788. 旋转数字 难度：Medium
标签：数学 、 动态规划
我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。
如果一个数的每位数字被旋转以后仍然还是一个数字，&amp;nbsp;则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方（在这种情况下，它们以不同的方向旋转，换句话说，2 和 5 互为镜像）；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。
现在我们有一个正整数&amp;nbsp;N, 计算从&amp;nbsp;1 到&amp;nbsp;N 中有多少个数&amp;nbsp;X 是好数？
&amp;nbsp;
示例：
输入: 10 输出: 4 解释: 在[1, 10]中有四个好数： 2, 5, 6, 9。 注意 1 和 10 不是好数, 因为他们在旋转之后不变。 &amp;nbsp;
提示：
N&amp;nbsp;的取值范围是&amp;nbsp;[1, 10000]。 方法一：枚举 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
官方check数组法 // 写法一： // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 var check = []int{0, 0, 1,-1,-1, 1, 1,-1, 0, 1} // 反转后0代码原样, 1有对应数字，-1 无效 func rotatedDigits(n int) (ans int) { for i := 1; i &amp;lt;= n; i++ { s := strconv.</description></item><item><title>【2022-09-15每日一题】672. 灯泡开关 Ⅱ</title><link>/study/leetcode/bulb-switcher-ii/</link><pubDate>Thu, 15 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/bulb-switcher-ii/</guid><description>2022-09-15每日一题：672. 灯泡开关 Ⅱ 难度：Medium 标签：位运算 、 深度优先搜索 、 广度优先搜索 、 数学 房间中有 n&amp;nbsp;只已经打开的灯泡，编号从 1 到 n 。墙上挂着 4 个开关 。
这 4 个开关各自都具有不同的功能，其中：
开关 1 ：反转当前所有灯的状态（即开变为关，关变为开） 开关 2 ：反转编号为偶数的灯的状态（即 2, 4, ...） 开关 3 ：反转编号为奇数的灯的状态（即 1, 3, ...） 开关 4 ：反转编号为 j = 3k + 1 的灯的状态，其中 k = 0, 1, 2, ...（即 1, 4, 7, 10, ...） 你必须 恰好 按压开关 presses 次。每次按压，你都需要从 4 个开关中选出一个来执行按压操作。
给你两个整数 n 和 presses ，执行完所有按压之后，返回 不同可能状态 的数量。
示例 1：
输入：n = 1, presses = 1 输出：2 解释：状态可以是： - 按压开关 1 ，[关] - 按压开关 2 ，[开] 示例 2：</description></item><item><title>【2022-09-13每日一题】670. 最大交换</title><link>/study/leetcode/maximum-swap/</link><pubDate>Tue, 13 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximum-swap/</guid><description>2022-09-13每日一题：670. 最大交换 难度：Medium 标签：贪心 、 数学 给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。
示例 1 :
输入: 2736 输出: 7236 解释: 交换数字2和数字7。 示例 2 :
输入: 9973 输出: 9973 解释: 不需要交换。 注意:
给定数字的范围是&amp;nbsp;[0, 108] ### 方法一：暴力枚举 func maximumSwap(num int) int { ans := num s := []byte(strconv.Itoa(num)) for i := range s { for j := range s[:i] { s[i], s[j] = s[j], s[i] v, _ := strconv.Atoi(string(s)) ans = max(ans, v) s[i], s[j] = s[j], s[i] // 还原 } } return ans } func max(a, b int) int { if a &amp;gt; b { return a } return b } 复杂度分析 时间复杂度：O(log^3*num) 空间复杂度：O(lognum) 方法二：贪心 解题思路 func maximumSwap(num int) int { nums := []byte(strconv.</description></item><item><title>【2022-09-08每日一题】667. 优美的排列 II</title><link>/study/leetcode/beautiful-arrangement-ii/</link><pubDate>Thu, 08 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/beautiful-arrangement-ii/</guid><description>2022-09-08每日一题：667. 优美的排列 II 难度：Medium 标签：数组 、 数学 给你两个整数 n 和 k ，请你构造一个答案列表 answer ，该列表应当包含从 1 到 n 的 n 个不同正整数，并同时满足下述条件：
假设该列表是 answer = [a1, a2, a3, ... , an] ，那么列表 [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] 中应该有且仅有 k 个不同整数。 返回列表 answer 。如果存在多种答案，只需返回其中 任意一种 。
示例 1：
输入：n = 3, k = 1 输出：[1, 2, 3] 解释：[1, 2, 3] 包含 3 个范围在 1-3 的不同整数，并且 [1, 1] 中有且仅有 1 个不同整数：1 示例 2：</description></item><item><title>【2022-08-28每日一题】793. 阶乘函数后 K 个零</title><link>/study/leetcode/preimage-size-of-factorial-zeroes-function/</link><pubDate>Sun, 28 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/preimage-size-of-factorial-zeroes-function/</guid><description>2022-08-28每日一题：793. 阶乘函数后 K 个零 难度：Hard 标签：数学 、 二分查找 &amp;nbsp;f(x)&amp;nbsp;是&amp;nbsp;x!&amp;nbsp;末尾是 0 的数量。回想一下&amp;nbsp;x! = 1 * 2 * 3 * ... * x，且 0! = 1&amp;nbsp;。
例如，&amp;nbsp;f(3) = 0&amp;nbsp;，因为 3! = 6 的末尾没有 0 ；而 f(11) = 2&amp;nbsp;，因为 11!= 39916800 末端有 2 个 0 。 给定&amp;nbsp;k，找出返回能满足 f(x) = k&amp;nbsp;的非负整数 x&amp;nbsp;的数量。
&amp;nbsp;
示例 1： 输入：k = 0 输出：5 解释：0!, 1!, 2!, 3!, 和 4!&amp;nbsp;均符合 k = 0 的条件。 示例 2：
输入：k = 5 输出：0 解释：没有匹配到这样的 x!，符合 k = 5 的条件。 示例 3:</description></item><item><title>【2022-08-23每日一题】782. 变为棋盘</title><link>/study/leetcode/transform-to-chessboard/</link><pubDate>Tue, 23 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/transform-to-chessboard/</guid><description>2022-08-23每日一题：782. 变为棋盘 难度：Hard 标签：位运算 、 数组 、 数学 、 矩阵 一个&amp;nbsp;n x n&amp;nbsp;的二维网络&amp;nbsp;board&amp;nbsp;仅由&amp;nbsp;0&amp;nbsp;和&amp;nbsp;1&amp;nbsp;组成&amp;nbsp;。每次移动，你能任意交换两列或是两行的位置。
返回 将这个矩阵变为&amp;nbsp; “棋盘”&amp;nbsp;&amp;nbsp;所需的最小移动次数&amp;nbsp;。如果不存在可行的变换，输出 -1。
“棋盘” 是指任意一格的上下左右四个方向的值均与本身不同的矩阵。
&amp;nbsp;
示例 1:
输入: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]] 输出: 2 解释:一种可行的变换方式如下，从左到右： 第一次移动交换了第一列和第二列。 第二次移动交换了第二行和第三行。 示例 2:
输入: board = [[0, 1], [1, 0]] 输出: 0 解释: 注意左上角的格值为0时也是合法的棋盘，也是合法的棋盘. 示例 3:
输入: board = [[1, 0], [1, 0]] 输出: -1 解释: 任意的变换都不能使这个输入变为合法的棋盘。 &amp;nbsp;
提示：
n == board.length n == board[i].length 2 &amp;lt;= n &amp;lt;= 30 board[i][j]&amp;nbsp;将只包含&amp;nbsp;0或&amp;nbsp;1 func getMoves(mask uint, count, n int) int { ones := bits.</description></item><item><title>【2022-08-10每日一题】640. 求解方程</title><link>/study/leetcode/solve-the-equation/</link><pubDate>Wed, 10 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/solve-the-equation/</guid><description>2022-08-10每日一题：640. 求解方程 难度：Medium 标签：数学 、 字符串 、 模拟 求解一个给定的方程，将x以字符串 "x=#value"&amp;nbsp;的形式返回。该方程仅包含 '+' ， '-' 操作，变量&amp;nbsp;x&amp;nbsp;和其对应系数。
如果方程没有解，请返回&amp;nbsp;"No solution"&amp;nbsp;。如果方程有无限解，则返回 “Infinite solutions” 。
如果方程中只有一个解，要保证返回值 'x'&amp;nbsp;是一个整数。
&amp;nbsp;
示例 1：
输入: equation = &amp;quot;x+5-3+x=6+x-2&amp;quot; 输出: &amp;quot;x=2&amp;quot; 示例 2:
输入: equation = &amp;quot;x=x&amp;quot; 输出: &amp;quot;Infinite solutions&amp;quot; 示例 3:
输入: equation = &amp;quot;2x=x&amp;quot; 输出: &amp;quot;x=0&amp;quot; &amp;nbsp;
&amp;nbsp;
提示:
3 &amp;lt;= equation.length &amp;lt;= 1000 equation&amp;nbsp;只有一个&amp;nbsp;'='. equation&amp;nbsp;方程由整数组成，其绝对值在&amp;nbsp;[0, 100]&amp;nbsp;范围内，不含前导零和变量 'x' 。&amp;nbsp;​​​ ### 方法一：模拟 根据题意进行模拟即可，设factor表示合并同类项的x的系数，val表示合并数字的值
首先我们对方程左右两边的表达式进行合并同类项 遍历左表达式，默认为正号 若字符是x，加到factor上 若字符是+或者-，改变符号位 若字符是数字，则判断后边有没有跟x，有则加到factor上，没有加到val上 遍历右表达式，默认为负号，相当于右边的表达式移动到左边（解析同上只是符号相反） 若factor == 0，判断val是否为0，为0则表示无穷解，不为0表示没有解 若factor != 0,直接解方程即可，现在的方程变为factor * x = -val,则x = (-val / factor) func solveEquation(equation string) string { factor, val := 0, 0 i, n, sign := 0, len(equation), 1 // 等式左边默认系数为正 for i &amp;lt; n { if equation[i] == '=' { sign = -1 // 等式右边默认系数为负 i++ continue } s := sign if equation[i] == '+' { // 去掉前面的符号 i++ } else if equation[i] == '-' { s = -s i++ } num, valid := 0, false for i &amp;lt; n &amp;amp;&amp;amp; unicode.</description></item><item><title>2022-08-03每日一题：899. 有序队列</title><link>/study/leetcode/orderly-queue/</link><pubDate>Wed, 03 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/orderly-queue/</guid><description>2022-08-03每日一题：899. 有序队列 给定一个字符串 s 和一个整数 k&amp;nbsp;。你可以从 s 的前 k 个字母中选择一个，并把它加到字符串的末尾。
返回 在应用上述步骤的任意数量的移动后，字典上最小的字符串&amp;nbsp;。
&amp;nbsp;
示例 1：
输入：s = "cba", k = 1 输出："acb" 解释： 在第一步中，我们将第一个字符（“c”）移动到最后，获得字符串 “bac”。 在第二步中，我们将第一个字符（“b”）移动到最后，获得最终结果 “acb”。 示例 2：
输入：s = "baaca", k = 3 输出："aaabc" 解释： 在第一步中，我们将第一个字符（“b”）移动到最后，获得字符串 “aacab”。 在第二步中，我们将第三个字符（“c”）移动到最后，获得最终结果 “aaabc”。 &amp;nbsp;
提示：
1 &amp;lt;= k&amp;nbsp;&amp;lt;= S.length&amp;nbsp;&amp;lt;= 1000 s&amp;nbsp;只由小写字母组成。 func orderlyQueue(s string, k int) string { if k == 1 { // 当k = 1时，共有 n 种候选方案, 遍历求其最小的字典序 ans := s for i := 1; i &amp;lt; len(s); i++ { s = s[1:] + s[:1] if s &amp;lt; ans { ans = s } } return ans } // 当k &amp;gt; 1时，经过不断的变换，我们总能让序列有序，直接对字符串进行字典序排序即可 t := []byte(s) sort.</description></item></channel></rss>