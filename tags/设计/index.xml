<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>设计 on lbbniu</title><link>/tags/%E8%AE%BE%E8%AE%A1/</link><description>Recent content in 设计 on lbbniu</description><generator>Hugo -- gohugo.io</generator><language>zh</language><managingEditor>lbbniu@gmail.com (lbbniu)</managingEditor><webMaster>lbbniu@gmail.com (lbbniu)</webMaster><copyright>&amp;copy; 2021 &lt;a href="https://blog.lbbniu.com/">lbbniu&lt;/a></copyright><lastBuildDate>Wed, 18 Jan 2023 00:01:00 +0800</lastBuildDate><atom:link href="/tags/%E8%AE%BE%E8%AE%A1/index.xml" rel="self" type="application/rss+xml"/><item><title>剑指 Offer 09 用两个栈实现队列</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/</guid><description>剑指 Offer 09 用两个栈实现队列 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead&amp;nbsp;操作返回 -1 )
&amp;nbsp;
示例 1：
输入： [&amp;quot;CQueue&amp;quot;,&amp;quot;appendTail&amp;quot;,&amp;quot;deleteHead&amp;quot;,&amp;quot;deleteHead&amp;quot;] [[],[3],[],[]] 输出：[null,null,3,-1] 示例 2：
输入： [&amp;quot;CQueue&amp;quot;,&amp;quot;deleteHead&amp;quot;,&amp;quot;appendTail&amp;quot;,&amp;quot;appendTail&amp;quot;,&amp;quot;deleteHead&amp;quot;,&amp;quot;deleteHead&amp;quot;] [[],[],[5],[2],[],[]] 输出：[null,-1,null,null,5,2] 提示：
1 &amp;lt;= values &amp;lt;= 10000 最多会对&amp;nbsp;appendTail、deleteHead 进行&amp;nbsp;10000&amp;nbsp;次调用 type CQueue struct { } func Constructor() CQueue { } func (this *CQueue) AppendTail(value int) { } func (this *CQueue) DeleteHead() int { } /** * Your CQueue object will be instantiated and called as such: * obj := Constructor(); * obj.AppendTail(value); * param_2 := obj.</description></item><item><title>剑指 Offer II 013 二维子矩阵的和</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/o4ndxx/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/o4ndxx/</guid><description>剑指 Offer II 013 二维子矩阵的和 给定一个二维矩阵 matrix，以下类型的多个请求：
计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1,&amp;nbsp;col1) ，右下角为 (row2,&amp;nbsp;col2) 。 实现 NumMatrix 类：
NumMatrix(int[][] matrix)&amp;nbsp;给定整数矩阵 matrix 进行初始化 int sumRegion(int row1, int col1, int row2, int col2)&amp;nbsp;返回左上角 (row1,&amp;nbsp;col1)&amp;nbsp;、右下角&amp;nbsp;(row2,&amp;nbsp;col2)&amp;nbsp;的子矩阵的元素总和。 &amp;nbsp;
示例 1：
输入: [&amp;quot;NumMatrix&amp;quot;,&amp;quot;sumRegion&amp;quot;,&amp;quot;sumRegion&amp;quot;,&amp;quot;sumRegion&amp;quot;] [[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]] 输出: [null, 8, 11, 12] 解释: NumMatrix numMatrix = new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]]); numMatrix.sumRegion(2, 1, 4, 3); // return 8 (红色矩形框的元素总和) numMatrix.sumRegion(1, 1, 2, 2); // return 11 (绿色矩形框的元素总和) numMatrix.sumRegion(1, 2, 2, 4); // return 12 (蓝色矩形框的元素总和) &amp;nbsp;
提示：
m == matrix.length n == matrix[i].</description></item><item><title>面试题 03.01 三合一</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/three-in-one-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/three-in-one-lcci/</guid><description>面试题 03.01 三合一 三合一。描述如何只用一个数组来实现三个栈。
你应该实现push(stackNum, value)、pop(stackNum)、isEmpty(stackNum)、peek(stackNum)方法。stackNum表示栈下标，value表示压入的值。
构造函数会传入一个stackSize参数，代表每个栈的大小。
示例1:
输入： ["TripleInOne", "push", "push", "pop", "pop", "pop", "isEmpty"] [[1], [0, 1], [0, 2], [0], [0], [0], [0]] 输出： [null, null, null, 1, -1, -1, true] 说明：当栈为空时`pop, peek`返回-1，当栈满时`push`不压入元素。 示例2:
输入： ["TripleInOne", "push", "push", "push", "pop", "pop", "pop", "peek"] [[2], [0, 1], [0, 2], [0, 3], [0], [0], [0], [0]] 输出： [null, null, null, null, 2, 1, -1, -1] &amp;nbsp;
提示：
0 &amp;lt;= stackNum &amp;lt;= 2 type TripleInOne struct { } func Constructor(stackSize int) TripleInOne { } func (this *TripleInOne) Push(stackNum int, value int) { } func (this *TripleInOne) Pop(stackNum int) int { } func (this *TripleInOne) Peek(stackNum int) int { } func (this *TripleInOne) IsEmpty(stackNum int) bool { } /** * Your TripleInOne object will be instantiated and called as such: * obj := Constructor(stackSize); * obj.</description></item><item><title>面试题 03.02 栈的最小值</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/min-stack-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/min-stack-lcci/</guid><description>面试题 03.02 栈的最小值 请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。
示例：MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); --> 返回 -3.
minStack.pop();
minStack.top(); --> 返回 0.
minStack.getMin(); --> 返回 -2.
type MinStack struct { } /** initialize your data structure here. */ func Constructor() MinStack { } func (this *MinStack) Push(x int) { } func (this *MinStack) Pop() { } func (this *MinStack) Top() int { } func (this *MinStack) GetMin() int { } /** * Your MinStack object will be instantiated and called as such: * obj := Constructor(); * obj.</description></item><item><title>面试题 03.03 堆盘子</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/stack-of-plates-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/stack-of-plates-lcci/</guid><description>面试题 03.03 堆盘子 堆盘子。设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构SetOfStacks，模拟这种行为。SetOfStacks应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，SetOfStacks.push()和SetOfStacks.pop()应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）。 进阶：实现一个popAt(int index)方法，根据指定的子栈，执行pop操作。
当某个栈为空时，应当删除该栈。当栈中没有元素或不存在该栈时，pop，popAt&amp;nbsp;应返回 -1.
示例1:
输入： [&amp;quot;StackOfPlates&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;popAt&amp;quot;, &amp;quot;pop&amp;quot;, &amp;quot;pop&amp;quot;] [[1], [1], [2], [1], [], []] 输出： [null, null, null, 2, 1, -1] 示例2:
输入： [&amp;quot;StackOfPlates&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;popAt&amp;quot;, &amp;quot;popAt&amp;quot;, &amp;quot;popAt&amp;quot;] [[2], [1], [2], [3], [0], [0], [0]] 输出： [null, null, null, null, 2, 1, 3] type StackOfPlates struct { } func Constructor(cap int) StackOfPlates { } func (this *StackOfPlates) Push(val int) { } func (this *StackOfPlates) Pop() int { } func (this *StackOfPlates) PopAt(index int) int { } /** * Your StackOfPlates object will be instantiated and called as such: * obj := Constructor(cap); * obj.</description></item><item><title>面试题 03.04 化栈为队</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/implement-queue-using-stacks-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/implement-queue-using-stacks-lcci/</guid><description>面试题 03.04 化栈为队 实现一个MyQueue类，该类用两个栈来实现一个队列。
示例：MyQueue queue = new MyQueue();
queue.push(1);
queue.push(2);
queue.peek(); // 返回 1
queue.pop(); // 返回 1
queue.empty(); // 返回 false
说明：
你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size 和 is empty 操作是合法的。你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。
type MyQueue struct { } /** Initialize your data structure here. */ func Constructor() MyQueue { } /** Push element x to the back of queue. */ func (this *MyQueue) Push(x int) { } /** Removes the element from in front of queue and returns that element.</description></item><item><title>面试题 03.05 栈排序</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sort-of-stacks-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sort-of-stacks-lcci/</guid><description>面试题 03.05 栈排序 栈排序。 编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：push、pop、peek 和 isEmpty。当栈为空时，peek&amp;nbsp;返回 -1。
示例1:
输入： [&amp;quot;SortedStack&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;peek&amp;quot;, &amp;quot;pop&amp;quot;, &amp;quot;peek&amp;quot;] [[], [1], [2], [], [], []] 输出： [null,null,null,1,null,2] 示例2:
输入： [&amp;quot;SortedStack&amp;quot;, &amp;quot;pop&amp;quot;, &amp;quot;pop&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;pop&amp;quot;, &amp;quot;isEmpty&amp;quot;] [[], [], [], [1], [], []] 输出： [null,null,null,null,null,true] 说明:
栈中的元素数目在[0, 5000]范围内。 type SortedStack struct { } func Constructor() SortedStack { } func (this *SortedStack) Push(val int) { } func (this *SortedStack) Pop() { } func (this *SortedStack) Peek() int { } func (this *SortedStack) IsEmpty() bool { } /** * Your SortedStack object will be instantiated and called as such: * obj := Constructor(); * obj.</description></item><item><title>面试题 03.06 动物收容所</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/animal-shelter-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/animal-shelter-lcci/</guid><description>面试题 03.06 动物收容所 动物收容所。有家动物收容所只收容狗与猫，且严格遵守&amp;ldquo;先进先出&amp;rdquo;的原则。在收养该收容所的动物时，收养人只能收养所有动物中&amp;ldquo;最老&amp;rdquo;（由其进入收容所的时间长短而定）的动物，或者可以挑选猫或狗（同时必须收养此类动物中&amp;ldquo;最老&amp;rdquo;的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如enqueue、dequeueAny、dequeueDog和dequeueCat。允许使用Java内置的LinkedList数据结构。
enqueue方法有一个animal参数，animal[0]代表动物编号，animal[1]代表动物种类，其中 0 代表猫，1 代表狗。
dequeue*方法返回一个列表[动物编号, 动物种类]，若没有可以收养的动物，则返回[-1,-1]。
示例1:
输入： [&amp;quot;AnimalShelf&amp;quot;, &amp;quot;enqueue&amp;quot;, &amp;quot;enqueue&amp;quot;, &amp;quot;dequeueCat&amp;quot;, &amp;quot;dequeueDog&amp;quot;, &amp;quot;dequeueAny&amp;quot;] [[], [[0, 0]], [[1, 0]], [], [], []] 输出： [null,null,null,[0,0],[-1,-1],[1,0]] 示例2:
输入： [&amp;quot;AnimalShelf&amp;quot;, &amp;quot;enqueue&amp;quot;, &amp;quot;enqueue&amp;quot;, &amp;quot;enqueue&amp;quot;, &amp;quot;dequeueDog&amp;quot;, &amp;quot;dequeueCat&amp;quot;, &amp;quot;dequeueAny&amp;quot;] [[], [[0, 0]], [[1, 0]], [[2, 1]], [], [], []] 输出： [null,null,null,null,[2,1],[0,0],[1,0]] 说明:
收纳所的最大容量为20000 type AnimalShelf struct { } func Constructor() AnimalShelf { } func (this *AnimalShelf) Enqueue(animal []int) { } func (this *AnimalShelf) DequeueAny() []int { } func (this *AnimalShelf) DequeueDog() []int { } func (this *AnimalShelf) DequeueCat() []int { } /** * Your AnimalShelf object will be instantiated and called as such: * obj := Constructor(); * obj.</description></item><item><title>剑指 Offer 30 包含min函数的栈</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/bao-han-minhan-shu-de-zhan-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/bao-han-minhan-shu-de-zhan-lcof/</guid><description>剑指 Offer 30 包含min函数的栈 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。
&amp;nbsp;
示例:
MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.min(); --&amp;gt; 返回 -3. minStack.pop(); minStack.top(); --&amp;gt; 返回 0. minStack.min(); --&amp;gt; 返回 -2. &amp;nbsp;
提示：
各函数的调用总次数不超过 20000 次 &amp;nbsp;
注意：本题与主站 155 题相同：https://leetcode-cn.com/problems/min-stack/
type MinStack struct { } /** initialize your data structure here. */ func Constructor() MinStack { } func (this *MinStack) Push(x int) { } func (this *MinStack) Pop() { } func (this *MinStack) Top() int { } func (this *MinStack) Min() int { } /** * Your MinStack object will be instantiated and called as such: * obj := Constructor(); * obj.</description></item><item><title>剑指 Offer II 030 插入、删除和随机访问都是 O(1) 的容器</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/fortpu/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/fortpu/</guid><description>剑指 Offer II 030 插入、删除和随机访问都是 O(1) 的容器 设计一个支持在平均&amp;nbsp;时间复杂度 O(1)&amp;nbsp;下，执行以下操作的数据结构：
insert(val)：当元素 val 不存在时返回 true&amp;nbsp;，并向集合中插入该项，否则返回 false 。 remove(val)：当元素 val 存在时返回 true&amp;nbsp;，并从集合中移除该项，否则返回 false&amp;nbsp;。 getRandom：随机返回现有集合中的一项。每个元素应该有&amp;nbsp;相同的概率&amp;nbsp;被返回。 &amp;nbsp;
示例 :
输入: inputs = [&amp;quot;RandomizedSet&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;remove&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;getRandom&amp;quot;, &amp;quot;remove&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;getRandom&amp;quot;] [[], [1], [2], [2], [], [1], [2], []] 输出: [null, true, false, true, 2, true, false, 2] 解释: RandomizedSet randomSet = new RandomizedSet(); // 初始化一个空的集合 randomSet.insert(1); // 向集合中插入 1 ， 返回 true 表示 1 被成功地插入 randomSet.remove(2); // 返回 false，表示集合中不存在 2 randomSet.</description></item><item><title>剑指 Offer II 031 最近最少使用缓存</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/orixps/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/orixps/</guid><description>剑指 Offer II 031 最近最少使用缓存 运用所掌握的数据结构，设计和实现一个&amp;nbsp; LRU (Least Recently Used，最近最少使用) 缓存机制 。
实现 LRUCache 类：
LRUCache(int capacity) 以正整数作为容量&amp;nbsp;capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。 void put(int key, int value)&amp;nbsp;如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。 &amp;nbsp;
示例：
输入 [&amp;quot;LRUCache&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;get&amp;quot;] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]] 输出 [null, null, null, 1, null, -1, null, -1, 3, 4] 解释 LRUCache lRUCache = new LRUCache(2); lRUCache.</description></item><item><title>剑指 Offer 37 序列化二叉树</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/xu-lie-hua-er-cha-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/xu-lie-hua-er-cha-shu-lcof/</guid><description>剑指 Offer 37 序列化二叉树 请实现两个函数，分别用来序列化和反序列化二叉树。
你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。
提示：输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅&amp;nbsp;LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。
&amp;nbsp;
示例：
输入：root = [1,2,3,null,null,4,5] 输出：[1,2,3,null,null,4,5] &amp;nbsp;
注意：本题与主站 297 题相同：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/
LeetCode题库地址 https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof</description></item><item><title>剑指 Offer 41 数据流中的中位数</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/</guid><description>剑指 Offer 41 数据流中的中位数 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。
例如，
[2,3,4]&amp;nbsp;的中位数是 3
[2,3] 的中位数是 (2 + 3) / 2 = 2.5
设计一个支持以下两种操作的数据结构：
void addNum(int num) - 从数据流中添加一个整数到数据结构中。 double findMedian() - 返回目前所有元素的中位数。 示例 1：
输入： [&amp;quot;MedianFinder&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;] [[],[1],[2],[],[3],[]] 输出：[null,null,null,1.50000,null,2.00000] 示例 2：
输入： [&amp;quot;MedianFinder&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;,&amp;quot;addNum&amp;quot;,&amp;quot;findMedian&amp;quot;] [[],[2],[],[3],[]] 输出：[null,null,2.00000,null,2.50000] &amp;nbsp;
限制：
最多会对&amp;nbsp;addNum、findMedian 进行&amp;nbsp;50000&amp;nbsp;次调用。 注意：本题与主站 295 题相同：https://leetcode-cn.com/problems/find-median-from-data-stream/
type MedianFinder struct { } /** initialize your data structure here. */ func Constructor() MedianFinder { } func (this *MedianFinder) AddNum(num int) { } func (this *MedianFinder) FindMedian() float64 { } /** * Your MedianFinder object will be instantiated and called as such: * obj := Constructor(); * obj.</description></item><item><title>剑指 Offer II 041 滑动窗口的平均值</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/qisx9u/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/qisx9u/</guid><description>剑指 Offer II 041 滑动窗口的平均值 给定一个整数数据流和一个窗口大小，根据该滑动窗口的大小，计算滑动窗口里所有数字的平均值。
实现 MovingAverage 类：
MovingAverage(int size) 用窗口大小 size 初始化对象。 double next(int val)&amp;nbsp;成员函数 next&amp;nbsp;每次调用的时候都会往滑动窗口增加一个整数，请计算并返回数据流中最后 size 个值的移动平均值，即滑动窗口里所有数字的平均值。 &amp;nbsp;
示例：
输入： inputs = [&amp;quot;MovingAverage&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;next&amp;quot;] inputs = [[3], [1], [10], [3], [5]] 输出： [null, 1.0, 5.5, 4.66667, 6.0] 解释： MovingAverage movingAverage = new MovingAverage(3); movingAverage.next(1); // 返回 1.0 = 1 / 1 movingAverage.next(10); // 返回 5.5 = (1 + 10) / 2 movingAverage.next(3); // 返回 4.66667 = (1 + 10 + 3) / 3 movingAverage.</description></item><item><title>剑指 Offer II 042 最近请求次数</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/h8086q/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/h8086q/</guid><description>剑指 Offer II 042 最近请求次数 写一个&amp;nbsp;RecentCounter&amp;nbsp;类来计算特定时间范围内最近的请求。
请实现 RecentCounter 类：
RecentCounter() 初始化计数器，请求数为 0 。 int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。 保证 每次对 ping 的调用都使用比之前更大的 t 值。
&amp;nbsp;
示例：
输入： inputs = [&amp;quot;RecentCounter&amp;quot;, &amp;quot;ping&amp;quot;, &amp;quot;ping&amp;quot;, &amp;quot;ping&amp;quot;, &amp;quot;ping&amp;quot;] inputs = [[], [1], [100], [3001], [3002]] 输出： [null, 1, 2, 3, 3] 解释： RecentCounter recentCounter = new RecentCounter(); recentCounter.ping(1); // requests = [1]，范围是 [-2999,1]，返回 1 recentCounter.ping(100); // requests = [1, 100]，范围是 [-2900,100]，返回 2 recentCounter.</description></item><item><title>剑指 Offer II 043 往完全二叉树添加节点</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/naqhdt/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/naqhdt/</guid><description>剑指 Offer II 043 往完全二叉树添加节点 完全二叉树是每一层（除最后一层外）都是完全填充（即，节点数达到最大，第 n 层有 2n-1&amp;nbsp;个节点）的，并且所有的节点都尽可能地集中在左侧。
设计一个用完全二叉树初始化的数据结构&amp;nbsp;CBTInserter，它支持以下几种操作：
CBTInserter(TreeNode root)&amp;nbsp;使用根节点为&amp;nbsp;root&amp;nbsp;的给定树初始化该数据结构； CBTInserter.insert(int v)&amp;nbsp; 向树中插入一个新节点，节点类型为 TreeNode，值为 v 。使树保持完全二叉树的状态，并返回插入的新节点的父节点的值； CBTInserter.get_root() 将返回树的根节点。 &amp;nbsp;
示例 1：
输入：inputs = [&amp;quot;CBTInserter&amp;quot;,&amp;quot;insert&amp;quot;,&amp;quot;get_root&amp;quot;], inputs = [[[1]],[2],[]] 输出：[null,1,[1,2]] 示例 2：
输入：inputs = [&amp;quot;CBTInserter&amp;quot;,&amp;quot;insert&amp;quot;,&amp;quot;insert&amp;quot;,&amp;quot;get_root&amp;quot;], inputs = [[[1,2,3,4,5,6]],[7],[8],[]] 输出：[null,3,4,[1,2,3,4,5,6,7,8]] &amp;nbsp;
提示：
最初给定的树是完全二叉树，且包含&amp;nbsp;1&amp;nbsp;到&amp;nbsp;1000&amp;nbsp;个节点。 每个测试用例最多调用&amp;nbsp;CBTInserter.insert&amp;nbsp; 操作&amp;nbsp;10000&amp;nbsp;次。 给定节点或插入节点的每个值都在&amp;nbsp;0&amp;nbsp;到&amp;nbsp;5000&amp;nbsp;之间。 &amp;nbsp;
注意：本题与主站 919&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/complete-binary-tree-inserter/
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ type CBTInserter struct { } func Constructor(root *TreeNode) CBTInserter { } func (this *CBTInserter) Insert(v int) int { } func (this *CBTInserter) Get_root() *TreeNode { } /** * Your CBTInserter object will be instantiated and called as such: * obj := Constructor(root); * param_1 := obj.</description></item><item><title>剑指 Offer II 048 序列化与反序列化二叉树</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/h54ybf/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/h54ybf/</guid><description>剑指 Offer II 048 序列化与反序列化二叉树 序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。
请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。
&amp;nbsp;
示例 1：
输入：root = [1,2,3,null,null,4,5] 输出：[1,2,3,null,null,4,5] 示例 2：
输入：root = [] 输出：[] 示例 3：
输入：root = [1] 输出：[1] 示例 4：
输入：root = [1,2] 输出：[1,2] &amp;nbsp;
提示：
输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅&amp;nbsp;LeetCode 序列化二叉树的格式。你并非必须采取这种方式，也可以采用其他的方法解决这个问题。 树中结点数在范围 [0, 104] 内 -1000 &amp;lt;= Node.val &amp;lt;= 1000 &amp;nbsp;
注意：本题与主站 297&amp;nbsp;题相同：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/&amp;nbsp;
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ type Codec struct { } func Constructor() Codec { } // Serializes a tree to a single string.</description></item><item><title>剑指 Offer II 055 二叉搜索树迭代器</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/ktoapq/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/ktoapq/</guid><description>剑指 Offer II 055 二叉搜索树迭代器 实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：
BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。 boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。 int next()将指针向右移动，然后返回指针处的数字。 注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。
可以假设&amp;nbsp;next()&amp;nbsp;调用总是有效的，也就是说，当调用 next()&amp;nbsp;时，BST 的中序遍历中至少存在一个下一个数字。
&amp;nbsp;
示例：
输入 inputs = [&amp;quot;BSTIterator&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;hasNext&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;hasNext&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;hasNext&amp;quot;, &amp;quot;next&amp;quot;, &amp;quot;hasNext&amp;quot;] inputs = [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []] 输出 [null, 3, 7, true, 9, true, 15, true, 20, false] 解释 BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]); bSTIterator.</description></item><item><title>剑指 Offer II 058 日程表</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/fi9suh/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/fi9suh/</guid><description>剑指 Offer II 058 日程表 请实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内没有其他安排，则可以存储这个新的日程安排。
MyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数&amp;nbsp;x 的范围为， &amp;nbsp;start &amp;lt;= x &amp;lt; end。
当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生重复预订。
每次调用 MyCalendar.book方法时，如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 true。否则，返回 false&amp;nbsp;并且不要将该日程安排添加到日历中。
请按照以下步骤调用 MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)
&amp;nbsp;
示例:
输入: [&amp;quot;MyCalendar&amp;quot;,&amp;quot;book&amp;quot;,&amp;quot;book&amp;quot;,&amp;quot;book&amp;quot;] [[],[10,20],[15,25],[20,30]] 输出: [null,true,false,true] 解释: MyCalendar myCalendar = new MyCalendar(); MyCalendar.book(10, 20); // returns true MyCalendar.book(15, 25); // returns false ，第二个日程安排不能添加到日历中，因为时间 15 已经被第一个日程安排预定了 MyCalendar.book(20, 30); // returns true ，第三个日程安排可以添加到日历中，因为第一个日程安排并不包含时间 20 &amp;nbsp;</description></item><item><title>剑指 Offer II 059 数据流的第 K 大数值</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/jbjn9c/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/jbjn9c/</guid><description>剑指 Offer II 059 数据流的第 K 大数值 设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。
请实现 KthLargest&amp;nbsp;类：
KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。 int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。 &amp;nbsp;
示例：
输入： [&amp;quot;KthLargest&amp;quot;, &amp;quot;add&amp;quot;, &amp;quot;add&amp;quot;, &amp;quot;add&amp;quot;, &amp;quot;add&amp;quot;, &amp;quot;add&amp;quot;] [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]] 输出： [null, 4, 5, 5, 8, 8] 解释： KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]); kthLargest.add(3); // return 4 kthLargest.</description></item><item><title>面试题 10.10 数字流的秩</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/rank-from-stream-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/rank-from-stream-lcci/</guid><description>面试题 10.10 数字流的秩 假设你正在读取一串整数。每隔一段时间，你希望能找出数字 x 的秩(小于或等于 x 的值的个数)。请实现数据结构和算法来支持这些操作，也就是说：
实现 track(int x)&amp;nbsp;方法，每读入一个数字都会调用该方法；
实现 getRankOfNumber(int x) 方法，返回小于或等于 x 的值的个数。
注意：本题相对原题稍作改动
示例:
输入: [&amp;quot;StreamRank&amp;quot;, &amp;quot;getRankOfNumber&amp;quot;, &amp;quot;track&amp;quot;, &amp;quot;getRankOfNumber&amp;quot;] [[], [1], [0], [0]] 输出: [null,0,null,1] 提示：
x &amp;lt;= 50000 track&amp;nbsp;和&amp;nbsp;getRankOfNumber 方法的调用次数均不超过 2000 次 type StreamRank struct { } func Constructor() StreamRank { } func (this *StreamRank) Track(x int) { } func (this *StreamRank) GetRankOfNumber(x int) int { } /** * Your StreamRank object will be instantiated and called as such: * obj := Constructor(); * obj.</description></item><item><title>剑指 Offer II 062 实现前缀树</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/qc3q1f/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/qc3q1f/</guid><description>剑指 Offer II 062 实现前缀树 Trie（发音类似 &amp;quot;try&amp;quot;）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。
请你实现 Trie 类：
Trie() 初始化前缀树对象。 void insert(String word) 向前缀树中插入字符串 word 。 boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。 boolean startsWith(String prefix) 如果之前已经插入的字符串&amp;nbsp;word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。 &amp;nbsp;
示例：
输入 inputs = [&amp;quot;Trie&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;search&amp;quot;, &amp;quot;search&amp;quot;, &amp;quot;startsWith&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;search&amp;quot;] inputs = [[], [&amp;quot;apple&amp;quot;], [&amp;quot;apple&amp;quot;], [&amp;quot;app&amp;quot;], [&amp;quot;app&amp;quot;], [&amp;quot;app&amp;quot;], [&amp;quot;app&amp;quot;]] 输出 [null, null, true, false, true, null, true] 解释 Trie trie = new Trie(); trie.</description></item><item><title>面试题 16.02 单词频率</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/words-frequency-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/words-frequency-lcci/</guid><description>面试题 16.02 单词频率 设计一个方法，找出任意指定单词在一本书中的出现频率。
你的实现应该支持如下操作：
WordsFrequency(book)构造函数，参数为字符串数组构成的一本书 get(word)查询指定单词在书中出现的频率 示例：
WordsFrequency wordsFrequency = new WordsFrequency({&amp;quot;i&amp;quot;, &amp;quot;have&amp;quot;, &amp;quot;an&amp;quot;, &amp;quot;apple&amp;quot;, &amp;quot;he&amp;quot;, &amp;quot;have&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;pen&amp;quot;}); wordsFrequency.get(&amp;quot;you&amp;quot;); //返回0，&amp;quot;you&amp;quot;没有出现过 wordsFrequency.get(&amp;quot;have&amp;quot;); //返回2，&amp;quot;have&amp;quot;出现2次 wordsFrequency.get(&amp;quot;an&amp;quot;); //返回1 wordsFrequency.get(&amp;quot;apple&amp;quot;); //返回1 wordsFrequency.get(&amp;quot;pen&amp;quot;); //返回1 提示：
book[i]中只包含小写字母 1 &amp;lt;= book.length &amp;lt;= 100000 1 &amp;lt;= book[i].length &amp;lt;= 10 get函数的调用次数不会超过100000 type WordsFrequency struct { } func Constructor(book []string) WordsFrequency { } func (this *WordsFrequency) Get(word string) int { } /** * Your WordsFrequency object will be instantiated and called as such: * obj := Constructor(book); * param_1 := obj.</description></item><item><title>剑指 Offer II 064 神奇的字典</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/us1pgt/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/us1pgt/</guid><description>剑指 Offer II 064 神奇的字典 设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同 。 如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于已构建的神奇字典中。
实现 MagicDictionary 类：
MagicDictionary() 初始化对象 void buildDict(String[]&amp;nbsp;dictionary) 使用字符串数组&amp;nbsp;dictionary 设定该数据结构，dictionary 中的字符串互不相同 bool search(String searchWord) 给定一个字符串 searchWord ，判定能否只将字符串中 一个 字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 true ；否则，返回 false 。 &amp;nbsp;
示例：
输入 inputs = [&amp;quot;MagicDictionary&amp;quot;, &amp;quot;buildDict&amp;quot;, &amp;quot;search&amp;quot;, &amp;quot;search&amp;quot;, &amp;quot;search&amp;quot;, &amp;quot;search&amp;quot;] inputs = [[], [[&amp;quot;hello&amp;quot;, &amp;quot;leetcode&amp;quot;]], [&amp;quot;hello&amp;quot;], [&amp;quot;hhllo&amp;quot;], [&amp;quot;hell&amp;quot;], [&amp;quot;leetcoded&amp;quot;]] 输出 [null, null, false, true, false, false] 解释 MagicDictionary magicDictionary = new MagicDictionary(); magicDictionary.buildDict([&amp;quot;hello&amp;quot;, &amp;quot;leetcode&amp;quot;]); magicDictionary.search(&amp;quot;hello&amp;quot;); // 返回 False magicDictionary.search(&amp;quot;hhllo&amp;quot;); // 将第二个 &amp;#39;h&amp;#39; 替换为 &amp;#39;e&amp;#39; 可以匹配 &amp;quot;hello&amp;quot; ，所以返回 True magicDictionary.</description></item><item><title>剑指 Offer 59 - II 队列的最大值</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/dui-lie-de-zui-da-zhi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/dui-lie-de-zui-da-zhi-lcof/</guid><description>剑指 Offer 59 - II 队列的最大值 请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。
若队列为空，pop_front 和 max_value&amp;nbsp;需要返回 -1
示例 1：
输入: [&amp;quot;MaxQueue&amp;quot;,&amp;quot;push_back&amp;quot;,&amp;quot;push_back&amp;quot;,&amp;quot;max_value&amp;quot;,&amp;quot;pop_front&amp;quot;,&amp;quot;max_value&amp;quot;] [[],[1],[2],[],[],[]] 输出:&amp;nbsp;[null,null,null,2,1,2] 示例 2：
输入: [&amp;quot;MaxQueue&amp;quot;,&amp;quot;pop_front&amp;quot;,&amp;quot;max_value&amp;quot;] [[],[],[]] 输出:&amp;nbsp;[null,-1,-1] &amp;nbsp;
限制：
1 &amp;lt;= push_back,pop_front,max_value的总操作数&amp;nbsp;&amp;lt;= 10000 1 &amp;lt;= value &amp;lt;= 10^5 type MaxQueue struct { } func Constructor() MaxQueue { } func (this *MaxQueue) Max_value() int { } func (this *MaxQueue) Push_back(value int) { } func (this *MaxQueue) Pop_front() int { } /** * Your MaxQueue object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.</description></item><item><title>面试题59 - II 队列的最大值</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/dui-lie-de-zui-da-zhi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/dui-lie-de-zui-da-zhi-lcof/</guid><description>面试题59 - II 队列的最大值 请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。
若队列为空，pop_front 和 max_value&amp;nbsp;需要返回 -1
示例 1：
输入: [&amp;quot;MaxQueue&amp;quot;,&amp;quot;push_back&amp;quot;,&amp;quot;push_back&amp;quot;,&amp;quot;max_value&amp;quot;,&amp;quot;pop_front&amp;quot;,&amp;quot;max_value&amp;quot;] [[],[1],[2],[],[],[]] 输出:&amp;nbsp;[null,null,null,2,1,2] 示例 2：
输入: [&amp;quot;MaxQueue&amp;quot;,&amp;quot;pop_front&amp;quot;,&amp;quot;max_value&amp;quot;] [[],[],[]] 输出:&amp;nbsp;[null,-1,-1] &amp;nbsp;
限制：
1 &amp;lt;= push_back,pop_front,max_value的总操作数&amp;nbsp;&amp;lt;= 10000 1 &amp;lt;= value &amp;lt;= 10^5 type MaxQueue struct { } func Constructor() MaxQueue { } func (this *MaxQueue) Max_value() int { } func (this *MaxQueue) Push_back(value int) { } func (this *MaxQueue) Pop_front() int { } /** * Your MaxQueue object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.</description></item><item><title>剑指 Offer II 066 单词之和</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/z1r5dt/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/z1r5dt/</guid><description>剑指 Offer II 066 单词之和 实现一个 MapSum 类，支持两个方法，insert&amp;nbsp;和&amp;nbsp;sum：
MapSum() 初始化 MapSum 对象 void insert(String key, int val) 插入 key-val 键值对，字符串表示键 key ，整数表示值 val 。如果键 key 已经存在，那么原来的键值对将被替代成新的键值对。 int sum(string prefix) 返回所有以该前缀 prefix 开头的键 key 的值的总和。 &amp;nbsp;
示例：
输入： inputs = [&amp;quot;MapSum&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;sum&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;sum&amp;quot;] inputs = [[], [&amp;quot;apple&amp;quot;, 3], [&amp;quot;ap&amp;quot;], [&amp;quot;app&amp;quot;, 2], [&amp;quot;ap&amp;quot;]] 输出： [null, null, 3, null, 5] 解释： MapSum mapSum = new MapSum(); mapSum.insert(&amp;quot;apple&amp;quot;, 3); mapSum.sum(&amp;quot;ap&amp;quot;); // return 3 (apple = 3) mapSum.insert(&amp;quot;app&amp;quot;, 2); mapSum.</description></item><item><title>面试题 16.09 运算</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/operations-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/operations-lcci/</guid><description>面试题 16.09 运算 请实现整数数字的乘法、减法和除法运算，运算结果均为整数数字，程序中只允许使用加法运算符和逻辑运算符，允许程序中出现正负常数，不允许使用位运算。
你的实现应该支持如下操作：
Operations() 构造函数 minus(a, b) 减法，返回a - b multiply(a, b) 乘法，返回a * b divide(a, b) 除法，返回a / b 示例：
Operations operations = new Operations(); operations.minus(1, 2); //返回-1 operations.multiply(3, 4); //返回12 operations.divide(5, -2); //返回-2 提示：
你可以假设函数输入一定是有效的，例如不会出现除法分母为0的情况 单个用例的函数调用次数不会超过1000次 type Operations struct { } func Constructor() Operations { } func (this *Operations) Minus(a int, b int) int { } func (this *Operations) Multiply(a int, b int) int { } func (this *Operations) Divide(a int, b int) int { } /** * Your Operations object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.</description></item><item><title>面试题 16.25 LRU 缓存</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/lru-cache-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/lru-cache-lcci/</guid><description>面试题 16.25 LRU 缓存 设计和构建一个&amp;ldquo;最近最少使用&amp;rdquo;缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。
它应该支持以下操作： 获取数据 get 和 写入数据 put 。
获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。
写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。
示例:
LRUCache cache = new LRUCache( 2 /* 缓存容量 */ ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // 返回 1 cache.put(3, 3); // 该操作会使得密钥 2 作废 cache.get(2); // 返回 -1 (未找到) cache.put(4, 4); // 该操作会使得密钥 1 作废 cache.get(1); // 返回 -1 (未找到) cache.get(3); // 返回 3 cache.get(4); // 返回 4 type LRUCache struct { } func Constructor(capacity int) LRUCache { } func (this *LRUCache) Get(key int) int { } func (this *LRUCache) Put(key int, value int) { } /** * Your LRUCache object will be instantiated and called as such: * obj := Constructor(capacity); * param_1 := obj.</description></item><item><title>面试题 17.20 连续中值</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/continuous-median-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/continuous-median-lcci/</guid><description>面试题 17.20 连续中值 随机产生数字并传递给一个方法。你能否完成这个方法，在每次产生新值时，寻找当前所有值的中间值（中位数）并保存。
中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。
例如，
[2,3,4]&amp;nbsp;的中位数是 3
[2,3] 的中位数是 (2 + 3) / 2 = 2.5
设计一个支持以下两种操作的数据结构：
void addNum(int num) - 从数据流中添加一个整数到数据结构中。 double findMedian() - 返回目前所有元素的中位数。 示例：
addNum(1) addNum(2) findMedian() -&amp;gt; 1.5 addNum(3) findMedian() -&amp;gt; 2 type MedianFinder struct { } /** initialize your data structure here. */ func Constructor() MedianFinder { } func (this *MedianFinder) AddNum(num int) { } func (this *MedianFinder) FindMedian() float64 { } /** * Your MedianFinder object will be instantiated and called as such: * obj := Constructor(); * obj.</description></item><item><title>【2023-01-18每日一题】1825. 求出 MK 平均值[Hard]</title><link>/study/leetcode/finding-mk-average/</link><pubDate>Wed, 18 Jan 2023 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/finding-mk-average/</guid><description>2023-01-18每日一题：1825. 求出 MK 平均值 难度：Hard
标签：设计 、 队列 、 数据流 、 有序集合 、 堆（优先队列）
给你两个整数&amp;nbsp;m&amp;nbsp;和&amp;nbsp;k&amp;nbsp;，以及数据流形式的若干整数。你需要实现一个数据结构，计算这个数据流的 MK 平均值&amp;nbsp;。
MK 平均值&amp;nbsp;按照如下步骤计算：
如果数据流中的整数少于 m&amp;nbsp;个，MK 平均值&amp;nbsp;为 -1&amp;nbsp;，否则将数据流中最后 m&amp;nbsp;个元素拷贝到一个独立的容器中。 从这个容器中删除最小的 k&amp;nbsp;个数和最大的 k&amp;nbsp;个数。 计算剩余元素的平均值，并 向下取整到最近的整数&amp;nbsp;。 请你实现&amp;nbsp;MKAverage&amp;nbsp;类：
MKAverage(int m, int k)&amp;nbsp;用一个空的数据流和两个整数 m&amp;nbsp;和 k&amp;nbsp;初始化&amp;nbsp;MKAverage&amp;nbsp;对象。 void addElement(int num)&amp;nbsp;往数据流中插入一个新的元素&amp;nbsp;num&amp;nbsp;。 int calculateMKAverage()&amp;nbsp;对当前的数据流计算并返回 MK 平均数&amp;nbsp;，结果需 向下取整到最近的整数 。 &amp;nbsp;
示例 1：
输入： ["MKAverage", "addElement", "addElement", "calculateMKAverage", "addElement", "calculateMKAverage", "addElement", "addElement", "addElement", "calculateMKAverage"] [[3, 1], [3], [1], [], [10], [], [5], [5], [5], []] 输出： [null, null, null, -1, null, 3, null, null, null, 5] 解释： MKAverage obj = new MKAverage(3, 1); obj.</description></item><item><title>【2022-12-30每日一题】855. 考场就座[Medium]</title><link>/study/leetcode/exam-room/</link><pubDate>Fri, 30 Dec 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/exam-room/</guid><description>2022-12-30每日一题：855. 考场就座 难度：Medium
标签：设计 、 有序集合 、 堆（优先队列）
在考场里，一排有&amp;nbsp;N&amp;nbsp;个座位，分别编号为&amp;nbsp;0, 1, 2, ..., N-1&amp;nbsp;。
当学生进入考场后，他必须坐在能够使他与离他最近的人之间的距离达到最大化的座位上。如果有多个这样的座位，他会坐在编号最小的座位上。(另外，如果考场里没有人，那么学生就坐在 0 号座位上。)
返回&amp;nbsp;ExamRoom(int N)&amp;nbsp;类，它有两个公开的函数：其中，函数&amp;nbsp;ExamRoom.seat()&amp;nbsp;会返回一个&amp;nbsp;int&amp;nbsp;（整型数据），代表学生坐的位置；函数&amp;nbsp;ExamRoom.leave(int p)&amp;nbsp;代表坐在座位 p 上的学生现在离开了考场。每次调用&amp;nbsp;ExamRoom.leave(p)&amp;nbsp;时都保证有学生坐在座位&amp;nbsp;p&amp;nbsp;上。
&amp;nbsp;
示例：
输入：[&amp;quot;ExamRoom&amp;quot;,&amp;quot;seat&amp;quot;,&amp;quot;seat&amp;quot;,&amp;quot;seat&amp;quot;,&amp;quot;seat&amp;quot;,&amp;quot;leave&amp;quot;,&amp;quot;seat&amp;quot;], [[10],[],[],[],[],[4],[]] 输出：[null,0,9,4,2,null,5] 解释： ExamRoom(10) -&amp;gt; null seat() -&amp;gt; 0，没有人在考场里，那么学生坐在 0 号座位上。 seat() -&amp;gt; 9，学生最后坐在 9 号座位上。 seat() -&amp;gt; 4，学生最后坐在 4 号座位上。 seat() -&amp;gt; 2，学生最后坐在 2 号座位上。 leave(4) -&amp;gt; null seat() -&amp;gt; 5，学生最后坐在 5 号座位上。 &amp;nbsp;
提示：
1 &amp;lt;= N &amp;lt;= 10^9 在所有的测试样例中&amp;nbsp;ExamRoom.seat()&amp;nbsp;和&amp;nbsp;ExamRoom.leave()&amp;nbsp;最多被调用&amp;nbsp;10^4&amp;nbsp;次。 保证在调用&amp;nbsp;ExamRoom.leave(p)&amp;nbsp;时有学生正坐在座位 p 上。 方法一： 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
type ExamRoom struct { } func Constructor(n int) ExamRoom { } func (this *ExamRoom) Seat() int { } func (this *ExamRoom) Leave(p int) { } /** * Your ExamRoom object will be instantiated and called as such: * obj := Constructor(n); * param_1 := obj.</description></item><item><title>【2022-11-30每日一题】895. 最大频率栈[Hard]</title><link>/study/leetcode/maximum-frequency-stack/</link><pubDate>Wed, 30 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/maximum-frequency-stack/</guid><description>2022-11-30每日一题：895. 最大频率栈 难度：Hard
标签：栈 、 设计 、 哈希表 、 有序集合
设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出出现频率最高的元素。
实现 FreqStack&amp;nbsp;类:
FreqStack()&amp;nbsp;构造一个空的堆栈。 void push(int val)&amp;nbsp;将一个整数&amp;nbsp;val&amp;nbsp;压入栈顶。 int pop()&amp;nbsp;删除并返回堆栈中出现频率最高的元素。 如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。 &amp;nbsp;
示例 1：
输入： ["FreqStack","push","push","push","push","push","push","pop","pop","pop","pop"], [[],[5],[7],[5],[7],[4],[5],[],[],[],[]] 输出：[null,null,null,null,null,null,null,5,7,5,4] 解释： FreqStack = new FreqStack(); freqStack.push (5);//堆栈为 [5] freqStack.push (7);//堆栈是 [5,7] freqStack.push (5);//堆栈是 [5,7,5] freqStack.push (7);//堆栈是 [5,7,5,7] freqStack.push (4);//堆栈是 [5,7,5,7,4] freqStack.push (5);//堆栈是 [5,7,5,7,4,5] freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,5,7,4]。 freqStack.pop ();//返回 7 ，因为 5 和 7 出现频率最高，但7最接近顶部。堆栈变成 [5,7,5,4]。 freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,4]。 freqStack.pop ();//返回 4 ，因为 4, 5 和 7 出现频率最高，但 4 是最接近顶部的。堆栈变成 [5,7]。 &amp;nbsp;</description></item><item><title>【2022-10-21每日一题】901. 股票价格跨度[Medium]</title><link>/study/leetcode/online-stock-span/</link><pubDate>Fri, 21 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/online-stock-span/</guid><description>2022-10-21每日一题：901. 股票价格跨度 难度：Medium
标签：栈 、 设计 、 数据流 、 单调栈
编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。
今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。
例如，如果未来7天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。
&amp;nbsp;
示例：
输入：[&amp;quot;StockSpanner&amp;quot;,&amp;quot;next&amp;quot;,&amp;quot;next&amp;quot;,&amp;quot;next&amp;quot;,&amp;quot;next&amp;quot;,&amp;quot;next&amp;quot;,&amp;quot;next&amp;quot;,&amp;quot;next&amp;quot;], [[],[100],[80],[60],[70],[60],[75],[85]] 输出：[null,1,1,1,2,1,4,6] 解释： 首先，初始化 S = StockSpanner()，然后： S.next(100) 被调用并返回 1， S.next(80) 被调用并返回 1， S.next(60) 被调用并返回 1， S.next(70) 被调用并返回 2， S.next(60) 被调用并返回 1， S.next(75) 被调用并返回 4， S.next(85) 被调用并返回 6。 注意 (例如) S.next(75) 返回 4，因为截至今天的最后 4 个价格 (包括今天的价格 75) 小于或等于今天的价格。 &amp;nbsp;
提示：
调用&amp;nbsp;StockSpanner.next(int price)&amp;nbsp;时，将有&amp;nbsp;1 &amp;lt;= price &amp;lt;= 10^5。 每个测试用例最多可以调用&amp;nbsp; 10000 次 StockSpanner.</description></item><item><title>【2022-09-23每日一题】707. 设计链表[Medium]</title><link>/study/leetcode/design-linked-list/</link><pubDate>Fri, 23 Sep 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/design-linked-list/</guid><description>2022-09-23每日一题：707. 设计链表 难度：Medium
标签：设计 、 链表
设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val&amp;nbsp;和&amp;nbsp;next。val&amp;nbsp;是当前节点的值，next&amp;nbsp;是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性&amp;nbsp;prev&amp;nbsp;以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。
在链表类中实现这些功能：
get(index)：获取链表中第&amp;nbsp;index&amp;nbsp;个节点的值。如果索引无效，则返回-1。 addAtHead(val)：在链表的第一个元素之前添加一个值为&amp;nbsp;val&amp;nbsp;的节点。插入后，新节点将成为链表的第一个节点。 addAtTail(val)：将值为&amp;nbsp;val 的节点追加到链表的最后一个元素。 addAtIndex(index,val)：在链表中的第&amp;nbsp;index&amp;nbsp;个节点之前添加值为&amp;nbsp;val&amp;nbsp; 的节点。如果&amp;nbsp;index&amp;nbsp;等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。 deleteAtIndex(index)：如果索引&amp;nbsp;index 有效，则删除链表中的第&amp;nbsp;index 个节点。 &amp;nbsp;
示例：
MyLinkedList linkedList = new MyLinkedList(); linkedList.addAtHead(1); linkedList.addAtTail(3); linkedList.addAtIndex(1,2); //链表变为1-&amp;gt; 2-&amp;gt; 3 linkedList.get(1); //返回2 linkedList.deleteAtIndex(1); //现在链表是1-&amp;gt; 3 linkedList.get(1); //返回3 &amp;nbsp;
提示：
所有val值都在&amp;nbsp;[1, 1000]&amp;nbsp;之内。 操作次数将在&amp;nbsp;&amp;nbsp;[1, 1000]&amp;nbsp;之内。 请不要使用内置的 LinkedList 库。 方法一：单向链表 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读
type MyLinkedList struct { head *ListNode count int } func Constructor() MyLinkedList { return MyLinkedList{&amp;amp;ListNode{}, 0} } func (this *MyLinkedList) Get(index int) int { // 获取链表中第 index 个节点的值。如果索引无效，则返回-1。 if index &amp;lt; 0 || index &amp;gt;= this.</description></item><item><title>【2022-08-16每日一题】1656. 设计有序流</title><link>/study/leetcode/design-an-ordered-stream/</link><pubDate>Tue, 16 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/design-an-ordered-stream/</guid><description>2022-08-16每日一题：1656. 设计有序流 难度：Easy 标签：设计 、 数组 、 哈希表 、 数据流 有 n 个 (id, value) 对，其中 id 是 1 到 n 之间的一个整数，value 是一个字符串。不存在 id 相同的两个 (id, value) 对。
设计一个流，以 任意 顺序获取 n 个 (id, value) 对，并在多次调用时 按 id 递增的顺序 返回一些值。
实现 OrderedStream 类：
OrderedStream(int n) 构造一个能接收 n 个值的流，并将当前指针 ptr 设为 1 。 String[] insert(int id, String value) 向流中存储新的 (id, value) 对。存储后： 如果流存储有 id = ptr 的 (id, value) 对，则找出从 id = ptr 开始的 最长 id 连续递增序列 ，并 按顺序 返回与这些 id 关联的值的列表。然后，将 ptr 更新为最后那个 id + 1 。 否则，返回一个空列表。</description></item><item><title>【2022-08-15每日一题】641. 设计循环双端队列</title><link>/study/leetcode/design-circular-deque/</link><pubDate>Mon, 15 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/design-circular-deque/</guid><description>2022-08-15每日一题：641. 设计循环双端队列 难度：Medium 标签：设计 、 队列 、 数组 、 链表 设计实现双端队列。
实现 MyCircularDeque 类:
MyCircularDeque(int k)&amp;nbsp;：构造函数,双端队列最大为 k 。 boolean insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true&amp;nbsp;，否则返回 false 。 boolean insertLast()&amp;nbsp;：将一个元素添加到双端队列尾部。如果操作成功返回 true&amp;nbsp;，否则返回 false 。 boolean deleteFront()&amp;nbsp;：从双端队列头部删除一个元素。 如果操作成功返回 true&amp;nbsp;，否则返回 false 。 boolean deleteLast()&amp;nbsp;：从双端队列尾部删除一个元素。如果操作成功返回 true&amp;nbsp;，否则返回 false 。 int getFront()&amp;nbsp;)：从双端队列头部获得一个元素。如果双端队列为空，返回 -1&amp;nbsp;。 int getRear()&amp;nbsp;：获得双端队列的最后一个元素。&amp;nbsp;如果双端队列为空，返回 -1 。 boolean isEmpty()&amp;nbsp;：若双端队列为空，则返回&amp;nbsp;true&amp;nbsp;，否则返回 false &amp;nbsp;。 boolean isFull()&amp;nbsp;：若双端队列满了，则返回&amp;nbsp;true&amp;nbsp;，否则返回 false 。 &amp;nbsp;
示例 1：
输入 ["MyCircularDeque", "insertLast", "insertLast", "insertFront", "insertFront", "getRear", "isFull", "deleteLast", "insertFront", "getFront"] [[3], [1], [2], [3], [4], [], [], [], [4], []] 输出 [null, true, true, true, false, 2, true, true, true, 4] 解释 MyCircularDeque circularDeque = new MycircularDeque(3); // 设置容量大小为3 circularDeque.</description></item><item><title>2022-08-01每日一题：622 设计循环队列</title><link>/study/leetcode/design-circular-queue/</link><pubDate>Tue, 02 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/design-circular-queue/</guid><description>622 设计循环队列 设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为&amp;ldquo;环形缓冲器&amp;rdquo;。
循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。
你的实现应该支持如下操作：
MyCircularQueue(k): 构造器，设置队列长度为 k 。 Front: 从队首获取元素。如果队列为空，返回 -1 。 Rear: 获取队尾元素。如果队列为空，返回 -1 。 enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。 deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。 isEmpty(): 检查循环队列是否为空。 isFull(): 检查循环队列是否已满。 &amp;nbsp;
示例：
MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3 circularQueue.enQueue(1); &amp;nbsp;// 返回 true circularQueue.enQueue(2); &amp;nbsp;// 返回 true circularQueue.enQueue(3); &amp;nbsp;// 返回 true circularQueue.enQueue(4); &amp;nbsp;// 返回 false，队列已满 circularQueue.Rear(); &amp;nbsp;// 返回 3 circularQueue.isFull(); &amp;nbsp;// 返回 true circularQueue.deQueue(); &amp;nbsp;// 返回 true circularQueue.enQueue(4); &amp;nbsp;// 返回 true circularQueue.Rear(); &amp;nbsp;// 返回 4 &amp;nbsp;
提示：</description></item></channel></rss>