<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>leetcode on lbbniu</title><link>/tags/leetcode/</link><description>Recent content in leetcode on lbbniu</description><generator>Hugo -- gohugo.io</generator><language>zh</language><managingEditor>lbbniu@gmail.com (lbbniu)</managingEditor><webMaster>lbbniu@gmail.com (lbbniu)</webMaster><copyright>&amp;copy; 2021 &lt;a href="https://blog.lbbniu.com/">lbbniu&lt;/a></copyright><lastBuildDate>Tue, 06 Feb 2024 23:43:47 +0800</lastBuildDate><atom:link href="/tags/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>预习</title><link>/study/algorithm/go/week00/</link><pubDate>Tue, 30 Nov 2021 13:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/go/week00/</guid><description>第1课 | 数据结构与算法总览 参考链接 算法训练营第 4 期学员谭帅的作业 （提取码：ykyn） 课后作业 绘制自己的数据结构和算法脑图 用脑图的方式把知识的脉络串联起来，不管对于学习新知识还是巩固已有知识，都是一种很好的学习方式。同学们可以将目前自己所掌握的数据结构和算法知识绘制成脑图，在绘制过程中可以查阅资料，补充目前掌握欠缺的部分，找到自己薄弱的地方。后面再通过课程的学习和刻意练习，动态地将自己绘制的脑图逐步补充、完善，从而达到真正的融会贯通。
脑图绘制工具不限，同学们需要按时将作业提交到班级 GitHub 中。
第2课 | 训练准备和复杂度分析 1. 训练环境设置、编码技巧和Code Style 参考链接 Windows Microsoft New Terminal VS Code Themes 教你打造一款颜值逆天的 VS Code 炫酷的 VS Code 毛玻璃效果 自顶向下的编程方式 自顶向下编程的 LeetCode 例题 2. 时间复杂度和空间复杂度分析 参考链接 如何理解算法时间复杂度的表示法 Master theorem 主定理 下周预习 预习知识点 数组：为什么很多编程语言中数组都从 0 开始编号？ 链表：如何实现 LRU 缓存淘汰算法? 链表：如何轻松写出正确的链表代码？ 跳表：为什么 Redis 一定要用跳表来实现有序集合？ 预习题目 移动零 盛最多水的容器 爬楼梯 三数之和 环形链表</description></item><item><title>第1周</title><link>/study/algorithm/php/01%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%80%E5%91%A8/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/php/01%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%80%E5%91%A8/</guid><description>第一周 第三课|数组、链表、跳表 参考链接 Java 源码分析（ArrayList） Linked List 的标准实现代码 [Linked List 示例代码](http://www.cs.cmu.edu/~adamchik/15-121/lectures/Linked Lists/code/LinkedList.java) Java 源码分析（LinkedList） LRU Cache - Linked list： LRU 缓存机制 Redis - Skip List：跳跃表 、为啥 Redis 使用跳表（Skip List）而不是使用 Red-Black？ Array 实战题目 11. 盛最多水的容器 //方法一： 暴力求解 双循环 class Solution { /** * @param Integer[] $height * @return Integer */ function maxArea($height) { $max = 0; $len = count($height); for ($i = 0; $i &amp;lt; $len - 1; $i++) { for ($j = $i + 1; $j &amp;lt; $len; $j++) { $area = ($j - $i) * min($height[$i], $height[$j]); $max = $area &amp;lt; $max ?</description></item><item><title>第1周 数组、链表、跳表</title><link>/study/algorithm/go/week01/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/go/week01/</guid><description>题目数量：16
第三课|数组、链表、跳表 1. 数组、链表、跳表的基本实现和特性 参考链接 Java 源码分析（ArrayList） Linked List 的标准实现代码 [Linked List 示例代码](http://www.cs.cmu.edu/~adamchik/15-121/lectures/Linked Lists/code/LinkedList.java)
Java 源码分析（LinkedList） LRU Cache - Linked list： LRU 缓存机制 Redis - Skip List：跳跃表 、为啥 Redis 使用跳表（Skip List）而不是使用 Red-Black？ 2. 实战题目解析：移动零 3. 实战题目解析：盛水最多的容器、爬楼梯 Array 实战题目 11. 盛最多水的容器 // 双指针 283. 移动零 // 双指针 70. 爬楼梯 15. 三数之和 (高频老题） // 排序 + 双指针 4. 实战题目解析：3数之和、环形链表 两数之和题目： https://leetcode-cn.com/problems/two-sum/ Linked List 实战题目 206. 反转链表 使用递归函数，一直递归到链表的最后一个结点，该结点就是反转后的头结点，记作 ret .
此后，每次函数在返回的过程中，让当前结点的下一个结点的 next 指针指向当前节点。
同时让当前结点的 next 指针指向 NULL ，从而实现从链表尾部开始的局部反转</description></item><item><title>第2周</title><link>/study/algorithm/php/02%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%BA%8C%E5%91%A8/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/php/02%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%BA%8C%E5%91%A8/</guid><description>第2周 第4课 | 栈、队列、优先队列、双端队列 参考链接 Java 的 PriorityQueue 文档 Java 的 Stack 源码 Java 的 Queue 源码 Python 的 heapq 高性能的 container 库 预习题目 20. 有效的括号 class Solution { /** * 方法一：栈(spl标准库) * @param String $s * @return Boolean */ function isValid($s) { //构造哈希表 $map = [')'=&amp;gt;'(', ']'=&amp;gt;'[', '}'=&amp;gt;'{']; $stack = new SplStack(); for ($i = 0, $len = strlen($s); $i &amp;lt; $len; $i++) { if (!isset($map[$s[$i]])) { $stack-&amp;gt;push($s[$i]); } else if (!$stack-&amp;gt;count() || $stack-&amp;gt;pop() !</description></item><item><title>第2周 栈、队列、哈希表</title><link>/study/algorithm/go/week02/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/go/week02/</guid><description>题目数量：9+
第4课 | 栈、队列、优先队列、双端队列 1. 栈和队列的实现与特性 参考链接 Java 的 PriorityQueue 文档 Java 的 Stack 源码 Java 的 Queue 源码 Python 的 heapq 高性能的 container 库 2. 实战题目解析：有效的括号、最小栈等问题 预习题目 20. 有效的括号 // 方法一：用map，最优写法 func isValid(s string) bool { n := len(s) if n % 2 != 0 { return false } mp := map[byte]byte{ ')': '(', ']': '[', '}': '{', } stack := []byte{} for i := range s { //课替换 for i := 0; i &amp;lt; n; i++ { if mp[s[i]] &amp;gt; 0 { if len(stack) == 0 || stack[len(stack) - 1] !</description></item><item><title>第3周</title><link>/study/algorithm/php/03%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%89%E5%91%A8/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/php/03%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%89%E5%91%A8/</guid><description>第3周 第6课 | 树、二叉树、二叉搜索树 1. 树、二叉树、二叉搜索树的实现和特性 参考链接 二叉搜索树 Demo 思考题 树的面试题解法一般都是递归，为什么？ 说明：同学们可以将自己的思考写在课程下方的留言区一起讨论，也可以写在第 2 周的学习总结中。
2. 实战题目解析：二叉树的中序遍历 参考链接 树的遍历 Demo 实战题目 / 课后作业 94. 二叉树的中序遍历 /** * Definition for a binary tree node. * class TreeNode { * public $val = null; * public $left = null; * public $right = null; * function __construct($value) { $this-&amp;gt;val = $value; } * } */ class Solution { private $values = []; /** * 方法一：递归 * @param TreeNode $root * @return Integer[] */ function inorderTraversal1($root) { $this-&amp;gt;inorder($root); return $this-&amp;gt;values; } function inorder($root) { if ($root) { $this-&amp;gt;inorder($root-&amp;gt;left); $this-&amp;gt;values[] = $root-&amp;gt;val; $this-&amp;gt;inorder($root-&amp;gt;right); } } /** * 方法二：迭代 * @param TreeNode $root * @return Integer[] */ function inorderTraversal2($root) { $stack = $res = []; while ($root || $stack) { while ($root) { $stack[] = $root; $root = $root-&amp;gt;left; } $root = array_pop($stack); $res[] = $root-&amp;gt;val; $root = $root-&amp;gt;right; } return $res; } /** * 方法三：颜色标记法 * @param TreeNode $root * @return Integer[] */ function inorderTraversal3($root) { $white = 0; $gray = 1; $stack = [[$white, $root]]; $res = []; while ($stack) { [$color, $node ] = array_pop($stack); if (!</description></item><item><title>第4周</title><link>/study/algorithm/php/04%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%9B%9B%E5%91%A8/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/php/04%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%9B%9B%E5%91%A8/</guid><description>第4周 第9课 | 深度优先搜索和广度优先搜索 1. 深度优先搜索、广度优先搜索的实现和特性 参考链接 DFS 代码模板（递归写法、非递归写法） 递归写法
visited = set() def dfs(node, visited): if node in visited: # terminator # already visited return visited.add(node) # process current node here. ... for next_node in node.children(): if next_node not in visited: dfs(next_node, visited) 非递归写法
def DFS(self, tree): if tree.root is None: return [] visited, stack = [], [tree.root] while stack: node = stack.pop() visited.add(node) process (node) nodes = generate_related_nodes(node) stack.push(nodes) # other processing work .</description></item><item><title>第6周</title><link>/study/algorithm/php/06%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%85%AD%E5%91%A8/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/php/06%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%85%AD%E5%91%A8/</guid><description>第12课 | 动态规划 1. 动态规划的实现及关键点 参考链接 递归代码模板 # Python 代码模板 def recursion(level, param1, param2, ...): # recursion terminator if level &amp;gt; MAX_LEVEL: process_result return # process logic in current level process(level, data...) # drill down self.recursion(level + 1, p1, ...) # reverse the current level status if needed //Java 代码模板 public void recur(int level, int param) { // terminator if (level &amp;gt; MAX_LEVEL) { // process result return; // process current logic process(level, param); // drill down recur( level: level + 1, newParam); // restore current status } 分治代码模板 def divide_conquer(problem, param1, param2, .</description></item><item><title>第6周 动态规划</title><link>/study/algorithm/go/week06/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/go/week06/</guid><description>题目数量：25+
第12课 动态规划 1.动态规划的实现与关键点 参考连接 递归代码模板 # go 代码模板 func recursion(level int, param1, param2, ...) { # recursion terminator if level &amp;gt; MAX_LEVEL { process_result return } # process logic in current level process(level, data...) # drill down recursion(level + 1, p1, ...) # reverse the current level status if needed } 分治代码模板 func divide_conquer(problem, param1, param2, ...) { # recursion terminator if problem == nil { print_result return } # prepare data data = prepare_data(problem) subproblems = split_problem(problem, data) # conquer subproblems subresult1 = divide_conquer(subproblems[0], p1, .</description></item><item><title>第7周</title><link>/study/algorithm/php/07%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%83%E5%91%A8/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/php/07%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B8%83%E5%91%A8/</guid><description>第7周 第13课 | 字典树和并查集 1. Trie树的基本实现和特性 参考链接 102. 二叉树的层序遍历 /** * Definition for a binary tree node. * class TreeNode { * public $val = null; * public $left = null; * public $right = null; * function __construct($value) { $this-&amp;gt;val = $value; } * } */ class Solution { /** * bfs * @param TreeNode $root * @return Integer[][] */ function levelOrder($root) { if (!$root) return []; $queue = [$root]; $res = []; while ($queue) { $count = count($queue); $row = []; while ($count--) { $node = array_shift($queue); $row[] = $node-&amp;gt;val; $node-&amp;gt;left &amp;amp;&amp;amp; $queue[] = $node-&amp;gt;left; $node-&amp;gt;right &amp;amp;&amp;amp; $queue[] = $node-&amp;gt;right; } $res[] = $row; } return $res; } // function levelOrder($root) { if (!</description></item><item><title>第8周</title><link>/study/algorithm/php/08%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%85%AB%E5%91%A8/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/php/08%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E5%85%AB%E5%91%A8/</guid><description>第8周 第16课 | 位运算 1. 位运算基础及实战要点 参考链接 如何从十进制转换为二进制 2. 位运算实战题目解析 参考链接 N 皇后位运算代码示例 def totalNQueens(self, n): if n &amp;lt; 1: return [] self.count = 0 self.DFS(n, 0, 0, 0, 0) return self.count def DFS(self, n, row, cols, pie, na): # recursion terminator if row &amp;gt;= n: self.count += 1 return bits = (~(cols | pie | na)) &amp;amp; ((1 &amp;lt;&amp;lt; n) — 1) # 得到当前所有的空位 while bits: p = bits &amp;amp; —bits # 取到最低位的1 bits = bits &amp;amp; (bits — 1) # 表示在p位置上放入皇后 self.</description></item><item><title>第9周</title><link>/study/algorithm/php/09%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B9%9D%E5%91%A8/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/php/09%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B9%9D%E5%91%A8/</guid><description>第9周 第19课 | 高级动态规划 1. 动态规划、状态转移方程串讲 参考链接 70.爬楼梯 class Solution { /** * 动态规划解法 * Binets 方法 和 斐波那契公式 时间复杂度为O(log(N)) * @param Integer $n * @return Integer */ function climbStairs($n) { if ($n &amp;lt;= 2) return $n; $first = 1; $second = 2; for ($i = 3; $i &amp;lt;= $n; $i++) { $tmp = $first + $second; $first = $second; $second = $tmp; } return $second; } } //斐波那契公式 public class Solution { public int climbStairs(int n) { double sqrt5=Math.</description></item><item><title>第9周 高级动态规划、字符串算法</title><link>/study/algorithm/go/week09/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/go/week09/</guid><description>题目数量：35+
第19课 | 高级动态规划 1. 动态规划、状态转移方程串讲 参考链接 70.爬楼梯 func climbStairs(n int) int { p, q := 1, 1 for i := 2; i &amp;lt;= n; i++ { p, q = q, p + q } return q } 62.不同路径 // 方法一： 标准二维dp func uniquePaths(m int, n int) int { dp := make([][]int, m) for i := range dp { dp[i] = make([]int, n) dp[i][0] = 1 } for i := 0; i &amp;lt; n; i++ { dp[0][i] = 1 } for i := 1; i &amp;lt; m; i++ { for j := 1; j &amp;lt; n; j++ { dp[i][j] = dp[i-1][j] + dp[i][j-1] } } return dp[m-1][n-1] } // 方法二：高级一维dp func uniquePaths(m int, n int) int { dp := make([]int, n) for i := range dp { dp[i] = 1 } for i := 1; i &amp;lt; m; i++ { for j := 1; j &amp;lt; n; j++ { dp[j] += dp[j-1] } } return dp[n-1] } 63.</description></item><item><title>第10周 期末串讲、期末考试、毕业刷题路线</title><link>/study/algorithm/go/week10/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/algorithm/go/week10/</guid><description>题目数量：77+
期末串讲 参考连接 Big O Cheat Sheet 算法训练营第 4 期学员谭帅的脑图作业 （提取码：ykyn）
Steve Jobs 演讲 期末考试 👉考试形式：考试平台为 LeetCode。 共 10 道单选题（每题 3 分）、2 道多选题（每题 5 分）、2 道编程题（每题 20 分）和 4 道附加选择题（每题 5 分），考试时长 3 小时。3 小时内可多次修改和提交，最终全部完成后点击“结束考试”即可。
注意：为保证评测体验，需要使用 Chrome 浏览器 注意：考试前不要尝试进入系统，进入系统即开始计时，3 小时为不间断计时，关闭网页不会暂停，仍在继续计时 注意：每道选择题务必点击提交再进行下一题
👉考试系统须知： https://shimo.im/docs/786914580242497f 👉登陆账号密码：均为你极客时间登陆时的手机帐号，如无法登陆，请联系班主任确认。
👉考试日期：截止至 2020 年 5 月 24 日 23:59
👉考试链接： https://e.leetcode-cn.com/assessment/geekbang-0019 本周是大家学习的最后一周，训练营学习服务团队希望能得到大家的建议和反馈，动动你的小手，填一下问卷吧！👉 https://jinshuju.net/f/ER0LhF 另外，如果你想换工作，不知道怎么写简历，可以看下这篇文章。
毕业刷题路线 首先，恭喜各位同学从极客大学算法训练营毕业，相信 70 天的刻意练习给你带来了不少改变。但是毕业后的练习还不能停止，除了课上老师讲授的题目和布置的作业，这里还有一份“左耳朵耗子”陈皓老师和超哥分享的毕业刷题路线，助你在训练营结束后持续练习。
基础 两数之和 （简单） 有效的括号 （简单） 字符串解码 （中等） LRU 缓存机制 （困难） 实现 Trie（前缀树） （中等） 添加与搜索单词 - 数据结构设计 （中等） 单词搜索 II （困难） 找不同 （简单） 单词规律 （简单） 字符串中的第一个唯一字符 （简单） 无重复字符的最长子串 （中等） 最小覆盖子串 （困难） 合并两个有序链表 （简单） 环形链表 （简单） 环形链表 II （中等） 反转链表 （简单） 反转链表 II （中等） 旋转链表 （中等） 排序链表 链表中倒数第 k 个节点 两两交换链表中的节点 （中等） 按奇偶排序数组 （简单） 按奇偶排序数组 II （简单） 有序数组的平方 （简单） 山脉数组的峰顶索引 （简单） 搜索旋转排序数组 （困难） 搜索旋转排序数组 II （中等） 寻找旋转排序数组中的最小值 （中等） 寻找旋转排序数组中的最小值 II （困难） 搜索二维矩阵 （中等） 等式方程的可满足性 （中等） 朋友圈 （中等） 账户合并 （中等） 深度优先搜索 二叉树的最大深度 （简单） 路径总和 （简单） 路径总和 II （中等） 被围绕的区域 （中等） 岛屿数量 （中等） 岛屿的最大面积 （中等） 在二叉树中分配硬币 （中等） 回溯 括号生成 （中等） N 皇后 （困难） N 皇后 II （困难） 解数独 （中等） 不同路径 III （困难） 单词搜索 （中等） 分治 搜索二维矩阵 II （中等） 合并 K 个排序链表 （中等） 为运算表达式设计优先级 （中等） 给表达式添加运算符 （困难） 数组中的第 K 个最大元素 （中等） 最接近原点的 K 个点 （中等） 鸡蛋掉落 （困难） 动态规划 使用最小花费爬楼梯 （简单） 爬楼梯 （简单） 不同路径 （简单） 最小路径和 （中等） 最大子序和 （简单） 乘积最大子数组 （中等） 买卖股票的最佳时机 （简单） 买卖股票的最佳时机 II （简单） 买卖股票的最佳时机 III （困难） 买卖股票的最佳时机 IV （困难） 最佳买卖股票时机含冷冻期 （中等） 买卖股票的最佳时机含手续费 （中等） 零钱兑换 （中等） 零钱兑换 II （中等） 编辑距离 （困难） 不同的子序列 （困难） 柱状图中最大的矩形 （困难） 最大矩形 （困难） 最大正方形 （中等） 最低票价 （中等） 区域和检索 - 数组不可变 （简单） 二维区域和检索 - 矩阵不可变 （中等） 最长上升子序列 （中等） 鸡蛋掉落 （困难）</description></item><item><title>LeetCode 回文串系列</title><link>/study/leetcode/leetcode-palindromic/</link><pubDate>Wed, 16 Mar 2022 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/leetcode-palindromic/</guid><description>剑指 Offer II 018. 有效的回文 剑指 Offer II 086. 分割回文子字符串 剑指 Offer II 020. 回文子字符串的个数 336. 回文对 125. 验证回文串 647. 回文子串 680. 验证回文字符串 Ⅱ 409. 最长回文串 131. 分割回文串 https://leetcode-cn.com/submissions/detail/152376203/ 132. 分割回文串 II 1278. 分割回文串 III 1745. 回文串分割 IV 5. 最长回文子串 1616. 分割两个字符串得到回文串 42. 接雨水 268. 丢失的数字 688. 骑士在棋盘上的概率 1005. K 次取反后最大化的数组和 1380. 矩阵中的幸运数</description></item><item><title>LeetCode每日一题</title><link>/study/leetcode/2022-03-04-leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</link><pubDate>Tue, 01 Mar 2022 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/2022-03-04-leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</guid><description>(03-25) 892. 三维形体的表面积 class Solution { /** * @param Integer[][] $grid * @return Integer */ function surfaceArea($grid) { $n = count($grid); $area = 0; for ($i = 0; $i &amp;lt; $n; $i++) { for ($j = 0; $j &amp;lt; $n; $j++) { $level = $grid[$i][$j]; if ($level &amp;gt; 0) { //贡献的面积 &amp;lt;&amp;lt; 2 相当于 * 4 $area += 2 + ($level &amp;lt;&amp;lt; 2); //减去重合的面积 &amp;lt;&amp;lt; 1 相当于 * 2 $area -= $i &amp;gt; 0 ? min($level, $grid[$i - 1][$j]) &amp;lt;&amp;lt; 1 : 0; //减去重合的面积 $area -= $j &amp;gt; 0 ?</description></item><item><title>2022年02月LeetCode每日一题</title><link>/study/leetcode/2022-02-00-leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</link><pubDate>Tue, 01 Feb 2022 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/2022-02-00-leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</guid><description>20220216 1719. 重构一棵树的方案数 困难 func checkWays(pairs [][]int) int { adj := map[int]map[int]bool{} for _, p := range pairs { x, y := p[0], p[1] if adj[x] == nil { adj[x] = map[int]bool{} } adj[x][y] = true if adj[y] == nil { adj[y] = map[int]bool{} } adj[y][x] = true } // 检测是否存在根节点 root := -1 for node, neighbours := range adj { if len(neighbours) == len(adj)-1 { root = node break } } if root == -1 { return 0 } ans := 1 for node, neighbours := range adj { if node == root { continue } currDegree := len(neighbours) parent := -1 parentDegree := math.</description></item><item><title>LeetCode</title><link>/study/leetcode/leetcode/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/leetcode/</guid><description>数组和链表 206. 反转链表 24. 两两交换链表中的节点 141. 环形链表 142. 环形链表 II 24. 两两交换链表中的节点 21. 合并两个有序链表 25.K 个一组翻转链表 86.分隔链表 92.反转链表 II /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* reverseBetween(ListNode* head, int m, int n) { int change_len = n - m + 1; ListNode *pre_head = NULL; ListNode *result = head; while (head &amp;amp;&amp;amp; --m) { pre_head = head; head = head-&amp;gt;next; } ListNode *modify_list_tail = head; ListNode *new_head = NULL; while (head &amp;amp;&amp;amp; change_len--) { ListNode *next = head-&amp;gt;next; head-&amp;gt;next = new_head; new_head = head; head = next; } //连接为翻转部分 modify_list_tail-&amp;gt;next = head; if (pre_head) { pre_head-&amp;gt;next = new_head; } else { result = new_head; } return result; } }; /** * Definition for a singly-linked list.</description></item><item><title>第八课动态规划</title><link>/study/batj%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/8.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link><pubDate>Sat, 20 Nov 2021 17:18:16 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/batj%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/8.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid><description>70. 爬楼梯 class Solution { public: int climbStairs(int n) { std::vector&amp;lt;int&amp;gt; dp(n + 3, 0); dp[1] = 1; dp[2] = 1; for (int i = 3; i &amp;lt;= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; } }; 198. 打家劫舍 class Solution { public: int rob(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.size() == 0) { return 0; } if (nums.size() == 1) { return nums[0]; } //设第一个房间的最优解dp[i] std::vector&amp;lt;int&amp;gt; dp(nums.size(), 0); dp[0] = nums[0]; dp[1] = std::max(nums[0], nums[1]); for (int i = 2; i &amp;lt; nums.</description></item></channel></rss>