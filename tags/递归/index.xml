<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>递归 on lbbniu</title><link>/tags/%E9%80%92%E5%BD%92/</link><description>Recent content in 递归 on lbbniu</description><generator>Hugo -- gohugo.io</generator><language>zh</language><managingEditor>lbbniu@gmail.com (lbbniu)</managingEditor><webMaster>lbbniu@gmail.com (lbbniu)</webMaster><copyright>&amp;copy; 2021 &lt;a href="https://blog.lbbniu.com/">lbbniu&lt;/a></copyright><lastBuildDate>Sun, 06 Nov 2022 00:01:00 +0800</lastBuildDate><atom:link href="/tags/%E9%80%92%E5%BD%92/index.xml" rel="self" type="application/rss+xml"/><item><title>剑指 Offer 06 从尾到头打印链表</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/cong-wei-dao-tou-da-yin-lian-biao-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/cong-wei-dao-tou-da-yin-lian-biao-lcof/</guid><description>剑指 Offer 06 从尾到头打印链表 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
&amp;nbsp;
示例 1：
输入：head = [1,3,2] 输出：[2,3,1] &amp;nbsp;
限制：
0 &amp;lt;= 链表长度 &amp;lt;= 10000
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reversePrint(head *ListNode) []int { } LeetCode题库地址 https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof</description></item><item><title>面试题 02.05 链表求和</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sum-lists-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/sum-lists-lcci/</guid><description>面试题 02.05 链表求和 给定两个用链表表示的整数，每个节点包含一个数位。
这些数位是反向存放的，也就是个位排在链表首部。
编写函数对这两个整数求和，并用链表形式返回结果。
&amp;nbsp;
示例：
输入：(7 -&amp;gt; 1 -&amp;gt; 6) + (5 -&amp;gt; 9 -&amp;gt; 2)，即617 + 295 输出：2 -&amp;gt; 1 -&amp;gt; 9，即912 进阶：思考一下，假设这些数位是正向存放的，又该如何解决呢?
示例：
输入：(6 -&amp;gt; 1 -&amp;gt; 7) + (2 -&amp;gt; 9 -&amp;gt; 5)，即617 + 295 输出：9 -&amp;gt; 1 -&amp;gt; 2，即912 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer 16 数值的整数次方</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zhi-de-zheng-shu-ci-fang-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/shu-zhi-de-zheng-shu-ci-fang-lcof/</guid><description>剑指 Offer 16 数值的整数次方 实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。
示例 1：
输入：x = 2.00000, n = 10 输出：1024.00000 示例 2：
输入：x = 2.10000, n = 3 输出：9.26100 示例 3：
输入：x = 2.00000, n = -2 输出：0.25000 解释：2-2 = 1/22 = 1/4 = 0.25 提示：
-100.0 &lt; x &lt; 100.0 -231 &lt;= n &lt;= 231-1 -104 &lt;= xn &lt;= 104 注意：本题与主站 50 题相同：https://leetcode-cn.com/problems/powx-n/
func myPow(x float64, n int) float64 { } LeetCode题库地址 https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof</description></item><item><title>面试题 02.06 回文链表</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/palindrome-linked-list-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/palindrome-linked-list-lcci/</guid><description>面试题 02.06 回文链表 编写一个函数，检查输入的链表是否是回文的。
&amp;nbsp;
示例 1：
输入： 1-&amp;gt;2 输出： false 示例 2：
输入： 1-&amp;gt;2-&amp;gt;2-&amp;gt;1 输出： true &amp;nbsp;
进阶：
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func isPalindrome(head *ListNode) bool { } LeetCode题库地址 https://leetcode.cn/problems/palindrome-linked-list-lcci</description></item><item><title>剑指 Offer 19 正则表达式匹配</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zheng-ze-biao-da-shi-pi-pei-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/zheng-ze-biao-da-shi-pi-pei-lcof/</guid><description>剑指 Offer 19 正则表达式匹配 请实现一个函数用来匹配包含&amp;#39;. &amp;#39;和&amp;#39;*&amp;#39;的正则表达式。模式中的字符&amp;#39;.&amp;#39;表示任意一个字符，而&amp;#39;*&amp;#39;表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&amp;quot;aaa&amp;quot;与模式&amp;quot;a.a&amp;quot;和&amp;quot;ab*ac*a&amp;quot;匹配，但与&amp;quot;aa.a&amp;quot;和&amp;quot;ab*a&amp;quot;均不匹配。
示例 1:
输入: s = &amp;quot;aa&amp;quot; p = &amp;quot;a&amp;quot; 输出: false 解释: &amp;quot;a&amp;quot; 无法匹配 &amp;quot;aa&amp;quot; 整个字符串。 示例 2:
输入: s = &amp;quot;aa&amp;quot; p = &amp;quot;a*&amp;quot; 输出: true 解释:&amp;nbsp;因为 &amp;#39;*&amp;#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &amp;#39;a&amp;#39;。因此，字符串 &amp;quot;aa&amp;quot; 可被视为 &amp;#39;a&amp;#39; 重复了一次。 示例&amp;nbsp;3:
输入: s = &amp;quot;ab&amp;quot; p = &amp;quot;.*&amp;quot; 输出: true 解释:&amp;nbsp;&amp;quot;.*&amp;quot; 表示可匹配零个或多个（&amp;#39;*&amp;#39;）任意字符（&amp;#39;.&amp;#39;）。 示例 4:
输入: s = &amp;quot;aab&amp;quot; p = &amp;quot;c*a*b&amp;quot; 输出: true 解释:&amp;nbsp;因为 &amp;#39;*&amp;#39; 表示零个或多个，这里 &amp;#39;c&amp;#39; 为 0 个, &amp;#39;a&amp;#39; 被重复一次。因此可以匹配字符串 &amp;quot;aab&amp;quot;。 示例 5:</description></item><item><title>剑指 Offer 24 反转链表</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/fan-zhuan-lian-biao-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/fan-zhuan-lian-biao-lcof/</guid><description>剑指 Offer 24 反转链表 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。
&amp;nbsp;
示例:
输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL 输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL &amp;nbsp;
限制：
0 &amp;lt;= 节点个数 &amp;lt;= 5000
&amp;nbsp;
注意：本题与主站 206 题相同：https://leetcode-cn.com/problems/reverse-linked-list/
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { } LeetCode题库地址 https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof</description></item><item><title>剑指 Offer 25 合并两个排序的链表</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/</guid><description>剑指 Offer 25 合并两个排序的链表 输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。
示例1：
输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4 输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4 限制：
0 &amp;lt;= 链表长度 &amp;lt;= 1000
注意：本题与主站 21 题相同：https://leetcode-cn.com/problems/merge-two-sorted-lists/
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { } LeetCode题库地址 https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof</description></item><item><title>剑指 Offer II 024 反转链表</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/uhnkqh/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/uhnkqh/</guid><description>剑指 Offer II 024 反转链表 给定单链表的头节点 head ，请反转链表，并返回反转后的链表的头节点。
&amp;nbsp;
示例 1：
输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1] 示例 2：
输入：head = [1,2] 输出：[2,1] 示例 3：
输入：head = [] 输出：[] &amp;nbsp;
提示：
链表中节点的数目范围是 [0, 5000] -5000 &amp;lt;= Node.val &amp;lt;= 5000 &amp;nbsp;
进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？
&amp;nbsp;
注意：本题与主站 206&amp;nbsp;题相同：&amp;nbsp;https://leetcode-cn.com/problems/reverse-linked-list/
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { } LeetCode题库地址 https://leetcode.cn/problems/UHnkqh</description></item><item><title>剑指 Offer II 026 重排链表</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/lgjmqu/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/lgjmqu/</guid><description>剑指 Offer II 026 重排链表 给定一个单链表 L 的头节点 head ，单链表 L 表示为：
&amp;nbsp;L0&amp;nbsp;&amp;rarr; L1&amp;nbsp;&amp;rarr; &amp;hellip; &amp;rarr; Ln-1&amp;nbsp;&amp;rarr; Ln&amp;nbsp;
请将其重新排列后变为：
L0&amp;nbsp;&amp;rarr;&amp;nbsp;Ln&amp;nbsp;&amp;rarr;&amp;nbsp;L1&amp;nbsp;&amp;rarr;&amp;nbsp;Ln-1&amp;nbsp;&amp;rarr;&amp;nbsp;L2&amp;nbsp;&amp;rarr;&amp;nbsp;Ln-2&amp;nbsp;&amp;rarr; &amp;hellip;
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
&amp;nbsp;
示例 1:
输入: head = [1,2,3,4] 输出: [1,4,2,3] 示例 2:
输入: head = [1,2,3,4,5] 输出: [1,5,2,4,3] &amp;nbsp;
提示：
链表的长度范围为 [1, 5 * 104] 1 &amp;lt;= node.val &amp;lt;= 1000 &amp;nbsp;
注意：本题与主站 143&amp;nbsp;题相同：https://leetcode-cn.com/problems/reorder-list/&amp;nbsp;
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reorderList(head *ListNode) { } LeetCode题库地址 https://leetcode.</description></item><item><title>剑指 Offer II 027 回文链表</title><link>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/amhzsa/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88/amhzsa/</guid><description>剑指 Offer II 027 回文链表 给定一个链表的 头节点&amp;nbsp;head&amp;nbsp;，请判断其是否为回文链表。
如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。
&amp;nbsp;
示例 1：
输入: head = [1,2,3,3,2,1] 输出: true 示例 2：
输入: head = [1,2] 输出: false &amp;nbsp;
提示：
链表 L 的长度范围为 [1, 105] 0&amp;nbsp;&amp;lt;= node.val &amp;lt;= 9 &amp;nbsp;
进阶：能否用&amp;nbsp;O(n) 时间复杂度和 O(1) 空间复杂度解决此题？
&amp;nbsp;
注意：本题与主站 234&amp;nbsp;题相同：https://leetcode-cn.com/problems/palindrome-linked-list/
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func isPalindrome(head *ListNode) bool { } LeetCode题库地址 https://leetcode.cn/problems/aMhZSa</description></item><item><title>剑指 Offer 33 二叉搜索树的后序遍历序列</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/</guid><description>剑指 Offer 33 二叉搜索树的后序遍历序列 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回&amp;nbsp;true，否则返回&amp;nbsp;false。假设输入的数组的任意两个数字都互不相同。
&amp;nbsp;
参考以下这颗二叉搜索树：
5 / \ 2 6 / \ 1 3 示例 1：
输入: [1,6,3,2,5] 输出: false 示例 2：
输入: [1,3,2,6,5] 输出: true &amp;nbsp;
提示：
数组长度 &amp;lt;= 1000 func verifyPostorder(postorder []int) bool { } LeetCode题库地址 https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof</description></item><item><title>剑指 Offer 43 1～n 整数中 1 出现的次数</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/</guid><description>剑指 Offer 43 1～n 整数中 1 出现的次数 输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。
例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。
示例 1：
输入：n = 12 输出：5 示例 2：
输入：n = 13 输出：6 限制：
1 &lt;= n &lt; 2^31 注意：本题与主站 233 题相同：https://leetcode-cn.com/problems/number-of-digit-one/
func countDigitOne(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof</description></item><item><title>面试题 08.05 递归乘法</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/recursive-mulitply-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/recursive-mulitply-lcci/</guid><description>面试题 08.05 递归乘法 递归乘法。 写一个递归函数，不使用 * 运算符， 实现两个正整数的相乘。可以使用加号、减号、位移，但要吝啬一些。
示例1:
输入：A = 1, B = 10 输出：10 示例2:
输入：A = 3, B = 4 输出：12 提示:
保证乘法范围不会溢出 func multiply(A int, B int) int { } LeetCode题库地址 https://leetcode.cn/problems/recursive-mulitply-lcci</description></item><item><title>面试题 08.06 汉诺塔问题</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/hanota-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/hanota-lcci/</guid><description>面试题 08.06 汉诺塔问题 在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:
(1) 每次只能移动一个盘子;
(2) 盘子只能从柱子顶端滑出移到下一根柱子;
(3) 盘子只能叠在比它大的盘子上。
请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。
你需要原地修改栈。
示例1:
输入：A = [2, 1, 0], B = [], C = [] 输出：C = [2, 1, 0] 示例2:
输入：A = [1, 0], B = [], C = [] 输出：C = [1, 0] 提示:
A中盘子的数目不大于14个。 func hanota(A []int, B []int, C []int) []int { } LeetCode题库地址 https://leetcode.cn/problems/hanota-lcci</description></item><item><title>剑指 Offer 62 圆圈中最后剩下的数字</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</guid><description>剑指 Offer 62 圆圈中最后剩下的数字 0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。
例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。
示例 1：
输入: n = 5, m = 3 输出: 3 示例 2：
输入: n = 10, m = 17 输出: 2 限制：
1 &lt;= n &lt;= 10^5 1 &lt;= m &lt;= 10^6 func lastRemaining(n int, m int) int { } LeetCode题库地址 https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof</description></item><item><title>面试题 16.08 整数的英语表示</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/english-int-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/english-int-lcci/</guid><description>面试题 16.08 整数的英语表示 给定一个整数，打印该整数的英文描述。
示例 1:
输入: 123 输出: "One Hundred Twenty Three" 示例 2:
输入: 12345 输出: "Twelve Thousand Three Hundred Forty Five" 示例 3:
输入: 1234567 输出: "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven" 示例 4:
输入: 1234567891 输出: "One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One" 注意：本题与 273 题相同：https://leetcode-cn.com/problems/integer-to-english-words/
func numberToWords(num int) string { } LeetCode题库地址 https://leetcode.cn/problems/english-int-lcci</description></item><item><title>剑指 Offer 64 求1+2+…+n</title><link>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/qiu-12n-lcof/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E5%89%91%E6%8C%87offer%E7%AC%AC2%E7%89%88/qiu-12n-lcof/</guid><description>剑指 Offer 64 求1+2+…+n 求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
&amp;nbsp;
示例 1：
输入: n = 3 输出:&amp;nbsp;6 示例 2：
输入: n = 9 输出:&amp;nbsp;45 &amp;nbsp;
限制：
1 &amp;lt;= n&amp;nbsp;&amp;lt;= 10000 func sumNums(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/qiu-12n-lcof</description></item><item><title>面试题 17.06 2出现的次数</title><link>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/number-of-2s-in-range-lcci/</link><pubDate>Thu, 28 Jul 2022 22:00:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%E7%AC%AC6%E7%89%88/number-of-2s-in-range-lcci/</guid><description>面试题 17.06 2出现的次数 编写一个方法，计算从 0 到 n (含 n) 中数字 2 出现的次数。
示例:
输入: 25 输出: 9 解释: (2, 12, 20, 21, 22, 23, 24, 25)(注意 22 应该算作两次) 提示：
n &amp;lt;= 10^9 func numberOf2sInRange(n int) int { } LeetCode题库地址 https://leetcode.cn/problems/number-of-2s-in-range-lcci</description></item><item><title>【2022-11-06 加练约瑟夫环】剑指 Offer 62. 圆圈中最后剩下的数字[Easy]</title><link>/study/leetcode/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</link><pubDate>Sun, 06 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</guid><description>加练：剑指 Offer 62. 圆圈中最后剩下的数字 难度：Easy
标签：递归 、 数学
0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。
例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。
示例 1：
输入: n = 5, m = 3 输出: 3 示例 2：
输入: n = 10, m = 17 输出: 2 限制：
1 &lt;= n &lt;= 10^5 1 &lt;= m &lt;= 10^6 方法一：递归 详细题解 核心思想：f(10,3)的结果就可以转化为f(9,3)的表达,后面也是同理：
f(10,3)=(f(9,3)+3)%10 f(9,3)=(f(8,3)+3)%9 …… f(2,3)=(f(1,3)+3)%2 f(1,3)=0 代码 func lastRemaining(n int, m int) int { if n == 1 { return 0 } return (lastRemaining(n-1, m) + m) % n } 复杂度分析 时间复杂度：O(n)。 空间复杂度：O(n)。 方法二：迭代 func lastRemaining(n int, m int) int { ans := 0 for i := 1; i &amp;lt;= n; i++ { ans = (ans + m) % i } return ans } 复杂度分析 时间复杂度：O(n)。 空间复杂度：O(1)。 LeetCode题库地址 https://leetcode.</description></item><item><title>【2022-11-05每日一题】1106. 解析布尔表达式[Hard]</title><link>/study/leetcode/parsing-a-boolean-expression/</link><pubDate>Sat, 05 Nov 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/parsing-a-boolean-expression/</guid><description>2022-11-05每日一题：1106. 解析布尔表达式 难度：Hard
标签：栈 、 递归 、 字符串
给你一个以字符串形式表述的&amp;nbsp;布尔表达式（boolean） expression，返回该式的运算结果。
有效的表达式需遵循以下约定：
&amp;quot;t&amp;quot;，运算结果为 True &amp;quot;f&amp;quot;，运算结果为 False &amp;quot;!(expr)&amp;quot;，运算过程为对内部表达式 expr 进行逻辑 非的运算（NOT） &amp;quot;&amp;amp;(expr1,expr2,...)&amp;quot;，运算过程为对 2 个或以上内部表达式 expr1, expr2, ... 进行逻辑 与的运算（AND） &amp;quot;|(expr1,expr2,...)&amp;quot;，运算过程为对 2 个或以上内部表达式 expr1, expr2, ... 进行逻辑 或的运算（OR） &amp;nbsp;
示例 1：
输入：expression = &amp;quot;!(f)&amp;quot; 输出：true 示例 2：
输入：expression = &amp;quot;|(f,t)&amp;quot; 输出：true 示例 3：
输入：expression = &amp;quot;&amp;amp;(t,f)&amp;quot; 输出：false 示例 4：
输入：expression = &amp;quot;|(&amp;amp;(t,f,t),!(t))&amp;quot; 输出：false &amp;nbsp;
提示：
1 &amp;lt;= expression.length &amp;lt;= 20000 expression[i] 由 {&amp;#39;(&amp;#39;, &amp;#39;)&amp;#39;, &amp;#39;&amp;amp;&amp;#39;, &amp;#39;|&amp;#39;, &amp;#39;!&amp;#39;, &amp;#39;t&amp;#39;, &amp;#39;f&amp;#39;, &amp;#39;,&amp;#39;} 中的字符组成。 expression 是以上述形式给出的有效表达式，表示一个布尔值。 方法一： 详细思路过程见官方题解，这里只做个人刷题记录，方便后续查询阅读</description></item><item><title>【2022-10-20每日一题】779. 第K个语法符号[Medium]</title><link>/study/leetcode/k-th-symbol-in-grammar/</link><pubDate>Thu, 20 Oct 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/k-th-symbol-in-grammar/</guid><description>2022-10-20每日一题：779. 第K个语法符号 难度：Medium
标签：位运算 、 递归 、 数学
我们构建了一个包含 n 行(&amp;nbsp;索引从 1&amp;nbsp; 开始&amp;nbsp;)的表。首先在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。
例如，对于 n = 3 ，第 1 行是 0 ，第 2 行是 01 ，第3行是 0110 。 给定行数&amp;nbsp;n&amp;nbsp;和序数 k，返回第 n 行中第 k&amp;nbsp;个字符。（&amp;nbsp;k&amp;nbsp;从索引 1 开始）
示例 1:
输入: n = 1, k = 1 输出: 0 解释: 第一行：0 示例 2:
输入: n = 2, k = 1 输出: 0 解释: 第一行: 0 第二行: 01 示例 3:
输入: n = 2, k = 2 输出: 1 解释: 第一行: 0 第二行: 01 &amp;nbsp;</description></item><item><title>【2022-08-08每日一题】761. 特殊的二进制序列</title><link>/study/leetcode/special-binary-string/</link><pubDate>Mon, 08 Aug 2022 00:01:00 +0800</pubDate><author>lbbniu@gmail.com (lbbniu)</author><guid>/study/leetcode/special-binary-string/</guid><description>2022-08-08每日一题：761. 特殊的二进制序列 难度：Hard
标签：递归 、 字符串
特殊的二进制序列是具有以下两个性质的二进制序列：
0 的数量与 1 的数量相等。 二进制序列的每一个前缀码中 1 的数量要大于等于 0 的数量。 给定一个特殊的二进制序列&amp;nbsp;S，以字符串形式表示。定义一个操作 为首先选择&amp;nbsp;S&amp;nbsp;的两个连续且非空的特殊的子串，然后将它们交换。（两个子串为连续的当且仅当第一个子串的最后一个字符恰好为第二个子串的第一个字符的前一个字符。)
在任意次数的操作之后，交换后的字符串按照字典序排列的最大的结果是什么？
示例 1:
输入: S = &amp;quot;11011000&amp;quot; 输出: &amp;quot;11100100&amp;quot; 解释: 将子串 &amp;quot;10&amp;quot; （在S[1]出现） 和 &amp;quot;1100&amp;quot; （在S[3]出现）进行交换。 这是在进行若干次操作后按字典序排列最大的结果。 说明:
S&amp;nbsp;的长度不超过&amp;nbsp;50。 S&amp;nbsp;保证为一个满足上述定义的特殊 的二进制序列。 ### 解题 此题可以看成是有效的括号，将 1 看成左括号 (，0 看成右括号 )，比如，&amp;ldquo;1100&amp;rdquo; 可以看做是 &amp;ldquo;(())&amp;quot;，这样就比较好理解。也就是说最后我们需要通过一系列操作（有效的括号子串交换位置）之后让左括号尽量在右括号前面，比如，对于 &amp;ldquo;(()(()))&amp;quot;，我们可以把中间 &amp;ldquo;()&amp;rdquo; 和 &amp;ldquo;(())&amp;rdquo; 交换之后变成 &amp;ldquo;((())())&amp;quot;。
那么，代码就比较容易写了，我们可以遍历整个字符串，找到它的有效子串，再把这些子串降序排个序就完事了，当然，这里在找到这些子串之后，子串内部也可以使用相同的规则去做处理，所以，我们可以使用递归来搞。
func makeLargestSpecial(s string) string { if len(s) &amp;lt;= 2 { return s } subs := sort.StringSlice{} cnt, left := 0, 0 for i, ch := range s { if ch == '1' { cnt++ } else if cnt--; cnt == 0 { subs = append(subs, &amp;quot;1&amp;quot;+makeLargestSpecial(s[left+1:i])+&amp;quot;0&amp;quot;) left = i + 1 } } sort.</description></item></channel></rss>